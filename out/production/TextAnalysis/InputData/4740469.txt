Efficient Mining of Event-Oriented Negative Sequential Rules

Abstract  Traditional sequential pattern mining deals with positive sequential patterns only, that is, only frequent sequential patterns with the appearance of items are discovered. How- ever, it is often interesting in many applications to find fre- quent sequential patterns with the non-occurrence of some items, which are referred to as negative sequential patterns.

This paper analyzes three types of negative sequential rules and presents a new technique to find event-oriented negative sequential rules. Its effectiveness and efficiency are shown in our experiments.

Keywords: Negative sequential patterns, negative sequen- tial rules, sequential patterns, sequence mining  1 Introduction  Association rule mining [1] and sequential pattern min- ing [2] were respectively proposed in 1993 and 1995, and have been well studied and developed. Traditional asso- ciation rules and sequential patterns involve only the co- occurrence of itemsets/events, that is, the positive relation- ship between itemsets/events. However, it is sometimes in- teresting to find negative correlations, e.g., two items are seldom bought together in a same basket. Therefore, nega- tive association rules are designed to find such kind of rela- tionships [11, 15, 3, 14]. Similarly, it is also interesting to find negative sequential patterns, e.g., one event seldom oc- curs after another event. Nevertheless, such kind of negative sequential patterns are seldom studied.

Moreover, in many applications, it is interesting to find which sequential patterns will lead to the occurrence/non-  occurrence of some single events. For example, in a web click-stream scenario, an analysis is to find the relation- ship between visiting sequences and the click of a link.

For a credit card company, it is interesting to discover the positive and negative relationship between transaction se- quences and an unrecovered debt. In homeland security, the correlation between a series of activities and a terrorism at- tack is one of the important aims of analysis.

In this paper, we will study the negative relationship in sequence data, which are defined in two forms: 1) negative sequential patterns (NSP) like a?(bc)da?e, where a to e are events/items; and 2) negative sequential rules (NSR) like A ? ?B, ?A ? B and ?A ? ?B, where A and B are positive sequential patterns composed of items in time or- der. From NSP, sequential rules like a?(bc)d ? a?e can be derived, and we name such kind of rules as generalized neg- ative sequential rules (GNSR). There are some preliminary work on negative sequential pattern mining [5, 8, 9, 13], but they only deal with a small part of the problem and are in- efficient for mining such patterns.

To tackle the above problem, we will develop the idea of negative sequential rules whose left or/and right sides can be negations of traditional positive sequential patterns, and a new efficient algorithm will be designed for mining event- oriented negative sequential rules, where the right side of a rule is a single event or its negation. The contributions of this paper are:  ? a definition of negative sequential rules and the sup- port, confidence and lift for negative sequential rules; and  ? an efficient algorithm for discovering event-oriented negative sequential rules based on SPAM algorithm [4].

DOI 10.1109/WIIAT.2008.60    DOI 10.1109/WIIAT.2008.60     Table 1. Notations Symbol Description  A,B Positive sequential patterns  A ?? B The conjunction of A and B, where A is fol- lowed by B in a sequence.

AB Same as A ?? B. They are used interchange- ably in this paper.

A&B The concurrence of A and B in a sequence.

Note that there is no time order between A and B, and they may even be interweaved in a sequence.

Ck The set of candidate frequent sequential pat- terns with k items  Lk The set of frequent sequential patterns with k items  Mk The set of infrequent sequential patterns with k items  The notations used throughout this paper are given in Ta- ble 1.

The rest of this paper is organized as follows. Section 2 briefly introduces some related work on negative associ- ation rules, sequential patterns and negative sequential pat- terns. The targeted problem is described in Section 3. Sec- tion 4 presents a formal definition of negative sequential rules, interestingness measures and an efficient technique for mining event-oriented negative sequential rules. Section 5 shows our experimental results. Conclusions and future work are given in the last section.

2 Background and Related Work  The technique of negative association rules has been well studied [3, 11, 14, 15]. Negative association rules are defined in the form of A ? ?B, ?A ? B and ?A ? ?B [14, 15]. Savasere et al. designed negative as- sociation rules as A ?? B [11]. Antonie and Za??ane defined generalized negative association rule as a rule containing a negation of an item, such as A??B??C?D ? E??F [3], but their work is still focused on finding rules like A ? ?B, ?A ? B and ?A ? ?B, which are referred to by them as confined negative association rules.

The idea of sequential patterns was proposed in 1995 to find frequent sequential patterns in sequence data, such as transactional data [2]. The difference from frequent itemset mining is that time order is taken into account in sequen- tial pattern mining. Well-known algorithms for sequen- tial pattern mining are AprioriALL [2], GSP (Generalized Sequential Patterns) [12], FreeSpan [7], PrefixSpan [10],  SPADE [16] and SPAM (Sequential PAttern Mining) [4].

For sequential patterns, the non-occurrence of an ele-  ment may also be interesting. For example, in social wel- fare, the lack of follow-up examination after the address change of a customer may result in overpayment to the cus- tomer. Such kind of sequences with the non-occurrence of elements are negative sequential patterns. However, most research on sequential patterns are focused on positives, and negative sequential patterns are underdeveloped. To the best of our knowledge, reported researches on negative sequen- tial patterns are as follows.

Sun et al. proposed negative event-oriented patterns [13].

A negative rule in the form of ?P T? e, where e is a tar- get event, P is a negative event-oriented pattern, and the occurrence of P is unexpected rear in T -sized intervals be- fore target events. It is a special case of negative sequential pattern ?A ? B. In their work, P is supposed to be an ?existence pattern? (i.e., a frequent itemset without time or- der), instead of a sequential pattern, although they claimed that their discussions can be easily extended to sequential patterns.

Bannai et al. proposed a method for finding optimal pairs of string patterns to discriminate between two sets of strings [5]. The pairs are in the forms of p? ? q? and p? ? q?, where p? is either p or ?p, q? is either q or ?q, and p and q are two substrings. Their concern is whether p and q appear in a string s. The substring can be taken as a special case of sequential pattern, where the elements in the patterns are continuous.

Ouyang and Huang proposed negative sequences as (A,?B), (?A,B) and (?A,?B) [9]. Their idea is gener- ating frequent itemsets first, based on which both frequent and infrequent sequences are found, and then negative se- quential patterns are derived from infrequent sequences. A drawback of their algorithm is that both frequent and infre- quent sequences have to be found at the first stage, which demands a large amount of space.

Lin et al. designed an algorithm NSPM (Negative Se- quential Patterns Mining) for mining negative sequential patterns [8]. In their designed negative patterns, only the last element can be negative, and all other elements are pos- itive.

Chen et al. designed a technique PNSP (Positive and Negative Sequential Patterns Mining) for mining pos- itive and negative sequential patterns in the form of (abc)?(de)(ijk) [6]. They proposed some constraints for negative sequential patterns, e.g., a valid negative sequen- tial patterns do not contain contiguous absence of elements, and an itemset must be frequent to make it a valid negative itemset. Their method is broken into three stages. At the first stage, all positive sequential patterns are found. At the second stage, all positive itemsets are found, from which all negative itemsets are derived. At the third stage, both pos-     itive and negative itemsets are joined to generate candidate negative sequential patterns, which are in turn joined itera- tively to generate longer negative sequences in an apriori- like way.

3 Problem Statement  A negative sequential rule (NSR) is defined as a rule in the form of A ? B, where either or both sides of the rule is/are the negations of positive sequential patterns. A neg- ative sequential rule with the right side as a single event is referred to as an event-target negative sequential rule. The target problem in this paper is as follows: Given a database of sequences and three user-specified parameters, minimum support minsupp, minimum confidence minconf and mini- mum lift minlift , find all event-oriented negative sequential rules whose support, confidence and lift are no less than minsupp, minconf and minlift , respectively.

In this paper, we consider the case where every transac- tion is composed of one item only. That is, the sequences look like abcad, instead of a{bc}ad, where b and c occur in one transaction in the latter case.

4 Mining Event-Oriented Negative Sequen- tial Rules  In this section, negative sequential rules will be designed and their support, confidence and lift will be derived. Then an efficient algorithm for mining event-oriented negative se- quential rules will be presented.

4.1 Negative Sequential Rules  Traditional sequential rules are positive sequential rules, which are in the form of A ? B, where both A and B are positive sequential patterns. It means that pattern A is followed by B. We refer to such positive rules as Type I sequential rules, and their support, confidence and lift are as follows.

supp(A ? B) = P (AB) (1) conf (A ? B) = P (AB)  P (A) (2)  lift(A ? B) = P (AB) P (A)P (B)  (3)  = 1 + P (AB) ? P (A)P (B)  P (A)P (B) (4)  By changing A or/and B to their negations, we can get the following three types of negative sequential rules:  ? Type II: A ? ?B, which means that pattern A is not followed by B;  ? Type III: ?A ? B, which means that if A doesnot appear, then B will occur; and  ? Type IV: ?A ? ?B, which means that if A doesnot appear, then B will not occur.

For types III and IV whose left sides are the negations of sequential patterns, the meaning of the rules are: if A does- not occur in a sequence, then B will (type III) or will not (type IV) occur in the sequence. That is to say, there is no time order between the left side and the right side. Note that A and B themselves are sequential patterns, which makes them different from negative association rules. However, if time constraint is considered in sequential rules, the two types of rules may have new meanings, which is out of the scope of this paper. The supports, confidences and lifts of the above three types of negative sequential rules are calcu- lated as follows.

supp(A ? ?B) = P (A?B) (5) = P (A) ? P (AB) (6)  conf (A ? ?B) = P (A) ? P (AB) P (A)  (7)  lift(A ? ?B) = P (A) ? P (AB) P (A)(1 ? P (B)) (8)  = 1 + P (A)P (B) ? P (AB)  P (A)(1 ? P (B)) (9) supp(?A ? B) = P (?A&B) (10)  = P (B) ? P (A&B) (11) conf (?A ? B) = P (B) ? P (A&B)  1 ? P (A) (12)  lift(?A ? B) = P (B) ? P (A&B) P (B)(1 ? P (A)) (13)  = 1 + P (A)P (B) ? P (A&B)  P (B)(1 ? P (A)) (14) supp(?A ? ?B) = supp(?A) ? supp(?A ? B) (15)  = 1 ? P (A) ? P (B) + P (A&B)(16) conf (?A ? ?B) = 1 ? P (A) ? P (B) + P (A&B)  1 ? P (A) (17)  lift(?A ? ?B) = 1 ? P (A) ? P (B) + P (A&B) (1 ? P (A))(1 ? P (B)) (18)  = 1 + P (A&B) ? P (A)P (B) (1 ? P (A))(1 ? P (B)) (19)  In the above equations, P (A&B) denotes the probability of the concurrence of A and B in a sequence, no matter which one occurs first, or whether they are interweaved. So we can get P (A&B) ? P (AB).

Based on the above equations for lifts, we get the fol- lowing: 1) If P (AB) > P (A)P (B), then P (A&B) > P (A)P (B), so lift(A ? B) > 1 (see Eqn. 4) and lift(?A ? ?B) > 1 (see Eqn. 19), which suggests that A ? B and ?A ? ?B may be interesting. Oth- erwise, A ? ?B may be interesting (see Eqn. 9). 2) If P (A&B) > P (A)P (B), then ?A ? ?B may be in- teresting (see Eqn. 19). Otherwise, we have P (AB) ? P (A&B) ? P (A)P (B), so A ? ?B (see Eqn. 9) and ?A ? B (see Eqn. 14) may be interesting. The above ob- servation coincides with Antonie and Za??ane?s idea to find positive and negative association rules [3]. They proposed to check the correlation between itemsets, and then gener- ate negative association rules like Types II & III when the correlation is negative and generate association rules like Types I & IV when the correlation is positive. However, our observation works for sequential patterns, while theirs works for association rules.

Note that the above four types of sequential rules and the above equations for their supports, confidences and lifts are not limited to event-oriented sequential rules, that is, they can also be applied to generalized sequential rules where the right sides are sequences with two or more items.

4.2 Algorithm for Mining Event-Oriented Negative Sequential Rules  To discover event-oriented negative sequential rules, we use SPAM (Sequential PAttern Mining) [4] as a start point, because it is more efficient than SPADE and Prefixpan [4], two well-known algorithms for sequential pattern mining.

SPAM uses a vertical bitmap representation of the database and a depth-first search strategy for efficient mining of se- quential patterns. It searches the sequence lattice in a depth- first way, and candidates of longer sequences Sg are gener- ated by append frequent items {i} to existing frequent se- quences Sa. The algorithm is very efficient in that it uses bitmap to count the frequency of sequences and only the nodes in the path to the current node are kept. The candidate generation of SPAM is composed of two steps: S-step and I-step. The S-step appends i to Sa, which builds a longer sequence Sg = Sa ?? i. The I-step adds i to the last itemset of Sa, which builds a new sequence of the same length as Sa. Since we consider transaction with one item only, a el- ement in a sequence is a single item, instead of an itemset.

Therefore, only S-step from SPAM is used in our technique.

The frequency of items (i.e., L1 sequence) are counted at first and kept for the computation of sequential rules. Since the algorithm works with a depth-first search strategy, so the support of Sa is available in the parent node. The support of item i is available at the very beginning. Because the bitmaps of Sa and i are available at each node for counting the support of Sa ?? i (with a bit-wise AND-operation), the  support of Sa&i can be easily derived. Therefore, all infor- mation is available for computing the support, confidence and lift of the sequential rules.

Figure 1 gives the pseudocode for finding negative se- quential rules, which is based on the function FindSequen- tialPatterns() from SPAM. A recursive call goes down the search lattice to find sequential rules. For each possible ex- tension i at a level, the support is computed with a bit-wise AND of post-processed bitmap with the candidate frequent- 1 itemset (see lines 2-6). If the result shows that the support is no less than a given support threshold, then i is added to the extension list of the node at next level and the con- fidence and lift for positive sequential patterns (Type I) are calculated (see lines 8-14). Otherwise, the support, confi- dence and lift for negative sequential patterns of types II, III and IV are computed (see lines 16-33). If the support, confidence and lift are all above predefined thresholds, the corresponding rules are outputted. Then the node at next level is checked recursively to find all sequential rules (see line 35). At each level of the sequence lattice, only one node is kept in memory, which makes it very space efficient.

5 Experimental Evaluation  Our designed algorithm (referred to as SpamNeg) was implemented with C++ based on the source code of the SPAM algorithm from http://himalaya- tools.sourceforge.net/Spam/ and tested with synthetic dataset generated with IBM AssocGen transactional data generator [2]. All the tests were conducted on a PC with Intel Core 2 CPU of 1.86GHz, 2GB memory and Windows XP Professional SP2. The number of items per transaction was set to one when generating datasets.

Our algorithm was first tested on a dataset with 10,000 customers, 50 items per sequence and the length of maximal patterns as 20. By setting the minimum supports ranging from 0.2 to 0.7, the results are shown in Figure 2. From the figure, both SpamNeg and Spam [4] run faster with larger minimum support, because the search space becomes smaller. Moreover, SpamNeg needs longer running time than Spam, and the extra time is caused by generating nega- tive sequential rules when the support of a candicate is less than the support threshold.

The scalability of our algorithm was tested on datasets with average sequence length as 40, length of maximal pat- terns as 10. The number of customers ranged from 10,000 to 60,000, and the support threshold was set to 0.3. Figure 3 shows the result of the above test. It?s clear from the figure that SpamNeg is linear with the number of sequences.

The running time with varying sequence lengths is shown Figure 4, where the datasets used have 100,000 cus- tomers, with length of maximal patterns as 20, and the av- erage sequence length ranging from 10 to 45. The support     ALGORITHM: FindNegativeSequentialRules, a recursive call that goes down the search lattice to find negative sequential rules INPUT: curNode: information about the current node OUTPUT: event-oriented negative sequential rules  1: FOR each possible s-extension i from this level  2: /* AND the post-processed s-step bitmap with the candidate frequent-1 itemset; */  3: cntA = curNode.parent.count; 4: cntB = i.count; 5: tempAndBitmap=Bit-Wise-And(post-processed bitmap of curNode, bitmap of i); 6: cntAB=tempAndBitmap.count; /* corresponding to P (AB) */ 7: IF cntAB ? minsupp ? totalCust /* totalCust is the number of customers/sequences. */ 8: add i to nextNode?s s-extension list;  9: /* generate positive sequential patterns */  10: // Type I: A ? B 11: supp = cntAB/totalCust ; 12: conf = cntAB/cntA; 13: lift = cntAB ? totalCust/(cntA ? cntB); 14: output ?A ? B? if supp ? minsupp, conf ? minconf and lift ? minlift ; 15: ELSE  16: /* generate negative sequential patterns */  17: tempOrBitmap=Bit-Wise-Or(bitmap of curNode, bitmap of i); 18: cntAorB = the count of ?1? in tempOrBitmap; 19: cntAandB = cntA + cntB ? cntAorB ; /* corresponding to P (A&B) */ 20: IF P (A&B) < P (A)P (B) /* P (AB) ? P (A&B) < P (A)P (B) */ 21: compute support, confidence and lift according to Equations 5, 7 and 8.

22: output ?A ? ?B? if supp ? minsupp, conf ? minconf and lift ? minlift ; 23: compute support, confidence and lift according to Equations 10, 12 and 13.

24: output ??A ? B? if supp ? minsupp, conf ? minconf and lift ? minlift ; 25: ELSE IF P (AB) < P (A)P (B) /* P (AB) < P (A)P (B) ? P (A&B) */ 26: compute support, confidence and lift according to Equations 5, 7 and 8.

27: output ?A ? ?B? if supp ? minsupp, conf ? minconf and lift ? minlift ; 28: compute support, confidence and lift according to Equations 15, 17 and 18.

29: output ??A ? ?B? if supp ? minsupp, conf ? minconf and lift ? minlift ; 30: ELSE /* P (A)P (B) ? P (AB) ? P (A&B) */ 31: compute support, confidence and lift according to Equations 15, 17 and 18.

32: output ??A ? ?B? if supp ? minsupp, conf ? minconf and lift ? minlift ; 33: END IF  34: END IF  35: FindNegativeSequentialRules(nextNode); /* A recursive call to check the node at the next level */  36: END FOR  Figure 1. Algorithm for Discovering Event-Oriented Negative Sequential Rules     threshold was set to 0.2. The figure shows that the running time becomes longer with the increase of the average num- ber of items per sequence.

The running time of our algorithm was also tested on datasets with average length of maximal patterns ranging from 5 to 15. Each dataset has 100,000 customers, with average sequence length as 30. The support threshold was also set to 0.2. The experimental results in Figure 5 show that the running time decreases slightly with the increase of the average length of maximal patterns.

6 Conclusions  We have formally defined negative sequential rules and have derived the supports, confidences and lifts for negative sequential rules. An efficient algorithm for mining event- oriented negative sequential rules is designed based on the SPAM algorithm. Our algorithm has been tested on numer- ous synthetic datasets generated with IBM data generator, which shows its efficiency and scalability.

The proposed algorithm can only find negative sequen- tial rules with a single event on the right side. Sometimes it may be interesting to find more generalized negative se- quential rules, which will be included in our future work.

Moreover, negative sequential rules with time constraints will also be a part of our future research.

