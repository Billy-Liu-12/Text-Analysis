Distributed Online Big Data Classification Using Context Information

Abstract? Distributed, online data mining systems have emerged as a result of applications requiring analysis of large amounts of correlated and high-dimensional data produced by multiple distributed data sources. We propose a distributed online data classification framework where data is gathered by distributed data sources and processed by a heterogeneous set of distributed learners which learn online, at run-time, how to classify the different data streams either by using their locally available classification functions or by helping each other by classifying each other?s data. Importantly, since the data is gathered at different locations, sending the data to another learner to process incurs additional costs such as delays, and hence this will be only beneficial if the benefits obtained from a better classification will exceed the costs. We model the problem of joint classification by the distributed and heterogeneous learners from multiple data sources as a distributed contextual bandit problem where each data is characterized by a specific context. We develop a distributed online learning algorithm for which we can prove sublinear regret. Compared to prior work in distributed online data mining, our work is the first to provide analytic regret results characterizing the performance of the proposed algorithm.



I. INTRODUCTION  A plethora of Big Data applications (network security, surveillance, health monitoring etc.) are emerging which require online classification of large data sets collected from distributed network and traffic monitors, multimedia sources, sensor networks, etc. This data is heterogeneous and dynamically evolves over time. In this paper, we introduce a distributed online learning framework for classification of high-dimensional data collected by distributed data sources.

The distributedly collected data is processed by a set of decentralized heterogeneous learners equipped with classi- fication functions with unknown accuracies. In this setting communication, computation and sharing costs make it in- feasible to use centralized data mining techniques where a single learner can access the entire data set. For example, in a wireless sensor surveillance network, nodes in different locations collect different information about different events.

The learners/machines at each node of the network may run different classification algorithms, may have different resolution, processing speed, etc.

The input data stream and its associated context can be time-varying and heterogeneous. We use the term ?context? generically, to represent any information related to the input data stream such as time, location and type (e.g., data features/characteristics/modality) information. Each learner can process (label) the incoming data in two different ways:  C. Tekin and M. van der Schaar are with the Dept. of Electrical Engineering, University of California, Los Angeles, CA, cmtkn@ucla.edu, mihaela@ee.ucla.edu  either it can exploit its own information and its own classifi- cation functions or it can forward its input stream to another learner (possibly by incurring some cost) to have it labeled.

A learner learns the accuracies of its own classification functions or other learners in an online way by comparing the result of the predictions with the true label of its input stream which is revealed at the end of each slot. The goal of each learner is to maximize its long term expected total reward, which is the expected number of correct labels minus the costs of classification. In this paper the cost is a generic term that can represent any known cost such as processing cost, delay cost, communication cost, etc. Similarly, data is used as a generic term. It can represent files of several Megabytes size, chunks of streaming media packets or contents of web pages. A key differentiating feature of our proposed approach is the focus on how the context information of the captured data can be utilized to maximize the classi- fication performance of a distributed data mining system.

We consider cooperative learners which classify other?s data when requested, but instead of maximizing the system utility function, a learner?s goal is to maximize its individual utility.

However, it can be shown that when the classification costs capture the cost to the learner which is cooperating with another learner to classify its data, maximizing the individual utility corresponds to maximizing the system utility.

To jointly optimize the performance of the distributed data mining system, we design a distributed online learning algorithm whose long-term average reward converges to the best distributed solution which can be obtained for the classification problem given complete knowledge of online data characteristics as well as their classification function accuracies and costs when applied to this data. We define the regret as the difference between the expected total reward of the best distributed classification scheme given complete knowledge about classification function accuracies and the expected total reward of the algorithm used by each learner.

We prove a sublinear upper bound on the regret, which implies that the average reward converges to the optimal average reward. The upper bound on regret gives a lower bound on convergence rate to the optimal average reward.

To illustrate our approach, we provide numerical results by applying our learning algorithm to the classification of network security data and compare the results with existing state-of-the-art solutions.

The remainder of the paper is organized as follows.

In Section II we describe the related work and highlight the differences from our work. In Section III we describe the decentralized data classification problem, the optimal distributed classification scheme given the complete system   Fifty-first Annual Allerton Conference Allerton House, UIUC, Illinois, USA October 2 - 3, 2013    model, its computational complexity, and the regret of a learning algorithm with respect to the optimal classification scheme. Then, we consider the model with unknown system statistics and propose a distributed online learning algorithm with uniform contextual partitioning in Section IV. Using a network security application we provide numerical results on the performance of our distributed online learning algorithm in Section V. Finally, the concluding remarks are given in Section VI.



II. RELATED WORK Related work can be divided into two categories: Online  learning for data mining and multi-armed bandit methods aimed at learning how to act sequentially.

Online learning in distributed data classification systems aims to address the informational decentralization, commu- nication costs and privacy issues arising in these systems.

For example in [1]?[4], various solutions are proposed for distributed data mining problems of horizontally distributed data, while in [5], [6] ensemble learning techniques are developed that exploit the correlation between the local learners for vertically distributed data. Several cooperative distributed data mining techniques are proposed in [6]? [9], where the goal is to improve the prediction accuracy with costly communication between local predictors. In this paper, we take a different approach: instead of focusing on the characteristics of a specific data stream, we focus on the characteristics of data streams with the same context information. This novel approach allows us to deal with both horizontally and vertically distributed data in a unified manner within a distributed data mining system. Although our framework and illustrative results are depicted using horizontally distributed data, if context is changed to be the set of relevant features, then our framework and results can operate on vertically distributed data. Moreover, we assume no prior knowledge of the data and context arrival processes and classification function accuracies, and the learning is done in a non-Bayesian way.

Most of the prior work in distributed data mining pro- vides algorithms which are asymptotically converging to an optimal or locally-optimal solution without providing any rates of convergence. On the contrary, we do not only prove convergence results, but we are also able to explicitly characterize the performance loss incurred at each time step with respect to the optimal solution. In other words, we prove regret bounds that hold uniformly over time. Some of the existing solutions (including [3], [4], [10]?[15]) propose ensemble learning techniques including bagging, boosting, stacked generalization and cascading, where the goal is to use classification results from several classifiers to increase the prediction accuracy. In our work we only consider choosing the best classification function (initially unknown) from a set of classification functions that are accessible by decentralized learners. However, our proposed distributed learning method can easily be adapted to perform ensemble learning. We provide a detailed comparison to our work in Table I.

Other than distributed data mining, our learning frame- work can be applied to any problem that can be formulated as  a decentralized contextual bandit problem. Contextual ban- dits have been studied before in [16]?[19] in a single agent setting, where the agent sequentially chooses from a set of alternatives with unknown rewards, and the rewards depend on the context information provided to the agent at each time step. To the best of our knowledge, our work is the first to ad- dress the decentralized contextual bandit problem in a system of cooperative learning agents. In [20], a contextual bandit algorithm named LinUCB is proposed for recommending personalized news articles, which is variant of the UCB algorithm [21] designed for linear payoffs. Numerical results on real-world Internet data are provided, but no theoretical results on the resulting regret are derived. A perceptron based algorithm is used with upper confidence bounds in [22] in a centralized single user setting that achieves sublinear regret when the instances are chosen by an adversary and the learning algorithm receives binary feedback about the true label instead of the true label itself. Previously, dis- tributed multi-user learning is only considered in the standard finite armed bandit problem. In [23], [24] distributed online learning algorithms that converge to the optimal allocation with logarithmic regret are proposed, given that the optimal allocation is an orthogonal allocation in which each user selects a different action. This is generalized in [25] to dynamic resource sharing problems and logarithmic regret results are also proved for this case. Alternatively, in this paper, we consider distributed online learning in a contextual bandit setting. We provide a detailed comparison between our work and related work in multi-armed bandit learning in Table II. Our decentralized contextual learning framework can be seen as an important extension of the centralized contextual bandits framework [16]. The main difference is that: (i) a three phase learning algorithm with training, exploration and exploitation phases are needed instead of the standard two phase, i.e., exploration and exploitation phases, algorithms used in centralized contextual bandit problems; (ii) the adaptive partitions of the context space should be formed in a way that each learner can efficiently utilize what is learned by other learners about the same context.

In the distributed contextual framework, the training phase is necessary since the context arrivals to learners are different which makes the learning rates of the learners for different context different.



III. PROBLEM FORMULATION  The system model is shown in Fig. 1. There are M learners which are indexed by the set M = {1, 2, . . . ,M}. Let M?i = M? {i}. These learners work in a discrete time setting t = 1, 2, . . . , T , where the following events happen sequentially, in each time slot: (i) a data stream si(t) with a specific context xi(t) arrives to each learner i ? M, (ii) each learner chooses one of its own classification functions or another learner to send its data and context, and produces a label based on the prediction of its own classification function or the learner to which its sent its data and context, (iii) the truth (true label) is revealed eventually, perhaps by     [3], [13] [7], [9] [5] This work [8], [14], [15]  Aggregation non- cooperative cooperative no cooperative  Message none data training data and label exchange residual only if improves  performance Learning offline/online offline offline Non-bayesian approach online Correlation N/A no no yes exploitation Information no all all only if improves from other accuracy learners Data horizontal horizontal vertical horizontal partition Regret no no no yes - sublinear bound  TABLE I COMPARISON WITH RELATED WORK IN DISTRIBUTED DATA MINING  [16]?[19] [23]?[25] [26] This work Multi-user no yes yes yes Cooperative N/A yes no yes Contextual yes no no yes Data arrival arbitrary i.i.d. or i.i.d. arbitrary process Markovian Regret sublinear logarithmic may be linear sublinear  TABLE II COMPARISON WITH RELATED WORK IN MULTI-ARMED BANDITS  events or by a supervisor, only to the classifier where the data arrived.

Each learner i ? M has access to a set of classifica- tion functions Fi which it can invoke to classify the data.

Classifier i knows the functions in Fi and costs of calling them1, but not their accuracies, while it knows the set of other learners M?i and costs of calling them but does not know the functions Fk, k ?M?i, but only knows an upper bound on the number of classification functions that each learner has, i.e., Fmax on |Fk|2, k ? M?i. Classifier i can either invoke one of its classification functions or forward the data to another learner to have it labeled. We assume that for learner i calling each classification function k ? Fi incurs a cost dk. For example, if the application is delay critical this can be the delay cost, or this can represent the computational cost and power consumption associated with calling a classification function. Since the costs are bounded, without loss of generality we assume that costs are normalized, i.e., dk ? [0, 1]. We assume that a learner can only call a single function for each input data in order to label it. This is a reasonable assumption when the application is delay sensitive since calling more than one classification function increases the delay. A learner i can also send its input to another learner in M?i in order to have it labeled.

Because of the communication cost and the delay caused by processing at the recipient, we assume that whenever a data stream is sent to another learner k ? M?i a cost of dk is incurred. The learners are cooperative which implies that learner k ?M?i will return a label to i when called by  1Alternatively, we can assume that the costs are random variables with bounded support whose distribution is unknown. In this case, the learners will not learn the accuracy but they will learn accuracy minus cost.

2For a set A, let |A| denote the cardinality of that set.

Fig. 1. Operation of the distributed data classification system from the viewpoint of learner 1.

i. Similarly, when called by k ? M?i, learner i will return a label to k. We do not consider the effect of this on i?s learning rate, however, since our results hold for the case when other learners are not helping i to learn about its own classification functions, they will hold when other learners help i to learn about its own classification functions. If we assume that dk also captures the cost to learner k to classify and sent the label to learner i, then maximizing i?s own utility corresponds to maximizing the system utility. Let Ki = Fi ?M?i. We call Ki the set of arms (alternatives).

We assume that each classification function produces a binary label3. The data stream at time t arrives to learner i with context information xi(t). The context may be generated as a result of pre-classification or a header of the data stream. For simplicity we assume that the context space is X = [0, 1]d, while our results will hold for any bounded d dimensional context space. We also note that the data input is high dimensional and its dimension is greater than d (in most of the cases its much larger than d) . For example, the network security data we use in numerical results section has 42 features, while the dimension of the context we use is at most 1.

Each classification function k ? ?i?MFi has an unknown accuracy ?k(x) ? [0, 1], depending on the context x. The ac- curacy ?k(x) represents the probability that an input stream with context x will be labeled correctly when classification function k is used to label it. Different classification functions can have different accuracies for the same context. Although we do not make any assumptions about the classification accuracy ?k(x) and the classification cost dk, in general one can assume that classification accuracy increases with  3In general we can assume that labels belong to R and define the classification error as the mean squared error or some other metric. Our results can be adapted to this case as well.

classification cost (e.g., classification functions with higher resolution, better processing). We assume that each classi- fier has similar accuracies for similar contexts; we formalize this in terms of a (uniform) Lipschitz condition.

Assumption 1: For each k ? ?i?MFi, there exists L > 0, ? > 0 such that for all x, x? ? X , we have |?k(x)??k(x?)| ? L||x? x?||?, where ||.|| denotes the Euclidian norm in Rd.

Assumption 1 indicates that the accuracy of a classification function for similar contexts will be similar to each other. We assume that ? is known by the learners. In the bandit setting this is referred to as similarity information [16], [27].

The goal of learner i is to explore the alternatives in Ki to learn the accuracies, while at the same time exploiting the best alternative for the context xt arriving at each time step t that balances the accuracy and cost to minimize its long term loss due to uncertainty. Learner i?s problem can be modeled as a contextual bandit problem [16]?[19]. After labeling the input at time t, each learner observes the true label and updates the sample mean accuracy of the selected arm based on this. Accuracies translate into rewards in bandit problems.

In the next subsection we formally define the benchmark solution which is computed using perfect knowledge about classification accuracies. Then, we define the regret which is the performance loss due to uncertainty about classification accuracies.

A. Optimal Classification with Complete Information  Our benchmark when evaluating the performance of the learning algorithm is the optimal solution which selects the classification function k with the highest accuracy minus cost for learner i from the set ?j?MFj given context xt at time t. We assume that the costs are normalized so the tradeoff between accuracy and cost is captured without using weights.

Specifically, the optimal solution we compare against is given by k?(x) = arg maxk?Ki ?k(x)? dk, ?x ? X .

Knowing the optimal solution means that learner i knows the classification function in ?i?MFi that yields the highest expected accuracy for each x ? X . Choosing the best classi- fication function for each context x requires to evaluate the accuracy minus cost for each context and is computationally intractable, because the context space X has infinitely many elements.

B. The Regret of Learning  In this subsection we define the regret as a performance measure of the learning algorithm used by the learners.

Simply, the regret is the loss incurred due to the unknown system dynamics. Regret of a learning algorithm for learner i is defined with respect to the best arm k?(x) for learner i.

The regret of a learning algorithm is given by  R(T ) :=  T? t=1  ?k?(xt)(xt)? E  [ T? t=1  (I(y?it = yt)? dk(xt))  ] ,  where y?it denotes prediction made by the classification func- tion or other learner k(xt) chosen by learner i at time t, yt denotes the true label and the expectation is taken with respect to the random selection made by the learning algo-  rithm. In the following section we will propose a distributed learning algorithm with sublinear regret.



IV. A DISTRIBUTED UNIFORM CONTEXT PARTITIONING ALGORITHM  In this section we consider a uniform partitioning algo- rithm. Assume that each learner runs the learning algorithm Classify or Send for Classification (CoS) given in Fig. 2.

Let mT be the slicing parameter of CoS that determines the partition of the context space X . Basically, choosing a large mT will improve classification accuracy while increasing the number of explorations. We will analyze the performance for a fixed mT and then optimize over it. CoS forms a partition of [0, 1]d consisting of (mT )d sets where each set is a d- dimensional hypercube with dimensions 1/mT ? 1/mT ? . . . ? 1/mT . Let PT = {P1, P2, . . . , P(mT )d} denote this partition where each Pl is a hypercube. When clear from the context, we will use l instead of Pl to denote the hypercube.

The set of arms for learner i consists of its classification functions and the set of learners it can send the data to, which is denoted by Ki.

Classify or Send for Classification (CoS for learner i):  1: Input: D1(t), D2(t), D3(t), T , mT 2: Initialize: Partition [0, 1]d into (mT )d sets. Let PT = {P1, . . . , P(mT )d} denote the sets in this partition.

N ik,l = 0,?k ? Ki, Pl ? PT , N i1,k,l = 0, ?k ?M?i, Pl ? PT .

3: while t ? 1 do 4: for l = 1, . . . , (mT )d do 5: if xi(t) ? Pl then 6: if ?k ? Fi such that N ik,l ? D1(t) then 7: Run Explore(k, N ik,l, r?k,l) 8: else if ?k ?M?i such that N i1,k,l ? D2(t) then 9: Obtain Nkl (t) from k, set  N i1,k,l = N k l (t)?N ik,l  10: if N i1,k,l ? D2(t) then 11: Run Train(k, N i1,k,l) 12: else 13: Go to line 15 14: end if 15: else if ?k ?M?i such that N ik,l ? D3(t) then 16: Run Explore(k, N ik,l, r?k,l) 17: else 18: Run Exploit(M il , r?l, Ki) 19: end if 20: end if 21: end for 22: t = t + 1 23: end while  Fig. 2. Pseudocode of CoS algorithm.

For each set in the partition PT , learner i keeps several  counters for each arm in Ki. Any time step t can be in one of the three phases: training phase in which learner i trains another learner by sending its own data, exploration phase in which learner i updates the estimated reward of an arm in Ki by selecting it, and exploitation phase in which learner i selects the arm with the highest estimated reward. The pseudocodes of these phases are given in Fig. 3. Upon each data arrival, learner i first checks to which set in the partition PT the context belongs. Let N il (t) be the number of data arrivals in Pl of learner i by time t. For k ? Fi, let N ik,l(t) be the number of times arm k is selected in response to a data     Train(k, n): 1: select arm k 2: Receive reward rk(t) = I(y?it = yt)? dk(xi(t)) 3: n + +  Explore(k, n, r): 1: select arm k 2: Receive reward rk(t) = I(y?it = yt)? dk(xi(t)) 3: r = nr+rk(t)  n+1 4: n + +  Exploit(n, r, Ki): 1: select arm k ? arg maxj?Ki rj 2: Receive reward rk(t) = I(y?it = yt)? dk(xi(t)) 3: r?k =  nk r?k+rk(t) nk+1  4: nk + +  Fig. 3. Pseudocode of the training, exploration and exploitation modules.

arriving to set Pl in the partition PT by learner i by time t.

Note that learner i does not know anything about learner k?s classification functions. Therefore, before forming estimates about the reward of k, it needs to make sure that k will almost always select its optimal classification function when called by i. This is why the training phase is needed for learners k ?M?i. To separate training, exploration and exploitation phases, learner i keeps two counters for k ? M?i. The first one, i.e., N i1,k,l(t), counts the number of data arrivals to learner k in set l by time t which includes data arrivals with context xk(t?) ? Pl, t? < t and data arrivals from learner i to k in the training phases of i. The second one, i.e., N i2,k,l(t), counts the number of data arrivals to learner k that are used in i?s reward estimation of k. This is the number of times data is sent from learner i to learner k in the exploration phase or exploitation phase of learner i. For simplicity of notation we let N ik,l(t) := N  i 2,k,l(t) for k ? M?i. The values of  these counters are random variables when the context arrival process is stochastic. Based on the values of these counters at time t, learner i either trains, explores or exploits an arm in Ki. This three phase learning structure is one of the major components of our learning algorithm which makes it different than the algorithms proposed for the contextual bandits in the literature which only have exploration and exploitation phases.

When a context xi(t) ? Pl arrives, in order to make sure that all classification functions of all learners are explored sufficiently, learner i checks if the following set is nonempty.

Si,l :=  { k ? Fi such that N ik,l(t) ? D1(t) or k ?M?i such that N i1,k,l(t) ? D2(t) or N i2,k,l(t) ? D3(t)  } .

For k ?M?i, let E ik,l(t) be the set of rewards collected from selections of arm k in set l by time t for which N i1,k,l(t) > D2(t). We note that, learner i does not have to communicate with learner k at each time step to update N i1,k,l(t). It only needs to communicate when N i1,k,l(t) ? D2(t). To obtain the correct value of N i1,k,l(t) it needs to know N  k l (t), since  N i1,k,l(t) = N k l (t) ? N i2,k,l(t). For k ? Fi, let E ik,l(t) the  set of rewards collected from arm k by time t. If Si,l 6= ?, then learner i explores by choosing randomly an arm ?(t) ? Si,l. If Si,l = ?, this implies that all classification functions have been explored sufficiently, so that learner i exploits by  choosing the arm with the highest sample mean estimate, i.e.,  ?(t) ? arg max k?Ki  r?ik,l(t), (1)  where r?ik,l(t) is the sample mean of the rewards in set E ik,l(t).

Explicitly, r?ik,l(t) = (  ? r?Eik,l(t)  r)/|E ik,l(t)|, where each r ? E ik,l(t) is equal to 1? dk if the classification is correct and ?dk if the classification is wrong. When there is more than one maximizer of (1), one of them is randomly selected. The exploration control functions D1(t), D2(t) and D3(t) ensure that each classification function is selected sufficiently many number of times so that the sample mean estimates r?ik,l(t) are accurate enough. In the following subsection we prove an upper bound on the regret of CoS.

A. Analysis of the regret of CoS  Let ?k(x) = ?k(x) ? dk, and ?a = ?? t=1 1/t  a.

For each Pl ? PT let ?k,l := supx?Pl ?k(x) and ? k,l  := infx?Pl ?k(x). Let x ? l be the context at the  center of the hypercube Pl. We define the optimal arm for Pl as k?(l) := arg maxk?Ki ?k(x  ? l ). Let Li?(t) :={  k ? Ki such that ?k?(l),l ? ?k,l > a1t ? }  , be the set of suboptimal arms for learner i at time t, where ? < 0, a1 > 0.

The learners are not required to know the values of the parameters ? and a1. They are only used in our analysis of the regret. First, we will give regret bounds that depend on values of ? and a1 and then we will optimize over these values to find the best bound.

The regret can be written as a sum of three components: R(T ) = E[Re(T )] +E[Rs(T )] +E[Rn(T )], where Re(T ) is the regret due to training and explorations by time T , Rs(T ) is the regret due to suboptimal arm selections in exploitations by time T and Rn(T ) is the regret due to near optimal arm selections in exploitations by time T , which are all random variables. In the following lemmas we will bound each of these terms separately. The following lemma bounds E[Re(T )]. Due to space constraints some of the proofs are not included in the paper. For the complete proofs please see the online appendix [28].

Lemma 1: When CoS is run by learner i with parameters D1(t) = t  z log t, D2(t) = Fmaxtz log t, D3(t) = tz log t and mT = dT ?e4, where 0 < z < 1 and 0 < ? < 1/d, we have  E[Re(T )] ? (mT )  d? l=1  (|Fi|+ (M ? 1)(Fmax + 1))T z log T  + (|Fi|+ 2(M ? 1))(mT )d  ? 2d(|Fi|+ (M ? 1)(Fmax + 1))T z+?d log T + 2d(|Fi|+ 2(M ? 1))T ?d .

From Lemma 1, we see that the regret due to explorations is linear in the number of hypercubes (mT )d, hence exponential in parameter ? and z. We conclude that z and ? should be small enough to achieve sublinear regret in exploration steps.

For any k ? Ki and Pl ? PT , the sample mean r?k,l(t)  4For a number r ? R, let dre be the smallest integer that is greater than or equal to r.

represents a random variable which is the average of the inde- pendent samples in set E ik,l(t). Different from classical finite- armed bandit theory [21], these samples are not identically distributed. In order to facilitate our analysis of the regret, we generate two different artificial i.i.d. processes to bound the probabilities related to r?k,l(t), k ? Ki. The first one is the best process in which rewards are generated according to a bounded i.i.d. process with expected reward ?k,l, the other one is the worst process in which the rewards are generated according to a bounded i.i.d. process with expected reward ? k,l  . Let rbestk,l (z) denote the sample mean of the z samples from the best process and rworstk,l (z) denote the sample mean of the z samples from the worst process. We will bound the terms E[Rn(T )] and E[Rs(T )] by using these artificial processes along with the similarity information given in Assumption 1. The following lemma bounds E[Rs(T )].

Lemma 2: When CoS is run with parameters D1(t) = tz log t, D2(t) = Fmaxtz log t, D3(t) = tz log t and mT = dT ?e, where 0 < z < 1 and 0 < ? < 1/d, given that 2L( ? d)?t??? + 6t?z/2 ? a1t?, we have  E[Rs(T )] ? 2d+1(M ? 1 + |Fi|)?2T ?d  + 2d+2(M ? 1)Fmax?2T ?d+z/2/z From Lemma 2, we see that the regret increases exponen- tially with parameters ? and z, similar to the result of Lemma 1. These two lemmas suggest that ? and z should be as small as possible, given the condition 2L(  ? d)?t??? + 6t?z/2 ?  a1t ?, is satisfied.

Each time learner i selects another learner k to label its data, learner k calls one of its classification functions. There is a positive probability that learner k will call one of its suboptimal classification functions, which implies that even if learner k is near optimal for learner i, selecting learner k may not yield a near optimal outcome. We need to take this into account, in order to bound E[Rn(T )]. The following lemma gives the bound on E[Rn(T )].

Lemma 3: When CoS is run with parameters D1(t) = tz log t, D2(t) = Fmaxtz log t, D3(t) = tz log t and mT = dT ?e, where 0 < z < 1 and 0 < ? < 1/d, given that 2L( ? d)?t??? + 6t?z/2 ? a1t?, we have E[Rn(T )] ?  (2a1T 1+?)/(1 + ?) + 4(M ? 1)Fmax?2.

From Lemma 3, we see that the regret due to near optimal arms depends exponentially on ? which is related to negative of ? and z. Therefore ? and z should be chosen as large as possible to minimize the regret due to near optimal arms.

Combining the above lemmas, we obtain the finite time, uniform regret bound given in the following theorem.

Theorem 1: Let the CoS algorithm run with exploration control functions D1(t) = t2?/(3?+d) log t, D2(t) = Fmaxt  2?/(3?+d) log t, D3(t) = t2?/(3?+d) log t and slicing parameter mT = T 1/(3?+d). Then,  E[R(T )] ? T 2?+d 3?+d  ( 2(2Ld?/2 + 6)  (2?+ d)/(3?+ d) + 2dZi log T  ) + T  ?+d 3?+d  2d+2(M ? 1)Fmax?2 (2?)/(3?+ d)  + T d  3?+d 2d(2Zi?2 + |Ki|) + 4(M ? 1)Fmax?2,  where Zi = Fi + (M ? 1)(Fmax + 1).

Proof: The highest orders of regret come from ex-  plorations and near optimal arms which are O(T ?d+z) and O(T 1+?) respectively. We need to optimize them with respect to the constraint 2Ld?/2t???+6t?z/2 ? a1t?, which is assumed in Lemmas 2 and 3. The values that minimize the regret for which this constraint hold is ? = ?z/2, ? = z/(2?) a1 = 2Ld  ?/2 + 6 and z = 2?/(3?+ d). Result follows from summing the bounds in Lemmas 1, 2 and 3.

Remark 1: Although the parameter mT of CoS depends on T and hence we require T as an input to the algorithm, we can make CoS run independent of the final time T and achieve the same regret bound by using a well known dou- bling trick (see, e.g., [16]). Consider phases ? ? {1, 2, . . .}, where each phase has length 2? . We run a new instance of algorithm CoS at the beginning of each phase with time parameter 2? . Then the regret of this algorithm up to any time T will be O  ( T (2?+d)/(3?+d)  ) .

For a fixed ?, the regret becomes linear in the limit as d goes to infinity. On the contrary, when d is fixed the regret decreases, and in the limit as ? goes to infinity it becomes O(T 2/3).

B. Regret of CoS for online learning classification functions  In our analysis we assumed that given a context x, the classification function accuracy ?k(x) is fixed. This holds when the classification functions are trained a priori, but the learners do not know the accuracy because k is not tested yet. By using our contextual framework, we can also allow the classification functions to learn over time based on the data. Usually in Big Data applications we cannot have the classifiers being pre-trained as they are often deployed for the first time in a certain setting. For example in [29], Bayesian online classifiers are used for text classification and filtering.

We do this by introducing time as a context, thus increasing the context dimension to d+1. Time is normalized in interval [0, 1] such that 0 corresponds to t = 0, 1 corresponds to t = T and each time slot is an interval of length 1/T .

For an online learning classifier, intuitively the accuracy is expected to increase with the number of samples, and thus, ?k(x, t) will be non-decreasing in time. On the other hand, the increase in the accuracy in a single time step should be bounded. Otherwise, the online learning classifier will be able to classify all possible data streams without any error after a finite number of steps. Because of this, in addition to Assumption 1, the following should hold for an online learning classifier: ?k(x, (t+ 1)/T ) ? ?k(x, t/T ) + LT??, for some L and ?. Then we have the following theorem when online learning classifiers are present.

Theorem 2: Let the CoS algorithm run with exploration control functions D1(t) = t2?/(3?+d+1) log t, D2(t) = Fmaxt  2?/(3?+d+1) log t, D3(t) = t2?/(3?+d+1) log t and slicing parameter mT = T 1/(3?+d+1). Then, E[R(T )]     ? T 2?+d+1 3?+d+1  ( 2(2L(d+ 1)?/2 + 6)  2?+d+1 3?+d+1  + 2d+1Zi log T  )  + T ?+d+1 3?+d+1  2d+3(M ? 1)Fmax?2 (2?)/(3?+ d+ 1)  + T d  3?+d+1 2d+1(2Zi?2 + |Ki|) + 4(M ? 1)Fmax?2,  where Zi = Fi + (M ? 1)(Fmax + 1).

C. Computational complexity of CoS  For each set Pl ? PT , classifier i keeps the sample mean of rewards from |Fi| + M ? 1 arms, while for a standard centralized bandit algorithm, the sample mean of the rewards of | ?k?M Fk| arms needs to be kept in memory. Since the number of sets in PT is upper bounded by 2dT d/(3?+d), the memory requirement is upper bounded by  (|Fi|+M ? 1)2dT d/(3?+d). (2)  This means that the memory requirement is sublinearly increasing in T and thus, in the limit T ?? goes to infinity, however, CoS can be modified so that the available memory provides an upper bound on mT . However, in this case the regret bound given in Theorem 1 may not hold.



V. NUMERICAL RESULTS  In this section we provide numerical results for CoS using network security data from KDD Cup 1999 data set. We compare the performance of our learning algorithm with AdaBoost [30] and the online version of AdaBoost called sliding window AdaBoost [31]. The network security data has 42 features. The goal is to predict at any given time if an attack occurs or not. We run the simulations for three different context information; (i) context is the label at the previous time step, (ii) context is the feature named srcbytes, which is the number of data bytes from source to destination, (iii) context is time. All the context information is normalized to be in [0, 1]. There are 4 local learners. Each local learner has 2 classification functions. Classification costs dk is set to 0 for all k ? K1.

All classification functions are trained using 5000 consecu- tive samples from different segments of the network security data. Then, they are tested on T = 20000 consecutive sam- ples. We run simulations for two different sets of classifiers.

In our first simulation S1, there are two good classifiers that have low number of errors on the test data, while in our second simulation S2, there are no good classifiers. The types of classification functions used in S1 and S2 are given in Table III along with the number of errors each of these classification functions made on the test data. From Table III we can observe that the error percentage of the best classification function is 3 in S1, while it is 47 in S2. A situation like in S2 can appear when the distribution of the data changes abruptly so that the classification functions trained on the old data becomes inaccurate for the new data. In our numerical results we will show how the context information can be used to improve the performance in both S1 and S2. The accuracies of the classifiers on the test data are unknown to the learners so they cannot simply choose  Learner 1 2 3 4 Class. Naive Bayes, Always 1, RBF Network, Random Tree, Func. (S1) Logistic Voted Perceptron J48 Always 0 Error 47, 53, 47, 47, % (S1) 3 4 47 47 Class. Naive Bayes, Always 1, RBF Network, Random Tree, Func. (S2) Random Random J48 Always 0 Error 47, 53, 47, 47, % (S2) 50 50 47 47  TABLE III ERROR PERCENTAGES OF CLASSIFICATION FUNCTIONS USED BY  LEARNERS ON THE TEST DATA.

D1(t) D2(t) D3(t) mT (C1) CoS t1/8 log t 2t1/8 log t t1/8 log t dT e1/4 (C2) CoS t1/2 log t 2t1/2 log t t1/2 log t dT e1/4  TABLE IV PARAMETERS FOR COS  the best classification function. In all our simulations, we assume that the test data sequentially arrives to the system and the label is revealed with a one step delay.

Since we only consider single dimensional context, d = 1.

However, due to the bursty, non-stochastic nature of the network security data we cannot find a value ? for which Assumption 1 is true. Nevertheless, we consider two cases, C1 and C2, given in Table IV, for CoS parameter values.

In C2, the parameters for CoS are selected according to Theorem 1, assuming ? = 1. In C1, the parameter values are selected in a way that will limit exploration and training.

However, the regret bound in Theorem 1 may not hold for these values.

In our simulations we consider the performance of learner 1. Table V shows under each simulation and parameter setup the percentage of errors made by CoS and the percentage of time steps spent in training and exploration phases for learner 1. We compare the performance of CoS with AdaBoost and sliding window AdaBoost (SWA) whose error rates are also given in Table V. AdaBoost and SWA are trained using 20000 consecutive samples from the data set different from the test data. SWA re-trains itself in an online way using the last w observations, which is called the window length.

Both AdaBoost and SWA are ensemble learning methods which require learner 1 to combine the predictions of all the classification functions. Therefore, when implementing these algorithms we assume that learner 1 has access to all classification functions and their predictions, whereas when using our algorithm we assume that learner 1 only has access to its own classification functions and other learners but not their classification functions. Moreover, learner 1 is limited to use a single prediction in CoS. This may be the case in a real system when the computational capability of local learners are limited and the communication costs are high.

First, we consider the case when the parameter values are as given in C1. We observe that when the context is the previous label, CoS performs better than AdaBoost and SWA for both S1 and S2. This result shows that although CoS only uses the prediction of a single classification func- tion, by exploiting the context information it can perform better than ensemble learning approaches which combine the predictions of all classification functions. We see that the error percentage is smallest for CoS when the context is the previous label. This is due to the bursty nature of     (parameter, Error % Training % Exploration % simulation) (C1,S1) CoS 0.7, 4.6, 4.8 0.3, 3, 2.8 1.4, 6.3, 8.5 (C1,S2) CoS 0.9, 39, 10 0.3, 3, 2.8 1.5, 6.5, 8.6 (C2,S1) CoS 16, 14, 41 8.5, 16, 79 55 27 20 (S1, S2) AdaBoost 4.8, 53 (S1, S2) SWA 2.4, 2.7 (w = 100) (S2, S2) SWA 11, 11 (w = 1000)  TABLE V ERROR, TRAINING EXPLORATION PERCENTAGES OF COS FOR  DIFFERENT PARAMETERS AND SIMULATIONS, AND ITS COMPARISON WITH ADABOOST AND SWA.

the attacks. When the context is the feature of the data or the time, for S1, CoS performs better than AdaBoost while SWA with window length w = 100 can be slightly better than CoS. But again, this difference is not due to the fact that CoS makes too many errors. It is because of the fact that CoS explores and trains other classification functions and learners. AdaBoost and SWA does not require these phases. But they require communication predictions of all classification functions and communication of all local learners with each other at each time step. Moreover, SWA re-trains itself by using the predictions and labels in its time window, which makes it computationally inefficient. Another observation is that using the feature as context is not very efficient when there are no good classifiers (S2). However, the error percentage of CoS (39%) is still lower than the error percentage of the best classifier in S2 which is 47%.

We observe that CoS performs poorly when the set of parameters is given by C2. This is due to the fact that the percentage of training and exploration phases is too large for C2, thus CoS cannot exploit the information it gathered efficiently. Another important reason for the poor perfor- mance is the short time horizon. As the time horizon grows, we expect the exploration and training rates to decrease, and the exploitation rate to increase which will improve the performance.



VI. CONCLUSION In this paper we developed a novel online learning algo-  rithm for decentralized Big Data classification using context information about the high dimensional data. We proved sublinear regret results for this algorithm and showed via numerical results that it outperforms ensemble learning ap- proaches in a network security application.

