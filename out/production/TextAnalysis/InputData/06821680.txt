Design of Cloud-Based University Data Structure

Abstract? The independently development of information system in a big organization which has many departments or sub- departments such as university has big problems on data exchange, duplication and consistency. Each application system architecture is increasingly incompatible when organization is growing while requires more availability, reliability, scalability for massive data and flexibility for many new requirements. In this paper, we design the unified cloud-based data structure and API for centralized applications data structure. The designed system is divided into 3 layers, storage, programmer and application layers for complexity isolation on cloud-based infrastructure. The paper discusses overall designed system architecture, the proposed Object-oriented data model and tree- based structure for hierarchically object relations. All applications storing and processing data on cloud-based infrastructure are interfaced by the REST-style API standard, which flexible for many languages and platforms. The data processing performance test results show stability and scalability of our system.

Keywords?cloud-based; data structure; university; tree-based; information system; object-oriented;

I. INTRODUCTION In a big organization such as the Prince of Songkla  University which has 5 campuses, 30 faculties around southern of Thailand, each faculty independently developed its own information systems for flexibility and meet user requirements.

However, this cause data exchange, duplication and consistency problems. In recent years, researchers have solved this problem by unified information portal under the environment of unified certification, unified users and unified security [1]. However, the system design and construction inflexible to develop and modified applications. The uncertain structure of data is a main problem because data stored is fixed- structure then the data structure cannot fully meet users? requirements. Some researcher proposed a method that converts dynamic attributes modifications of the uncertain data objects to records changing in fixed-structure table [2]. This research is designed the office automation based on J2EE architecture and used SQL Server 2005 which is a relational database. The database layer has a limitation of scalability and has high cost in a long term support [3]. The SOA technology is one solution to solved the problem of information exchange in digital campus [4]. However, the solution implemented also  on relational database, did not on cloud platform which has more scalability.

The cloud computing takes advantages of high scalability, availability and reliability which is suitable for the next generation information systems infrastructure [5]. Application development on cloud platform is difficult, complex and high cost because developer must learn both cloud computing system and distributed system programming. So, we proposed the system designed for separating the complex part of cloud based data management and establish connectivity with the REST (Representational State Transfer)-style API [6] to easier application development.

Based on this consideration, this paper discusses the design overview of infrastructure purposed the Object-oriented data model, tree-based structure for hierarchically object relations and the REST-style API standard interface for storing and processing data on cloud-based infrastructure. This system design on cloud platform using the Apache Hbase [7] which is a NoSQL databases for storing semi-structured data based on the Apache Hadoop [8], a distributed file system for store unstructured data for high-performance processing and retrieval massive data.

The rest of this paper is organized as follows. Section II briefly overview the system architecture. Section III, we present our data structure and API. Section IV, we discuss experimental results of performance testing of query and application implementation on the Object-oriented data model and tree-based structure. Finally, concludes the paper with some direction for the future work.



II. CLOUD-BASED SYSTEM ARCHITECTURE In order to support development of various applications in  the multi-campus university that has many faculties and has different requirements, need more availability, reliability and requires more data scalability for long term support. We have designed the system based on cloud computing architecture.

The development of application on cloud-based infrastructure is complex and the developer must have skill on cloud computing programming. The system architecture is designed by divided into 3 layers which are storage, programmer and application layers for isolation of each complex part as shown in Fig 1.

Fig. 1. The 3 layers of cloud-based system architecture  1) Storage Layer The storage layer is designed based on cloud-based  NoSQL database for storing and processing data using the Apache Hadoop and the Apache Hbase which were accepted in several researches [9]?[11]. Both are designed for high availability, reliability, scalability, and support both structured data and unstructured data. This layer, we have designed data structure as Object-oriented data model and tree-based structure for hierarchically object relations which will be discussed in the next section.

2) Programmer Layer The programmer layer is a layer for development of  functions or frameworks to manage and process No-SQL cloud-based data in Object-oriented data model and tree-base structure which is called WebObject. This layer provides a simple interface to the application layer using the REST-style API which supports in many programming languages. The basic REST-style API functions are create, read, update and delete object (CRUD) in storage layer. Moreover, we can build more complex functions or frameworks for supporting more specific applications by using the Application Manager API. Then, the Account Manager provide API for system account management based on the OAuth 2.0, an open standard for authorization which support on platform of well- known companies such as Facebook, Google and Microsoft [12].

3) Application Layer The application layer provides tools for developers or users  to develop and manage their jobs and workflows easily with no cloud computing programming knowledge. Applications are freely store or process WebObject depend on its functions.

However, for more easily application development, we design a drag and drop style Web application tools for easily creating form and workflow.



III. DATA STRUCTURE AND API This section describes detail of Object-oriented data model,  tree-based structure and REST-style API and implementation example.

A. Objected-Oriented Data Model Applications may need to manipulate various data,  structure or unstructured. The system has to support both of them for flexibility. However, fixed-structure may limited a new requirements which usually occurs on any active systems.

So, our database design goal is to model a generic form of data that can be used to represents anything. This is modeled by using object-oriented concept, data is an object.  The object is composed of properties, a key-value data. This model can be constructed and implemented with fixed-structure but flexible for storing and processing any kind of object.

In Fig 2 show an example of fixed-structure. The table composed of 3 columns are URI which is a primary key for object reference, property-key and property-value. Two example objects which represented by the right side box are the ?/ebook? and the ?/AccountA? which referred by URI.

Each object has key-value properties that can freely set depend on type of object such as the ?/ebook? have ?id?, ?path? and ?type? properties and the ?/AccountA? have ?id?, ?firstname? and ?lastname? properties. We also have designed common properties for object such as ?created?, ?last modified?, etc.

Including, the relations between objects will be discussed next.

Fig. 2. Objected-oriented data model  B. Tree-Based Structure Tree structure represents relations between parent and child  node. Root node of a tree generally drawn at the top represents origin of all nodes. This structure can be applied in many areas to represent many data models especially modeling problems or solutions. Many fast search algorithms were developed under tree structure and have been proofed for a long time.

Moreover, the tree structure is very familiar for everyone because it is a structure of file systems while a node in the tree can be referred by path or URI. Construction and implementation for adding, removing and searching nodes on cloud-base infrastructure also clear because of this well-known structure. The tree-based structure design example as shown in Fig 3.

Application Layer  Storage Layer  HDFS (Hadoop Distributed File System)  HBASE (NoSQL Databases)  Programmer Layer (REST API)  Application1 Application2 Application3 Application4  WebObjectManager  Account Manager Application Manager  URI Property-Key Property-Value  /ebook  /ebook  Table  type  id  file   /ebook  /AccountA  /AccountA  /AccountA  path /ebook  id 2000101  firstname john  lastname maven  ebook  id : String = 1000101 path : String = /ebook type : String = file  AccountA  id : String = 2000101 firstname : String = john lastname : String = maven      Fig. 3. Tree-based structure design example  To demonstrate the application of our design, an example of simple organization is shown in Fig 3. The root node of tree organization model is the ?System? node. It has two child nodes called ?Groups? and ?Account?. The ?Account A? and ?Account B? nodes represents users ?A? and ?B? which are child node of ?Account? node. Besides that, in a box title ?Properties? represents properties of the ?Account B? node.

There are URI called ?/System/Account/Account B? and properties called ?Username?, ?Password?, ?Firstname?, ?Lastname?, ?Rolename? and ?Status?. All of nodes and tree structure construction and management or properties getting and setting can be done by using the REST style API.

C. REST-style API We have designed API for Object-oriented and tree-based  structure management in storage layer. The API based on the REST architectural style introduced by Roy Thomas Fielding in 2000 [13], which implies the use of HTTP, and the Extensible Markup Language (XML) and JavaScript Object Notation (JSON), a lightweight text-based code, to create objects and transfer (object/data) over the Internet [14]. This ensures that our API is easily accessible using many popular programming languages. The concept proposed in this paper is functional to manage objects on tree-based structure, create, read, update and delete object. The object is called WebObject and API is called WebObjectManager. The REST-style API is displayed in Fig 4.

Fig. 4. REST-style API design  As can be seen from Fig 3, we design data structure to Object-oriented and tree-based structure which represent node  in tree is WebObject and API for manage WebObject on Object-oriented and tree-based structure is WebObject Manager.

1) WebObjectManager The WebObjectManager use for create, read, update and  delete object in Object-oriented and tree-based structure which other API can build on top it. The REST-style API also map the tree of object in to URI which is a simple and commonly used for programming on the Web.

2) Account Manager The Account Manager is the API to manage account which  provide services for registration, authentication, and authorization.

3) Application Manager The Application Manager provide the API for tools at  application layer which are utilities for job and workflow management. These API can be used to build any specific applications. For example, human resource management system, accounting system, E-document system and student information system, etc., which each application has different processing flows thus the API is designed flexible to apply for many requirements.



IV. EXPERIMENTAL AND ANALYSIS  A. Methodology We separated performance testing into 2 groups, basic  object management test and object scanning test. The basic object management test is a test of 4 functions, create, read, update and delete object. The object scanning test is a test for searching objects based on its property condition. The testing software was developed in Java language and interface with the system via the REST-style API. The testing process is to measure performance when the system growing start at 1 million objects to 10 million objects step increasing by 1 million objects. Each step, we averaged response time from 200 times of measurements.

B. Experimental Setup The experimental setup has 2 type of environments, virtual  and physical machines. In virtual machine environments, we used the Oracle VirtualBox software run 6 virtual machines on each 2 physical machines, each machine was running on CPU AMD FX(tm)-8120 8-Core at speed 3.1 GHz with 16 GBs of RAM and each virtual machine was limited to run on 1 core CPU with 2 GBs of RAM. In physical machine environment, each machine was running on CPU Intel core i5 3470 at speed 2.90 GHz with 8 GBs of RAM. All machines was setup to run the Apache Hadoop version 1.2.1 in multi-node mode and the Apache Hbase version 0.94.12 under 64-bit Ubuntu 12.10 operating system.

C. Results In Fig 5-8, the result show performance of CRUD  functions on virtual machines on 1, 4, 8 and 12 nodes. The  Programmer Layer  WebObjectManager  Account Manager Application Manager  Create Read Update Delete  Application(S)  REST  System  GroupsAccount  Account A  Account B  ROOT  PARENT  CHILD  Property (Account B)  Username Password Firstname LastName Rolename StatusURI : /System/Account/Account B     execution times which evaluated from 1-10 million objects show stable performance when number of objects is increased.

The result of create function in Fig 5 show a little faster on single node than multi-nodes, around 0.010-0.012 seconds, read function in Fig 6 show that on 8 node has a little slower at 3, 7 and 9 million objects, update function in Fig 7 show that there are sometimes slower response on 8 and 12 node and delete function in Fig 8 show that on 1 node is slowest, around 0.041-0.043 seconds.

0.000  0.010  0.020  0.030  0.040  0.050  0.060  1 2 3 4 5 6 7 8 9 10  R E  SP O  N SE  T IM  E (s  )  NUMBER OF OBJECT (MILLION)  CREATE (VIRTUAL MACHINE)  1N 4N 8N 12N Fig. 5. Performance of create function on virtual machines, 1,4,8,12 nodes  0.000  0.010  0.020  0.030  0.040  0.050  0.060  1 2 3 4 5 6 7 8 9 10  R ES  PO N  SE T  IM E  (s )  NUMBER OF OBJECT (MILLION)  READ (VIRTUAL MACHINE)  1N 4N 8N 12N Fig. 6. Performance of read function on virtual machines, 1,4,8,12 nodes  0.000  0.010  0.020  0.030  0.040  0.050  0.060  1 2 3 4 5 6 7 8 9 10  R ES  PO N  SE T  IM E  (s )  NUMBER OF OBJECT (MILLION)  UPDATE (VIRTUAL MACHINE)  1N 4N 8N 12N Fig. 7. Performance of update function on virtual machines, 1,4,8,12 nodes  0.000  0.010  0.020  0.030  0.040  0.050  0.060  1 2 3 4 5 6 7 8 9 10  R ES  PO N  SE T  IM E  (s )  NUMBER OF OBJECT (MILLION)  DELETE (VIRTUAL MACHINE)  1N 4N 8N 12N Fig. 8. Performance of delete function on virtual machines, 1,4,8,12 nodes  In Fig 9-12, the result show performance of CRUD functions on physical machines, 1, 4, 8 and 12 nodes. The execution time which evaluated from 1-10 million objects show stable performance when number of object is increased.

All results of CRUD functions show that on single node has around 2 times faster than multi-nodes. The result of create and read function in Fig 9 and 10, respectively show that the performance of 4 node is slowest, around 0.022-0.027 seconds for create and around 0.019-0.023 seconds for read.

0.000  0.010  0.020  0.030  0.040  0.050  0.060  1 2 3 4 5 6 7 8 9 10  R ES  PO N  SE T  IM E  (s )  NUMBER OF OBJECT (MILLION)  CREATE (PHYSICAL MACHINE)  1N 4N 8N 12N Fig. 9. Performance of create function on physical machines, 1,4,8,12 nodes  0.000  0.010  0.020  0.030  0.040  0.050  0.060  1 2 3 4 5 6 7 8 9 10  R ES  PO N  SE T  IM E  (s )  NUMBER OF OBJECT (MILLION)  READ (PHYSICAL MACHINE)  1N 4N 8N 12N Fig. 10. Performance of read function on physical machines, 1,4,8,12 nodes     0.000  0.010  0.020  0.030  0.040  0.050  0.060  1 2 3 4 5 6 7 8 9 10  R ES  PO N  SE T  IM E  (s )  NUMBER OF OBJECT (MILLION)  UPDATE (PHYSICAL MACHINE)  1N 4N 8N 12N Fig. 11. Performance of update function on physical machines, 1,4,8,12 nodes  0.000  0.010  0.020  0.030  0.040  0.050  0.060  1 2 3 4 5 6 7 8 9 10  R ES  PO N  SE T  IM E  (s )  NUMBER OF OBJECT (MILLION)  DELETE (PHYSICAL MACHINE)  1N 4N 8N 12N Fig. 12. Performance of delete function on physical machines, 1,4,8,12 nodes  Overall performance of CRUD functions on physical machines is more stable than on virtual machines which has limited resources. On single node of physical machine is around 2 times faster than multi-node. This may cause from network traffics and load balancing process in multi-node mode.

The average execution time of CRUD functions evaluated from 1-10 million objects on 1, 4, 8 and 12 virtual machines is shown in Fig 13. The create function is fastest and update function is slowest.

0.000  0.010  0.020  0.030  0.040  0.050  0.060  CREATE READ UPDATE DELETE  R ES  PO N  SE T  IM E  (s )  FUNCTION  PERFORMANCE OF CRUD FUNCTIONS ON VIRTUAL MACHINES  12N 8N 4N 1N Fig. 13. Performance of CRUD functions on virtual machines, 1,4,8,12 nodes  The average execution time of CRUD functions evaluated from 1-10 million objects on 1, 4, 8 and 12 physical machines  is shown in Fig 14. The read functions is fastest and update function is slowest.

0.000  0.010  0.020  0.030  0.040  0.050  0.060  CREATE READ UPDATE DELETE  R E  SP O  N SE  T IM  E (s  )  FUNCTION  PERFORMANCE OF CRUD FUNCTIONS ON PHYSICAL MACHINES  1N 4N 8N 12N   Fig. 14. Performance of CRUD functions on physical machines, 1,4,8,12 nodes  Fig 15 show the results of search performance on physical machines in 1, 4, 8 and 12 nodes. Overall performance is increasing when number of node is increased. However, the results show unstable performance, for 8 nodes at 5 million objects and 12 nodes at 10 million objects due to the auto split feature in the Hbase that sometimes when server overload but the Hbase cannot move region to other region server for load balancing. Then, that overload region server has slow response which affect overall response time.

1 2 3 4 5 6 7 8 9 10  R E  SP O  N SE  T IM  E (s  )  NUMBER OF OBJECT (MILLION)  PERFORMANCE OF SEARCH ON PHYSICAL MACHINES  1N 4N 8N 12N   Fig. 15. Performance of search on physical machines, 1,4,8,12 nodes

V. CONCLUSION Affectively information system such as HR management,  financial management is the guarantee to achieve competitive advantage for the enterprise. In this paper, the cloud-based system architecture has been designed by divided into 3 layers for complexity separation. The flexibility of data structure also designed by using the Object-oriented concept for data modeling support both structure and unstructured data and tree- based structure for hierarchically objects relations. The REST- style API is implemented for manage objects and support for many programming languages. The experimental result show how to storing data from each application and show performance of 4 functions via the REST-style API compared when increase number of node which the performance test results show stability and scalability of our system based on the Apache Hadoop and the Apache Hbase.

