CTU-Mine: An Efficient High Utility Itemset Mining  Algorithm Using the Pattern Growth Approach

Abstract  Frequent pattern mining discovers patterns in transaction databases based only on the relative frequency of occurrence of items without considering their utility. For many real world applications, however, utility of itemsets based on cost, profit or revenue is of importance. The utility mining problem is to find itemsets that have higher utility than a user specified minimum. Unlike itemset support in frequent pattern mining, itemset utility does not have the anti- monotone property and so efficient high utility mining poses a greater challenge. Recent research on utility mining has been based on the candidate-generation- and-test approach which is suitable for sparse data sets with short patterns, but not feasible for dense data sets or long patterns. In this paper we propose a new algorithm called CTU-Mine that mines high utility itemsets using the pattern growth approach. We have tested our algorithm on several dense data sets, compared it with the recent algorithms and the results show that our algorithm works efficiently.

Keywords Utility mining, high utility itemset, frequent pattern  1. Introduction   Data mining is used to extract structured knowledge from large data sets. Frequent pattern mining [1] is the foundation for association rules mining, and is also used in classification and clustering methods.

Association rule mining is a method of finding relationships of the form X Y amongst itemsets that occur together in a database where X and Y are disjoint itemsets. Frequent pattern mining algorithms work on transaction databases that represent the occurrence of each item in a transaction as a binary value without considering its quantity or weight (based on price, cost or profit). However, quantity and weight are significant for addressing real world decision problems that require maximizing the utility in an organization. For  example, selling a laser printer may occur less frequently than sale of glossy paper in an electronic superstore, but the former gives a much higher profit per unit sold. The high utility itemset mining problem is to find all itemsets that have utility larger than a user specified value of min_utility.

The frequent pattern mining algorithms use the Apriori principle [1] that any superset of a non- frequent itemset is also non-frequent. This anti- monotone property of itemsets is used to reduce the search space by pruning the non-frequent itemsets early. The Apriory principle does not hold for itemset utility, since the superset of a low utility itemset may not be a low utility itemset. For example, if itemset {printer ink} has a low utility, its superset, {printer ink, color laser printer} might have a high utility, and so we cannot prune {printer ink}.

Yao et al. [2, 3] proposed a framework for high utility itemset mining and described pruning strategies based on the mathematical properties of utility constraints. Using these pruning strategies, they developed algorithms Umine and Umine_H to find high utility itemsets. Recent research has focused on efficient high utility mining using intermediate anti- monotone measures for pruning the search space. Liu et al. [4] propose a two phase algorithm to mine high utility itemsets. They use a transaction weighted utility measure in the first phase to find supersets of high utility itemsets, followed by a rescan of the database to determine the actual high utility itemsets among them.

However, their algorithm is based on the candidate generation-and-test approach and so suffers from poor performance when mining dense datasets and long patterns much like the Apriori algorithm for frequent pattern mining.

In this paper, we propose an efficient algorithm for utility mining using the pattern growth approach [5] to overcome the limitations of existing algorithms based on the candidate generation-and-test approach. We introduce a compact data representation named Compressed Transaction Utility tree (CTU-tree) which extends the CT-tree of [6] for utility mining, and a new algorithm named CTU-Mine for mining complete high   DOI 10.1109/CIT.2007.120     utility itemsets. Compared to the two phase algorithm of Liu et al. [4], our algorithm not only uses pattern growth instead of candidate generation-and-test, but also eliminates the expensive second phase of scanning the database to remove the spurious high utility itemsets. The performance of CTU-Mine is compared against the implementation of the TwoPhase algorithm [4] available from [8].

The rest of the paper is organized as follows: In Section 2, we define the relevant terms. In Section 3, we present the CTU-Tree data structure. Section 4 describes the CTU-Mine algorithm. The performance studies of the algorithm are given in section 5. Section 6 is the conclusion of the paper.

2. High Utility Itemset Mining   In this Section, we give the basic notations and the definitions of terms to describe high utility itemset (HUI) mining, based on [2, 3]. Let I={i1,i2,?,im} be a set of items and D={T1,T2,?,Tn} be a transaction database where the items of each transaction Ti  is a subset of I. Itemset X is a subset of I. The quantity of an item ip in a transaction Tq is denoted by o(ip,Tq). The external utility s(ip) is the value of a unit of item ip in the utility table, (e.g., profit per unit). The utility of item ip in transaction Tq, denoted by u(ip,Tq) is defined as o(ip,Tq) ? s(ip). Let an itemset X be a subset of I. The utility of X in transaction Tq, denoted by u(X,Tq) is defined as :  ? ?= Xi qpq p TiuTXu ),(),( .        (1) The utility of itemset X in the database, denoted by u(X) is defined as:  ? ???= qq TXDT qTXuXu ),()( .       (2) The task of high utility itemset mining is to find all  itemsets that have utility above a user-specified min_utility. Since utility is not anti-monotone, Liu et al. [4] proposed the concepts of Transaction Utility (TU) and Transaction Weighted Utility (TWU) to prune the search space of high utility itemsets.

Transaction Utility of a transaction, denoted tu(Tq) is the sum of the utilities of all items in Tq:  ? ?  = qp Ti  qpq TiuTtu ),()( .    (3)  Transaction Weighted Utility of an itemset X, denoted as twu(X) is the sum of the transaction utilities of all the transactions containing X:  ? ???  = qq TXDT  qTtuXtwu )()(         (4)  As shown in [4], any superset of a low TWU itemset is also a low TWU itemset. Thus we can use  TWU to prune the supersets of low TWU itemsets.

However, since TWU is an over-estimation of the real utility itemset value, further pruning of high TWU itemsets will be required for mining high utility itemsets.

A B C D E F TID   Transaction Utility ($)  t1 2 0 1 1 0 0 80 t2 2 1 1 0 0 0 195 t3 0 0 1 1 10 0 110 t4 0 1 0 0 15 0 225 t5 1 0 1 0 0 1 37 t6 2 0 0 1 10 0 105 t7 2 0 0 0 8 1 62 t8 1 1 0 1 2 0 205 t9 1 0 0 1 10 0 95 t10 1 1 0 0 5 0 185  total 12 4 4 5 60 2 1299 (a) Transaction database   Item Profit ($)  A Printer Ink 10 B Color Laser Printer 150 C Bubble Jet Printer 25 D Digital Camera 35 E Glossy Photo Paper 5 F Floppy Disk 2  (b) Utility table Figure 1.  An example transaction database and utility table   Suppose we have a small transaction database of an  electronic retailer as shown in Figure 1(a). Figure 1(b) shows the profit (external utility) for each item. The values in each row in figure 1(a) shows the quantity of each item bought in a particular transaction, (i.e. the local transaction utility value). The last column shows the transaction utility for each transaction with total transaction utility of the database in the last row.

In transaction t1, two A (printer ink), one C (bubble jet printer), and one D (digital camera) were bought, yielding transaction utility of $80. The utility of item A, u(A,t1) is $20 and the utility of item A in the whole database, u(A) = $120. Itemset CD occurs 2 times, in transactions t1 and t3. Further, u(CD,t1) = $60, u(CD,t3) = $60 and u(CD) = $120. The TWU of item B (color laser printer) is the sum of the transaction utilities of (t2, t4, t8, t10) = $810 and the TWU of itemset AC is the sum of transaction utilities of (t1, t2, t5) = $312.

3. CTU-Tree Data Structure   We have designed the CTU-Tree data structure to compactly represent the transaction data required for high utility mining. CTU-tree is an extension of CT- tree introduced in [6]. As shown in Figure 2, a CTU- tree consists of two parts:                      (1) ItemTable: It contains all the high TWU (hTWU)  items sorted in ascending order of their TWU values. Each entry in the ItemTable consists of six fields, (1) index or the mapped item-id used in the compressed transaction tree, (2) original item-id, (3) profit or utility per unit of the item, (4) total quantity of the item in the database, (5) TWU of the individual item in the database and (6) a pointer to the root of the subtree of the given item.

(2) Compressed Transaction Utility Tree: It records all transactions of high TWU items along with the quantities of transactions in a compressed form.

Each node contains a mapped item-id and an array of TWU values for the patterns at that node, each with a pointer to associated quantities. The root of the tree corresponds to the first item in ItemTable.

The TWU values and quantities at a node are consolidated from all the transactions that have the corresponding patterns represented at that node.

Based on the description above, the CTU Tree can be constructed as follows:  1. Construction of ItemTable: Initially the table contains just the row headings and none of the items.

The database is scanned once. On retrieval of each transaction, the ItemTable is updated as follows: (a) For each item present in the transaction and not  present in the ItemTable, generate a new column of the table and initialize the entries, namely, the original item-id , utility per unit of the item, total quantity of the item in the transaction, and the transaction utility of this transaction. Note that the mapped item-id and the pointer to the root of the subtree will be null at this stage.

(b) For each item present in the transaction and in the ItemTable, update the following entries in the column corresponding to the item: add the total quantity of the item in the transaction to the  existing entree; add the transaction utility of this transaction to the existing entree.

On the completion of the first scanning of the database the ItemTable is reorganized as follows: (a) Delete the items and the respective columns from  the table if the respective TWU of the item is less than min_utility .

(b) Sort the remaining items of the table in ascending order of their TWU values termed as individual high TWU (1-hTWU).

(c) The sorted item-ids are mapped to new identifiers that are in an ascending sequence of integers.

(d) For each item-id in the ItemTable associate a pointer to the root of the subtree of the corresponding mapped new item-id. Let N denote the number of items with 1-hTWU listed in ItemTable.

Consider the transaction database and the utility table of items given in Figure 1. Suppose the user wants to mine the high utility itemsets with a minimum utility of 10% of total transaction utility in the database that is equal to $129.9. On completing the database scan, the items with less than min_util will be pruned.

For our example, the item 6 is excluded, since its TWU is 99, which is less than min_utility. The constructed ItemTable is shown in Figure 2. The mapped new index 1 to 5 correspond respectively to the original items 3, 4, 2, 1 and 5.

2. Construction of Compressed Transaction Utility Tree (CTU ? tree):  First initialize the CTU-Tree with root node identified by item-id 1. From the root node construct a path with (N-1) nodes identified by item- ids 2, ?, N such that node i is successor of node (i-1) for 2 ? i ? N. For each item i in the ItemTable attach a pointer to the root of the subtree generated by the node i of the initial CTU-Tree. This pointer will be used as a starting point to mine all high utility itemsets using CTU-Tree. We attach to node i the 1-itemset {i} and the corresponding TWU is initialized to zero. Node  i will represent the following: patterns [(i-1)i], [(i-2)(i- 1)i], ?, [12 ? i] generated from its predecessors; the corresponding array of their TWU values (initially set to zero) and each pattern has a pointer associated to an array of the total quantities (initially set to zero) of the items transacted by this pattern in the database. Note that the pattern itself is not stored at each node but it is shown for clarity by shaded region in Figure 2. In ItemTable, there is a pointer to the subtree (PST) of each item. Also note that each node of the CTU-tree will be identified using an appropriate mapped item-id defined by the ItemTable.

Next the database is scanned once to complete the construction of the CTU-tree. On scanning a transaction, we insert into the CTU-tree relevant patterns and related information generated by the  Figure 2 CTU-Tree and Item Table     1-hTWU items listed in ItemTable. More specifically, the CTU-tree is updated as follows after scanning each transaction:  Let i1, i2, ?, ik be the 1-hTWU items in the increasing order of the mapped index-id. that appeared in the transaction. If a pattern generated by this transaction is not present in the current CTU-tree, a node is created as part of an appropriate subtree and all the relevant patterns are recorded along with the updated TWU and the array of total quantities.   If a pattern generated by this transaction is present in some node of the current CTU-tree, then we update the TWU and the array of total quantities associated with it.

While updating the TWU for any pattern the contributions of the items not included in the ItemTable are deducted from the corresponding transaction value.

Consider the ItemTable constructed in Figure 2.

Each transaction will be inserted into the tree using the mapping in ItemTable. For example while scanning transaction 1, which has sorted mapped item-id 1, 2 and 4 (for the original items 3, 4 and 1) with respective quantities 1, 1, and 2. This pattern is inserted into the tree with the TWU (80) and a pointer pointing to the quantity values 1, 1 and 2. When a transaction is inserted into the tree, all entries along the path starting with the left most items are updated with appropriate TWU and quantity. For example, when a transaction with pattern 124 is inserted, the TWU entries and quantity of pattern 1 and 12 will also be updated.

4. CTU-Mine Algorithm   In this Section, we describe the CTU-Mine  algorithm. The pseudo code of the algorithm is presented in Figure 3.

Each item of the ItemTable is used as the starting point to mine all high utility itemsets in the associated subtree by first checking its TWU. In the following discussion for a given itemset the corresponding values of utility and TWU are indicated by the type of enclosing brackets, such as (utility) and <TWU>.

Starting with the subtree that has item 1 in the root (line 2), itemsets at the node are checked for minimum utility (line 3). The result is the pattern 1(100) which corresponded to itemset 3 (see Figure 2). Since the value is less than min_utility, pattern 1 is not included in HUI. Next, the child sub-trees of the current node are checked for the remaining items in ItemTable from the rightmost to the second item on the right of the current item. An array named sumTWU (initialized in line 5) is used for storing the temporary results of TWU during traversal. Starting from the rightmost item which is 5, we check the TWU of pattern 15 by  visiting all the occurrences of item 5 under the subtrees of item 1 and keep adding the TWU in the sumTWU array. There is one occurrence of nodes which contains 5 that represents pattern 125 with TWU 110. The calculation of the real utility will not take place, since TWU < min_utility. Because 5 is the rightmost item in the ItemTable, pattern 15 cannot be extended further.

So the process to mine longer pattern with pattern 15 as the prefix will not be considered.

After finishing with pattern 15, it continues to check the TWU of pattern 14. Three patterns that contain 14 are 14, 134 and 124 with respective TWU values  <35>, <195> and <80>. Further, these TWU total to <310> a value larger than min_utility. Hence the mining process continues to calculate the actual utility of the pattern 14 as follows:  From the nodes representing patterns 14, 134 and 124 the respective contributions to the utility are 35 (=1 ? 25 + 1 ? 10) , 45 (=1 ? 25 + 2 ? 10)   and 45 (=1 ? 25 + 2 ? 10) . The total utility for pattern 14 is 125 and it is less than min_utility. Since pattern 14 has high TWU the extension of it to longer pattern is explored, but then there does not exist any transaction with pattern 145.

Next pattern to be mined is 13. There is only one occurrence of pattern 13 with TWU 195 greater than min_utility. The utility of pattern 13 is calculated to be 175 and so it is a high utility pattern and it represents itemset 23 in terms of the original item identities.

Since pattern 13 has high TWU, we extend the process to mine for patterns 135 and 134. We note that pattern 135 does not occur and mining for pattern 134 results itemset 123 (with utility 195) in terms of the original item identities. Since pattern 134 has high TWU, the process is continued to mine a extended pattern 1345. But there is no transaction with pattern 1345. We cannot extend 1345 further so the recursive algorithm stops here. Item 3 is the second item to the right of item 1 in ItemTable; so the process will not continue to item 2 (line 4). Pattern with 12 as the prefix will be derived later while mining itemsets under subtree of pattern 2. Since paths 13 exist in the tree, line 15 is executed and the TWU and quantity of that pattern is moved to the node in the leftmost branch.

After completing the mining of subtree for item 1, the program continues to mine high utility itemsets under the subtree of item 2. We get patterns 12 (120) and 2 (175) from the root. Notice that pattern 12 can be derived from this node. This is why we need to stop at the second item on the right of the current item.

SumTWU will contain two entries: entry 0 to keep the TWU of pattern beginning with 2 and entry 1 to keep the TWU of pattern beginning with 12. The program continues to check TWU values and gives 25 <515> and 125 <110>  as well as  24 <485>  and  124  <80>.

Figure 3. CTU-Mine Algorithm  Every time we have finished visiting all occurrences of item 5 (or item 4), each pattern TWU in sumTWU will be checked to determine the TWU of 25 and 125 (or 24 and 124). If the TWU is > min_utility. The calculation of real utlity from this point gives HUI of 25(300) and 24(200) which map to itemset 45 and itemset 14 respectively. Pattern 25 cannot be extended further, but since pattern 24 has high TWU and it can be extended  further, the mining process will continue to mine pattern 245(255) as well as pattern 1245(0).

Paths 24 and 245 exist, so we need to add up its TWU and respective quantity to the leftmost branch of the tree. The TWU and quantity pointed at node 4 in path 24 will be added to the pattern TWU of node 4 representing pattern 4 at the leftmost branch of the tree.

The TWU and quantity pointed at node 5 in path 245 will be added to the TWU and quantity pointed of node 5 representing pattern 45 at the leftmost branch of the tree.

From the root of subtree for item 3, the utility of 123(0), 23(185) and 3(600) can be determined. When its child node 5 is visited, the TWU of patterns 35<615>, 235<205> and 1235<0> are extracted and the utility of pattern 35(560), 235(195) and 1235(0) determined. It will map back and resulting HUI 25 and HUI 245. Pattern 34 and other patterns with 34 as their prefix need not be mined in this step since they will be mined when we mine subtree of item 4.

Root of the subtree of item 4 gives the count of 1234(0), 234(195), 34(490) and 4(120).    From root of the subtree of item 5 we get patterns 12345(0), 2345(205), 345(355), 45(245), 5(300) and the mining process will stop. The high utility itemsets (after mapped back to the original item-id) are the following: {B(600), E(300), AB(490), AD(200), AE(245), BC(175), BD(185), BE(560), DE(300), ABC(195), ABD(195), ABE(355), ADE(255), BDE(195), ABDE(205)}.

5. Performance Study   In this Section, the performance of CTU-Mine is empirically compared with the implementation of TwoPhase downloaded from [8]. CTU-Mine is written in C and compiled using g++ version 4.1.0. All the testing was performed on a Pentium Duo Core, 1.5 GB RAM, with Linux Fedora Core 5 operating system.

We generated two synthetic datasets using our program and IBM Quest data generator [8]: (a) T10I5D50K with transaction length 10 and size of maximal potentially frequent pattern 5 and the number of transaction 50K; (b) T10I10D10K as a more dense, with longer patterns dataset with transaction length and size of maximal potentially frequent pattern of 10 and number of transactions 10K. We generated profit value with lognormal distribution as in [4] and the quantities of the items as random numbers from 1 to 15. Results of our experiments are shown in Figure 4.

The graphs show that for high thresholds, TwoPhase runs relatively fast compared to CTU-Mine, but when the utility threshold becomes lower, CTU- Mine outperforms TwoPhase. For very low utility  Algorithm CTU-Mine Input  : compressed transaction tree Output : High Utility Itemsets (1) Procedure Mining() (2) for each subtree root item i in ItemTable (3) calculate utility at the root of  subtree item i and add to the set of HUI if larger than minimum utility  (4) for each remaining item j in ItemTable after i from the rightmost to the second item on the right of i  (5) initialize sumTWU (6) calculate TWU of all patterns  corresponding to the paths ending at node j and store the result into sumTWU  (7) check each TWU entry in sumTWU (8) if there is pattern with TWU > min_  utility (9) do the real utility calculation  put itemset in HUI if utility > min_utility  (10) endif (11) if there is some high utility  itemset in sumTWU and j is not the rightmost item in ItemTable  (12)   MineFI(ij) (13) endif (14) if there exists path ij in the tree (15) add each pattern TWU and pointer  entry to the respective pattern TWU and pointer at the leftmost branch of the tree  (16) endif (17)   endfor (18) Endfor   (19) Procedure MineFI(k) (20) for each remaining item l after the last  item in k from the rightmost to the next item on the right of k  (21) initialize sumTWU (22) calculate TWU of all patterns  corresponding to the paths ending at node l and store the result into sumTWU  (23) check each TWU entry in sumTWU (24) if there is pattern with TWU >  min_utility (25) do the real utility calculation,  put pattern in HUI if utility > min_utility  (26) endif (27) if there is some frequent itemset in  sumTWU and l is not the rightmost item in ItemTable  (28) MineFI(kl) (29) endif (30) endfor     thresholds, TwoPhase could not complete the computation even after 10 hours of CPU Time. This is due to the limitations of the generation-and-test approach of TwoPhase that has to traverse the database many times to enumerate and compute the large number of possible itemsets high transaction weighted utility.

Figure 4. Execution time with varying minimum utility thresholds on synthetic datasets.

6. Conclusion   In this paper, we proposed the CTU-Mine algorithm to mine the complete set of high utility itemsets from relatively dense or long pattern datasets.

The data structure and algorithm extend the pattern growth approach, taking into account the lack of anti- monotone property for pruning utility based patterns.

We have compared the the performance of CTU-Mine against the recent TwoPhase algorithm [4]. The results show that for dense, long pattern datasets, CTU-Mine works more efficiently than Twophase.

We used the same value of transaction weighted utility as the user specified itemset utility for growing and pruning the patterns. Though the transaction  weighted utility measure is anti-monotone, it overestimates the potential high utility itemsets, thereby increasing the memory and computational requirements compared to the pattern growth algorithms for frequent pattern mining. Further research is needed to determine how the thresholds for transaction weighted utility may be varied from the user specified utility to reduce this overestimate. We are also studying sampling based approximations to complement this investigation.

7. References  [1] R. Agrawal, T. Imielinski, and A. Swami, "Mining  Association Rules between Sets of Items in Large Database", Proc. ACM SIGMOD Intl. Conf, 1993, pp 207-216.

[2] H. Yao and H. J. Hamilton, "Mining itemset utilities from transaction databases", Data & Knowledge Engineering, vol. 59, 2006, pp. 603- 626.

[3] H. Yao, H. J. Hamilton, and C. J. Butz, "A Foundational Approach to Mining Itemset Utilities from Databases", Proc. 4th SIAM Intl Conf on Data Mining, Florida USA, 2004, pp.

[4] Y. Liu, W.-K. Liao, and A. Choudhary, "A Fast High Utility Itemsets Mining Algorithm", Proc.

UBDM'05, Chicago Illinois, 2005.

[5] J. Han, J. Pei, and Y. Yin, "Mining Frequent Patterns without Candidate Generation", Proc.

ACM SIGMOD Intl. Conf on Management of Data, 2000, pp 1-12.

[6] Y. G. Sucahyo and R. P. Gopalan, "CT-ITL: Efficient Frequent Itemset Mining Using a Compressed Prefix Tree with Pattern Growth", Proc. 14th Australasian Database Conf, Adelaide, Australia, 2003, pp 95-104.

[7] R. P. Gopalan and Y. G. Sucahyo, "Fast Frequent Itemset Mining using Compressed Data Representation", Proc. IASTED Intl Conf on Databases and Applications, Innsbruck, Austria, 2003, pp 1203-1208.

