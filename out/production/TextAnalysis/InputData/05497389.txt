May 12, 2010 15:42 RPS : Trim Size: 8.50in x 11.00in (IEEE) icfcc2010-lineup?vol-2: F477

Abstract?A data stream is a continuous,huge,fast changing,rapid,infinite sequence of data elements.The nature of streaming data makes it essential to use online algorithms which require only one scan over the data for knowledge discovery.Mining frequent patterns on streaming data is a new challenging problem . Recent research mainly focuses on mining  frequent itemsets over data stream. However, when the threshold of support set is small, the number of frequent itemsets is staggering. moreever frequent closed itemsets is completely contains the information of frequent itemsets and the tatol number of  frequent closed itemsets is still much smaller  than that of frequent itemsets . Therefore, mining frequent closed itemsets is a better choice .In this paper,A new algotihm named MFCIDS_BD Mining Frequent Closed Itemsets Over Data Stream Based On Bit-vector and Digraph is proposed to mine frequent all closed itemset in the transaction sliding window over data stream. MCFIDS_BD uses a Bit-vector table based data structure,an an effective bit- sequence representation of items, to dynamically maintain all information over transactions slding window . A digraph based data structure is developed in the MFCDS_BD to depth- first mine all CFIs. The maximum number of nodes in digraph does not exceed the total number of items in data stream . in the mining process, MFCDS_BD uses simple bit ?AND? Operations to calculate the support of itemset. MFC-DS_BD Effectively save the save memory and improve speed.

Experimental results show that MFCSD_BD is effective and effi-cient.

Keywords- data stream;frequent closed itemsets; data mining;

I. INTRODUCTION Data are coming continuously and at a very rapid rate  and the size of data is unbounded, and data(including the patterns hidden in the data)are time-varying.Nowadays, a growing number of applications generate data streams,such as telecom call records,web clickstreams,data collected in sensor networks and etc.With the growing number of applications of data stream ,the research on stream turns  hot.Data stream has new characteristics thus new challenges are posed:data can not be stored in secondary storage and only one or limited scans can be performed when data arrives;furthemore,the data distribution may dynamically changed with time,so the analyzing result of dat stream often changes greatly.Especially,problem of mining frequent patterns over data stream is one of the most problems of minig data stream.

Mining frequent patterns on static data sets has been studied extensively .And many efficient algorithms have been proposed,such as Apriori[1],Fp- growth[2],Eclat[7],ect.Howe-ver, these traditional methods are not available on data streams due to the above characteristics of data stream.

Recently,finding frequent itemsets is one of the most important data mining tasks.There have many works focus on FIs mining in data stream[3,4,5].Most of them have the similar problem is that the results may become huge when the minimum support turns lower ,so the special FI mining approaches include closed itemsets mining ,maximal itemsets mining and top-k itemsets mining are proposed,in which closed frequent[12,13,14] itemsets(CFIs) store all the information of FIs but take up much less memory thus is much suitable for mining stream.

The concept CFI was firstly proposed in [6].An itemset is closed if none of its super-itemsets has the same weight with it,and a CFI if both closed and frequent[1]. There have many works focus on FIs mining [8,9,10].Recently ,some CFI mining approaches over sliding window of stream were presented include Chi et al. [11] introduced a novel algorithm, Moment, to mine closed frequent itemsets over data stream sliding windows. An efficient in-memory data structure, the closed enumeration tree (CET), is used to record all closed frequent itemsets in the current sliding window.

In this paper,A new algotihm named MFCDS_BD Mining Frequent Closed Itemsets Over Data Stream Based  This research is partly supported by the National Science Foundation of Hainan Province(808155,109002),Youth program for Science reseacher of Hainan Normal University(QN0923, QN0919)     May 12, 2010 15:42 RPS : Trim Size: 8.50in x 11.00in (IEEE) icfcc2010-lineup?vol-2: F477  On Bitvector and Digraph is proposed to mine all frequent closed itemsets in the sliding window over stream.

Algorithm uses Bit-vector table based data structure,an an effective bit-sequence representation of items, to dynamically maintain all information over transactions slding window . A digraph  based data structure is developed in the MFCDS_BD to depth-first mine all CFIs. The maximum number of nodes in digraph does not exceed the total number of items in data stream. Compared with other sliding window based mining techniques,we save memory and improve speed.



II. PROBLEM DEFINITION Definition 1.Given I={e1,e2,e3??em} be a set of  items,in whitch |I|=m denote the number of item. let TSD={T1,T2,T3,??TN??},is a sequence of incomng transactions, where  N is the tid of latest incoming transaction TN .A transaction,Ti={tid ,x1 , x2,x3??x m}, is a subset of I, where tid is the id of the transaction. the id of Ti is i.We assume that there is a lexicographical order among the items in I and we use ei ej(i<j) to denote that item ei is lexicographically smaller than item ej.An itemset,X={x1,x2,x3,??xn}is a subset of

I.suppose,|X|=k,we call X a k-itemset . Furthermore, an itemset can be represented by a sequence,wherein items are lexicographically ordered.For instance,X={A,B,C} is represented by ABC,given that A . we also use  to denote the lexicographical order between two itemsets,i.e.,AB AC CD.For two itemsets X={x1,x2,x3,??xs} and Y={y1,y2,y3,??yt},if  z2,z2,z3,??zs satisfy 1 z1<z2<??zs t and x1 yz1,x2 yz2,??xs ycs we call X a subset of Y and Y a superset  of X,denoted as X Y(if X Y,then denoted as X Y). The suppot of an itemset X,denoted sup(X),is the number of transactions in which that itemset occurs as a subset .An itemset X is called a frequent itemset (FI)if sup(X)>=s*|TDS|,where s (0,1) is a user-specified minimum support threshold and |TSD| is the size of the database.

B C  Definition 2(Transaction Sliding Window).A Transaction Sliding Window(TSW) in the transaction data stream is a window that slides forward for every transaction .

the window at each slide has a fixed number, w,of transactions ,and w is called the size of the window.Hence , the current transaction sliding window is TSW={TN-w+1,TN- w+2,??TN},where N-w+1 is the window identifier of current TSW.Figure 1 is an example with I={A,B,C,D,E}and let the size of window  w be 9.the transaction data stream consists of two transaction sliding windwos ,i.e.,TSW #1=[T1,T2,T3,T4,T5,T6,T7,T8,T9] and TSW#2=[T2,T3,T4,T5,T6,T7,T8,T9,T10],the example is shown in Fig1.We use this example throughout the paper with minimum suppot s= 0.5  A,B,C10  A,B,C,E9  A,C8  B,C7  A,C6  A,B,D5  B,C4  B,D3  A,B,E2  A,B,E1  itemstid  A,B,C10  A,B,C,E9  A,C8  B,C7  A,C6  A,B,D5  B,C4  B,D3  A,B,E2  A,B,E1  itemstid  tim e   line  TSW #1  TSW #1  TSW #2  TSW #2  Figure 1. A Runnig Example  In order to improve the efficiency of the algorithm , this paper give the frequent closed itemsets definition different from [10].

Definition 3(f(X)): Let T be the subsets of TDS and X be the subsets of I,let f(X)={t TDS| i X and i t} which returns the set of transactions containing item set X.let |f(X)| is the number of transacations including X.

Definition 4:let X1 is a subset of I and X2 is a subset of

I.if X2 is the superset of X1  |f(X2)|>=|f(X1)|,then X1 is coverd by X2.

Definition 5: (Fruqeunt Closed Itemset).Given X is a subset of I.if there is not any Y(Y is the superset of I)and Y covers X.then X is CI.if sup(X)>=s *|TDS|,then X is an FCI.



III. MCFISD_BD A ALGORITHM Algorithm MFCIDS_BD is composed of three steps  step 1,initializing Window step 2, Updating Window;step 3,Mining frequent closed itemsets;step 3 is usually performed periodically of when it is needed.

A. Window initialization  Let  I={e1 e2 e3??en} be itemset,the size of TSW be w.we assume that there is a lexicographical order among the items in I.First of all,initializing Bitvector and f_list.Bitvector is a table of bit-sequence . f_list is a 1-itemset table.Bitvector dynamic maintain data information by ?0? or ?1? bit-sequence . we use f_list  that is a summary strcuture is  consistd by two domains :item,the name of item whicht appears in the data stream ; f,the count of item that appears in the TSW (Summary structure shown in Figure 3). Here we describe in detail Bitvector initialization  and f_list initialization.For each item ei(ei ),a bit-sequence with w bits,denoted as Bit(ei), is constructed.every bit in Bitvector is set to be ?0?.In this paper ,Bit(ei) is denoted as Bit(ei)= (00??0).all f of f_list is set to be ?0?. then updating bit- sequence and f_list with the incoming of trasactions.If an item ei is in the ith trasaction of current TSW,the ith bit of Bit(ei) is set to be ?1? and the ei.f=ei.f+1 is set in f_list.Example.Figure 2 is  the initialization results of     May 12, 2010 15:42 RPS : Trim Size: 8.50in x 11.00in (IEEE) icfcc2010-lineup?vol-2: F477  Bitvector in TSW#1 above Figure 1. Figure 3  is the initialization results of f_list in TSW#1 above Figure 1.

100000011Bit(E)  000010100Bit(D)  111101000Bit(C)  101011111Bit(B)  110110011Bit(A)  T9T8T7T6T5T4T3T2T1BitVictor  100000011Bit(E)  000010100Bit(D)  111101000Bit(C)  101011111Bit(B)  110110011Bit(A)  T9T8T7T6T5T4T3T2T1BitVictor  Figure 2. Bitvector table of TSW #1  32576f  EDCBAItem  32576f  EDCBAItem  Figure 3. 1-itemsets f_list of TSW #1  The algorithm in detail as follows:  Algorithm 1 :TSW_Initialization Input:I f_list ; BitVector ; TDS Output:f_list;BitVector TSW_Initialization(BitVector ,f_list,TDS) for(i=1;i |I|;i++) for(j=1 ; j w ; j++) Bit(ei).j=0; for all Ti  ,1 i w ,Ti TDS  for(j=1 ; j |I| ; j++) if(ej Ti)  {Bit(ej).i=1; ej.f = ej.f+1;}  return;  B. Window Update  The window update is activated after the current TSW become full.A new incoming transaction is appended to the current TSW,and the oldest transaction is removed from the TSW. The specific process is as follows:first of all, scaning the aged transaction and the newest trasaction in the current TSW to update f_list.for each ei the aged transaction,ei.f=ei.f-1 is activated.for each ei the newest transaction, ei.f=ei.f+1 is activated. Then remove the olded trasaction from current TSW.For removing oldest information , an efficient metnod is used in the proposed algorithm.Based on the bit-sequence representation, MFCISD_BD algorithm uses the bitwise left shift operation to remove the aged trasaction from the set of items it the current TSW. If the ei the newest transaction and the wth bit of Bit(ei) is set ?1?, Otherwise Bit(ei).w=0 is activated.Example,Figure 4 and Figrue 5are the updating result of TSW #1 to TSW #2 in Figrue 1,i.e.,from Figure 2 to Figure 4 and from Figure 3 to Figure 5.

010000001Bit(E)  000001010Bit(D)  111110100Bit(C)  110101111Bit(B)  111011001Bit(A)  T9T8T7T6T5T4T3T2T1BitVictor  010000001Bit(E)  000001010Bit(D)  111110100Bit(C)  110101111Bit(B)  111011001Bit(A)  T9T8T7T6T5T4T3T2T1BitVictor  Figure 4. Bitvector table of TSW #2  22676f  EDCBAItem  22676f  EDCBAItem  Figure 5. 1-itemsets f_list of TSW #2  The algorithm of updateing  in detail as follows:  Algorithm2:TSW_updata Input: Bitvector ; f_list ; Tnewest Output: Bitvector ;  f_list TSW_updata(BitVector , f_list , Tnewest) for  all ei f_list and ei TN-w+1 if(Bit(ei)==1) ei.f=ei.f-1; for all Bit(ei) Bitvector Bit(ei)>>1  //bit left one for all ei Tnewest Bit(ei).w=1; return;  C. Mining frequent closed itemsets  Mining frequent closed itemsets is performed only when the up-to-date set of frequent closed itemsets is requested .

Mining frequent closed itemsets is composed of two steps:step 1, Constructing a Digraph.step 2,Mining all frequent closed itemsets.First of all, Introducing a character before the start of this phase.

Step 1: Constructing a Digraph  Defination 6. Let itemset X={x1,x2,x3??xm}, Bit(X)=Bi- t(x1) Bit(x2) Bit(x3) ?? Bit(xm), the number of bits ?1? in Bit(X) is denoted |Bit(X)|,so sup(X)=|Bit(X)|*w.

According to defination 1 and defination 6,iff ei ej |Bit({eiej})| >=s*w, then exist a directed edge between ei and ej, denoted as  e ej .the weight of directed edge is denoted sup({eiej}).Based on the description above ,scaning the current TSW to constructe digraph.Example, According to Figure4 and Figure5 build a directed graph Figure6.

May 12, 2010 15:42 RPS : Trim Size: 8.50in x 11.00in (IEEE) icfcc2010-lineup?vol-2: F477  A  B  C D  E  Bit(A)={100110111}  Bit(D)={010100000}  Bit(B)={111101011}  B it(  E )=  {1   }  Bit(C)={001011111}     Figure 6. Digraph initialization of 2-CFI  The algorithm of Digraph _Initialization in detail as follows:  Algorithm3 :Digraph_ Initialization Input:Bitvector ; f_list ; s ; w Output: Digraph Digraph_ Initialization(Bitvector,f_list ,s ,w ) for all ei f_list  for all ej f_list if(sup({eiej})>=s*w and ei ej)  //creat ei->ej Digraph. ei.link.add(ej); return Digraph;  step 2 Mining all frequent closed itemsets  Each node in digraph will  be tested .MFCIDS_BD will recursive mining all frequent closed itemsets. Actually,the frequent 2-itemsets   have been given on digraph and itemesets can be expanded through directed graph.

Property 1:Let X={x1,x2,x3??xm} be frequent itemse t,iff not existing a directed edge between xm and v, then X v={x1,x2,x3??xm,v} Can not be a frequent itemset.

Proof. Because there no exists edge between xm and v, so sup ({xm, v}) <s * w, is infrequent.accoding Apriori [11], Any itemsets  that contains non-frequent itemsets  can not be the frequent itemsets. Therefore, X v can not be frequent itemsets.  Based on the property 1,if we want to get frequent m +1- itemsets, just need to start from the node xm to xm adjacent vertex v and ensure that sup ({X v})> = s * w.

Defination 7:Given X={x1,x2,x3??xm} be a FI and in lexicographical order.CFIs  SX= {s |s ={x1,x2,x3??xm} {j1,j2,?,jl}, xk> jn, 1 k m,1 n l}is a prefix itemset cluster of itemset X. set  S?X= {s |s ={x1,x2,x3??xm} {j}, xk> j, 1 k m } is known as a extended prefix itemset cluster of itemset X and exists relation SX S?X .

Property 2:Given X={x1,x2,x3??xm} is a  FI. Then the all FIs can be expressed as S=Si1 Si2 ? Sim .

Proof. if all the FIs are indexed in lexicographical order, then these FIs are classified by the first frequent item , Each class is a frequent itemset cluster with each item as the prefix.

Propery 3:Given FI X={x1,x2,x3??xm},then FI cluster to be denoted as SX= S(X v), v < in, 1 n m .

Proof . similar to propery 2, SX can also be classified in accordance with the item v . And because of all frequent itemsets ordered in lexicgraphical .,v < in, 1 n m .

Based on definition 4,definition 5 and discussion above, we can mining all CFIs in digraph. The algorithm of mining CFIs with X as the  prefix  in detail as follows:  Algorithm 4:DeapFirst_MCFI //Mining the frequent closed itemsets that X as a prefix Input:X: Prefix itemset Bit(X) sup(X);s;w Output:CFI DeapFirst_MCFI(X,Bit(X),sup(X),s* w,CFI) BOOL  covered=false; let ei is the last item in itemset X for all ej,ej ei.link {  X?=X {ej}; Bit(X?)=Bit(X) Bit(ej); if(sup(X? s*w)  if(sup(X?)=sup(X)) covered=ture;  DeapFirst_MCFI(X?,Bit(X?),sup(X?),s*w,CFI); }  if (covered==flase) //definition 3 and 4 if( Y CFI X Y sup(Y) sup(X))  CFI=CFI X; return CFI;  The algorithm of mining all CFIs in detail as follows:  Algorthm 5:MCFI //Mining all CFI Input:f_list,s,w,Digraph Output:CFI MFCI(f_list,s,w,Digraph) CFI=  for ei Digraph DeapFirst_MCFI(ei,Bit(ei),ei.f,s*w,CFI);  return  CFI; Propery 4:Algorithm MFCI_BD can finds all the CFIs.

Proof . All the frequent itemsets generated throuth MFCI_BD form a sequence L .Given X={x1,x2,x3??xm} be current generated FI Sbefore is CFI generated prior to the X,Safter is CFI generated after the X. X is CFI only if X is not covered by any other frequent itemsets, i.e., X is neither being covered by Sbefore of CFI, nor was covered by Safter of CFI  .Based on defination 4 ,defination 5 and property 3,if X is not covered by itemset cluster that is  an expansion of the prefix ,then X is not covered by CFIs of     May 12, 2010 15:42 RPS : Trim Size: 8.50in x 11.00in (IEEE) icfcc2010-lineup?vol-2: F477  Safter .therefor, first of all, Set covers marked covered as false. When X is covered by any extended itemset,marked covered as true.If further concluded that X is not covered by itemsets of CFI, Then X is a CFI and adding X to CFI. On the basis of the above, MFCIDS_BD can find all CFIs.Based on TSW #2,CFIs={{ABC:2},{ABE:2},{AB:4},{AC:4},{A:6},{BC: 4}{BD:2},{B:7},{C:6}}.



IV. EXPERIMENTS AND PERFORMANCE ANALYSIS In this section,we will describe the experimental  evaluation of the porosed algorithm MFCIDS_BD.All the programs are implemented using Microsoft Visual C++ 6.0 and performed on a 1.8 GHz Pentium(R) PC machine with 1G MB memory running .For testing algorithm MFCIDS_BD over sliding windows,synthetic data streams are generated by using IBM synthetic data generator proposed by Agrawal and Srikant(1994).There synthetic data streams,denoted by T.20I.16D.1000K,T.20I.

12D.1000K and T.16I.16D.1000K are generated ,where T,I and D mean the average transaction length,the average length of the maximal frequent closed itemset,and the total number of transactions,respectively.To simulate data streams,the transactions in three synthetic data  are look up in sequence and feed them in the buffer.The window size is set 100k. 10K different projects are contained in data stream.

Figure7 shows the memory requirement of window initialization phase ,window sliding phase ,and mining frequent closed itemsets phase on T.20I. 12D.1000K with different threshold.Figure 8 shows the processing time of window initialization phase ,window sliding phase ,and mining frequent closed itemsets phase on T.20I. 12D.1000K with different threshold.As shown in Figure7 and Fig.8,when the support is define,processing time and required memory space is gradually stabilized.Therefore,MFCIDS_BD is applied to the environment of data steam . but with the decline of support,the processing time and memory space required were significantly increased Because of minsup increases,the number of freqent closed itemsets generated in MFCIDS_BD deceases.Figure9 shows the comparison of average processing time on there synthetic data stream with the different supporth threshold.The average length of trasaction and the average length of CFI greater impact the efficiency of MFCIDS_BD.

w  Figure 7. Memory usage of  MFCI_BD  Figure 8. Processing Time of MFCI_BD  Figure 9. Comparison of Proccessing Time

V. CONCLUSIONS In this paper , we propose a efficient one-pass algorithm  named MFCIDS_BD, to mine all frequent closed itemsets online .MCFIDS_BD uses a Bitvector table based data structure,an an effective bit-sequence representation of items, to dynamically maintain all information over transactions slding window  and uses 1-itemset table ,named f_list to statistics the number of each item that appears in transactions  over transaction slding window.

A digraph  based data structure is developed in the MFCDS_BD to depth-first mine all CFIs. The maximum number of nodes in digraph does not exceed the total number of items in data stream , in the mining process, MFCDS_BD uses simple bit ?AND? Operations to calculate the support of itemset.  moreover frequent closed itemsets is completely contains the information of frequent itemsets and the total number of  frequent closed itemsets is still much smaller  than that of frequent itemsets.

From the above, Compared with other sliding window based mining techniques,we save memory and improve     May 12, 2010 15:42 RPS : Trim Size: 8.50in x 11.00in (IEEE) icfcc2010-lineup?vol-2: F477  speed.Experimental results show that MFCSD_BD is effective and efficient.

