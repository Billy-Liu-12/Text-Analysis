Interactive Constrained Frequent-Pattern Mining System

Abstract  Data mining refers to the search for implicit, previously unknown, and potentially useful information (such as fre- quent patterns) that might be embedded in data. Most of the existing data mining algorithms do not allow users to express the patterns to be mined according to their inten- tion via the use of constraints. Consequently, these un- constrained mining algorithms can yield numerous patterns that are not interesting to users. Moreover, data mining is supposed to be an exploratory process. In this context, we are working on a project with the objective of imple- menting an efficient, interactive, human-centered system for mining frequent patterns that satisfy the user constraints.

In this paper, we develop such a system, called iCFP, for interactive mining of Constrained Frequent Patterns. Our developed system uses a tree-based mining framework. In addition, it (i) allows human users to impose a certain fo- cus on the mining process, (ii) provides users with feedback during the mining process, and (iii) permits users to dynam- ically change their constraints during the process.

Keywords: Data mining and knowledge discovery, interac- tive system, constraints, constraint changes, succinctness, frequent sets, FP-trees  1. Introduction  Since its introduction [1], the problem of mining as- sociation rules?and the more general problem of finding frequent patterns?from large databases has been the sub- ject of numerous studies. These studies can be broadly di- vided into two generations. In the first generation, all stud- ies focused either on performance issues (e.g., the Apriori framework [2, 3], hashing and segmentation [16, 20], the tree-based framework [13], incremental updating [8, 9]), or on functionality issues (e.g., extending the initial notion of association rules or frequent patterns to long patterns [4], quantitative and multi-dimensional rules [10, 17], as well as correlations and causal structures [7, 23]). Studies in this generation basically considered the data mining exer- cise in isolation.

On the other hand, studies in the second generation explored how data mining can best interact with other key components?such as the database management sys- tem [22, 25] and the human user?in the broader picture of knowledge discovery. From this standpoint, studies in the first generation rely on a computational model where the mining system does almost everything, and the user (and/or the DBMS) is un-engaged in the mining process. Conse- quently, this model provides little or no support for user focus (e.g., limiting the computation to what interests the user) and user interaction (e.g., obtaining feedback from the computational model, making dynamic changes to the mining parameters midstream).

However, the support for both user focus and user inter- action is necessary. For instance, in many real-life applica- tions, the user may have certain broad phenomena in mind on which to focus the mining (e.g., may want to find expen- sive snack items). Without user focus, the user often needs to wait for a long time for numerous frequent patterns, out of which only a tiny fraction may be interesting to the user.

This motivates the call for constrained mining. Moreover, it is also not uncommon that, even with broad phenomena in mind, the user may need to modify the mining parame- ters/constraints (e.g., to slightly modify the price value that quantifies the ?expensiveness? of snack items) during the mining process. This is because an inappropriate choice (e.g., for the price value) can yield either too many or too few interesting patterns. This problem is worsened when lacking continuous feedback from the mining system, as the user may not realize the inappropriateness of the parameters until the end of a possibly long wait! This motivates the call for interactive mining. In addition, for a mining system to be truly interactive, it is important for the system to pro- vide comprehensible feedback in a ?real time? fashion. Re- cent studies [13] show that those algorithms based on a Fre- quent Pattern tree (FP-tree)?which is an extended prefix tree for effective capturing of the content of the transaction database?avoid the time-consuming candidate generation process, and thereby speeding up the mining process. Con- sequently, such tree-based mining helps achieve real-time responses (due to enhancement in performance).

Proceedings of the International Database Engineering and Applications Symposium (IDEAS?04)     Table 1. Our implemented iCFP system vs. the most relevant algorithms Carma CAP  ? ? ? DCF Our proposed  [14] [19] [21] [15] iCFP system  Constrained mining ? ? ? ? ? Interactive mining:  ? Provides continuous feedback ? ? ? ? ?? Handles dynamic constraint changes ? ? ? ? ? FP-tree based mining ? ? ? ? ?  In response to the calls for constrained and/or inter- active mining, several algorithms [5, 6, 11, 12, 24] have been proposed to provide user focus and/or user interac- tion. However, to our knowledge, there is no work on in- corporating constrained mining with interactive mining in a tree-based framework. To elaborate, existing algorithms? including the most relevant ones like Carma [14], CAP [19],? ? ?  [21] and DCF [15]?fall short in different aspects.

For instance, while CAP and  ? ? ? are effective in captur-  ing user constraints, they do not handle dynamic changes to the constraints (i.e., not interactive mining). Carma does not handle constraints, let alone deal with dynamic changes to the constraints (i.e., not constrained mining). While DCF handles constraints and dynamic changes to them, it does not use the FP-tree (i.e., not FP-tree based mining).

The key contribution of this work is the develop- ment of an efficient, interactive, human-centered system for mining frequent patterns that satisfy the user constraints.

More specifically, we implement a system, called iCFP, for interactive mining of Constrained Frequent Patterns. Our system provides the user with (i) the opportunity to impose a certain focus on the mining process, (ii) the privilege to obtain continuous feedback during the mining process, and (iii) the flexibility to dynamically change the constraints during the mining process. The system pushes the con- straints deep inside the mining process, and thus leads to more effective pruning and more efficient mining. In addi- tion, iCFP uses tree-based mining to further enhance its per- formance. Last but certainly not the least, this implemented system is novel and original. To the best of our knowledge, no work has been done to incorporate constrained mining (i.e., handling user constraints) with interactive mining (i.e., handling dynamic changes to user constraints during the computation) in an FP-tree based framework. Table 1 sum- marizes the salient features of our iCFP system as compared with its most relevant algorithms.

This paper is organized as follows. In the next section, related work is discussed. Section 3 introduces our iCFP system for handling constraints. Section 4 describes how the iCFP system handles dynamic changes to constraints.

Section 5 shows the experimental results. Finally, conclu- sions are presented in Section 6.

2. Related work  Regarding constrained mining, Ng et al. [19] pro- posed a constrained frequent-set mining framework within which the user can use a rich set of constraints? including SQL-style aggregate constraints (e.g., ?   ? ?  ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ?   ) and non- aggregate constraints (e.g., ? !

? ? ? ? ? ? ? " # ? )?to guide the mining process to find only those itemsets satisfying the constraints. Here, constraint ? ? ?  ? ? ? ? ? ? ? ? ? ? ? ? says that the minimum ? ? ? ? ? value of all items in an item- set ? is at least ? ? ; constraint ? !

? ? ? ? ? ? ? " # ? says that all items in an itemset ? are of ? ? ? ? ? equal to # ? .

These two constraints ( ? 	 and ? ! ) are anti-monotone be- cause any supersets of an itemset violating the constraints (e.g., itemsets containing an item whose ? ? ? ? ? $ ? ? vi- olate ? 	 ) also violate the constraints. All three afore- mentioned constraints ( ? 	 ? ? ? and ? ! ) are succinct be- cause one can directly generate precisely all and only those itemsets satisfying the constraints (e.g., by using a precise ?formula?, called a member generating function [19], that does not require generating and excluding itemsets not sat- isfying the constraints). For instance, itemsets satisfying  ? ? ? ? ? ? ? ? ? ? ? ? ? ?   can be precisely generated by combining at least one item whose ? ? ? ? ?   with some optional items (whose ? ? ? values are unimportant), thereby avoiding the substantial overhead of the generation and exclusion of invalid itemsets. It is important to note the following [19]: A majority of constraints are succinct.

For constraints that are not succinct, many of them can be induced into weaker constraints that are succinct! Refer to the work of Ng et al. [19] for more details about anti- monotone constraints and succinct constraints.

Among the existing constrained mining algorithms, the most relevant ones are CAP [19],  ? ? ? [21] and DCF [15].

Although CAP, ? ? ?  , DCF and iCFP all handle constraints, there are several key differences among them. First, CAP and DCF handle constraints in an Apriori-based framework, whereas  ? ? ? and iCFP do so in an FP-tree based frame-  work. Second, although ? ? ?  can handle succinct con- straints, it does so indirectly (by ?converting? the succinct constraints into another class of constraints) and does not  Proceedings of the International Database Engineering and Applications Symposium (IDEAS?04)     completely exploit properties of succinct constraints. Our iCFP system, on the other hand, directly handles the suc- cinct constraints and exploits their properties. Third, both CAP and  ? ? ? do not handle dynamic changes to the con-  straints, that is, they are not for interactive mining.

Regarding interactive mining, Nag et al. [18] proposed  caching algorithms that cache previous results and reuse these results (as needed) for future queries. However, the algorithms do not handle changes to parameters during the mining process for the current query. They only allow the user to change the parameters at the end of the mining pro- cess for the current query.

3. The iCFP system handles constraints  Before discussing how our iCFP system handles dy- namic changes to constraints, let us describe in this section how iCFP efficiently handles constraints by effectively ex- ploiting the properties of constraints.

A na??ve approach to handle a constraint ? in an FP-tree based framework is to first run an unconstrained FP-tree based mining algorithm to compute all frequent itemsets, and then to check each of these computed itemsets whether it is valid (i.e., whether it satisfies ? ). While simple, this na??ve approach suffers from the fact that ? is not pushed in- side the mining algorithm to effect pruning as early as pos- sible. As a result, although the use of an FP-tree based al- gorithm helps improve performance (when compared with its Apriori counterpart), the computational effort is still not proportional to the selectivity of ? . This problem is wors- ened when ? is a highly selective one (i.e., when only a tiny fraction of frequent itemsets satisfy ? ). To overcome this problem, our iCFP system pushes the constraint ? deep in- side the computation, and exploits properties of ? . Recall that a constraint can be succinct, and/or anti-monotone, or neither. As described below, the iCFP can do a lot better when the constraint is succinct.

3.1. Succinctness-based exploitation  Like many FP-tree based algorithms, our proposed iCFP system handles a succinct constraint ? ? by using two main operations: (i) the construction of FP-tree and (ii) the recur- sive growth of valid frequent patterns. The system exploits a nice property of succinct constraints: One can easily enu- merate all and only those itemsets that are guaranteed to satisfy the succinct constraint ? ? . To elaborate, any fre- quent itemset ? satisfying ? ? (e.g., ? ? ? ? ? ? ? ?  ? ? ? ,  ? ? ? ? ? ? ? ? ? ? ) is composed of mandatory items (i.e., items satisfying ? ? ) and possibly some optional items (i.e., items not satisfying ? ? ). Let ? ? ? ? ? and ? ? ? ? ? denote the set of mandatory items and the set of optional items, respec- tively. Then, a frequent itemset ? satisfying ? ? is usually  of the form: ? ? ? (1)  where (i) ? ? ? ? ? such that ? ? , and (ii) ? 	 ? ? ? ? ? .

Due to succinctness, items in ? ? ? ? ? and ? ? ? ? ? can be effi- ciently enumerated.

Because of succinctness, our iCFP system can discover frequent patterns satisfying a succinct constraint ? ? as fol- lows. It first divides the domain items into two sets? the set ? ? ? ? ? consisting of all mandatory items and the set ? ? ? ? ? consisting of all optional items; it then scans the transaction database to check for frequency of all items in both sets, and infrequent items are removed. Afterwards, iCFP builds an FP-tree with the (mandatory and optional) items ordered in such a way that mandatory items appear before optional items. In other words, mandatory items ap- pear below optional items in the FP-tree (i.e., mandatory items are closer to the leaves, and optional items are closer to the root). With this item-ordering scheme, if an item- set ? ? ? ? violates ? ? , then ? ? is an optional item and any item ? ? ordered after item ? ? is also optional; thus, item- set ? ? ? ? ? ? ? ? ? also violates ? ? . Given that all frequent itemsets satisfying ? ? must be ?extensions? of an item from  ? ? ? ? ? (i.e., all valid frequent itemsets must be grown from an item in ? ? ? ? ? ), all iCFP needs to do is to recursively apply the usual FP-tree based mining process to each pro- jected database of only those valid frequent itemsets (i.e., apply to each -projected database?which is a collection of transactions having as its prefix?where ? ? ? ? ? ).

Note that our iCFP system pushes the succinct con- straints inside the computation, and exploits the ?succinct- ness? property of the constraints. As a result, during the en- tire mining process, no constraint checking is required for projected databases at recursive steps. All valid frequent patterns can be discovered by the above procedure without any extra constraint checking. This is feasible due to the way in which iCFP orders the domain items. More specifi- cally, with the above item order, (i) all the mandatory items can be identified at the initial step (by using a member gen- erating function mentioned in Section 2), and (ii) all the valid itemsets can be grown from the projected databases of these mandatory items. Pruning for constraint satisfaction is done once-and-for-all (at the initial step when iCFP divides the domain items), thereby avoiding all unnecessary con- straint checking for projected databases at recursive steps.

To gain a better understanding of how the iCFP system works, let us consider the following example.

Example 1 Consider the following transaction database:  Transactions Contents   ? ? ? ? ? ? ? ? ? ?  ? ? ? ? ? ?  ? ? ? ? ? ? ? ? ? ?  ? ? ? ? ? ? ? ? ? ?  Proceedings of the International Database Engineering and Applications Symposium (IDEAS?04)     a:1 a:1  FP?tree for Trans. DB  b:4  d:1 e:1  a:1d:1  e:1 Mandatory  Optional  e:1  e:1a:2  b:3  c:2  FP?tree for {d}?proj. DB FP?tree for {a}?proj. DB  {a,e}?proj. DB FP?tree for  {a,c}?proj. DB FP?tree for  b:2 b:2  b:3  c:2  d:1  => {d,a}, {d,b}, {d,a,b}  => {a,e,b} => {a,c,b}  => {a}, {d}  => {a,b}, {a,c}, {a,e}  Figure 1. The iCFP system discovers frequent patterns satisfying the succinct constraint ? ?  with the following auxiliary information about items:  Item ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ?   ? ? ? ? ? ? ? ? ? ?  ? ? ? ? ?  Let succinct constraint ? ? be constraint 	 ? ? ? ? ? ? ? ? ? ? ?  ? ? , and the minimum support threshold be ? (i.e., ? ? ? ). The iCFP system discovers valid frequent itemsets as follows. It first partitions the domain items into two sets: (i) the mandatory set containing items ? and ? ; and (ii) the optional set containing items ? ? ? and ? . Then, iCFP builds an FP-tree as shown in Figure 1. In the figure, the dashed line indicates the boundary between mandatory and optional items in the initial FP-tree (i.e., the FP-tree built for the transaction database). Here, mandatory items appear below/before optional items. Within each of the mandatory set and the optional set, items can be arranged consistently according to any item-ordering scheme (e.g, a non-ascending frequency order). Note that for a succinct constraint, the boundary only exists in the initial FP-tree, but not in any FP-trees built for subsequent projected databases. The reason is that once a projected database is formed for each valid frequent singleton itemset (e.g.,  ? ? ? ? ? ? ? ), there is no distinction between mandatory and optional items. In other words, once a valid itemset ? contains a mandatory item, any other items in ? can be chosen from the mandatory or the optional sets (refer to  Equation (1)). This explains why once iCFP forms the ? ? ? - and ? ? ? -projected databases, the usual FP-tree based min- ing process (with only frequency checking) can be applied recursively to these and subsequent projected databases.

Let us complete the execution. The iCFP system finds frequent (and thus valid) itemsets ? ? ? ? ? ? ? ? ? ? ? and  ? ? ? ? ? ? ? from the ? ? ? -projected database; it finds fre- quent itemsets ? ? ? ? ? ? ? ? ? ? ? and ? ? ? ? ? from the ? ? ? - projected database. As the mining process is ap- plied recursively, ? ? ? ? ? - and ? ? ? ? ? -projected databases are formed and (valid) frequent itemsets ? ? ? ? ? ? ? and  ? ? ? ? ? ? ? are found, respectively. Therefore, iCFP finds all and only those valid frequent itemsets ? ? ? ? ? ? ? ,  ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? , ? ? ? ? ? ? ? and ? ? ? ? ? ? ? . Note that projected databases are formed only for valid frequent singleton itemsets (e.g., ? ? ? ? ? ? ? ), and no constraint checking is required for projected databases at recursive steps.

3.2. Succinct-antimonotonicity based exploitation  So far, we have described how the iCFP system exploits the ?succinctness? property of succinct constraints for ef- fective mining. Next, we discuss the case where the suc- cinct constraints happen to be anti-monotone as well. In the reminder of this paper, we denote these succinct anti- monotone constraints as SAM constraints. Similarly, we denote those succinct non-antimonotone constraints as SUC constraints. Hence, succinct constraints can be divided into SAM constraints and SUC constraints.

In addition to exploiting the ?succinctness? property, iCFP also exploits the ?anti-monotonicity? property of the SAM constraints: If an itemset violates the SAM constraint, then all its supersets also violate the constraint. Recall from Section 3.1 that, for a succinct constraint, optional items are those items not satisfying the constraint (i.e., those items violating the constraint). Hence, for a SAM con- straint ? ? ? 	 , any itemsets containing an optional item do not satisfy ? ? ? 	 (i.e., any itemsets containing an optional item violate ? ? ? 	 ). Therefore, any frequent itemset ? sat- isfying ? ? ? 	 is composed of only valid/mandatory items, and can be represented in the form:  ? ? ? (2)  where (i) ? ? ? ?  ? (which is the set of valid/mandatory items) such that ? ?? ? , and (ii) ? ? ?  ? ? (which is the set of invalid/optional items) such that ? ? . This form can be reduced to become the following:  ? ? ? ?  ? (3)  By exploiting nice properties of the SAM constraints, our iCFP system can effectively find valid frequent itemsets as  Proceedings of the International Database Engineering and Applications Symposium (IDEAS?04)     follows. The system first divides the domain items into two sets?the set ? ? ? ? ? consisting of all valid/mandatory items and the set ? ? ? ? ? consisting of all invalid items. It then scans the transaction database to check for frequency of all items, and infrequent items are removed. After- wards, iCFP builds an FP-tree with the items ordered in such a way that valid items appear after/above invalid items.

Given that all frequent itemsets satisfying ? ? ? ? must be grown only from the items in ? ? ? ? ? , all iCFP needs to do is to recursively apply the FP-tree based mining process to each projected database of only valid frequent itemsets. In other words, invalid items are not included in any projected databases; these invalid items are only kept in this initial FP-tree for the purpose of dynamic mining (which will be described in Section 4.2).

For lack of space, we do not show further details. We leave as an exercise for the reader to apply iCFP for find- ing frequent patterns satisfying ? ? ? ? ? ? ? ? ? ? ? ?  ? ? ? from the database given in Example 1.

4. The iCFP system handles dynamic changes to constraints  In the previous section, we discussed how our iCFP sys- tem handles succinct constraints (i.e., SAM constraints as well as SUC constraints). In this section, we show how it handles dynamic changes to these succinct constraints. Re- garding dynamic changes, there are two cases?a tightening change and a relaxing change.

Our discussion here assumes that at any point in time, there is at most one constraint being modified. During the entire process, many different constraints can, of course, be changed. The base case of our discussion below is on how to deal with changes to the constant ? ? ? ? ? . When  ? ? ? ? ? is modified by the user in the direction of restrict- ing the new solution space to be a subset of the old space, we call this a tightening change. Otherwise, whenever the change to ? ? ? ? ? corresponds to the situation when the new solution space contains the old space, we call this a re- laxing change. For example, if the original succinct con- straint is ? ? ? ? ? ? ? ? ?  ? ? ? , then changing from ? ? to ? ? (or to any value that is less than ? ? ) corresponds to a tightening change. Similarly, changing from ? ? to  ? ? (or to any value that is greater than ? ? ) corresponds to a relaxing change. Clearly, inserting a new constraint is a special case of a tightening change, and deleting an old constraint is an extreme case of a relaxing change.

Thus, while our discussion below is confined to changing the constant ? ? ? ? ? , any other modification to constraints (e.g., modifying ? ? ? ? ? ? ? ? ?  ? ? ? to ? ? ? ? ? ? ? ? ?  ?  ? ? ), can be dealt with as a pair of constraint deletion and insertion.

4.1. Handling a dynamic tightening change to a SAM constraint  By definition, a tightening change from an old suc- cinct constraint ? ? ? ? to a new constraint ? ? ? ? corresponds to a restriction of the old solution space. In other words,  ? ? ? ? ? ? ? ? ? ? ? , where ? ? ? ? ? and ? ? ? ? ? respectively de- note the old solution space and the new solution space. To accommodate ? ? ? ? dynamically, our iCFP system carries out two main operations:  ? For processed frequent itemsets satisfying ? ? ? ? , check if they still satisfy ? ? ? ? .

? For unprocessed itemsets, only generate those satisfy- ing ? ? ? ? .

Recall from Section 3.2 that any frequent itemset ? satisfy- ing a SAM constraint is composed of only valid items (i.e., items satisfying the constraint individually). In other words,  ? is a subset of the set ? ? ? ? ? of valid items. For a tighten- ing change, any frequent itemset ? satisfying the new SAM constraint ? ? ? ? is a subset of ? ? ? ? ? ? ? ? , which is a subset of ? ? ? ? ? ? ? ? :  ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? (4) An alternative way to view this tightening change is that some items are no longer valid (i.e., some items are trans- ferred from ? ? ? ? ? to the set of invalid items ? ? ? ? ? ).

To handle the tightening change, a na??ve approach is to rebuild a new FP-tree from the transaction database so as to reflect the changes to constraints. However, a close examination reveals that such a tree reconstruction is un- necessary. Instead, after a SAM constraint is tightened, one can reuse the existing FP-tree to generate the unpro- cessed itemsets. Specifically, our iCFP system uses the existing FP-tree to form projected databases only for the items satisfying ? ? ? ? . When forming an ? 	 	 -projected database for an item ? ? ? ? ? ? ? ? , iCFP excludes the items that satisfy ? ? ? ? but not ? ? ? ? . These ?excluded? items can be efficiently enumerated due to succinctness.

Once iCFP forms these ? 	 	 -projected databases, the usual FP-tree based mining process can be applied recursively to these projected databases. As a final step, iCFP checks for each itemset that was processed before the tightening con- straint change (i.e., the itemset that satisfies ? ? ? ? ). Among these itemsets that satisfy ? ? ? ? , iCFP keeps and returns only those itemsets that satisfy both ? ? ? ? and ? ? ? ? . Example 2 below shows how iCFP deals with a tightening change to a SAM constraint.

Example 2 Consider the same transaction database as in Example 1. Suppose a SAM constraint ? ? ? ? ?  ? ? ? ? ? ? ? ? ?  ? ? ? is tightened to ? ? ? ? ? ? ? ? ? ? ? ? ? ?  ? ? ? after the ? ? 	 -projected database has  Proceedings of the International Database Engineering and Applications Symposium (IDEAS?04)     Items to be excluded  b:4  d:2  c:1e:1  c:1  a:3 d:1  => {b}, {a}, {d}, {c}, {e}  change  After the FP-tree for  b:2  Processed  FP-tree for {d}-proj. DB  bad:1, bd:1  a:2  => {d,a} a:2  => {e,a}, {e,b}, {e,a,b}  bace:1, bade:1  Before the  items  FP-tree for Trans. DB  e:1  {e}-proj. DB change  Figure 2. The iCFP system handles tightening changes to a SAM constraint  been processed (i.e., after obtaining all three itemsets con- taining ? ?namely, ? ? ? ? ? ? ? ? ? ? ? and ? ? ? ? ? ? ? ). Then, due to succinctness, the items that satisfy ? ? ? ? but not ? ? ? ? can be efficiently enumerated: items ? and ? . Therefore, as shown in Figure 2, when forming the ? ? ? -projected database, iCFP excludes items ? and ? from the extracted paths  ? ? ? ? ? ? ? :2 and ? ? ? ? ? :1. A valid frequent itemset ? ? ? ? ? is then produced by using the FP-tree built for the ? ? ? - projected database. Finally, iCFP needs to check all the itemsets that were processed before the change (i.e., the five singleton itemsets and the three itemsets containing ? , which all satisfy ? ? ? ? ) whether they still satisfy ? ? ? ? .

4.2. Handling a dynamic relaxing change to a SAM constraint  In general, a relaxing change from an old succinct constraint ? ? ? ? to a new constraint ? ? ? ? has different? and tougher?computational requirements than a tighten- ing change. The reason is that for a tightening change, the new solution space is contained in the old space (i.e.,  ? ? ? ? ? ? ? ? ? ? ? ), and all that is needed is to verify whether  every itemset ? satisfying ? ? ? ? also satisfies ? ? ? ? . In con- trast, for a relaxing change, this verification is unnecessary because ? ? ? ? ? ? ? ? ? ? ? . What is needed, however, is to in- sert into the new solution space all the itemsets that were not generated before the constraint was relaxed. Therefore, our iCFP system needs to carry out the following operations:  ? For processed itemsets satisfying ? ? ? ? , no further con- straint checking is required because they also satisfy  ? ? ? ? .

? For unprocessed itemsets, iCFP generates (i) the re-  maining itemsets satisfying ? ? ? ? , as well as (ii) those satisfying ? ? ? ? but not ? ? ? ? .

For a relaxing change, any frequent itemset ? satisfying the new SAM constraint ? ? ? ? is a subset of ? ? ? ? ? ? , which is a superset of ? ? ? ? ? ? :  ? ? ? ? ? ? ? ? ? where ? ? ? ? ? ? ? ? ? ? ? ? ? . (5)  Again, an alternative way to view the relaxing change is that some items are transferred from ? ? ? to ? ? ? . From this angle, the treatment for the relaxing changes can be simi- lar, though not identical, to that for the tightening changes.

Specifically, the iCFP system uses the existing FP-tree? which was built before the relaxing constraint change? to generate all unprocessed itemsets. This is possible be- cause all frequent items (valid as well as invalid items) are kept in the tree (refer to Section 3.2). By forming a projected database for each item that satisfies ? ? ? ? (i.e., items in ? ? ? ? ? ? ? ? ? ? ? ? ? ), iCFP generates all the re- maining itemsets satisfying ? ? ? ? . In addition, iCFP also needs to generate those itemsets satisfying ? ? ? ? but not  ? ? ? ? . To generate these itemsets, iCFP forms projected databases for all items that satisfy ? ? ? ? but not ? ? ? ? (i.e., the items that are transferred from ? ? ? to ? ? ? ). Simi- lar to the tightening case, iCFP excludes some items, but it excludes the items that violate both ? ? ? ? and ? ? ? ? (i.e., those ?non-transferred? optional items) for the relaxing case. These items can be efficiently enumerated because of succinctness.

For lack of space, we do not show further de- tails. We leave as an exercise for the reader to show how iCFP handles the case where a SAM constraint  ? ? ? ? ? ? ? ? ? ?  ? ? ? ? ? ? ? is relaxed to ? ? ? ? ? ? ? ? ? ?  ? ? ? ? ? ? ? after the ? ? ? -projected database has been processed.

4.3. Handling a dynamic tightening change to a SUC constraint  We have discussed how iCFP handles dynamic changes to one class of succinct constraints?namely, dynamic changes to a SAM constraint ? ? ? ? . Next, we turn our attention to dynamic changes to another class of suc- cinct constraints?namely, dynamic changes to a SUC con- straint ? ? ? ? . Recall from previous sections that a tighten- ing change to a SAM constraint can be viewed as a situation where some valid items are transferred to the set of invalid items (i.e., from ? ? ? to ? ? ? ). Similarly, a tightening change to a SUC constraint can be viewed as a situation in which some mandatory items are transferred to the set of optional items (i.e., from ? ? ? to ? ? ). On the sur- face, this tightening change appears to be very similar to a tightening change to a SAM constraint, but a close exam- ination reveals that the former is more complicated. The reason is that for the SAM constraint, once a valid item  Proceedings of the International Database Engineering and Applications Symposium (IDEAS?04)     become invalid, it can be ignored because it will not con- tribute to the final answers of valid frequent itemsets (even when combining with any valid items). In contrast, for the SUC constraint, once a mandatory item become optional, there are still opportunities for it to contribute to the final an- swers (e.g., when this optional item is combined with some mandatory items to form a valid itemset). See Example 3.

Example 3 Consider items ? ? ? and ? in Example 1. The ? ? ? values of these items are ? ? ? ? ? ? ? and ? ? ? , respec- tively. Then, with ? ? ? ? ? 	 ? ? ?  ? ? ? ? ? ? ? ? , (i) items ? and ? are mandatory, whereas item ? is optional; (ii) item- sets ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? and ? ? ? ? ? ? ? are valid.

When this constraint is tightened to become ? ? ? ? ?  ? ? ?  ? ? ? ? ? ? ? ? , the mandatory item ? becomes op- tional, but it still contributes to the final answers (e.g., item- set ? ? ? ? ? is valid).

Therefore, to ensure the completeness of the resulting answer sets of valid frequent itemsets, the iCFP system ex- ecutes as follows. It forms a projected database only for each item that is mandatory with respect to ? ? ? ? . When forming the ? ? ? -projected database (for each mandatory item ? ), iCFP includes not only the items above ? in the tree (as usual) but also all the ?unprocessed? optional items below ? that are located in the same tree path as ? . Once iCFP forms these ? ? ? -projected databases, the usual FP- tree based mining process (with the usual node extraction from tree paths, and with only frequency checking) can be applied recursively to these projected databases. So, the complication arises only when forming projected databases from the initial FP-tree; the formation of subsequent pro- jected databases from subsequent FP-trees can be found as usual. Example 4 illustrates how the iCFP system handles a tightening change to a SUC constraint.

Example 4 Consider the same transaction database as in Example 1. Suppose a SUC constraint ? ? ? ? ?  ? ? ?  ? ? ? ? ? ? ? ? is tightened to ? ? ? ? ? ? ? ?  ? ? ? ? ? ? ? ? after the ? ? ? -projected database has been processed (i.e., after obtaining all three itemsets con- taining ? ?namely, ? ? ? ? ? ? ? ? ? ? ? and ? ? ? ? ? ? ? ). Then, due to succinctness, the items that satisfy ? ? ? ? but not ? ? ? ? can be efficiently enumerated: items ? and ? . Since the  ? ? ? -projected database has been processed, iCFP will not include item ? in the extracted paths. Therefore, as shown in Figure 3, when forming the ? ? ? -projected database, iCFP includes ?unprocessed? optional item ? in the ex- tracted paths (i.e.,  ? ? ? ? ? ? ? ? ? :1, ? ? ? ? ? ? ? :1 and ? ? ? ? ? :1).

Three valid frequent itemset ? ? ? ? ? ? ? ? ? ? ? and ? ? ? ? ? ? ? can then be found from the FP-tree built for the ? ? ? - projected database. Similarly, when forming the ? ? ? - projected database, iCFP includes item ? in the extracted paths (i.e.,  ? ? ? ? ? ? ? :1, ? ? ? ? ? ? ? ? :1 and ? ? ? ? ? :1). Three valid  {c}, {e} => {b}, {a}, {d},  Before the  Processed  d:2  a:3  b:4  c:1  d:1  items  change  {a,c,b}  {a}-proj. DB FP-tree for  c:2  bac:1, ba_c:1, ba:1  change  After thebace:1, bade:1  => {e,a}, {e,b}, => {a,c}, {a,b},  badc:1, bad:1, bd:1  => {d,a}, {d,b},  FP-tree for  b:2  FP-tree for  {d,a,b}  a:2a:2  b:3b:3  {d}-proj. DB  {e,a,b}  {e}-proj. DB  e:1c:1e:1  FP-tree for Trans. DB  Figure 3. The iCFP system handles tightening changes to a SUC constraint  frequent itemset ? ? ? ? ? ? ? ? ? ? ? and ? ? ? ? ? ? ? can then be found from the FP-tree built for the ? ? ? -projected database.

Finally, iCFP needs to check all the itemsets were processed before the change (i.e., the five singleton itemsets and the three itemsets containing ? , which all satisfy ? ? ? ? ) whether they still satisfy ? ? ? ? .

4.4. Handling a dynamic relaxing change to a SUC constraint  Recall from the previous section that a tightening change to a SUC constraint causes some items to transfer from  ? ? ? ? 	 to ? ? ? ? . In contrast, a relaxing change to a SUC constraint does the opposite, that is, some items are trans- ferred from ? ? ? ? to ? ? ? ? 	 .

Since both tightening and relaxing changes cause the transfer of items, their treatment is quite similar, except for the following. When a SUC constraint is tightened, iCFP only needs to generate the itemsets satisfying ? ? ? ? . In contrast, when a SUC constraint is relaxed, iCFP needs to generate both (i) the remaining/unprocessed itemsets sat- isfying ? ? ? ? and (ii) those itemsets satisfying ? ? ? ? but not ? ? ? ? . Therefore, the iCFP system first forms a pro- jected database for each item that is mandatory with re- spect to ? ? ? ? , and computes valid frequent itemsets from the projected database as usual. Second, it forms a projected database for each item ? that satisfies ? ? ? ? but not ? ? ? ? .

When forming a projected database for each of these items, iCFP includes not only all the items above ? in the tree (as usual) but also all the optional items below ? that are lo- cated in the same tree path as ? . Once iCFP forms these  ? ? ? -projected databases, the usual FP-tree based mining process (with the usual node extraction from tree paths, and with only frequency checking) can be applied recursively to these projected databases.

Proceedings of the International Database Engineering and Applications Symposium (IDEAS?04)          0 20 40 60 80 100  R un  tim e  (in s  ec on  ds )  Selectivity (i.e., percentage of items selected)  Handling the SUC constraint  FIC iCFP            0 20 40 60 80 100  R un  tim e  (in s  ec on  ds )  Selectivity (i.e., percentage of items selected)  Handling the SAM constraint  FIC iCFP  (a) Handling the SUC constraint (b) Handling the SAM constraint  Figure 4. Runtime: iCFP vs.

? ? ?  For lack of space, we do not show further details.

We leave as an exercise for the reader to show how iCFP handles the case where a SUC constraint ? ? ? ? ?  ? ? ? ? ? ? ?  ? ? ? ? is relaxed to ? ? ? ? ? ? ? ? ? ? ? ?  ? ? ? ? after the ? ? ? -projected database has been processed.

5. Experimental results  The experimental results cited below are based on a transaction database of 100k records with an average trans- action length of 10 items, and a domain of 1000 items. The database was generated by the program developed at IBM Almaden Research Center [3]. Unless otherwise specified, we used a minimum support threshold of 0.01%. All experi- ments were run in a time-sharing environment in a 700 MHz machine. The reported figures are based on the average of multiple runs. In the experiment, all the algorithms were implemented in C.

In the first set of experiments, we evaluated the effective- ness of (i) succinctness-based exploitation and (ii) succinct- antimonotonicity based exploitation. More specifically, we compared our iCFP system with its most relevant algo- rithm  ? ? ? . The key difference between them is that  ? ? ?  does not completely exploit properties of succinct con- straints whereas iCFP does.

The y-axis of Figure 4 shows the runtimes of iCFP and? ? ? , and the x-axis shows the selectivity of the succinct  constraint. A constraint with pct% selectivity means pct% of items is selected. The higher the pct value, the more is the number of selected items.

It is observed from Figure 4(a) that as the selectivity of the SUC constraint ? ? ? ? decreases (i.e., fewer items are selected), the runtime of iCFP decreases but that of  ? ? ?  increases. In terms of speedup, it is more beneficial to use iCFP than  ? ? ? , especially when ? ? ? ? has a lower selec-  tivity. A reason for the gap in runtime is that iCFP exploits the properties of ? ? ? ? . Consequently, constraint check- ing is only performed on the original database at the initial step, but not on projected databases at recursive steps. Prun- ing is done once-and-for-all! In contrast,  ? ? ? checks con-  straints at many steps, including many projected databases at recursive steps. The results show the effectiveness of succinctness-based exploitation.

Similarly, it is observed from Figure 4(b) that there is a gap in runtime between iCFP and  ? ? ? . In terms of runtime,  when the selectivity of the succinct anti-monotone (SAM) constraint ? ? ? ? decreases (i.e., fewer items are selected), both  ? ? ? and iCFP take shorter execution time. Again, a  reason for the gain in performance, when compared iCFP with  ? ? ? , is that the iCFP system exploits properties of  SAM constraints. The results show the effectiveness of succinct-antimonotonicity based exploitation.

We have tested with various minimum support thresh- olds. The results show that when the threshold increases, the runtime decreases. In addition, we have also tested scal- ability with the number of transactions. The results show that our proposed iCFP system has a linear scalability.

In the second set of experiments, we evaluated the ef- fectiveness of iCFP in handling dynamic changes to con- straints. More specifically, we compared our iCFP system with its most relevant algorithms DCF and Rerun. The key differences among them are as follows: (i) iCFP and Rerun are FP-tree based, whereas DCF is Apriori-based; (ii) iCFP and DCF reuse the processed itemsets as much as possible after a constraint is changed, whereas Rerun ignores all pro- cessed itemsets and generates itemsets satisfying the modi- fied constraint from scratch.

Rerun is a na??ve approach of handling dynamic changes to constraints. It simply ignores all valid frequent item- sets that have been produced so far with respect to the  Proceedings of the International Database Engineering and Applications Symposium (IDEAS?04)            0 0.2 0.4 0.6 0.8 1  R un  tim e  (in s  ec on  ds )  Fraction of items processed before changing the constraint  Handling a dynamic tightening change to the SAM constraint  Rerun, old pct=80%, new pct=60% iCFP, old pct=80%, new pct=60%  Rerun, old pct=60%, new pct=40% iCFP, old pct=60%, new pct=40%           0 0.2 0.4 0.6 0.8 1  R un  tim e  (in s  ec on  ds )  Fraction of items processed before changing the constraint  Handling a dynamic relaxing change to the SAM constraint  Rerun, old pct=80%, new pct=100% iCFP, old pct=80%, new pct==100%  Rerun, old pct=60%, new pct=80% iCFP, old pct=60%, new pct=80%  (a) Handling a tightening change (b) Handling a relaxing change  Figure 5. Runtime for handling a dynamic change to a SAM constraint: iCFP vs. Rerun  old constraint ? ? ? ? (i.e., ignore all ?processed? itemsets), and reruns the mining process again using the new con- straint ? ? ? ? . Our iCFP system takes a better approach.

It exploits properties of constraints and reuses all ?pro- cessed? itemsets. To evaluate the effectiveness of our sys- tem, we experimented with a situation where a SAM con- straint ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ?  ? is tightened to ? ? ? ? ?  ? ? ? ? ? ? ? ? ? ? ? ? ? . The percentage old pct of items hav- ing ? ? ? ?  ? and the percentage new pct of items having  ? ? ? ? ? ? are set in such a way that new pct = old pct ? ? ? ? . We varied old pct from ? ? ? to ? ? ? . The x-axis in Figure 5(a) shows the fraction ? of itemsets processed before tightening the constraint, and ? varied from ? ? ? to  ? ? ? . The y-axis shows the total runtime (in seconds) of both iCFP and Rerun. From the graph, it is clear that our iCFP system always beats Rerun, but the extent varies under dif- ferent situations. When ? is higher (i.e., more itemsets are processed), the relative speedup is higher. In other words, it is more beneficial to use iCFP than Rerun especially when  ? is high. The reason is that, when ? is higher (i.e., more items have been processed), more processed items are ig- nored by Rerun!

Next, we turned our attention to a relaxing change. Fig- ure 5(b) shows the experimental results for a situation where a SAM constraint ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ?  ? is relaxed to ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? . Here, the percentage old pct of items having ? ? ? ?  ? and the percentage new pct of items having ? ? ? ? ? ? are set in such a way that new pct = old pct  ? ? ? ? . We varied old pct from ? ? ?  to ? ? ? . The figure again shows that our iCFP system al- ways beats Rerun. The reasons are as follows. First, Rerun ignores all the itemsets produced before the change (i.e., the itemsets satisfying ? ? ? ? and computes itemsets satisfy- ing ? ? ? ? , which contain those ignored itemsets. Hence, the higher the ? , the higher is the number of itemsets that are  generated and ignored by Rerun. One can easily observed that Reurn is really a waste of computation. Second, our iCFP system reuses all the itemsets ignored by Rerun (i.e., all those itemsets satisfying ? ? ? ? ). Due to succinctness,  ? ? ? ? ? ? ? ? ? ? ? . After ? ? ? ? is relaxed to become ? ? ? ? , the iCFP generates (i) the remaining itemsets satisfying ? ? ? ? and (ii) those satisfying ? ? ? ? but not ? ? ? ? . This explains why the runtime of iCFP is quite steady. Therefore, it is more beneficial to use iCFP than to use Rerun, especially when ? is high (i.e., more items have been processed).

In addition, we have also compared iCFP with DCF. In all experiments, iCFP far dominates DCF. A reason is that the former is FP-tree based, and thus avoids the compu- tationally costly and time-consuming candidate generation process of the latter. This shows the importance and the benefits of incorporating interactive constrained in the FP- tree based mining framework.

6. Conclusions  A key contribution of this paper is to develop and im- plement an interactive mining system, called iCFP, for the interactive mining of Constrained Frequent Patterns.

The system is an integration of constrained mining, tree- based mining, and interactive mining. Consequently, the system (i) allows human users to impose a certain focus on the mining process, (ii) provides users with quick re- sponse/feedback during the mining process, and (iii) per- mits users to dynamically change their constraints during the process.

In ongoing work, we are interested in exploring im- provements to the iCFP system. For example, we are in- terested in investigating efficient methods for handling dy- namic changes to non-succinct constraints. Along this di- rection, an interesting question to explore is how to incor-  Proceedings of the International Database Engineering and Applications Symposium (IDEAS?04)     porate iCFP into a data mining tool for handling various real-life applications.

Acknowledgement  This project is partially sponsored by Natural Sciences and Engineering Research Council of Canada (NSERC) and The University of Manitoba in the form of research grants.

