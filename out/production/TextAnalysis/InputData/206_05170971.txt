Application in Market Basket Analysis Based  on FP-growth Algorithm

Abstract  Market basket analysis gives us insight into the merchandise by telling us which products tend to be purchased together and which are most enable to purchase .The market basket analysis is a powerful tool especially in retailing it is essential to discover large baskets, since it deals with thousands of items. FP-growth algorithm is an efficient algorithm for mining frequent patterns. It does not need to produce the candidate sets and that is quite time consuming. It scans database only twice and frequent item set is mining by using of FP tree.

In this paper, Visual C++ is applied to design the program to mine the frequent itemsets using FP-growth algorithm. According to the mining result, the merchandise in the supermarket is arranged together in the same place well-suited for customer.

1. Introduction  Generally, there are transactions thousands upon thousands in a supermarket daily, in the face of so much information, if we want to find out the relationship between the merchandises and make business decisions include what to put on sale, how to design coupons, how to place merchandise on shelves in order to maximize the profit, etc, it is very difficult to do these work if we have no effective way. Therefore, for understanding the relationships among items in transactions, many algorithms are introduced to mine the frequent itemsets. The Apriori[1] Algorithm is a well- known approach which is proposed by Agrawal and Srikant. However, candidate set generation is still costly, especially when there exist a large number of patterns and/or long patterns. One of the currently fastest and most popular algorithms for frequent item set mining is the FP-growth[2] algorithm without Candidate Generation, since it condenses the transaction information into a tree structure. The problem of mining association rules over basket data was introduced by Agrawal, Imielinski and Swami[3], here we only introduce the basic concepts related with FP-growth algorithm.

Let I = {i1 , i 2 ,..., i m } be a set of items. Let D be the task relevant data. And let T be a set of database transactions where each transactions T is a set of items such that T ??I. Each transaction is associated with an identifier called TID. Let A be a set of items, A transaction T is said to contain A if and only if A?T. An  association rule is an implication of the form A??B, where A?I?B?I and A?B=?. The rule A?? ?B holds in transaction set D with support s, where s is the percentage of transaction in D that contains A?B. The rule A?? ?B has confidence c in the transaction set D if c is the percentage of transactions in D containing A which also contain B.

Rules that satisfy both a minimum support threshold (MinSup) and a minimum confidence threshold (MinConf) are called strong. An item-set that contains k items is a k-itemset. The set {Computer, Financial Management Software} is a 2-itemset. The occurrence frequency of an itemset is the number of transactions that contain the itemset. This is also known, simply, as the frequency or support count of the itemset. An item-set satisfies MinSup if the occurrence frequency of the item- set is greater than or equal to the product of MinSup and the total number of transactions in D. If an itemset satisfies minimum support, then it is a frequent itemset.

The set of frequent k-itemsets is commonly denoted by kL .

2. Market Basket Analysis  The term market basket analysis[4,5,6] in the retail business refers to research that provides the retailer with information to understand the purchase behaviour of a buyer. This information will enable the retailer to understand the buyer's needs and rewrite the store's layout accordingly, develop cross-promotional programs, or even capture new buyers (much like the cross-selling concept). An early illustrative example for this was when one super market chain discovered in its analysis that customers that bought diapers often bought beer as well, have put the diapers close to beer coolers, and their sales increased drastically. Although this is only an example that professors use to illustrate the concept to students, the explanation of this imaginary phenomenon might be that fathers that are sent out to buy diapers often buy a beer as well, as a reward. This kind of analysis is an example of the use of data mining.

The input for the market basket analysis is a dataset of purchases. A market basket is composed of items bought together in a single trip to a store. The most significant attributes are the transaction identification and item identification. While ignoring the quantity bought and the price. Each transaction represents a purchase, which occurred in a specific time and place. This purchase can be linked to an identified customer or to a non-identified customer.

2009 World Congress on Computer Science and Information Engineering  DOI 10.1109/CSIE.2009.1073     3. FP-growth Algorithm  FP-growth (frequent pattern growth) [7] uses an extended prefix-tree (FP-tree) structure to store the database in a compressed form. FP-growth adopts a divide-and-conquer approach to decompose both the mining tasks and the databases. It uses a pattern fragment growth method to avoid the costly process of candidate generation. FP-growth algorithm scans database altogether two times[8]. The first scanning database, we can obtain the frequent 1-itemset, and the second scanning database, we can get the database's non-frequent itemset by using of frequent 1-itemset, and FP-tree is generated simultaneously. Last, we can obtain the association rule by using of the FP-tree.

3.1 Transactional Database To exemplify the FP-growth algorithm for finding  frequent itemsets, an instance with 5 transactions is given in table 1, as shown as pink column.

Table 1: Sample data to illustrate the FP-growth algorithm  TID Items in basket Fre. item (ordered)  100 {f, a, c, d, g, i, m, p} {c, f, a, m, p} 200 {a, b, c, f, l, m, o} {c, f, a, b, m} 300 {b, f, h, j, o} {f, b} 400 {b, c, k, s, p} {c, b, p} 500 {a, f, c, e, l, p, m, n} {c, f, a, m, p}  3.2 Frequent Pattern Tree  There are 3 steps to create a frequent pattern tree.

Step 1: Create a table of candidate data items in  descending order (Table 2).

Step 2: Build the Frequent Pattern Tree according to  each event of the candidate data items.

Step 3: Link the table with the tree.

Let the minimum support threshold be 3. First, a scan  of DB derives a list of frequent items, (f:4), (c:4), (a:3), (b:3), (m:3), (p:3) (the number after ?:? indicates the support), get the frequent one item set in descending order.

Table 2: Get the frequent one item set in descending order Item Support Frequency  c 4 f 4 a 3 b 3 m 3 p 3  Using the data present in table 1, we can build the frequent pattern tree according to each event of the candidate data items. For convenience of later discussions, the frequent items in each transaction are listed in this ordering, as shown as green column in table 1. The steps as following:  Firstly, the root of a tree is created and labeled with ?NULL?. The FP-tree is constructed as follows by scanning the transaction database DB the second time.

For example, the scan of the first transaction leads to the construction of the first branch of the tree : <(c:1), (f:1), (a:1), (m:1), (p:1)>. Notice that the frequent items in the transaction are listed according to the order in the list of frequent items. The branch of the tree has five nodes, and the node (c:1) is linked as a child of root, then f link to c, and a link to f, and m link to a, last, p link to m. For the second transaction, since its (ordered) frequent item list <( c:1), (f:1), (a:1), (b:1) , (m:1) > shares a common prefix< c, f, a> with the existing path < c, f, a, m, p>, the count of each node along the prefix is incremented by 1, and one new node (b:1) is created and linked as a child of (a:2) and another new node (m:1) is created and linked as the child of (b:1). In general, when we add a new branch for a transaction, the count of each node along the prefix is incremented by 1 and a new node which is followed the prefix is created and linked. And so on indefinitely, after scanning all the transactions, the tree, together with the associated node-links, are shown in figure 1.

Figure1. Frequent Pattern Tree  3.3 Conditional Pattern Base  Once the header table and the FP-tree are constructed, then for each frequent item in the header table, the conditional pattern base, which is a list of nodes that link the frequent item?s node in the FP-tree to the root node (?NULL?), is formed. Each pattern base is assigned a support count which is the minimum of the support counts for the items in the pattern base. The conditional pattern base is generated, as shown as table 3. The set of items in such single pattern bases form the frequent itemset.

Table3: Conditional pattern base  Head Item  conditional pattern base  f c:4 a cf:3 b cfa:1, cf:1, c:1 m cfa:2, cfab:1 p cfam:2, cb:1       3.4 Frequent Itemset  In the condition pattern base, from the beginning of the p-item, every item of the condition pattern base is scanned, and the common content is list, including an individual item and the combination. At the same time, the number of the corresponding item is counted and the  condition FP-tree is generated. And then FP-tree is connected with the corresponding header-able-item, and eventually frequent itemset are generated. As shown in table 4.

Table 4: Frequent Itemset  Head Item  Conditional Pattern Base Conditional FP-Tree Frequent Itemset  p cfam:2, cb:1  c:3  cp:3 m cfa:2, cfab:1 c:3,f:3,a:3,cf:3,ca:3,fa:3, fa:3 cm:3,fm:3,am:3,cfm:3,cam:3,fam:3,cfam:3 b cfa:1, cf:1, c:1 c:3  cb:3 a cf:3 cf:3  ca:3,fa:3,cfa:3 f c:4 c:4  cf:4 c ? ? ?  4. Programming Design  We use tools such as UltraEdit to provide the original data (commodities in market basket). The code is developed by the tools of Visual C++ Development environment, according to the FP-growth algorithm, we get the frequent itemsets. The flow chart is as shown in Figure 2.

Figure2. Programming Design Chart  Building a frequent pattern tree is the most important step during processing. Therefore, here we give out 3 structural unions which are used to build the tree.

struct Childnode { FPTreeNode node; childLink next; } ChildNode;  struct FPnode { int item; int count; int numPath; FPTreeNode parent; childLink  children; FPTreeNode hlink; } FPNode;  struct Itemsetnode *LargeItemPtr; typedef struct Itemsetnode { int support; float corr; int *itemset; LargeItemPtr next;  }ItemsetNode; .

5. Experimental Result  As shown in Table 5, we use these randomly sample data to simulate the process of FP-growth algorithm. The data in the table indicate that different customers purchase different types of goods, the first column data is the serial number of customers, and the number in each is the commodities in the market basket. We can mine the relationship of goods in the original market basket.

There are 8124 transactions total, every customer buy many kinds of good, let 87, 9, 4 etc. be goods. For instance, 87 means milk, 9 means break and 4 means beer and so on. Input data is an ASCII format file,  including plenty of data which is shown in table 5. After initialization of the data, it is processed by FP-growth algorithm. When the data mining is finished, the frequent itemsets are print into the screen. The results of the market basket analysis are as shown in Figure 3. Figures (a) to (e) show frequent 1-itemset, frequent 2-itemset, frequent 3-itemset, frequent 4-itemset and frequent 5- itemset. These frequent itemsets means what kinds of goods customers usually buy at the same time. Therefore, the result is significative of merchantmen?s decision.

