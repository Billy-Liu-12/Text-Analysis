Using Incremental Mining to Generate Fuzzy Rules for Real-Time  Network Intrusion Detection Systems

Abstract   In the paper, we propose a fast algorithm to  generate fuzzy association rules by incremental mining  approach, for which the transactions or data records are  online instantly collected from live packets. That is, as  one data record is collected online, the latest fuzzy rules  can be obtained immediately. According to our  simulation, in case of the number of features do not  excess twenty, mining process can be completed from  several milliseconds to seconds depending on the  number of features.

1. Introduction   The fuzzy association rule [1] has been receiving a  great attention recently and has been applied to many  applications in different fields so far [2, 3, 4]. Several  researchers adopted fuzzy association rule to design their  Network Intrusion Detection Systems (NIDSs) [2, 5, 6].

However, they all emphasized the effectiveness of applying  fuzzy association rules to design NIDSs (high detection  rate, low false alarm rate, etc), but ignored the time  efficiency of their own mining algorithms. Basically, they  adopted a static mining approach to mine out fuzzy  association rules for further judgment.

In this paper we present an on-line incremental  mining algorithm for generating fuzzy association rules for  NIDS design. Our algorithm is fast enough, but it is not  suitable to be applied to applications which need more than  20 features. This is because its memory consumption is  severe and mainly depends on the number of features.

Fortunately, for most NIDSs they don?t need more than 20  features [6, 7]. Besides, there are some techniques, such as  PCA (Principal Component Analysis) [8], can be applied to  reduce the feature dimensionalities in case of the number  of features is more than 20. The rest of the paper is  organized as follows. Some background knowledge is  introduced in Section 2. Our algorithm is clearly described  in Section 3. Its experimental results are shown in Section  4. Finally, conclusion is given in Section 5.

2. Background An association rule has the form of ?If X, then Y?,  denoted as X ? Y, where X and Y are sets of items (or  called itemsets). Refer to [9] for Apriori algorithm, in   DOI 10.1109/WAINA.2008.69    DOI 10.1109/WAINA.2008.69     which given two thresholds of mini_sup and mini_conf, the  algorithm will find all such rules as X ? Y with s ?  mini_sup and c ? mini_conf.

Since Apriori algorithm was designed for mining  records in database with binary features (item and feature  being used interchangeably throughout the paper), fuzzy  association rules mining [1] was one of those variations to  deal with quantitative features. Let T = {t1, t2, ?, tn} be the  database and each record ti represents the ith tuple in T.

Moreover, we use I = {i1, i2, ?, im} to represent all features  appeared in T. Each quantitative feature ik, 1 ? k ? m, is  associate with some fuzzy variables, say v1, v2, ?, vj.

Every fuzzy variable is represented by a membership  function. For easy representation in the following, we use Fik.vj to uniquely denote the jth membership function of  feature ik.

Suppose four features, say #packet, #SYN, #ACK, and  #connection are concerned in a NIDS and each feature has  three fuzzy variables, say low, medium, and high, then 4 ?  3 = 12 membership functions are involved. So, F#packet.low  denotes the low function of feature #packet, F#ACK.high  denotes the high function of feature #ACK, etc. In fuzzy  association rule mining, a fuzzy itemset consists of two  parts: items and fuzzy variables, denoted as <X, V>, where  X = (x1, x2, ?, xi) ? I is a collection of items (or features)  and V = (v1, v2, ?, vi), is the collection of corresponding  fuzzy variables to X in order. The support of <X, V> is  computed as [1]:   in recordsofnumber  , satisfying  votesof Sum ) ,Sup( T  VXVX ><=><  , ])[(   T  xtFTt jisxXxi jjj? ?? ??=             (1)  where ti[xj] denotes the value of feature xj of the ith record,  and |T| represents the total number of records.

Instead of ?If X, then Y? in association rule, a fuzzy  association rule now has the form of ?If <X, V>, then <X?,  V?>?. Here <X, V> and <X?, V?> are two itemsets, X ? I, X?  ? I, and X ? X? = ?. Similarly support s and confidence c  of the fuzzy association rule <X, V> ? <X?, V?> are  computed as s = Sup (<Y, U>) and c = Sup (<Y, U>) / Sup  (<X, V>), where <Y, U> being the concatenation itemset of  <X, V> and <X?, V?>. For instance, if X = (x1, x2, ?, xi), V =  (v1, v2, ?, vi), X? = ( ''2'1 ,,, jxxx ), and V? = ( ''2'1 ,,, jvvv ),  then Y = (x1, x2, ?, xi, ''2'1 ,,, jxxx ) and U = (v1, v2, ?, vi, ''  ' 1 ,,, jvvv ).

3. Our Incremental Mining Algorithm for Fuzzy Association Rules   3.1 Basic Concept Each current support value of an itemset is kept in the  memory for a while; as the next data record is being  gathered, our algorithm use the current support value to  compute the new one instead. See an example. Suppose the  quantitative values of four features: #packet, #SYN, #ACK,  and #connection, are measured for each time slot, and in  sequence they are t1 = (70, 6, 5, 12), t2 = (59, 8, 4, 3), ?, ti  = (200, 25, 12, 31), ?. For the itemset <X, V> = {#packet  is low, #SYN is medium, #connection is low}, its support  value s at t1, t2, t3, ?, ti, ?, is computed individually as?  s at t1 = (F#packet.low(70) ? F#SYN.medium(6) ? F#connection.low(12))  /1 ? tmp;  s at t2 = (tmp ? 1 + (F#packet.low(59) ? F#SYN.medium(8) ?  F#connection.low(3))) / 2 ? tmp; ? s at ti = (tmp ? (i-1) + (F#packet.low(200) ? F#SYN.medium(25) ?  F#connection.low(31))) / i ? tmp;  ?     3.2 Data Structure We use an alphabet character to denote one feature?s  fuzzy variable in our algorithm. So if there are n features  and each has m fuzzy variables, then n ? m consecutive  characters are used. For the example of n = 6 and m = 3,  starting with character ?A? the matrix is shown in Figure 1.

low   medium  high 0       1        2  A B C  D E F  G H I  J K L  M N O  P Q R  Figure 1. Transformation among character ASCII, position index, and fuzzy variable    After such arrangement, each fuzzy itemset can be  expressed by a string. For instance, string ?EJR? denotes  the fuzzy itemset {f2 is medium, f4 is low, f6 is high}.

In our algorithm, each fuzzy itemset is represented by a  node.

struct itemset { float SupVal; char STRING[maxlen]; struct itemset *next;  };   Variable SupVal is used to store the current support  value, and the maxlen is defined as the longest length of  itemset, which theoretically is less than or equal to the  number of features. Fortunately, maxlen in practical is  much less than the number of features; this claim is  affirmed in Section 4. Our algorithm consists of threes  procedures: Initialization, SupCal, and RuleGen. The  procedure Initialization is run only once at the beginning,  while the procedures SupCal and RuleGen are run one  time as one new record is being gathered.

3.3 Initialization Procedure Again the example in Figure 1 is used for easy  illustration. All possible fuzzy itemsets are linked as  shown in Figure 2. This work can be done by the  following Initialization procedure.

Figure 2. All possible fuzzy itemsets  Procedure Initialization //Input: features n, degrees m, and the longest itemset length:  maxlen ? n //Output: maxlen linked lists in memory; for each list, nodes  have the same length and appear in lexicographic order.

//Assumption: Matrix[][] and length are two global variables.

01  Matrix[i][j] ? 0, for all i and j;    //zero matrix 02  for (length = 1; length ? maxlen; length++) {  CreateLinkedList(length, 0); 03  }   SubProcedure CreateLinkedList (int len, int start)  01  if len = 1, then { 02    for (i = start; i < n; i++) { 03      for (j = 0; j < m; j++) { 04        Matrix[i][j] ? 1; 05        Scan Matrix from top to down and left to right, to  find out all positions set to 1; 06        Dynamically allocate a node and use the STRING  field to store the corresponding fuzzy itemset;  07        Add the node to the tail of the list with length length;  08        Matrix[i][j] ? 0; 09      } 10    } 11  } //end if 12  else {   // len > 1 13    for (i = start; i ? n - len; i++) {  f1  0  f2  1  f3  2  f4  3  f5  4  f6  5  ? A B Q R ? AD AE OQ OR ? ADG ADH LOQ LOR  ... ...

?  length              maxlen     14      for (j = 0; j < m; j++) { 15        Matrix[i][j] ? 1; 16        CreateLinkList(len - 1, i + 1); 17        Matrix[i][j] ? 0; 18      } 19    } 20  } //end else    Following the above example, let?s see how to  construct the linked list of length 3 for instance, i.e., the  execution of CreateLinkedList(3, 0). The execution is  visualized as a tree, shown in Figure 3. In the figure, the  last, i.e. third, ?1? should be placed independently in each  position on the shaded area in row major, by the nested  for-loop in lines 2 and 3 of the subprocedure  CreateLinkedList. During the execution, each possible  arrangement is replaced by a node, and STRING field of  the node stored the characters for which positions in  Matrix are marked ?1?. Two feasible arrangements and  their corresponding itemsets are shown in Figure 4.

Figure 3. The execution of CreateLinkedList(3, 0)  1 0 0 0 0 0 0 0 0 0 1 0 0 0 1 0 0 0 0 1 0 0 0 0 0 0 0 1 0 0 0 0 0    0 0 1    ?AIK?              ?EMR?   Figure 4. Two itemset candidates  3.4 SupCal Procedure Here we then describe how to fast update each  itemset?s support value as one new record is being  gathered. Such updating is basically according to the  concept presented in Subsection 3.1, and all details are  given in the following SupCal procedure.

Procedure SupCal //Input: an incoming record, say (i+1)th record //Output: update of support value for each itemset //Assumption: The (i+1)th record?s n quantitative feature values are stored sequentially in array OneRecord, i.e., fj?s value is stored in OneRecord[j-1], 1 ? j ? n.

01 for each linked list { 02   for each node in the linked list { 03      FuzzyValue ? 1; 04     for each character in the STRING field { 05     Transfer the character to its matrix position, say (u, v); 06     Take OneRecord[u] to the membership function of  fu+1?s (v+1)th fuzzy variable, and assign the result to OneItemTmp;  07      FuzzyValue ? FuzzyValue ? OneItemTmp; 08      }  //update the support value 09   SupVal ? [ (SupVal ? i) + FuzzyValue ] / (i + 1);  10   If SupVal ? mini_sup, then  RuleGen(length of itemset, STRING, SupVal); 11   } 12 }   3.5 RuleGen Procedure  The final procedure RuleGen contains three  subprocedurs: FuzzyRules, RuleConfidence, and  PrintOut. The FuzzyRules is used to recursively generate  = {f1 is low, f3 is high, f4 is medium}  = {f2 is medium, f5 is low, f6 is high}  fo(i=5 i<6; i++) fo(j=0; j<3; j++)  fo(i=2; i<6; i++) fo(j=0; j<3; j++)  CreateLinkedList (1, 5)  fo(i=2; i<6; i++) fo(j=0; j<3; j++)  ? i=1, j=0  CreateLinkedList (2, 1)  i=3, j=2  i=0, j=1 i=0, j=0  CreateLinkedList (3, 0)  Matrix[0][0] = 1  ?  Matrix[1][1] = 1 Matrix[4][2] = 1  CreateLinkedList (1, 2) CreateLinkedList (1, 2)      i=0, j=2 i=1, j=0  i=1, j=1  i=4, j=2  1 1   Matrix[1][0] = 1  ?     all candidate rules; meanwhile RuleConfidence is  applied to compute each candidate rule?s confidence and  PrintOut is called to print out a qualified rule.

Procedure RuleGen (int length, char string[], float support) //Assumption: variables len, str[], sup and Litems[] are global.

01 len ? length; 02 str ? string + ?\0?;  //plus an end-string character 03 sup ? support; 04 Litems[0] ? ? ?; 05 FuzzyRules (1);  SubProcedure FuzzyRules (int leftlen) 01  if leftlen = len, then return; 02  else { 03    for (i = leftlen - 1; i < len; i++) { 04      if Litems[leftlen - 1] < str[i], then { 05        Litems[leftlen] ? str[i]; 06       Litems[leftlen + 1] ? ?\0?; 07        conf ? RuleConfidence(leftlen); 08        if conf > mini_conf, then PrintOut; 09        FuzzyRules(leftlen + 1); 10      } 11    } 12  } //end else  SubProcedure RuleConfidence (int leftlen) 01  LitemsPlus ? &Litems[1]; //the address of Litems[1]; 02  for each node in the linked list of length leftlen {  //compare the letters 03    if LitemsPlus = STRING of the node, then { 04       conf = sup / (SupValue of the node); 05       return conf; 06     } 07  } //end for-loop  SubProcedure PrintOut  01  index ? 1; 02  printf(?%s ? ?, Litems);  //show the antecedent 03  for(i = 0; i < len; i++) {  //show the consequent 04    if str[i] = Litems[index], then index++; 05    else printf(?%c?, str[i]); 06  } //end for-loop    4. Performance Analysis  Our program was coded by C++ and run on  Windows XP platform with P4-3.2GHZ CPU and 2.0GB  memory. Applied fuzzy membership functions are  illustrated in Figure 5. The output value of any  membership function was falling in the interval [0, 1].

All records were randomly generated with features  values falling in the interval [1, 500].

Figure 5. Membership functions.

Table 1. #rules derived from variant itemset lengths  n = 9 n = 12 n = 15 n = 18 n = 21  len = 1 0 0 0 0 0  len = 2 27.91 30.08 31.81 29.76 29.70  len = 3 4.79 5.13 6.81 4.73 7.80  len = 4 5.02 4.96 2.05 4.69 3.98  len = 5 3.54 3.31 0.37 3.48 1.28  len = 6 1.07 0.89 0 1.21 0.24  len = 7 0 0 0 0 0  len = 8 0 0 0 0 0    Throughout this section, we denote n to be the  number of features and m to be the number of degrees  for each feature. It is not difficult to compute that totally  ? =  maxlen  x  n x  xCm  nodes will be constructed by our  algorithm, where C is the combinatorial notation and  maxlen is the longest itemset set in the Initialization  procedure in Section 3.3. Theoretically maxlen should  be equal to n; however according to our experiment  maxlen set to 6 is enough. See Table 1. As m = 3, maxlen  = 8, mini_sup = 0.2 and mini_conf = 0.4, no rules was  derived from itemsets with lengths greater than 6. In the  # features # rules  Low?f ( x ) = 1 / ( 1 + exp( 0.05 ( x - 130) ) ) Medium?f ( x ) = 1 / ( 1 + | ( x - 250) / 80 | ^ 4 )  High?f ( x ) = 1 / ( 1 + exp( -0.05 ( x - 380) ) )     experiment, two hundreds records were randomly  generated. Once mining was done as one record being  randomly generated, so 200 times of mining were  performed. Value for each case was the average number  of rules.

Table 2. Memory consumptions for different numbers of features as m =3 and maxlen = 6  #nodes KBytes MBytes  n = 6 4095 63.98 0.062 n = 9 104679 1635.61 1.597 n = 12 912717 14261.20 13.927 n = 15 4502214 70347.09 68.698 n = 18 15886503 748226.61 242.409 n = 21 45025911 703529.86 687.041 n = 24 109366866 1708857.28 1668.806    Table 3. Time expenses for different numbers of features   n = 6 n = 9 n = 12  a b c  0.00344 0.00320 0.00305  0.06719 0.06891 0.06851  0.49907 0.51156 0.51687  n = 15 n = 18 n = 21 a b c  2.22039 2.25758 2.26899  7.39321 7.37078 7.35562  19.59477 19.57117 19.51157  Note: a: mini_sup = 0.1, mini_conf = 0.3; b: mini_sup = 0.3, mini_conf = 0.5; c: mini_sup = 0.5, mini_conf = 0.7  As we fixed m = 3, maxlen = 6, the number of nodes  and their memory consumptions are displayed in Table 2,  for 6 ? n ? 24. Each node was counted as 16 bytes. Next  we have evaluated the time expense for once mining. As  m = 3 and maxlen = 6, the time spent for once mining in  average is given in Table 3.

5. Conclusion   Several Researches [2, 5, 6] have shown that the fuzzy  association rule can be effectively applied to design their  NIDSs. However, none of them can really achieve  detection in real time because they all collected a lot of  records of network traffic information first, and then  analyzed these records later by static mining. The main  contribute of this paper is to propose an online incremental  mining algorithm for generating fuzzy association rule.

Thus, as one new record of network traffic information is  being gathered, the latest set of rules can be generated.

