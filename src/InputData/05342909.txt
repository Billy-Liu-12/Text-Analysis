IEEE International Workshop on Intelligent Data Acquisition and Advanced Computing Systems: Technology and Applications  21-23 September 2009, Rende (Cosenza), Italy

Abstract - Endianness concept is of great value for engineers who are employing microcontrollers in their applications. This paper presents a perspective on endianness learning using 8-bit microcontroller units (MCUs). The authors propose a practicable approach on assembly language arithmetic techniques, addressed to aid students in exploring big and little-endian ordering for handling memory storage. The proposed approach associates the study of endianness representation with a regular challenge in 8-bit microcontroller education, that is, the assembly-level arithmetic techniques for numbers extending one-byte range. The educational objective intended to be reached in this communication is to provide to the students a better understanding of the processor?s workings at the machine level, and help them in exploiting byte ordering towards to an optimum performance of a low-level system implementation.

Keywords - Assembly-level programming, big-endian  representation, little-endian representation, integer arithmetic, microcontrollers

I. INTRODUCTION  Endianness in computing is referred to the attribute that describes data storage and accessing process of a multi- byte integer value in computer?s memory. Processor architectures regularly store/access integers as sequence of bytes in which, numeric significance can be of either big- endian or little-endian ordering (that is, a decreasing or increasing respectively byte ordering as memory is counted-up). For example, the four-byte (4B) integer of 0x1234ABCD value would be represented at the very beginning of a 256B memory as follow: Big-endian: 0x00:0x03 = 0x1234ABCD; Little-endian: 0x00:0x03 = 0xCDAB3412. In addition, some architectures feature bi- endian representation, which is referred to the capability of supporting both endian formats and is addressed for improving computers performance [1]. In this communication the authors propose a perspective on endianness learning, which is addressed in an assembly- level tutoring system for 8-bit microcontroller units  (MCUs). Byte-wide memory organization in small MCUs allows data storage and accessing process in consideration of user?s agreement during the assembly code development process. Although endianness concept is of great value for engineers who are employing microcontrollers in their applications [2], traditional approaches to education of small MCUs [3, 4] fail to provide an endianness scheme for handling memory storage. The approach presented in this paper proposes the association of endianness concept with a regular challenge in 8-bit microcontroller education, that is, the assembly- level arithmetic techniques for numbers extending one- byte range.

The present effort is a part of an overall research on higher education, which is carried out at the Department of Communications, Informatics and Management, Epirus Educational Institute of Technology, Arta, Greece. Our lines of research are a concern of a revision of the traditional Computer Architecture course to Microcomputer Architecture [5-10]. This choice stems from the need of taking active role in the demands and technologies that are, nowadays, shaping computing discipline. Regarding the fact that students within computing curricula might become programmers of general-purpose computers or embedded systems in their prospective careers [11], our contributions rely on the enhanced role of a new challenging course at expense of the traditional Computer Architecture. Due to the technological/professional nature of the proposed course, one aspect of our research is in reference with innovative practicable examinations of issues regularly studied by theory [9]. This paper presents an unconventional perspective on endianness learning that is addressed to provide to the students a better understanding of the processor?s workings at the machine level, and help them in exploiting byte ordering for the optimum performance of a low-level system implementation. Following a set of application examples involving arithmetic operations, students have the opportunity to study the advanced     handling techniques of memory storage by means of a practicable approach.



II. BACKGROUND  Microcontrollers? technology is traditionally addressed to engineers of the electrical/electronic curriculum.

However, many reports on the migration of MCUs to allied engineering disciplines appear in the literature [12- 18]. Case studies on the education of biological and agricultural engineers [12, 13], mechanical engineers [14, 15], industrial engineers [16], chemical engineers [17] and computer engineers [18] are some of the abundant propositions that have been posed in the literature over the last decades. It is generally accepted that a different educational approach should be engaged when teaching complex computerized systems [19]. Students who practically cannot have an in-depth understanding of all major technologies involved in a computerized system should focus on a certain are of interest only.

Our lines of research have been focused on the education of software engineers, in an attempt to provide more flexibility and less specialization in graduates together with an increased capability for design and innovation [20]. The employment of a simplified embedded computer system (i.e. an 8-bit MCU) in the education of engineers with a background on software design issues was a concern of a reinforcing of the students? background on the hardware domain [5]. In consideration of the need for the incorporation of more content into engineering courses [21], our decisions relied on the encompassing of an 8-MCU into Computer Architecture class and therefore, a switching of the traditional course to Microcomputer Architecture. The present effort deals with a critical issue on computer architecture learning, i.e. the endianness concept, and promotes its study by means of a practicable approach using 8-bit MCUs. Since endianness concept is regularly missing in traditional approaches to education of small MCUs [3,4], this communication aims in the enhancement of the traditional tutoring methods. Regarding the widely employment of MCUs in various engineering disciplines [12-18], as well as the importance of endianness concept to engineers who are employing microcontrollers in their applications [2], the authors anticipate the present effort would provide valuable feedback to educators who address MCUs to other than electrical/electronic engineering students.



III. THE PROPOSED APPROACH  The proposed approach associates the study of endianness representation with a regular challenge in 8-bit microcontroller education, that is, the assembly-level arithmetic techniques for numbers extending one-byte (1B) range. The examples presented hereafter deal with arithmetic operations of unsigned numbers in double-word (i.e. 4B) size length, assigned to memory either in big or little-endian ordering. In order to provide a clear scheme  on endianness ordering for optimizing the performance of a low-level system implementation, number bytes are manipulated as being array elements in microcontroller?s random access memory (RAM). This particular technique promotes the advantages and disadvantages of byte ordering with reference to assembly code optimization, and provides to the students the opportunity to study in detail the microcontroller?s instructions set architecture (ISA), as well as the advanced handling techniques of memory storage. It is worth noting that, the proposed examples follow a sequence of lessons that are based on an interdisciplinary methodology for bridging the gap between low-level and high-level programming [8] and thus, students are already familiarized with indexing techniques for accessing array elements in RAM. The examples are in line with the MC68HC908GP32 [22] ISA and focus on arithmetic addition/subtraction, as well as multiplication/division by means of a shifting operation (i.e. multiply/divide by 2).

A. Addition/Subtraction Fig. 1 and 2 present the addition of two double-word  numbers in big-endian and little-endian mode respectively. Fig. 1a) and 2a) perform addition in a simplified process, while Fig. 1b) and 2b) manipulate data that are organized in array.

Fig. 1. Addition of double-word numbers in big-endian.

In both cases, addendum is assumed to be stored in memory locations 0x0040-0x0043, while adder is assumed to be stored in memory locations 0x0044- 0x0047. Addresses 0x0048-0x4B are reserved for the sum.

Regarding, for example, an addendum of 0x1234ABCD value, the number is stored in memory as follow: Big- endian: (0x0040=0x12, 0x0041=0x34, 0x0042=0xAB, 0x0043=0xCD); Little-endian: (0x0040=0xCD, 0x0041=0xAB, 0x0042=0x34, 0x0043=0x12). Due to the fact that addition initiates from the least significant byte, Fig. 1b) uses an iterative loop with a decrement counter, while Fig. 2b) uses an increment counter for accessing number bytes.

Fig. 2. Addition of double-word numbers in little-endian.

The algorithm for the addition is achieved in lines 5- 8 for big-endian mode (Fig. 1b), and in lines 5-12 for little-endian mode (Fig. 2b); while test expression of the loop is achieved in line 8 for the former case, and in lines 10-12 for the latter. At this point the students have the opportunity to compare the two kinds of endianness representation and reach to the result that, optimal implementation is achieved in big-endian mode because of the employment of the low-level compound instruction in  line 8 (DBNZ ? decrement index register low and branch if not zero). In addition, little-endian mode needs two more instructions (lines 5, 9) for a temporary storage and subsequent retrieval of the condition code register (CCR) to/from accumulator (TPA ? transfer processor status bytes to accumulator, TAP ? transfer accumulator to processor status bytes). In order to understand the need for these particular instructions, the students have to study the effect on CCR of the instructions used in test expression.

DBNZ instruction does not have an effect on CCR carry flag and thus, it does not affect addition procedure.

However, CMPX (compare index register low with memory) instruction affects carry flag (which is subsequently evaluated by instruction BNE ? branch if not equal) and thus, a temporary storage of the carry flag should be taken into account.

Following the example of addition, students could straightforwardly revise addition to subtraction by switching ADC (add with carry) instruction to SBC (subtract with carry). Thus, the students have the opportunity to study the double service of carry flag, which is used as carry during addition and borrow during subtraction. Those examples are addressed to provide to the students a deeper insight into the inner workings of the central processing unit (CPU), and help them enhance their programming skills at machine level as well. It is worth noting that, association of the endianness concept to low-level arithmetic operations provides a great opportunity on code optimization practicing. Hereafter, we give another example regarding a multiplication and division by 2.

Fig. 3. Multiplication of a double-word number in big-endian.

B. Multiplication/Division Fig. 3 and 4 present the multiplication (by 2) of a  double-word number in big-endian and little-endian mode respectively. Fig. 3a) and 4a) perform multiplication in a simplified process, while Fig. 3b) and 4b) manipulate data that are organized in array.

In both cases, number is assumed to be stored in memory locations 0x0040-0x0043, while result is assumed to be stored in the same memory locations. Due     to the fact that shift-left processes initiate from the least significant byte, Fig. 3b) uses an iterative loop with a decrement counter, while Fig. 4b) uses an increment counter for accessing number bytes. The algorithm for the multiplication is achieved in lines 5-6 for big-endian mode (Fig. 3b), and in lines 5-10 for little-endian mode (Fig.

4b). Test expression of the loop is achieved in line 6 for the former case, and in lines 8-10 for the latter.

Fig. 4. Multiplication of a double-word number in little-endian.

Accordingly, optimal implementation is achieved in big-endian mode because of the employment of the DBNZ instruction in line 6, while little-endian mode needs the two extra instructions (lines 5, 7) for the temporary storage and subsequent retrieval of the condition code register (CCR) to/from accumulator.

Regarding the division operation, shift-right processes initiate from the most significant byte and thus, optimal implementation is achieved in little-endian mode. Figure 5 and 6 present the division (by 2) of a double-word number in big-endian and little-endian mode respectively.

Fig. 5a) and 6a) perform division in a simplified process, while Fig. 5b) and 6b) manipulate data that are organized in array. Moreover, ROL (rotate left through carry) instruction is switched to ROR (rotate right through carry).

This particular example helps students clarify that big- endian mode does not consist an ideal byte ordering scheme. Therefore, students have to decide on the selection of the suitable representation mode according to the arithmetic operation being implemented. It is worth noting that the proposed addition/subtraction and multiplication/division examples are designed to fit within a two-hour lesson, while their assessment (presented hereafter) reveal the positive contribution on students learning, in consideration of a clear scheme on endianness term (by means of a practicable approach).

Fig. 5. Division of a double-word number in big-endian.

Fig. 6. Division of a double-word number in little-endian.



IV. ASSESSMENT  Seventeen students participated in an anonymous questionnaire regarding the assessment of the proposed approach. The questionnaire was administrative to each student at the end of this particular lesson. Table 1 summarizes the results of the assessment survey, where scores (1) to (5) stand for ?at all?, ?shortly?, ?enough?, ?much? and ?very much? respectively. (AV) stands for average.

The first question explores the effectiveness of the proposed practicable approach on endianness learning, while the next two explore the value of the proposed approach on the obtaining of its educational benefits. The high score in the first question confirms that a practicable perspective on endianness learning is more appropriate than a theoretical one. Positive results of the two subsequent questions find students agreed with the effectiveness of the proposed approach on the     understanding of the a) advanced handling techniques of memory storage and b) exploiting of endianness representation towards to an optimum performance of a low-level system implementation. The higher score in the second question is fair enough, since students have already been introduced to more sophisticated methods for code optimization techniques, by means of macro- instructions [8, 9]. What is even more promising is the fact that none of the students believes the current method helped in the conception of endianness learning at all.

Table I ASSESSMENT SURVEY  Scores Questions  (5) (4) (3) (2) (1) (AV) Do you believe that a practicable approach on big-endian & little- endian representation provides a better understanding of these terms compared to a theoretical approach?

6 6 4 1 0 4  Did the lesson help understand the advanced handling techniques of memory storage for an 8-bit microcontroller?

3 5 7 2 0 3.53  Did the lesson help you understand how to exploit endianness modes for an optimum performance of a low- level system implementation?

1 4 10 2 0 3.24

V. CONCLUSION  This paper has presented an unconventional approach on endianness learning based on assembly-level programming for 8-bit microcontrollers. The proposed approach relied on the association of endianness representation with the assembly-level arithmetic techniques for numbers extending one-byte range, as a supporting scheme towards to a better understanding of the a) advanced handling techniques of memory storage, b) exploiting of byte ordering formats for the optimum performance of a low-level system implementation. The proposed approach (which is a part of an overall research project regarding the revision of the traditional Computer Architecture course to Microcomputer Architecture) addressed to enhance traditional tutoring methods on small MCUs.

