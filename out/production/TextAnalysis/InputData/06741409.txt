A Continuous Reverse Skyline Query Processing   for Moving Objects

Abstract?Many studies on reverse skyline query processing have been done for various services. The existing reverse skyline query processing methods are based on dynamic skylines. There are no reverse skyline query processing algorithms based on metric spaces for location-based services. The existing methods for processing a reverse skyline query have the limitation of service domains and require the high costs of computation to provide various location-based services. In this paper, we propose a new reverse skyline query processing method that efficiently processes a query over the moving objects. In addition, the proposed method processes a continuous reverse skyline query efficiently. In order to show the superiority of the proposed method, we compare it with the previous reverse skyline query processing method in various environments. As a result, the proposed method achieves better performance than the existing method.

Keywords? Continuous query, Reverse skyline, Moving object, Location-based services

I.  INTRODUCTION With the development of mobile devices such as smart  phone and tablet, various applications for the mobile devices have been released. In this situation, one of the most important services for the mobile devices is Location-Based Services (LBS) [1-2]. LBS provides the useful information based on the locations of mobile users. To provide LBS, various query processing techniques over moving object environments have been widely studied [3-5]. Many studies for skyline queries which consider multi-attribute values have been done [6-7].

The result of a skyline query is a set of objects in the database whose attribute vectors are not dominated by any other objects.

With the development of various skyline query processing techniques, it becomes possible to provide various services considering multi-attribute values such as the cheapest and nearest restaurant. As the variant of the skyline query  processing, a reverse skyline query has been studied [8-11].

The reverse skyline query is a query type returning a set of objects that includes the query object as the result of the skyline query. For example, the restaurant is able to retrieve the customers that consider it to be the cheapest and nearest one by the reverse skyline query. We can also provide more useful services through the reverse skyline query. In recent, various reverse skyline query processing methods have been studied.

But, they are based on dynamic skyline [12]. The traditional skyline to retrieve skyline points usually assumes static data objects in the database. However, the dynamic skyline focuses on skyline queries with dynamic attributes. The dynamic skyline is the specific skyline to process a similar query. Thus, the existing reverse skyline methods have the limitation of service domains and require the high costs of computation to provide various location-based services.

Recently, we proposed an efficient method for processing the reverse skyline queries [12]. This method processes a reverse skyline query using the spatial grid indexing method [13]. However, it needs to process the final verification.

Because the method proposed in [12] implements the final verification, the method proposed in [12] accesses more cells in a grid index to process the reverse skyline. In this paper, we propose a new reverse skyline query processing method that efficiently processes a query over moving objects. In addition, the proposed method also processes continuous reverse skyline queries efficiently. The proposed method makes the verification range to guarantee the result of a reverse skyline query. Therefore, the proposed method does not need to implement final verification when the new objects appear or the moving objects. In order to show the superiority of the proposed method, we compare it with the previous reverse skyline query processing method in various environments. As a result, the proposed method achieves better performance than the existing method.

The rest of this paper is organized as follows. Section 2 reviews related works. Section 3 illustrates our proposed method. Section 4 presents the performance evaluation results of our proposed method. Finally, Section 5 concludes this paper.



II. RELATED WORK  A. The Skyline Query A skyline query that has been widely studied is a specific  example of multi-attribute queries. The result of a skyline query is a set of objects in the database whose attribute values are not dominated by any other objects. For example, if a customer wants to find the cheapest and nearest restaurant, the location of the customer is a query point in the space and the restaurants are the target objects of the query. The attributes of the objects are the price and the distance.

Figure 1 shows how to process a skyline query. As shown in Figure 1(a), there are certain objects, p1, p2, p3, p4, p5 and p6.

In this case there are no objects satisfying the customer?s requirements. However, the customer will want some restaurants whose conditions are close to their expectations. In other words, the customer does not consider the objects which have a higher price and greater distance than another object.

After removing the objects dominated by other objects on all dimensions, the remaining objects are the result of the query. p3 and p4 are removed, since they are dominated by other objects.

That is, p3 is dominated by p2, p4 and p5, and p4 is dominated by p5. The result of the query is shown in Figure 1(b).

price  distance  p1 p3  p2  p4  p5 p6    price  distance  p1 p3  p2  p4  p5 p6   (a) Objects on logical space  with price and distance (b) Result of skyline query  Fig. 1. Example of skyline query processing  B. The Reverse Skyline Query The reverse skyline query is a query type returning a set of  objects that includes the query object as the result of the skyline query. For example, when a restaurant wants to advertise a bargain day, the advertisement is more impressive to customers who think the restaurant is cheaper and closer than other restaurants. In this case, the restaurant is a query object issuing a reverse skyline query and the customers are the target objects for the query. Figure 2 shows the skyline of target objects. Figure 2(a) shows the skyline of c1. c1 is the reverse skyline. In this case, query q is the skyline. Figure 2(b) shows the skyline of c2. c2 is not the reverse skyline. In this case, query q is not the skyline.

price  distancec1  s1 s3s2  s4  q s6    price  distancec2  s1 q  s2  s4  s5 s6   (a) skyline of reverse skyline c1 (b) skyline of non-reverse skyline c2  Fig. 2. The skyline of target objects  The naive method to process a reverse skyline query is Greedy Reverse Skyline (GRSL) [8], which finds target objects including the query object as a result of a skyline query for each target object. However, the method requires a lot of computation time to process the reverse skyline query.

Recently, various reverse skyline query processing methods have been proposed. E. Dellis proposed a reverse skyline query processing method using the Branch and Bound Skyline (BBS) algorithm, and Reverse Skyline Computation Using Skyline Approximations (RSSA) to reduce the quantity of a range query [8]. X. Lian proposed Reverse Skyline Search over Uncertain Databases [9]. L. Zhu proposed Reverse Skyline on Data Stream [10].

As the variant of a skyline query, a reverse skyline query has been studied [6-7]. However, the existing methods for processing it are based on dynamic skyline [14]. The traditional skyline to retrieve skyline points usually assumes static data objects in the database. However, the dynamic skyline focuses on skyline queries with dynamic attributes. The dynamic skyline is the specific skyline to process a similar query. Thus, the existing reverse skyline methods have the limitation of service domains and require the high costs of computation to provide various location-based services. Therefore, we proposed an efficient method for processing reverse skyline queries [12]. This method processes a reverse skyline query using the spatial grid indexing method. This method prunes the objects that do not affect a query using skyline dominant relationship during the reverse skyline query processing.

Figure 3 shows the algorithm for processing the reverse skyline query. Figure 3(a) shows all objects in the spatial space. In Figure 3(a), the values in parentheses are the static attributes and q denotes the query object. First, this method searches for the same type of object dominating q without the distance attribute in the order of their proximity to q. o6 is the first object found by the query algorithm but o6 does not dominate q.

Therefore, the algorithm continues to find the next nearest object until an object dominating q appears. Second, if an object dominating q is found, we draw the bisector between the object and q. Figure 3(b) shows that o2 is the object dominating q and the bisector between o2 and q is drawn. All objects located outside the bisector do not contain q as the skyline result. It is because the objects are always closer to o2 than q and even o2 dominates q in static attributes. q is dominated by o2 on the skyline of both c1 and c2. These processes are repeated until all objects inside the bisector are checked.

During the processes, we cache different types of objects located inside the bisector and search for objects dominating q as the candidates of the result. In this case, c3 and c5 are the     candidate objects of the query. Finally, we refine the candidate objects by determining whether or not the objects dominate q and locate closer against q as shown in Figure 3(d). Figure 3(d) shows the final verification. As a result, c5 is included in the result of the reverse skyline query.

(a) objects in spatial space (b) searching the objects dominating q    (c) checking all objects inside the bisector (d) the final verification  Fig. 3. Processing a reverse skyline query

III. THE PROPOSED METHOD The method proposed in [12] processes a reverse skyline  query efficiently. This method processes a reverse skyline query using the spatial grid indexing. However, this method needs to process the final verification when the new objects appear or the moving objects move. Since this method performs the final verification, it accesses more cells to process the reverse skyline. Therefore, this method is not efficient to process a continuous reverse skyline query. In this paper, we propose a new method that efficiently processes a reverse skyline query over the moving objects. In addition, the proposed method also processes a continuous reverse skyline query efficiently. The proposed method makes the verification range to guarantee the result of the reverse skyline query.

Therefore, the proposed method does not need to perform the final verification when the new objects appear or the moving objects move.

A. The Reverse Skyline Processing Method The method proposed in [12] does not guarantee the reverse  skyline result. Therefore, it needs to implement the final verification. To implement the final verification, this method performs a range query to refine the candidate objects by determining whether the objects dominate q and are closer than q or not. In this paper, we propose a new method that efficiently processes a reverse skyline query over the moving objects. The proposed reverse skyline query processing method makes a verification range to guarantee the result of the reverse skyline query. Therefore, the proposed method does not need to implement the final verification when the new objects appear or the moving objects move. Since the proposed method does not need to implement the final verification, it is an efficient method to process the continuous reverse skyline.

Figure 4 shows the initial step of the proposed reverse skyline query processing method. Figure 4(a) shows all objects in the space. First, the proposed method searches for the same type of objects dominating q without considering the distance attribute in the order of their proximity to q. o6 is the first object found by the query algorithm but o6 does not dominate q.

Therefore, the algorithm continues to find the next nearest object until an object dominating q appears. Second, if an object dominating q is found, we draw the bisector between the object and q as shown in Figure 4(a). Figure 4(a) shows that o2 is the object dominating q and the bisector between o2 and q is drawn. All objects located outside the bisector do not contain q as the skyline result. It is because the objects are always closer to o2 than q and even o2 dominates q for static attributes. q is dominated by o2 on the skyline of both c1 and c2. If there is the intersection point during processing the reverse skyline query, the proposed method makes the verification range as shown in Figure 4(b). Through the verification range, the proposed method can prune the objects that do not affect the query.

These processes are repeated until all objects inside the verification range are checked as shown in Figure 4(c). As a result, c5 is included in the result of the reverse skyline query as shown in Figure 4(d).

Figure 5 shows the proposed reverse skyline query processing algorithm. The input is grid index [13] G and query object q. The output is objects that include the query object as the result of the skyline query. The proposed method searches for the same type of objects dominating q without considering the distance attribute in the order of their proximity to q. If an object dominating q is found, we draw the bisector between the object and q (Line 6~14). If there is the intersection point during processing the reverse skyline query, the proposed method makes the verification range (Line 8~11). The proposed method can prune the objects that do not affect the query by the verification range. These processes are repeated until all objects inside the verification range are checked.

Finally, the proposed method returns the RESULT_SET.

(a) searching the objects dominating q (b) making the verification range    (c) checking all objects inside the verification range (d) making the reverse skyline range  Fig. 4.  The proposed reverse skyline query processing method     ComputeReverseSkyline(G, q)  input : G : Grid index, q : query object  output : RESULT_SET  : objects that include the query object as the result of the skyline  query.

00   {  01      Insert q from Query Table  02      c = the cell including q on G  03      Insert c into H  04      While (H is not empty) {  05         s = get an same type object from H  // H is managed like CPM 06         If (q is dominated by s) {  07            Draw a bisector on a segment between q and s  08            If ( there is the intersection point between bisectors ) {  09               Draw the verification range  10               Remove all objects and cells outside the verification range from H  11            }  12            Remove objects outside the bisectors of q from RESULT_SET  13         }  14      }  15      return RESULT_SET  16   }  Fig. 5. The reverse skyline query processing algorithm  B. The Continuous Reverse Skyline Processing Method The proposed method processes a continuous reverse  skyline query efficiently in moving object environments. The method proposed in [12] performs final verification when the new objects appear or the moving objects move. Crange is a cost of checking whether the moving object is a result of the query or not. Crefine is a cost of final verification of objects included in the reverse skyline range. In this case, the cost of the continuous reverse skyline query processing using the method proposed in [12] during n times is (n * (Crange + Crefine)). But the query processing cost using the proposed method is only (n * Crange). The proposed method achieves about (n * Crefine) better performance than the method proposed in [12].

Figure 6 shows the index structure to process a continuous query. The query object has the query information such as < qid, coordinates, reference_object, result_set >. The coordinates is the location of the query. The reference_object is an object to make a reverse skyline range of the query. The result_set is the result of the reverse skyline query. The object has the object information such as < oid, coordinates, type, values >. The values are the attribute values of an object such as price and reputation. The type is a condition of the object whether it has the same type or different type against q. To process the continuous reverse skyline query, each cell has an object list and a query list.

Fig. 6. Spatial index structure to process the continuous reverse skyline  Figure 7 shows the proposed continuous reverse skyline query processing algorithm. The input is a grid index G and moving object o. When o moves to the current location from the previous location, the proposed method loads all query lists of cells including the previous location and the current location (Line 3). Next, the proposed method checks the conditions of q included in RESULT_SET at the previous and current locations (Line 4~5). And then the proposed method checks the condition of o included in the reverse skyline range of the query. The proposed method computes the reverse skyline range using reference_object. And the proposed method computes the condition of o included in the reverse skyline range of the query using coordinates. Finally, the proposed method compares s1 with s2. If s1 is not the same against s2, the proposed method updates the result of the reverse skyline query (Line 6~12).

ComputeContinuousReverseSkyline(G, o)  input : G : Grid index, o : Moving object  00   {  01      o : move from the previous location to the  current location  02      qlist : all query lists of cells including previous location and current location  03      While (qlist is not empty) {  04         q = the query included in qlist  04         s1 = condition of q included in RESULT_SET at the previous location  05         s2 = condition of q included in RESULT_SET at the current location  06         If ( s1 != s2 ) {  07            If ( s1 is included in the reverse skyline range of q)  08               Insert o into RESULT_SET of q  09             else  10              Delete o at RESULT_SET of q  11            }  12         }  13      }  14   }  Fig. 7. The continuous reverse skyline query processing algorithm

IV. PERFORMANCE EVALUATION All experiments have been performed on a Windows XP  operating system with a 3.0 GHz CPU and 2 GB main memory.

In each experiment, we performed 1,000 reverse skyline queries in the particular data set that has 10,000 objects generated in 10,000?10,000 space and 20?20 cells. We generate all attributes by random functions. We experimentally evaluate the efficiency of the proposed method for the reverse     skyline computation. We compare the proposed method with the existing method [12] by various experiments.

TABLE I.  EVALUATION PARAMETERS  Parameters Values  Number of objects 10,000  Number of cells 20? 20  Number of queries 1,000  Size of space 10,000 x 10,000    Figure 8 shows the experimental results by varying the attribute values of a query from 1,000 to 10,000. As a result, the proposed method achieves better performance than the existing method in the small attribute value section. If the attribute value is small, the result of the reverse skyline query is big. Therefore, the existing method needs to access more cells to process the reverse skyline query. However, if the attribute value increases, the result of the reverse skyline query is few. As a result, the query processing cost of the proposed method is similar to that of the existing method.

Existing method Proposed method  Attribute value of queries  N um  be r o  f c el  l a cc  es se  s    Fig. 8. Performance comparison according to the attribute value of a query  Figure 9 shows the experimental results by varying the number of cells from 5?5 to 50?50. As a result, the proposed method achieves better performance than the existing method.

If the number of cells increases, there are many objects in the each cell. Therefore, the reverse skyline processing methods access more cells to process the reverse skyline query.

Existing method Proposed method  Number of cells  N um  be r o  f c el  l a cc  es se  s    Fig. 9. Performance comparison according to the number of cells  We experimentally evaluate the efficiency of the proposed method for the continuous reverse skyline computation. Figure 10 shows the experimental results of continuous reverse skyline queries by varying the number of moving objects from 100 to 1,000. Since the existing method performs the final verification when the new objects appear or the moving objects move, the existing method accesses more cells to process the continuous reverse skyline query. As a result, the proposed method achieves about 500% better performance than the existing method to process the continuous reverse skyline queries when the number of moving objects is 1,000.

Existing method Proposed method  Number of moving objects  N um  be r o  f c el  l a cc  es se  s    Fig. 10. Performance comparison according to the number of moving objects

V. CONCLUSION In this paper, we proposed a new efficient reverse skyline  query processing method over the moving objects. In addition, the proposed method also processes a continuous reverse skyline query efficiently. In order to show the superiority of the proposed method, we compared it with the previous reverse skyline query processing method in various environments. As a result, the proposed method achieved much better performance than the existing method.

