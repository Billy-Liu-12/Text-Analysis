An Efficient Scheme for Continuous Skyline Query  Processing over Dynamic Data Set

Abstract? Interests in skyline query processing have significantly increased since it can be used in many applications, such as multi-criteria decision making, data mining, and user preference queries. In this paper, we propose continuous skyline queries over dynamic data set. Since the dynamic data set constantly changes as time passes, continuous skyline queries processing over dynamic data set becomes ever more complicated compared with static data set. We propose a multiple layer grids scheme for efficiently processing continuous skyline queries over skewed data set. The proposed scheme divides the work space into multiple layer grids and creates the skyline influence regions of each layer grid based on the existing data set. The continuous skyline queries are handled only when the dynamic data points update within the skyline influence regions of each layer grid.

Since the multiple layer grids are divided dynamically, it is feasible even for the highly skewed data set. Experiments based on various synthetic data sets and real data sets show that our proposed scheme outperforms the existing schemes.

Keywords? Skyline query, Continuous skyline query, Dynamic data set, Skewed data set.



I. INTRODUCTION In recent years, a skyline query as an important operator in  databases for multi-preference analysis and decision making has received much attention due to its wide application backgrounds. The skyline query has been defined as retrieving a set of points which are not dominated by any other points from a multi-dimensional data set. Given a multi-attribute dataset P containing objects {P1, P2 ? Pn}, the skyline operator returns all objects Pi such that Pi is not dominated by another object Pj in each attribute.

Some existing works on the skyline query have concentrated on its efficient evaluation in the static data set [3], [6], [7], [8], [11], [13], [19], [23]. However, in most of the real applications, the data set is dynamic, i.e. the data set changes constantly as time passes, such as the dynamic data set or data streams. A typical application of continuous skyline query processing over dynamic data is the online stock trading.

Traders are interested not only in the trading price of a stock, but also the trading volume at a price or the others. And every trading may affect the last trading price, the volume of trading, and others. Since trades are continuing and traders may only be interested in trades with the latest information, the results can be obtained by constantly execute the skyline queries. For such  cases, directly applying existing techniques would incur inconceivable large overhead. Efficient continuously considered algorithms are needed.

Recently, several methods were proposed for continuous skyline computation on sliding window data streams [16], [24] and moving objects [9], [15]. The continuous skyline computation on sliding window streams assumes that the lifespan of the data must be pre-defined and the first-in first-out characteristics must be satisfied. However, the lifespan of data set in most applications are indeterminate. The continuous skyline query (CSQ) method for moving objects assumes that each object has only one single dynamic attribute (the location of the moving object) and one or more static attributes, which lacks generalization.

In this paper, we focus on processing continuous skyline queries over dynamic data set without any constraints. The number of the dynamic attributes of each data tuple is arbitrary.

All of dynamic data set is processed in a first-in first-service (FIFS) manner. Although a grid index based algorithm for continuous skyline computation (GICSC) [25], [26] has been proposed to handle these issues, it is not suitable for highly skewed dynamic data set. We propose a multiple layer grids scheme for efficiently processing continuous skyline queries over skewed dynamic data set. The proposed scheme employs multiple layer grids to manage the highly dynamic data set and maintains skyline influence region of each layer grid according to the dynamic skyline data points. For highly skewed data set, the high density area of the data space can be handled by creating multiple layer grids upon the base grid layer. If data changes the skyline queries are handled only when the changed data points within skyline influence region of each layer grid.

The skyline influence region is updated according to the change of relevant data points. By doing it, the cell size of high density data area is assigned fine and the others is coarse. Since the skyline influence region of high density data area is precise, more irrelevant data points can be filtered out. Especially, for the highly skewed dynamic data set, the advantage is very obvious.

The remainder of this paper is organized as follows.

Related work is covered in section 2. We present our scheme in section 3. Experiment evaluations are presented in section 4, and finally, section 5 contains our conclusions and future works.



II. RELATED WORK In [14], Kung et al. first proposed the skyline algorithm.

Borzsonyi et al. [3] who first introduced the skyline operation in database systems and proposed two solutions based on Block Nested Loop (BNL) and Divide and Conquer (D&C).

DC divides the data set into several partitions in memory. The skylines in each partition are computed separately and then merged to produce the final skyline. BNL adopts a buffer to store skyline data. Each data tuple in the database is compared with the other data and is stored in the buffer if it is not dominated. The sort-first-skyline (SFS) as the variation of BNL was proposed by Chomicki et al. in [7]. It sorts the data set according to a predefined preference function, and then the skyline can be computed from the sorted list. All of the methods in [3], [7] are not suitable for large or dynamic data set since the skyline result cannot be reported until the entire data set is processed. The nearest neighbor (NN) algorithm [13] indexes the data set with R-tree. NN performs a nearest neighbor query [21] to find the skyline results. The skyline is evaluated by accessing the R-tree, which has not to process the entire data set. In [19] and [20], an improved algorithm named branch and bound skyline (BBS) was proposed. BBS is also based on nearest neighbors search but it only accesses nodes that contain skyline points. Therefore, BBS is more efficient than NN. However, the R-tree based methods are not suitable for processing dynamic data set as the update of the R-tree is high expensive.

Recently, some distributed and paralleled approaches were proposed to compute skyline over large distributed data sets. [2] and [17] addressed skyline operations over distributed web sources. They consider that the data set is vertically partitioned, i.e. each server keeps only one attribute of the data set. In [27], the subspace skyline processing over a super-peer network was studied. Different from [2] and [17], each peer holds its data in an autonomous manner in [27]. The subspace skylines are computed at each peer and merged at the super peer. The global skyline is computed by gathering the skyline data from super peers. Wang et al. [28] developed a skyline space partitioning (SSP) approach to compute the skyline on a tree- structured P2P platform BATON [10]. Akrivi et al. proposed an angle-based space partitioning scheme for efficient parallel skyline computation in [1]. It focuses on how to partition the dataset to the distributed servers. And then, the skyline queries are executed simultaneously on all servers. In order to further improve the computation time, K?hler et al. [12] proposed parallel skyline processing using hyperplane projections. This approach used hyperplane projections to obtain useful partitions of the data set. The partitions not only ensure small local skyline sets but enable efficient merging of results as well.

However, the space partitioning schemes [28], [1] and [12] are not suitable for processing the highly dynamic data set since the data change will result in the change of partitions. Cui et al.

[4], [5] studied skyline queries in a distributed environment.

They used the Minimum Bounding Regions (MBRs) to summarize the data stored at each server. According to the MBRs of all servers, incomparable groups are assigned. The skyline is computed within each group using specific plans.

The methods described above did not provide the operations that reflect the data updates. None of them are  suitable for skyline computation over highly dynamic datasets.

Several methods were proposed for continuous skyline computation on sliding window data streams and moving objects where the data set is update constantly. In [16], Lin et al.

proposed n-of-N skyline query processing scheme against the most recent N elements to support on-line computation against sliding windows over a rapid data stream. This method indexes all data in an R-tree and uses an interval tree to determine when a point is no longer amongst the most recent N points.

However, it has to check every data to obtain the skyline result over a data stream which is inefficient. Tao et al. proposed maintaining the sliding window skylines on data streams in [24]. Two algorithms called Lazy and Eager were proposed for continuously monitoring the incoming data and maintaining the skyline incrementally. This approach utilizes the properties of stream skyline to expunge the non-promising data from the system as early as possible. Since some non-promising data can be expunged before processing, this method is more efficient than n-of-N skyline. Morse et al. proposed a scalable LookOut algorithm for updating the continuous time-interval skyline efficiently over a data stream in [18]. However, for sliding window streams based continuous skyline computation methods [16], [24] and [18], they assume that the data must have pre-defined arrival and expiration time, and the first-in first-out characteristics must be satisfied. In this paper, we consider that the dynamic data sets change randomly and the lifespan of each data object is indeterministic in advance.

Huang et al. has given a method to compute continuous skyline for moving objects in [9]. It addresses the problems of continuous skyline query processing, where the skyline query point is a moving object and the skyline changes continuously with the movement of a query point. The continuous skyline query method for moving objects assumes that each object has only one single dynamic attribute (the location of the moving object) and one or more static attributes, which lacks generalization. Li T. et al. [25], [26] proposed the grid index based algorithm (GICSC) for continuous skyline computation over highly dynamic datasets without any constraints. It employs a grid structure to manage the entire data set and creates a skyline influence region to filter out the unnecessary skyline processing over the dynamic data sets. Since the processing of the non-promising data can be expunged, this method is efficient for continuous skyline computation over the dynamic data set. However, when the dynamic data set is skewed, the cell size of the grid is difficult to be assigned. In these cases, the schemes described in [25], [26] will degrade the performance significantly. Therefore, a multiple layer grids scheme for efficiently processing continuous skyline queries over dynamically skewed data set is proposed in this paper.



III. THE PROPOSED CONTINUOUS SKYLINE QUERY PROCESSING SCHEME  A. Motivations We present the processing of GICSC algorithm on the  uniform data set shown in Figure 1 (a). The dataset is managed by a grid structure. The grid structure covers the entire data space and it is divided into equal-sized cells at each dimension.

The skyline influence region is the cells which are not dominated by the existing skyline data points, as shown in Figure 1 (a), the shaded region. When data points change, the     skyline query is re-computed only when the changed data points within the skyline influence region. When existing data points expire, the skyline query is handled only when the data points are skyline points.

However, when data set is skewed, as shown in Figure 1 (b), the cell size of GICSC scheme is difficult to be assigned, which significantly impacts performance. Since a smaller cell size can decrease the number of the data points within each cell and reduces the total area of the skyline influence region, the performance is improved by filtering out more irrelevant data points. However, for skewed data set, a large number of additional trashy cells are generated. Processing these cells will cause large computation costs and memory requirements, which is inefficient. In contrast, a bigger cell size cannot incarnate well the advantage of the grid scheme. For the large data set, a large number of data points will be contained within one cell. The high frequency change of the irrelevant data points cannot be filtered out by the skyline influence region.

Especially, in extreme cases, the work space has only one cell, then, the GICSC scheme is similar to the BNL scheme. The BNL scheme is only suitable for static skyline queries and the data set is not large, which is certified in [25], [26], the basic continuous skyline computation algorithm. Therefore, in this paper, our objective is finding a new approach which can well decide the cell size for skewed dynamic data set.

(a) The uniform data  (b) The skewed data  Figure 1. Two data sets for skyline query processing.

If the data set is composed of tuples with d-dimensions, we present to adopt a d-dimensional grid with equal-sized cells to manage the data set. Given the attributes value of an object, it is easy to find the cell that it belongs to. When the number of data points within one cell grows too large, it can be handled by creating a second layer grid. According to the data distributions, three or more layer grids can be generated.

Therefore, the cells for high density data area of data space are fine, and the rest are coarse. The skyline influence regions of each layer grid are created, since the data points fall outside the skyline influence region are dominated by the existing skyline data points that cannot be skyline, we present that the skyline query is only re-computed when the dynamic data changes in the skyline influence region of each layer grid. As time passes, the cell with low density can become high data density and vice versa. The multiple layer grids structure is variable; the multiple layer grids are revoked when the high data density area of the data space becomes low data density.

Figure 2 shows an example of the multiple layer grids scheme. In order to easily explain the proposed scheme, we assume that the dimension of the dataset and the layers of the grid are two in the rest of this paper. The high data density cells (e.g. the dark gray cells) are handled by creating an upper layer grid. The skyline influence regions of the first and second layer grid are evaluated. Therefore, the data points within the skyline influence region of the first layer grid but outside the skyline influence region of the second layer grid can be filter out for processing.

Figure 2. An example of multiple layer grids.

B. Structures and Algorithms of the Proposed Method Figure 3 shows the data structure of the proposed method  that is composed of skyline list (SL), object list (OL), and work space grid such as the first layer grid and the second layer grid.

For a 2-dimensional data set, a tuple <OID, x, y> represents an object, where ?OID? is a unique number created by a hash function; x, y represent the values of two attributes. OL stores the entire data set. SL is composed of the skyline data points among entire data. The work space grid is composed of cells (the cells of the 1st layer grid) and extended cells (the cells of the 2nd layer grid). In terms of the data distribution three or more layer grids can be created.

x axis  y axis  C(0,0)  x axis  y axis  C(0,0)  Large data within few cells  x axis  y axis  C(0,0)  x axis  y axis  x axis  y axis     Figure 3. The data structure for the proposed method.

Algorithm : SL_Init  Input: initial dataset, t  Output: SL (skyline list), IR (skyline influence region)  Description: 1. set SL=NULL; Queue1=NULL; int n = t; // t is the threshold value  2. let C1(x, y) = C1(0, 0); C1(x,y)  represents the cell of the left-bottom corner of the grid;  3. insert C1(0, 0) into Queue1;  4. while (Queue1!=NULL) do 5.   remove C1(x, y) from Queue1;  6.   if 0<the number of the data points of C1(x, y)<t then 7.      adopt BNL to compute skyline, update SL;  8.      if C1(x, y+1) or C1(x+1, y) is not extended, and is not strictly dominated by the skyline data points, and (x+1) or (y+1)<Max(x/y), then  9.         insert C1(x, y+1) or C1(x+1, y) into Queue1, set C1(x, y) as skyline influence region;  10.  else if  the number of the date point of C1(x, y)>n then  11.       create a 2nd layer grid base on C1(x, y), and the 2nd layer grid is processed in the same way as the 1st layer grid (line 1~12);  12. end while  Figure 4. The initialization phase of the proposed method.

The main procedure of the proposed method is composed of the initialization phase and the maintenance phase. The initialization module is responsible for computing the skyline influence region and skyline set from the given initial static data set. The pseudo code of the initialization phase is shown in Figure 4. As shown in line 3, it starts from inserting the C1(0,0) cell (the cell of the left-bottom corner of the grid) into the queue1. When the cell C1(x,y) is popped from the queue1, its upper cell C1(x,y+1) and right cell C1(x+1,y) are appended to the tail of the queue1 if they satisfy the extension condition as shown in line 8. The extension condition is that the cell has not been extended and is not strictly dominated by the existing skyline data points. The skyline influence region and skyline data are verified as the cells are processed. The skyline data within the cell C1(x,y) is evaluated by the BNL scheme, as shown in line 7. The cell C1(x,y) is set to the skyline influence  region if it is not dominated by the existing skyline data. Notice that when the number of data points within C1(x,y) is greater than the predefined threshold value t, C1(x,y) is converted to a second layer grid, and the second layer grid is handled in the same manner as the first layer grid. The SL_Init algorithm terminates when the queue1 becomes empty.

After obtaining the initial skyline set and the skyline influence regions, the skyline and skyline influence regions in the continuous case may change according to new data points arrive or existing data points expire. In order to save space, the algorithms for handling new data arriving and existing data expiring are omitted here.



IV. PERFORMANCE EVALUATION In this section, we compare GICSC scheme with our  proposed method through various experiments. We conducted our experiments on a desktop PC running on Windows XP professional. The PC has a Pentium IV 3.20GHz CPU and 1GB memory. All of the experiments were coded in Java. The experimental results based on synthetic data sets and real data set are presented. The three synthetic data sets, correlated, anti- correlated and independent are generated according to [3]. We select the batting information of the hustle score of Lahman?s baseball database from 1871 to 2009 as the real data set. In this data set, there are 92706 instances, and the information of each baseball player is dynamic after each game.

Figure 5. Effect of the various skewed data rates.

In the first experiment, we compare GICSC with the proposed method in terms of the diverse skew ratios and data size. We utilize the anti-correlated data type, where the data size is 100000 and the number of dimensions is 2. The distribution of skewed data indicates the percentage that the data distribution region occupies in the full data area. The two methods are examined in terms of execution times when the percentage varies from 65% to 10%. Figure 5 illustrates the execution times of the two methods. The skew data within full data set is varied from 10% to 100%. The results show that the execution time is increased when the number of skew data of full data set increases. The proposed method is obviously more efficient than GICSC when the whole data are distributed in less than 25% of the entire data area. For less skewed data, the difference between GICSC and our proposed method is  S1 S2 S3 ? Sn  Work Space Grid  SL (Skyline List)  OL (Object List)  OID Data O1 X1,Y1 O2 X2,Y2 O3 X3,Y3 ? ? On Xn,Yn  2nd Layer Grid  1st Layer Grid (0,0)             10% 30% 50% 100%  Ex ec  u ti o n t  im e  (m s)  The scale of skewed data within full dataset  GICSC-65% The proposed method-65% GICSC-50% The proposed method-50% GICSC-25% The proposed method-25%     inconspicuous. To save the space, without specially pointing out, we present only the performance evaluation results of the synthetic data set that is distributed in 25% of the entire data area and occupies full data set.

(a) Synthetic data set  (b) Real data set  Figure 6. Execution times with respect to the size of data.

We next compare GICSC with the proposed method in different data types, anti (anti-correlated data set), cor (correlated data set), indep (independent data set) and the real data. This experiment examines the performance of the schemes by varying the number of synthetic data from 1K to 250K and real data from 10000 to 92706. We set the number of dimension is 2. Figure 6 (a) shows the results for the execution time of the skyline queries with respect to the synthetic datasets.

All of them achieve nearly similar performance when the number of data is 10k or less. This is because when the data size is small, the number of data within each cell is not large and the multiple layer grids are not generated. When the data size is 10k or more, the proposed method outperforms GICSC since more irrelevant data points are filtered out without computation due to the skyline influence region of multiple layer grids. The execution time of a skyline query in anti- correlated data set is higher than that of a skyline query in the independent data set and correlated data set. The reason is that the skyline influence region of the anti-correlated data set is larger than that of independent and correlated data sets. GICSC can also achieve good performance by adjusting its cell size to accommodate the increased data size. However, for highly skewed data set, it is not efficient since additional trash cells need to be processed. Even for the uniform data set, the cells cannot be increased with the endless data increase. Figure 6 (b) shows the result on the real data set (the hustle score of  Lahman?s baseball database) as the number of data is varied.

And the result of the performance is similar to the synthetic data sets, the execution time is between anti and cor.



V. CONCLUSION In this paper, we proposed a continuous skyline query  processing scheme over skewed dynamic data set. For skewed data sets, the proposed scheme divides the work space into multiple layer grids and creates the skyline influence regions of each layer grid. Under the highly dynamic data environment, the skyline query is handled only when the data are changed within the skyline influence region of each layer grid. The skyline influence region of each layer grid is updated when the skyline data change. Since the proposed scheme filters out more irrelevant data points without computation, it significantly improves performance. The experimental results have shown that the proposed method is more efficient than the existing method over synthetic data sets and real data set. In the future, we aim to extend our scheme for more real applications.

