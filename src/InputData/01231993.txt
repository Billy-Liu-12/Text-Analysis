Microarray Gene Expression Data Association Rules Mining Based On JG-Tree

Abstract The main techniques currently employed in analyzing  microarray expression data are clustering and  classification. In this paper we propose to use association  rules to mine the association relationships among  different genes under the same experimental condition.

These kinds of relations may also exist across many  different experiments with various experimental conditions.

In this paper, a new approach, called LIS-growth (Large  ItemSet growth) tree, is proposed for mining the  microarray data. Our approach uses a new data structure,  JG-tree (Jiang, Gruenwald), and a new data partition  format for gene expression level data. Each data value  can be presented by a sign bit, fraction bits and exponent  bits. Each bit at the same position can be organized into a  JG-tree. A JG-tree is a lossless and compression tree. It  can be built on fly, a kind of real-time compression for bits  string. Based on these two new data structures it is  possible to mine the association rules efficiently and  quickly from the gene expression database. Our algorithm  was tested using the real-life datasets from the gene  expression database at Stanford University.

1. Introduction 1.1 Problem statement DNA microarrays enable scientists to study an entire  genome's expression under a variety of conditions. The  advent of DNA microarrays has facilitated a fundamental  shift from gene-centric science to genome-centric science.

With the draft human genome published, we are now  entering the postgenomic age. The main focus in genomic  research is switching from sequencing to using genome  sequences in order to understand how genomes are  functioning. Some questions we would like to ask are the  following:  What are the functional roles of different genes  and in what cellular processes do they  participate?

How are genes regulated, how do genes and gene  products interact, and what are these interaction  networks?

How does gene expression level differ in various  cell types and states, and how is gene expression  changed by various diseases or compound  treatments?

With tremendously increasing of gene expression data  by microarray technology, it is possible for attacking these  questions. However, on the other hand, one question  raised is that how we analyze these data quickly and  efficiently. The greatest challenge now is to develop  efficient methods for organizing, distributing, interpreting,  and extracting insights from the large volumes of data  these experiments provided. So far there have existed  many data mining methods used to mine gene expression  data, such as Clustering[1,2] and Classification[3,4].

However all these methods mainly focused on gene  expression profiles, which are the expression values for a  single gene across many experimental conditions. An  example of these methods is clustering unknown genes  with known genes in the same cluster in order to provide  clues to their functions. This is based on the hypothesis  that genes that have the similar gene expression trend at  various conditions may have the similar functions. In this  paper we propose using association rules to mine  association relationships, such as one gene being the  regulator of another gene, among different genes under the  same experimental condition. These kinds of relations may  also exist across many different experiments with various  experimental conditions. This information is very  important to answer the questions mentioned previously. It  will help us understand gene regulation, metabolic and  signaling pathways, and gene regulatory networks.

When applying an association rule mining algorithm  to the microarray gene expression data, the following  special characteristics should be taken into consideration:  One of the main challenges in dealing with  microarray data is the dimensionality of the data.

For example, we use each microarray slide as one  transaction, and each gene as one item. If we  have a 5000-gene microarray slide experiment,  and want to find 10-item candidates, then there  are 5000!/(10!*4990!) itemsets theoretically. For  human beings there are 50,000 to 100,000 genes.

For an algorithm to work effectively, it must be  able to deal robustly with the dimensionality of  this feature space.

One fundamental challenge in dealing with DNA  microarray data is data normalization. Due to  Proceedings of the 14th International Workshop on Database and Expert Systems Applications (DEXA?03)    technical limitations, the constant of  proportionality between the actual number of  mRNA samples per cell and the relative amount  measured by a microarray experiment is  unknown, and varies across microarray  experiments. So, how we normalize the  microarray gene expression data will have a  significant effect on the results mined from these  data.

The existing data association rule mining works  (Apriori[5], FP-growth[6], P-tree ARM[7].) do not use the  dataset similar to microarray gene expression data and do  not consider the above characteristics of the Microarray  gene expression data though they perform well when  analyzing other data. The objective of this study is to  propose a new association rule mining algorithm to  analyze the microarray gene expression data by taking all  their characteristics into consideration.

1.2 Association rule introduction Let D be a database. Let T = {x1, x2, ?, xn} be a set of  distinct literals (or items). A set X  T with k = |X| is  called a k-itemset. Each T  D is called a transaction. An  association rule is an expression X Y, where X, Y are  itemsets, X, Y  T, and X  Y =  holds. The fraction of  transactions T supporting an itemset X with respect to  database D is called the support of X, supp(X) = |{T  D |  X  T}| / |D|. The support of a rule X  Y is defined as  supp(X  Y) = supp(X  Y). The confidence of this rule  is defined as conf (X  Y) = supp(X  Y) / supp(X)[9].

Association rule mining has two important steps: one  is to find all large itemsets, and the other is to mine  association rules from these large itemsets. Usually the  later step is straightforward to get association rules. So the  main challenge is to find large itemsets. For practical  applications looking at all subsets of T is doomed to  failure by the huge search space. For example, there exist  50,000 to 100,000 genes for human genome. The search  space is 250000 ?1 to 2100000-1.

1.3 Organization of the paper The rest of this paper is organized as follows. Section  2 proposes a new association rule mining algorithm, called  LIS-growth algorithm, to analyze the gene expression  data. A new data structure JG-tree and new data partition  model are also introduced. Section 3 presents the  experimental results of the LIS-growth algorithm on the  real-life datasets. In Section 4, the conclusions and  directions of the future research are presented.

2. LIS-growth Algorithm 2.1 Data Partition  There are various kinds of data on which we can  perform data mining to get useful information. For gene  expression data, usually log ratio is used for gene  expression level values, such as positive fraction, negative  fraction and zero. Here we propose a new format shown in  Figure 1 to represent all kinds of digital data. Any number  can be represented as a fraction and exponent. Then the  fraction can be represented as one bit for  sign following  n bits for fraction (depending on the required precision),  and the exponent can be represented as one bit for  sign  following m bits for exponent (depending on the size of  exponent). We give a simple illustrative example in Figure  1.

? n ? ? m ?  Figure 1. New data partition format  For example, if we choose n=8 and m=3, then this data  partition format can represent the number ranging from  +0.99609375 107 to -0.99609375 107.

The advantages of using this new data partition format  are that, first, this new data partition format can represent  all kinds of digital number precisely. Second, different bits  have different degrees of contribution to the intensity  value. In some applications, some of these bits give us  enough information; so, we do not need all the bits. Third,  this new data partition format facilitates better data  compression (see later JG-tree). Fourth, and most  importantly, this new data partition format facilitates the  creation of an efficient, rich data structure which supports  JG-Tree.

2.2 JG-Tree Data Structure JG-Tree is a bit string compression tree and a lossless  tree. One (or several) JG-tree is built for one gene, which  has the expression data collected under various  experimental conditions. In each JG-tree, the sequence  order of each bit, which comes from the partition of gene  expression data collected under various experimental  conditions, should be fixed. So it is easy to use AND, OR,  XOR ? logical operations between the JG-trees of genes.

Second, optimal (or close to optimal) data compression  should be obtained in order to save search time and  storage space. JG-tree will be used in our LIS-growth  algorithm to find large itemsets (see later in Section 2.3  for detail).

2.2.1 The Details of JG-tree  In JG-Tree, for each node, we use the model shown  below to represent it.

node-level | bit-type |1-bit-count  Node level is the virtual level value. Bit type shows 1 for  all 1-bit nodes, 0 for all 0-bit nodes and m for 1, 0 mixture  Proceedings of the 14th International Workshop on Database and Expert Systems Applications (DEXA?03)    bit nodes. 1-bit count shows the number of 1-bits in the  subtree or entire tree. Depending on the optimum data  compression, we can choose one of the JG2, 3, 4, 5, 6, ..., n-Tree  (n is the number of sibling nodes, n<the maximum  transaction size). We have several ways to build JG-tree,  for example, we can build the JG tree on fly. Here we  show one of these methods. We build the JG-Tree in the  ?bottom-up? model. For example, for building JG2-Tree,  our algorithm counts 2(L-1) bits for each node in virtual  level L. Initially the virtual level L value is 1. Then the  Merger() merges two low level L nodes (subtrees) into  next high level (L=L+1) node (subtree). If the bit type in  these two low level L nodes (subtrees) is the same. We do  not need to keep these low level nodes (sub-subtrees) for  this new next high level node (subtree), so this new node  (subtree) is the lowest node (leaf) of this tree branch.

Similarly, we continue to count 2(L-1) bits for each node in  virtual level L (now L=L+1). During the course of  counting, if the bit type is different, then the node is  broken down to next low virtual level L=L-1 till the same  bit type in one node (node size = 2(L-1) bits). If there are  two same level nodes, then the algorithm repeats the  merge() function. After all expression data for one gene  are read, Merger() merges all low virtual level nodes to  next higher level nodes till JG tree root node is formed.

This pattern is applied to all genes.

Table 1. The sample of microarray gene expression database G1 G2 G3 G4 G5 G6 G7 G8  Slide1 1 1 0 0 1 1 0 1  Slide2 1 1 0 1 0 1 1 1  Slide3 1 0 0 1 0 0 1 0  Slide4 0 1 0 0 1 0 0 1  Slide5 1 0 0 1 0 0 1 0  Slide6 1 1 0 0 0 0 0 0  Figure 2.  A.The JG2-tree of G1. B. The JG2-tree of G3.  C.

The JG2-tree of G6  For one JG-tree, if we are to expand all subtrees,  including those for all 1-bits and all 0-bits leaves, then the  leaf sequence is just the transactions order that is stored in  the original database. Here we give an example. Actually  we do not need the table like Table 1 (where G means a  gene) in our programming. Because the bits can be  transfered from DataPartition() directly.

2.2.2 ANDing The JG-Trees  JG-tree structure is a lossless representation of the  original data. The JG-tree structure can be viewed as a  data-mining-ready structure as it facilitates efficient ways  for data mining. JG-tree is somewhat similar in  construction to other data structures in the literature (e.g.,  binary tree, P-tree[7]). JG-tree can perform some logical  operations (AND, OR, ?) efficiently. Here we give a  simple example for performing the logical AND operation  on the bit type (0 or 1) at the leaf nodes in the two JG-  trees (we called ANDing JG-tree). ANDing JG2-tree using  the JG2-tree in Figure 2, A anding B, and A anding C are  shown in Figure 3.

A anding C 4|m|2  3|m|2  2|1|2  2|0|0  2|0|0  A anding B  4|0|0  Figure 3. The ANDing of JG2-tree in Figure 2  2.3 LIS-growth tree  In the LIS-growth algorithm, we propose a new  structure, LIS-growth tree, to find all possible large k-  itemsets efficiently. In this algorithm the candidate  itemsets are generated on fly and not need to be stored.

With JG-trees ANDing, LIS-tree grows from the large 1-  itemsets to the large k-itemsets. This algorithm never loses  any possible large itemsets. Finally all possible (1 to k)-  itemsets are stored in one LIS-tree (Figure 4). In this way  memory space is reduced. Also it saves a lot of execution  time. Further detail is shown in Figure 4. First, the  algorithm reads gene expression data from a gene  expression database, and then divides the data into the bits  according to data partition format. Each of the bits is sent  to the corresponding JG-tree builder to build its JG-tree as  shown earlier. Second, the algorithm uses the basic JG-  tree to calculate the support of each gene. For one gene, its  support is generated by counting the occurrence of the  gene in the whole database. In our system, each  microarray slide is a transaction; each gene on the  microarray is one item. In each JG-tree, the root count  means the number of transactions that contain the gene Gi at some bit level. So,  A   4|m|5  3|m|3  2|1|2  2|m|2   2|1|2  1|1|1    1|0|0  B  4|0|0  C 4|m|2  3|m|2  2|1|2  2|0|0  2|0|0  Support = root count / total number of transactions in database  For example, for G1 in Figure 2A, Support = 5/6 = 83.3%.

Third, the LIS-tree of large 1-itemsets is built as level 1 in  Figure 4. Forth, starting from root, deep first search to  most left leaf node, say N. Getting the ANDing JG-tree of  all visited genes, say T1, then using T1 AND with the  basic JG-tree of each N?s sibling in the right side under  the same parent node to get the new ANDing JG-trees,  The supports are calculated using these new ANDing JG-  Proceedings of the 14th International Workshop on Database and Expert Systems Applications (DEXA?03)    trees. If support is greater than or equal to minimal  support, then one new subnode (with the same name as  this N?s sibling node) is generated under the node N. This  pattern is applied to each leaf node recursively till the  entire LIS-growth tree is built. For example, in database D  (Table 1), suppose that miniSup=50%. First, the basic JG-  trees are built. Then using root count to calculate the  support, G1?s JG-tree root count =5, G2?s, G4?s, G7?s and  G8?s JG-trees root count=3, Their supports  miniSup, so  G1, G2, G4, G7 and G8 are large 1-itemsets in LIS-  growth tree level 1 (Figure 4). For building large 2-  itemsets, each leaf node in level 1 is combined with its  siblings in the right side, such as G1G2, G1G4, G1G7,  G1G8, and then getting their ANDing JG-tree. The root  counts of the G1G2?s, G1G4?s and G1G7?s ANDing JG-  trees are 3. Their supports are equal to minSup (0.5). So  they are large 2-itemsets (level 2 in Figure 4). The root  count of G1G8?s ANDing JG-tree is 2; its support <  miniSup. So G1G8 is a small 2-itemset and not in the LIS-  tree. Each node in level follows this way to generate its  level 2 subnodes. In the same way the nodes in level 3 (3-  item large itemsets) are generated from level 2 nodes. For  example, starting from the root depth first search to the  most left node, such as root->G1->G2, building the  ANDing JG-tree of G1G2, say T, then ANDing T with the  basic JG-tree of each sibling (G4, G7)in the right side  under the same parent node to get the ANDing JG-trees of  G1G2G4 and G1G2G7. Because their root counts are 1,  their support<miniSup, so no subnode is formed. Then we  back up to G2?s nearest parent node (G1) to search the  next most left node (G4). We do that in the same way as  that on the G2. We got the G1G4G7. The root count of  G1G4G7?s JG-tree is 3; its support = miniSup. So a new  subnode G7 is formed under G4. In this way each node  can generate its next level nodes till the entire LIS-growth  tree is completed. This is a very efficient way to generate  all k-item large itemsets. In Figure 4, all large itemsets,  G1, G2, G4, G7, G8, G1G2, G1G4, G1G7, G2G8, G4G7,  and G1G4G7 , are stored in one LIS-tree efficiently.

Root      level 0  G1       G2   G4      G7       G8      level 1  G2   G4  G7  G8   G7      level 2  G7      level 3  Figure 4. LIS-growth tree  The algorithm is described as follow:  LIS-growth tree algorithm {  Build basic JG-trees;  Build 1-item LIS1-growth tree;  From k=2 to (n-1) do  LIS-tree grows  End  Answer = LISn-1-tree  }  The LIS-tree is a kind of lossless, compression tree. In  the LIS-growth tree, from the root to level 1, we will get  all large 1-itemsets. From the root to level 2 all large 2-  itemsets are obtained, and so on for large k-itemsets from  the root to level k. Based on the LIS-growth tree, then we  can straight forward to derive the association rules. For  example, G1G2 is a large 2-itemset in the LIS-growth tree.

Suppose that miniSupp is 50%, miniConf is 50%. For  G1G2, support = 3/6 = 50%. for G1 in Figure 2A, support  = 5/6 = 83.3%. So,  Confidence = |G1  G2|/|G1| = 3/5 = 60%  Then rule G1 => G2 holds.

2.4 The Advantages and Open Problems 2.4.1 Advantages  JG-tree is a compression tree, a space-efficient,  lossless, data mining ready structure for association rule  mining. This data structure provides a fast way to  calculate support and confidence for association rule  mining. JG-tree can be built on fly, a kind of real-time  compression for bit strings. We do not need to know the  file size in advance. We do not need to form a special file  called bSQ file like P-tree[7]. We do not need to wait for  all of the items to be read before we start to build the gene  JG-tree. Comparing to reading I/O time, the time for  building JG-Tree is negligible. Also no limitation is on the  file size. Depending on the optimum data compression we  can use any n size JGn-tree (n for sibling node number,  n=1, 2, ?k, k<the maximum transaction size). Our data  partition format can accommodate any value. Also there  are several other advantages as mentioned in Section 2.1.

JG-Tree also has all advantages of P-tree[7]. The LIS-  growth tree is also a kind of compression tree. With LIS-  growth tree growing, it finds and stores all possible large  itemsets into one tree.

2.4.2 Open Problems  The LIS-growth algorithm has many advantages  mentioned above. Also there exist some problems, such  as, how to choose the JGn-tree size n to get the JGn-tree as  an optimum compression tree or close to an optimum  compression tree. Further work can be done to improve  this algorithm.

3. Experimental Results The experiments were performed on a SUN  workstation Ultre5 Sparc-IIi, clocked at 360 MHz. The  experiments in Figure 5 comparing our algorithm and the  existing data mining algorithm Apriori were carried out  using real-life gene expression datasets from Stanford  University[8]. Before these data were used in our  Proceedings of the 14th International Workshop on Database and Expert Systems Applications (DEXA?03)    association rule mining program, they were normalized as  follows. First, we got the ratio (r) of Red value to Green  value from each spot on the microarray slides. r = (R ?  R.Bkg) / (G ? G.Bkg) where each array consists of  Timepoint 1 (low OD, high glucose) labeled in green, and  Timepoint 1,2,3,4,5,6, or 7 labeled in Red. G -- Green  Channel (Timepoint 1), R -- Red Channel (Timepoints 1-  7), Bkg -- Background Counts. Second, we choose  Timepoint-1 as the control. Using the formula Ratio = log  (r / r1), we get the log ratio of each gene expression value  at each time point. Where r1 is the Timepoint-1 ratio (r1 =  (R1 ? R1.Bkg) / (G1 ? G1.Bkg)). So, in this way, if the  gene expression level increases its ratio will be larger than  zero, if the gene expression level decreases its ratio will be  less than zero; otherwise, its ratio will be equal to zero (no  change). Based on the characteristics of the microarray  gene expression data, we choose the execution time vs. k-  itemsets, and execution time vs. ?support? as the  performance measurements. Our experiments show that  our algorithm outperforms Apriori in terms of execution  time. At the higher support value or small amount large  itemsets no significant difference between our algorithm  and Apriori algorithm. But at low support value or large  amount of large itemsets our algorithm always run mush  faster than Apriori algorithm.

0 200000 400000 600000  Large Itemsets  E x  e c  u ti  o n  T im  e (  s )  Apriori  LIS-growth    0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9  Support  E x  e c  u ti  o n  T im  e (  s )  Apriori  LIS-growth  Figure 5 Execution time of the algorithms for generating large  2-itemsets for gene expression level >2 fold to control in real-life  dataset[8]  4. Conclusions and Future Reserach In this paper, we proposed a new association rule  mining algorithm, LIS-growth Algorithm, based on the  two new data structure JG-tree and LIS-growth tree. We  also proposed a new data partition model. The paper then  presented the experimental results for finding large  itemsets using real-life datasets. The LIS-growth  algorithm was developed to take the characteristics of the  microarray gene expression data into consideration. Two  new data structures, JG-tree and LIS-growth tree, make  this new efficient association rule mining algorithm  possible. A JG-tree is a lossless and bits compression tree.

It can be built on fly, a kind of real-time compression for  bit strings. JG-tree is also a ?data mining ready? data  structure. It provides a fast way to calculate support and  confidence for association rule mining. The LIS-growth  tree is also a compression tree. With the LIS-growth tree  growing, it finds and stores all possible large k-itemsets  into one tree. Based on these two new data structures it is  possible to mine the association rules efficiently and  quickly from a single gene expression database as well as  from multiple gene expression databases. Our experiments  show that our algorithm outperforms Apriori in terms of  execution time. For future research, we will use this new  algorithm to find the gene regulation information from  microarray gene expression data. The new algorithm and  data structures represented here have the merit of  generality. We will extend to other related research fields  for using the merit of our data structures and algorithm,  such as multi-database association rules mining.

