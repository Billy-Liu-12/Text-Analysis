Capability of Classification of Control Chart Patterns Classifiers Using Symbolic  Representation Preprocessing and Evolutionary Computation

Abstract ? Ability to monitor and detect abnormalities accurately is important in a manufacturing process. This can be achieved by recognizing abnormalities in its control charts.

This work is concerned with classification of control chart patterns (CCPs) by utilizing a technique known as Symbolic Aggregate Approximation (SAX) and an evolutionary based data mining program known as Self-adjusting Association Rules Generator (SARG). SAX is used in preprocessing to transform CCPs, which can be considered as time series, to symbolic representations. SARG is then applied to these symbolic representations to generate a classifier in a form of a nested IF-THEN-ELSE rules. A more efficient nested IF- THEN-ELSE rules classifier in SARG is discovered. A systematic investigation was carried out to find the capability of the proposed method. This was done by attempting to generate classifiers for CCPs datasets with different level of noises in them. CCPs were generated by Generalized Autoregressive Conditional Heteroskedasticity (GARH) Model where ? is the noise level parameter. Two crucial parameters in SAX are Piecewise Aggregate Approximation and Alphabet Size values.  This work identifies suitable values for both parameters in SAX for SARG to generate CCPs classifiers.

This is the first work to generate CCPs classifiers with accuracy up to 90% for ? at 13 and 95 % for ? at 9.

Keywords - Association Rules; Autoregressive Conditional Heteroskedasticity (GARH) Model; Control Chart Patterns (CCPs); Evolutionary Computation; Symbolic Aggregate Approximation (SAX); Symbolic Representation; Self-adjusting Association Rules Generator (SARG); Time Series

I.  INTRODUCTION Control chart patterns (CCPs) are used in Statistical  Process Control to provide information on the state of a process. They are used in detecting abnormalities in a system?s condition by monitoring the behavior of the system in order to ensure high quality control. CCPs can be considered as time series. They represent sequences of real values over a period of time. In order to monitor the system?s condition, control charts are classified into different categories. Hence, accurate classification is a vital for an effective system monitoring. Apart from an ability to classify time series, discovering useful hidden patterns in them is advantageous as their behaviors and characteristics can then be understood. As hidden patterns in time series are detected from consecutives values rather than from values at particular instances, this renders most data mining algorithms  which work on values of individual attributes inappropriate.

It is also difficulty to classify the patterns of CCPs in highly noisy situation. Therefore, suitable symbolic representation of the CCPs time series data under investigation is beneficial to the mining process.

This work is an improvement to classification of control chart patterns by utilizing a technique in symbolic representation of time series known as Symbolic Aggregate Approximation (SAX) and a technique in generating association rules known as Self-adjusting Association Rules Generator (SARG). SAX is the method of preprocessing CCPs data. In pre-processing using SAX, real valued time series are transformed into the Piecewise Aggregate Approximation (PAA) representation and then symbolize the PAA representation into a discrete string which also retains its essential features. This preprocessing data performs dimensionality reduction and lower bounding of the data.

Output from SAX (i.e. symbolic representations) can then be an input to SARG in order to generate association rules for the classification. SARG adopts evolutionary computation approach which comprises 3 main components, Data Preprocessing, Evolutionary Computation and Final Classifier Builder. The main objective of this study is to systematically investigate the suitable values for PAA and Alphabet Size in SAX for classification of CCPs as well as assess the classification ability of utilizing both SAX and SARG by increasing the noise in CCPs. It also discovers a more effective way to generate a nested IF-THEN-ELSE rules in the Final Classifier Builder in SARG.



II. CONTROL CHART PATTERNS Control chart patterns (CCPs) are used to detect  abnormalities during the process [1]. There are many unnatural patterns that may exist indicating the process is out of control. The presence of unnatural patterns implies that a process is affected by abnormal causes, and correction should be taken as soon as possible. Identification of unnatural patterns can greatly narrow the set of possible causes that must be investigated, and thus reducing the diagnostic time. CCPs used in this work are patterns which are commonly occurred in control systems. Figure 1. shows the example of six main types of pattern that might be observed on a control chart : normal, cyclic, decreasing trend, increasing trend, downward shift and upward shift.

DOI 10.1109/ICTAI.2011.178                   Figure 1. Example of six control chart patterns  These patterns are generated  by  GARH  (Generalized  Autoregressive Conditional Heteroskedasticity Model) [2].

Equations which are used to generate control chart patterns used in this work can be found in [3].

Equations for GARH are shown below:  1. Normal:         y(t)  =  ? + r(t)?            (1) 2. Cyclic:         y(t)  =  ? + r(t)? + a sin(2?t/T)      (2) 3. Decreasing trend:  y(t)  =  ? + r(t)? - gt       (3) 4. Increasing trend:   y(t)  =  ? + r(t)? + gt       (4) 5. Downward shift:   y(t)  =  ? + r(t)? - ks       (5) 6. Upward shift:         y(t)  =  ? + r(t)? + ks       (6)   Where y(t) = Time Series value ? = Mean value r(.) = Normally distributed random number t = Time ? = Standard deviation a = Amplitude of cyclic variations g = Magnitude of gradient trend k = Determines shift position s = Shift magnitude T = Period of cycle   The standard deviation (?) is  the  critical  parameter  which dictates  the level of noise in each pattern. Higher value of ? presents higher level of noise in the CCPs and most researches in classification of CCPs tend to concentrate on varying the ? value.



III. RELATED WORK Numerous approaches have been proposed to control  chart patterns classification. Earliest work on these patterns attempted to study performance of neural networks and was proven superior to the use of expert systems and statistical methods [4]. Synergy of neural networks was also developed for this classification with better performance than a single unit [5]. Other works on these patterns attempted to study performance of different architectures of neural networks.

These include Self-Organizing Network [6], wavelet analysis with neural networks [7] and supervised neural networks [8].

Recently, capability of neural networks in classifying CCPs  was systematically investigated to find limitation of neural networks in CCPs classification [9].

To improve classification, preprocessing techniques were introduced. The earliest work [10] is to investigate suitable training algorithms. One of the more promising approaches is to extract useful features from the signals so they could then be used in training neural networks. The first attempt was carried out by [11] where four features (mean, standard deviation, skewness and kurtosis) used in image processing were extracted. Synergy of neural networks was also introduced  together  with  features extraction  in  [12]  and [13]  by incorporating two more features (slope and Pearson correlation coefficient) and additional transformation of original signals. The advantage of extracting statistical features from CCPs as input vector to neural networks was also affirmed in [14].

Other significant works on the classification of control CCPs include [15] where discriminative patterns were extracted by piecewise constant modeling of temporal signals by regression trees. SAX was also employed for this classification in [16].

Inductive learning is one of many techniques where patterns can be learned or induced from a collection of samples. A popular method in evolutionary computation Genetic Algorithms (GAs) was employed in a program Genetic Algorithm for Inductive Learning (GAIL) [17], where chromosomes represent possible classification rules.

GAIL was furthered improved into SynGAIL [18], which achieved higher accuracy by adopting synergism of different GAIL units. The program Genetic Programming for Inductive Learning (GPIL) (a data mining program) [19] is an improvement from GAIL and SynGAIL. In application of evolutionary computation in CCPs classification, tree representation of chromosomes was proven more flexible and efficient than binary strings.

A recent approach [20] applied SAX in preprocessing to transform the time series CCPs to symbolic representations for a mining program SARG, to generate association rules [21]. Even though, utilizing SAX and SARG had proven superior to previous works, it has not determine the optimal values for Piecewise Aggregate Approximation segments (PAA) (l) and Alphabet Size (s) for transforming CCPs into symbolic representations for mining algorithms. The work also revealed that the difficulty in the classification lies in differentiation of some patterns which may appear very similar when signals are highly noisy.



IV. UTILIZING SAX  AND  SARG  IN  CLASSIFICATION OF CCPS  This work bases the classification of CCPs from the previous work [20] where SAX and SARG were utilized in building classifiers for CCPs. It investigates these two techniques for classification of CCPs. This Section provides a brief description of both SAX and SARG. Figure 2.

illustrates the development of the CCPs classifier in this work.

Figure 2. Development of CCPs Classifier  A. Symbolic Aggregate Approximation (SAX) As reported in [20], a suitable choice of representation  affects the efficiency of time series data mining algorithms considerably. Several time series representations have been introduced, including Discrete Fourier Transform, Piecewise Linear Approximation, Max. Wavelet Transform and Piecewise Constant Approximation.

The major drawback of using the above representations in mining time series data is that they are real value. This limits the algorithms, data structures and definitions available for them. Such limitation has led many researchers to consider transforming real valued time series data into symbolic representations. SAX adopted in this work was first introduced in [22]. SAX has the advantage of dimensionality and noise reductions. It also allows real valued data to remain the original characteristics with only an infinitesimal time and space overhead.

In SAX, the number of Piecewise Aggregate Approximation segments (l) is defined to reduce dimensions of the time series. Hence, a time series data T of length n can now be represented in T  of length l. Each element of T  is calculate by the following equation :  ( 1) 1  n i l  i j nj i l  T T = ? +  = ?                                   (7)  The Alphabet Size (s) is then defined. For example, if alphabets ?a?, ?b?, ?c? and ?d? are to be used, then the Alphabet Size (s) is 4. Each value of iT  is now represented by an alphabet that is determined by breakpoint. Because the distribution of the data is normal, the breakpoint is defined by value from statistical table (Z-table). For example, Figure 3 illustrates SAX representation of an upward shift control chart for n = 60, l = 6 and s = 4.

Figure 3.  An example of SAX representation   The result of the SAX representation for the upward shift control chart above is ?1a2b3b4b5d6d?. Detail and analysis of SAX can be founded in [15] and [16].

B. Self-adjusting Association Rules Generator (SARG) The mining algorithm creating the classifier in this work  is SARG [21]. It adopts evolutionary computation approach which comprises 3 main components, data preprocessing, evolutionary computation and Final Classifier Builder as shown in Figure 4.

Figure 4. Three main components in SARG   In SARG, the data set must be split into 2 sets, ?training set? and ?test set?. Data preprocessing preprocesses the training set for the input to the evolutionary computation.

The evolutionary computation is responsible for generating rules. It comprises 2 processes as namely, Regrouping and Genetic Programming (GP). Referring to Figure 4, the number of Regroup, GP Unit and Rules sorting sequences are equal to the number of categories in the classification.

Each sequence is responsible for generating rules for that particular class.

In each Regroup, it splits the dataset into two groups, those which belong to that group and those which do not.

During the inductive learning, SARG has the ability to adjust its evolutionary computation to suit the nature of the training dataset. This is done by means of a crossover method known as ?MaxToMin? (i.e. replacing sub-branch of a tree which has the minimum fitness value with a sub-  Control Chart Patterns (CCPs)  Classifier for the Control Chart Patterns (Nested IF-THEN-ELSE rules)  Self-adjusting Association Rules Generator (SARG)  Symbolic Representations of CCPs  Eg. ?1a2b3b4b5d6d?  Symbolic Representation of the Control Chart Patterns (Symbolic Aggregate approXimation)     branch from another tree with the maximum fitness value) together with three modes of operations. The progress in evolutionary computation is monitored and the operation mode is changed if no progress occurs after 50 generations have elapsed. These are three modes of operation in GP Unit (i.e. different combinations of  ?Crossover? and ?Selection? methods).

In Rule Sorting, all rules generated are sorted according to their fitness value. The one with the highest fitness value is then taken as the rule (i.e. a classifier) to classify patterns in that category. The detail of these operators can be found in [21]. The Final Classifier Builder in SARG builds a classifier in the form of a nested IF-THEN-ELSE format.

Association rules from all categories are nested according to the fitness value rather than category number. This is because rules with higher fitness values are likely to classify samples more accurately than those with lower one. Finally the classifier is evaluated for their accuracy by the test dataset (i.e. how accurate it can classify the test dataset).

This work improves the Final Classifier Builder based on observation and intuition. This is discussed in the next Section.



V. IMPROVEMENT TO THE FINAL CLASSIFIER BUILDER As stated in the previous section, SARG builds a  classifier in the form of a nested IF-THEN-ELSE format. An example of a classifier for n categories is shown below :    IF [condition(s) for the rule with highest fitness value] THEN class = category of the rule with highest fitness value ELSE IF [condition(s) for the rule with 2nd highest fitness value] THEN class=category of the rule with 2nd highest fitness value  ???.

ELSE IF [condition(s) for the rule with lowest fitness value] THEN class = category of the rule with lowest fitness value ELSE sample is unclassified   All rules are used in the above format. A situation where  a pattern does not fit condition(s) in any category merits further investigation. As all rules are ranked by their fitness value, fitness value of condition(s) for each category can also be seen as a probability of belonging to that particular category. If a pattern also does not fit any condition(s) in the nested IF-THEN-ELSE format, this implies that the pattern is too hard to be classified and hence it is labeled as ?unclassified?. In reality, however, it actually belongs to one of the categories, but the classifier fails to find its category.

From observation, experiment, and human intuition suggest an alternative format to the nested IF-THEN-ELSE rules. Considering an analogy where there can only be three categories (A, B and C) to all patterns. If a pattern is proven that it is neither A nor B, then an assumption can be made that it belongs to C with no verification necessary. Referring back to the nested IF-THEN-ELSE rules above, if a pattern  does not fit any condition(s) from the category with the highest fitness value to the 2nd lowest fitness value. Declaring it as belonging to the category with the lowest fitness value rule actually carries a lower risk of being incorrect than declaring it as ?unclassified?. This work proposes an alternative format for the classifier by removing the rule with the lowest fitness value and declaring the pattern belongs to that category if it fails to match all condition(s) of the rules for categories with higher fitness value. Hence, there is no possibility of ?unclassified? pattern. The alternative format is shown below:   IF [condition(s) for the rule with highest fitness value] THEN class = category of the rule with highest fitness value ELSE IF [condition(s) for the rule with 2nd highest fitness value] THEN class= category of the rule with 2nd highest fitness value  ???.

ELSE IF [condition(s)  for  the  rule with 2nd lowest fitness value]  THEN class = category of the rule with 2nd lowest fitness value  ELSE class = category of the rule with lowest fitness value  Experiments have been carried out with the new nested  IF-THEN-ELSE rules on numerous test datasets. They were found superior to the one used in previous work. For example, the format used in the previous work [20] was test on datasets with ? at 5 It yielded 95 % accuracy while the new format presented here yield 96 % accuracy on the same datasets.



VI. SYSTEMATIC INVESTIGATION OF CCPS CLASSIFIERS? CAPABILITY  In order to investigate the full potential of using SAX in preprocessing and SARG in generating classifiers for different sets of CCPs, datasets for the six patterns of CCPs were generated using equations 1 to 6 as stated in Section 2.

They were generated with different level of noise in them by varying the parameter ? in the GARH model.

The best classifier is the one which can classify all given set of patterns with 100% accuracy. In practice, however, setting a goal to develop a classifier, especially for CCPs which contain high level of noise, with 100% accuracy may be unrealistic. Therefore, this work investigates the full potential of developing classifiers for CCPs by setting two levels of accuracy at 90% and 95% as these two levels are commonly expected and deemed acceptable.

As stated in Section 2, ? is the most critical parameter as it dictates the level of noise in the CCPs. Therefore, this work investigated CCPs systematically by generating datasets with ? at 1, 2, etc. until the SARG was unable to generate a classifier with an accuracy of at least 90 %. The results are discussed in the next section.

A dataset at each ? comprises 800 samples. Each sample consists of 60 interval values. 600 samples were used for the ?training set? and 200 samples were used for the ?test set? for     SARG. In order to ensure the validity of the investigation, samples in the original dataset were mixed up and three datasets were created. Each contains different samples in both ?training set? and ?test set?.

To investigate suitable combination(s) for PPA (l) and Alphabet Size (s) values in SAX, variation of these two parameters were carried out. Alphabet Size (s) values were considered from the breakpoint determination that would produce an equal-sized area under Gaussian curve by referring to a statistical table as suggested in [15]. Hence, Alphabet Size (s) at 2, 3, 4, 5 and 6 were considered in this investigation. As each sample consists of 60 interval values, the PPA (l) values were selected to be the numbers which can divide 60 exactly without any remainder starting from 2 (i.e. 2, 3, 4, 5, 6, 10, 12, 15 and 20). Using PPA (l) more than 20 is not so meaningful bearing in mind that the purpose of SAX is to transform a time series into symbolic representation. Reducing 60 values to more than 20 values is very unlikely to provide suitable representation for SARG.

Therefore, there are 45 combinations for these two parameters in SAX for each ?. As 14 values for ? were considered and three datasets were created for each ?, there were 1,890 processes altogether.

Each process (i.e. generation of a classifier), was carried out on a personal computer (PC) with Intel(R) CPU specification of CORE(TM) 2 Duo, E E8600 3.33GHz and 3.25 GB. RAM. Parameters in SARG were set to the same as in previous work [20]. The population size was 50. Each process took around 1:25 hrs. to generate a classifier for 500 generations in evolutionary computation unit.



VII. RESULTS As three datasets were generated for each ?, the method  proposed here generated a classifier (i.e. nested IF-THEN- ELSE rules) for each dataset. The results of the three classifiers for each ? were averaged. Table I and II shows the results (using average values) of the classifiers for each ? which could at least achieved 90% level of accuracy (values are shown in nearest integer for ease of understanding) altogether with the PAA (l) and Alphabet Size (s) values.

Note that there can be more than one possible combinations for PAA (l) and Alphabet Size (s) for ? of 1 and 2. This is because there were relatively less noise in their CCPs, which made the proposed method able to generate classifiers with more than one combinations. Once the CCPs datasets contained more noise in them, the task of generating very high accuracy classifiers became very hard without suitable combination for PAA (l) and Alphabet Size (s) values in preprocessing using SAX. As many types of classifiers exist, producing a classifiers for CCPs with ? of less than 5 is not a difficult task and several previous works had managed to do so with significantly high level of accuracy.

If the 90% accuracy threshold is sufficient, the proposed method was able to generate a classifier up to ? of 13. If a more stringent accuracy threshold of 95 % is required, the proposed method was able to generate a classifier up to ? of 9. Incidentally, the suitable PAA (l) and Alphabet Size (s) values for both ? = 13 and 9 are 3 and 4 respectively.

TABLE I.  CLASSIFICATION ACCURACY FOR EACH ? AND THEIR PAA(L) AND ALPHABET SIZE (S) VALUES  ? Accuracy PAA(l) Alphabet Size(s)  1 100   3 3 4 3 5 3  2 100 2 3 6 3 100 2 4 4 100 2 5 5 98 3 2 6 100 2 6 7 100 2 6 8 95 3 4 9 95 3 4  10 91 3 6 11 92 3 4 12 92 3 6 13 91 3 4 14 88 3 4

VIII. DISCUSSION While it may be possible that suitable PAA (l) and  Alphabet Size (s) may occurs at different combinations and still yield the same level of accuracy. This work suggests that it is not likely. It is also important to realize that lower number for both PAA (l) and Alphabet Size (s) are preferable than higher ones. This is because higher values for these two parameters means more computation time while generating a classifier.

The pattern of time series under investigation also affect the determination PAA (l) and Alphabet Size (s) values using SAX. Intuitively, if the amplitude range in the time series is large, this suggests that more values for PAA (l) may be necessary and similar rationale can be said about Alphabet Size (s). If the time series comprises a large numbers of points, a suitable value for Alphabet Size (s) is likely to be higher too.



IX. CONCLUSION AND FUTURE WORK This work affirms that suitable symbolic representations  have direct influence to SARG in generating accurate CCPs classifiers. This directly implies that good combination for PAA (l) and Alphabet Size (s) values for SAX is needed.

This work systematically investigates these parameters and found that PAA (l) of 3 and Alphabet Size (s) of 4 are the best combination for CCPS classification in general. A new and more efficient format for generating a nested IF-THEN- ELSE rules classifier in Final Classifier Builder in SARG is also discovered.

Several works had classified CCPs based on GARH model, and all had used ? at no more than 8. This work is the first to produce CCPs classifiers for with accuracy up to 90% for ? at 13 and 95 % for ? at 9. However, it must be borne in mind that high accuracy classification also depends on the     level of noises CCPS or in the time series of interest in general. If CCPs (or any time series) contain very high level of noise (i.e. signal to noise ratio is very low), this simply implies that there are a lot of noise and very little signal in them. In such situation, it is probably impossible to develop a classifier with high degrees of accuracy regardless of technique used.

Future work can be carried out in several aspects. Similar study can be carried out on other kinds of time series data to learn more about relationship between PAA (l) and Alphabet Size (s) in SAX. Other time series benchmarks available in public websites can also be considered [23].

The self-adjusting unit in SARG merits further improvement as this would make it possible to generate more efficient classifiers and possibly with less computation time. Evolutionary operators may be investigated and calibrated to achieve maximum efficiency. At present, a classification rule for each category is taken from the rule with highest fitness value. An alternative method is to improve the Final Classifier Builder to come up with different format rather than a nested IF-THEN-ELSE rules.

Generating a probabilistic form of classifier similar to those used in Bayesian classifiers may also be investigated.

ACKNOWLEDGEMENT The authors gratefully acknowledge the KMUTT research  grant for this work and School of Information Technology at KMUTT for its computing facilities.

