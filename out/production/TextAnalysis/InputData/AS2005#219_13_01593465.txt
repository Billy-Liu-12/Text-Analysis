<html><head></head><body><pre style="word-wrap: break-word; white-space: pre-wrap;">Mining  frequent patterns from XML data

Abstract  The web is rich with information. However, the data contained in the web is not well organized which makes obtaining useful information from the web a difficult task. The successful development of eXtensible Markup Language (XML) as a standard to represent semistructured data makes the data contained in the web more readable and the task of mining useful information from the web becomes feasible. XML has become very popular for representing semistructured data and a standard for data exchange over the web. Mining XML data from the web is becoming increasingly important.

The previous studies adpot an Apriori-like candidate set generation approach but candidate set generation is still costly. We propose that extracting association rules from XML documents without any preprocessing or postprocessing using XML query language XQuery is possible and analyze the XQuery implementation of the efficient FP-tree based mining method, FP-growth, for mining the complete set of frequent patterns by pattern fragment growth. FP-tree based mining adopts a pattern fragment growth method to avoid the costly generation of a large number of candidate sets and a partition- based, divide-and-conquer method is used. Divide-and- conquer method divides the problem into a number of subproblems and the subproblems by solving them recursively. If the subproblem sizes are small enough, however, just solve the subproblems in a straightforward manner and then combine the solutions to the subproblems into the solution for the original problem. In addition, we suggest features that need to be added into XQuery in order to make the implementation of the FP growth more efficient.

Keyword: XML data, XQuery, FP-growth method  1. Introduction  Data mining traditionally is used to find trends in data stored in a database. One data mining technique that has proved popular is association rule mining[7], which finds associations between items in a database. In recent years, the successful development of eXtensible Markup Language (XML)[2] as a standard to represent semistructured data and the fast growing amount of available XML data sets a pressing need for languages and tools to manage collections of XML documents, as well as to mine interesting information out of them[9].

With developments like Xyleme [3, 4] which is a huge warehouse integrating XML data from the Web, it is essential that direct techniques for mining XML data are developed. The query language XQuery [5] was proposed by theW3C [6] in order to provide a flexible way to extract XML data and provide the necessary interaction between the web world and database world.

XQuery is expected to become the standard query language for extracting XML data from XML  documents. Therefore, if we can mine XML data using XQuery, then we can integrate the data mining technique into XML native databases. So, we are interested to know whether XQuery is expressive enough to mine XML data. One data mining technique that has proved popular is association rule mining [7, 8].

that has proved popular is association rule mining [7, 8].

It finds associations between items in a database. In this paper, we will show that XML data can be mined for association rules by implementing the FP-growth algorithm using XQuery. The algorithm that we introduce works with any XML document as long as the structure of the document is known in advance.

The outline of this paper is as follows. In section 2, we describe the related work. In section 3, we describe the basic concept of association rule mining. In section 4, we discuss the FP-growth algorithm. In section 5, we describe XQuery. In section 6, we discuss the XQuery expression for the FP-growth algorithm that is used to mine XML data. We conclude this paper in section 7.

2. Related Work  Algorithms for mining association rules from relational data have been well developed. Several query languages have been proposed, to assist association rule mining such as [10,11]. The topic of mining XML data has received little attention, as the data mining community has focused on the development of techniques for extracting common structure from heterogeneous XML data. For instance, [12] has proposed an algorithm to construct a frequent tree by finding common subtrees embedded in the heterogeneous XML data. On the other hand, some researchers focus on developing a standard model to represent the knowledge extracted from the data using XML. For example, the Predictive Model Markup Language (PMML) [1] is an XML-based language, which provides a way for applications to define statistical and data mining models and to share models between PMML compliant applications. To date, mining XML documents requires mapping the data to the relational data model and using techniques designed for relational databases to do the mining. For instance, the XMINE operator has been introduced by Braga et al. [9] for extracting association rules from XML documents, where mapping the XML data to a relational structure is required before mining is performed.

3. Association Rules  In this section we overview the basic concepts of association rule mining. We refer the reader to [7,8] for further details. Association rule mining was first introduced by Agrawal et al.[7], and was used for market basket analysis. The problem of mining association rules can be explained as follows: There is the itemset I=i1, i2, ?., in, where I is a set of n distinct items, and a set of transactions D, where each transaction T is a set of items such that T I. Table 1 gives an example where a database D contains a set of transaction T, and each transaction consist of one or more items.

?

Transaction-id Items bought 1 A,B,C 2 A,C 3 A,D 4 B  Table 1: An Example Database  An association rule is an implication of the form X?Y, where X, Y I and X Y = ? I ? . The    form X?Y, where X, Y I and X Y = ? I ? . The rule X Y has support s in the transaction set D if s% of transactions in D contain X  Y. The support for a rule is defined as support (X  Y). The rule X?Y holds in the transaction set D with confidence c if c% of transactions in D that contain X also contain Y. The confidence for a rule is defined as support (X  Y) / support (X). For example, consider the database in table 1. Let minimum support be 50% and minimum confidence be 50%. When people buy A , they also buy C of the cases, for rule A C: ?

U U U ?

support = support ({A}  {C}) = 50% U confidence= support ({A} U  {C}) / support ({A}) = 66.6% Association rule mining is a two-step process: 1. Find all frequent itemsets: each of these itemsets will occur at least as frequently as a pre-determined minimum support count.

2. Generate strong association rules from the frequent itemsets: these rules must satisfy minimum support and minimum confidence.

4. FP-growth algorithm  In 2000, Han et al. proposed the FP-growth algorithm?the first pattern-growth concept algorithm.

FP-growth constructs an FP-tree structure and mines frequent patterns by traversing the constructed FPtree.

The FP-tree structure is an extended prefix-tree structure involving crucial condensed information of frequent patterns.

(a) FP-tree structure  The FP-tree structure has sufficient information to mine complete frequent patterns. It consists of a prefixtree of frequent 1-itemset and a frequent-item header table. Each node in the prefix-tree has three fields: item-name, count, and node-link.

? item-name is the name of the item.

? count is the number of transactions that consist of the frequent 1-items on the path from root to this node.

? node-link is the link to the next same itemname node in the FP-tree. Each entry in the frequent- item header table has two fields: item-name and head of node-link.

? item-name is the name of the item.

? head of node-link is the link to the first same item-name node in the prefix-tree.

(b) Construction of FP-tree  FP-growth has to scan the TDB twice to construct an FP-tree. The first scan of TDB retrieves a set of frequent items from the TDB . Then, the retrieved frequent items are ordered by descending order of their supports. The ordered list is called an F-list. In the second scan, a tree T whose root node R labeled with ?null? is created. Then, the following steps are applied to every transaction in the TDB . Here, let a transaction represent [p\P] where p is the first item of the    represent [p\P] where p is the first item of the transaction and P is the remaining items.

-In each transaction, infrequent items are discarded.

-Then, only the frequent items are sorted by the same order of F-list.

-Call insert_tree (p\P,R) to construct an FP- tree.

The function insert_tree ( p\P,R) appends a transaction [p\P] to the root node R of the tree T .

Pseudo code of the function insert_tree (p\P,R) is shown.

An example of an FP-tree is shown in Figure 1.

This FP-tree is constructed from Table 2 with min- sup=2. In Figure 1, every node is represented by (item- name: count). Links to next same item-name node are represented by dotted arrows.

Table 2. Sample TDB              function insert_tree ( p|P,R) { let N be a direct child node of R, such that N ?s item-name = p ?s item-name.

if ( R has a direct child node N ) { increment N ?s count by 1.

} else{ create a new node M linked under the R .

set M ?s item-name equal to p .

set M ?s count equal to 1.

} call insert_tree  (  P ,N).

}   Item ID  Support count Node-link A B C D E null {} B: 7 A: 4 D:1 C:2 C:2 D:1E:1 E:1  Figure 1: Example of an FP-tree    Figure 1: Example of an FP-tree   (c)FP-growth  FP-growth mines frequent patterns from an FP- tree. To generate complete frequent patterns, FP-growth traverses all the node-links from ?head of node-links? in the FPtree?s header table. For example, we describe how to mine all the frequent patterns including item C from the FP-tree shown in Figure 1. For node C , FP-growth mines a frequent pattern (C:4) by traversing C ?s node- links through node (C:2) to node (C:2). Then, it extracts C ?s prefix paths; &lt;B:7,A:4&gt; and &lt;B:7&gt;. To study which items appear together with C , the transformed path &lt;B:2,A:2&gt; is extracted from &lt;B:7,A:4&gt; because the support value of C is 2. Similarly, we have &lt;B:2&gt;. The set of these paths {(B:2,A:2),(B:2)} is called C ?s conditional pattern base. FP-growth then constructs C?s conditional FP-tree containing only the paths in C?s conditional pattern base as shown in Table 3 . As only B is an item occurring more than min_sup appearing in C ?s conditional pattern base, C ?s conditional FP-tree leads to only one branch (B:7). Hence, only one frequent pattern (BC:4) is mined. The final frequent patterns including item C are (C:4) and (BC:4).

TID Items Frequent Items 100 A,B,E A,B,E 200 B,D B,D 300 B,C B,C 400 A,B,D A,B,D 500 B,C B,C 600 A,B,C,E A,B,C,E 700 A,B,C A,B,C  5. XQuery  A query language allows to select elements/attributes from input documents, join data from multiple input documents, make modifications to the data, calculate new data, add new elements/attributes to the results and sort the results.

XML Input XQuery Query XML Output    Figure 2: XQuery processing  XQuery Example Input document &lt;ordernum= ?00299432? date= ?2004-09-15? cust= ?0221A?&gt; &lt;item dept= ?WMN? num= ?557? quantity= ?1? color= ?tan?/&gt; &lt;item dept= ?ACC? num= ?563? quantity= ?1?/&gt; &lt;item dept= ?ACC? num= ?443? quantity=?2?/&gt; &lt;item dept= ?MEN? num= ?784? quantity= ?1? color= ?blue?/&gt; &lt;item dept= ?MEN? num= ?784? quantity= ?1? color= ?red?/&gt; &lt;item dept= ?WMN? num= ?557? quantity= ?1? color= ?gage?/&gt; &lt;/order&gt;  Query for $d in distinct values (doc(?ord.xml?)// item/@dept) let $items:=doc(?ord.xml?)//item[@dept=$d] order by $d return &lt;department name=  ?{$d}? total Quantity= ?{sum($items/@quantity)}?/&gt;    total Quantity= ?{sum($items/@quantity)}?/&gt;  Results &lt;department name= ?ACC? totalQuantity= ?3?/&gt; &lt;department name= ?MEN? totalQuantity= ?2?/&gt; &lt;departmentname= ?WMN? totalQuantity= ?2?/&gt;  6. XQuery Expression  We refer to the sample XML document, depicted in Figure 3 where information about the items purchased in each transaction are represented. For example, the set of transactions are identified by the tag &lt;transactions&gt; and each transaction in the transactions set is identified by the tag &lt;transaction&gt;. The set of items in each transaction are identified by the tag &lt;items&gt; and an item is identified by the tag &lt;item&gt;.

&lt;transactions&gt; &lt;transaction id=?1?&gt; &lt;items&gt; &lt;item&gt; A &lt;/item&gt; &lt;item&gt; B &lt;/item&gt; &lt;item&gt; E &lt;/item&gt; &lt;/items&gt; &lt;/transaction&gt; &lt;transaction id=?2?&gt; &lt;items&gt; &lt;item&gt; B &lt;/item&gt; &lt;item&gt; D &lt;/item&gt; &lt;/items&gt; &lt;/transaction&gt; &lt;transaction id=?3?&gt; &lt;items&gt; &lt;item&gt; B &lt;/item&gt; &lt;item&gt; C &lt;/item&gt; &lt;/items&gt; &lt;/transaction&gt; &lt;transaction id=?4?&gt; &lt;items&gt;  &lt;item&gt; A &lt;/item&gt; &lt;item&gt; B &lt;/item&gt; &lt;item&gt; D &lt;/item&gt; &lt;/items&gt; &lt;/transaction&gt; &lt;transaction id=?5?&gt; &lt;items&gt; &lt;item&gt; B &lt;/item&gt; &lt;item&gt; C &lt;/item&gt; &lt;/items&gt; &lt;/transaction&gt; &lt;transaction id=?6?&gt; &lt;items&gt; &lt;item&gt; A &lt;/item&gt; &lt;item&gt; B &lt;/item&gt; &lt;item&gt; C &lt;/item&gt; &lt;item&gt; E &lt;/item&gt; &lt;/items&gt; &lt;/transaction&gt; &lt;transaction id=?7?&gt; &lt;items&gt; &lt;item&gt; A &lt;/item&gt; &lt;item&gt; B &lt;/item&gt; &lt;item&gt; C &lt;/item&gt; &lt;/items&gt; &lt;/transaction&gt; &lt;/transactions&gt;  Figure 3: Transaction document (transactions.xml)  Consider the problem of mining FP-growth    among items that appear in the transactions document as shown in Figure 3. Let us set the minimum support (minsup)=2. We now present the XQuery expressions  let $src:=document (?/transactions.xml?)//items let $minsup:=2 let $total:=count($src)*1.00 let $c:=distinct-values($src/*) let $l:=(for $itemset in $c let $items:=(for $item in $src/* where $itemset=$item return $item) let $sup:=(count($items)+1)) where $sup&gt;=$minsup return &lt;largeItemset&gt; &lt;items&gt; {$items} &lt;/items&gt; &lt;support&gt; {$sup} &lt;/support&gt; &lt;/largeItemset&gt;) let $L:=$l return &lt;largeItemsets&gt;{FP-growth($l,$L,$minsup,$total,$src)} &lt;/largeItemsets&gt;  The XQuery expressions for the FP-growth are as follows: define function FP-growth(element $l, element $L, element $minsup, element $total, element $src) returns element { let $f-item:=first item in $L let $l-item:=last item in $L let $T:=getl-itemsets($src, $total, $minsup) return &lt;items&gt; {join ($l-item, $T)} &lt;/items&gt; let $l:=$l-items let $L:=remove($l)  for f-item in $L where $f-item != $l-item return  FP-growth ($l, $L, $minsup, $total, $src) }  define function getl-itemsets(element $src, element $total, element $minsup) returns element { let $l:=(for $itemset in $src where $itemset=$l-item return $itemset) let $sup:=(count($l)+1 where $sup&gt;=$minsup return &lt;largeItemset&gt; &lt;items&gt; {$item} &lt;/items&gt; &lt;support&gt; {$sup} &lt;/support&gt; &lt;/largeItemset&gt; }  Figure 4 shows all the large itemsets generated by our XQuery queries.

&lt;largeItemsets&gt; &lt;largeItemset&gt; &lt;items&gt; &lt;item&gt; B &lt;/item&gt; &lt;/items&gt; &lt;support&gt; 7 &lt;/support&gt; &lt;largeItemset&gt; &lt;largeItemset&gt; &lt;items&gt; &lt;item&gt; A &lt;/item&gt; &lt;/items&gt; &lt;support&gt; 4 &lt;/support&gt; &lt;largeItemset&gt;  &lt;largeItemset&gt; &lt;items&gt;    &lt;items&gt; &lt;item&gt; C &lt;/item&gt;  &lt;/items&gt; &lt;support&gt; 4 &lt;/support&gt; &lt;largeItemset&gt;  &lt;largeItemset&gt; &lt;items&gt; &lt;item&gt; D &lt;/item&gt; &lt;/items&gt; &lt;support&gt; 2 &lt;/support&gt; &lt;largeItemset&gt;  &lt;largeItemset&gt; &lt;items&gt; &lt;item&gt; E &lt;/item&gt; &lt;/items&gt; &lt;support&gt; 2 &lt;/support&gt; &lt;largeItemset&gt; &lt;/largeItemsets&gt;  Figure 4 : Large Itemsets document (large.xml)  Item    conditional  conditional    frequent pattern pattern base    FP-tree           generated E     {(BAC:1),(BA:1)}  &lt;B:2,A:2&gt;      BE:2,AE:2, BAE:2 D    {(B:1),(BA:1)}         &lt;B:2&gt;             BD:2 C    {(BA:2),(B:2)}         &lt;B:4,A:2&gt;      BC:2,AC:2, BAC:2 A    {(B:4}                      &lt;B:4&gt;              BA:4  Table 3: Mining FP-tree  7. Conclusion  In this paper, we presented the XQuery expression of the FP-growth method from XML data.

We use the FP-growth algorithm to generate the large itemset document, and then select all association rules from the large item set where support is greater than or equal to the minimum support. We have proposed frequent pattern tree (FP-tree) and developed a pattern growth method, FP-growth. There are several advantages of FP-growth over other approaches. It constructs a highly compact FP-tree, which is usually substantially smaller than the original database, and thus saves the costly database scans in the subsequent mining processes. It applies a pattern growth method which avoids costly candidate generation and test by successively concatenating frequent 1-itemset found in the (conditional) FP-trees. It applies a partitioning-based divide-and-conquer method which dramatically reduces the size of the subsequent conditional pattern bases and conditional FP-trees. To our knowledge, the FP-growth method has been implemented using the query language XQuery, without pre-processing or post-processing of the data. Many issues remain open, one of the issues concerns the structure of the XML data. Since the structure of the XML data can be  very complex and irregular, identifying the mining context on such XML data becomes difficult. Our current and future research in this area focuses on investigating what other standard data mining algorithms can be expressed in XQuery.

