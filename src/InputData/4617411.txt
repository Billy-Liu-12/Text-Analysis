A Sequential Pattern Mining Algorithm Based on   Improved FP-tree

Abstract   Sequential pattern mining is an important data mining problem with broad application. Most of the previously developed sequential pattern mining methods need to scan the database many times. In this study, STMFP algorithm based on improved FP-tree is presented for sequential pattern mining. By improving the FP-tree structure, every node of the tree can store a set of items instead of one item. After scanning the sequential database once time, the tree can store all the sequences. In addition, a novel mining method, combining nodes from leaf to root which helps mining sequential patterns, is proposed. The cost of mining pattern sequence is divided into two parts. One is to construct STMFP Tree. The cost of this part associates with the size of sequential database. Another one is to find random assembled nodes from leaf to root in every path of STMFP tree. Because the maximal length of path is bounded by the maximal length of one transaction, and there are exiting common nodes which help reduce the number of leaf nodes, so the cost of this part must be much less than the size of the database. Compared with other methods which need to scan the sequential database many times, the cost of our method must be less than two passes of the database. Through the whole mining process, it only needs scan the database once time.

1. Introduction   Sequential pattern mining, which discovers frequent subsequences as patterns in a sequence database, is an important data mining problem with broad applications. Sequential pattern mining is the extension of the association rules. Many sequential pattern mining algorithms, which are based on the methods used in the association rules, are proposed [1, 5, 6, 7].They are presented for mining sequential patterns on the basis of the Apriori heuristic firstly put forward by Agrawal and Srikant in association mining. The Apriori heuristic is that any super-pattern of a  nonfrequent pattern cannot be frequent. Though they perform well, the Apriori-based methods must scan the database frequently. When the length of each sequence grows, this bears a nontrivial cost. Zaki proposed the algorithm SPADE [8] which generates numerous candidates. Algorithm FreeSpan[2] aims at integrating the mining of frequent sequences with frequent patterns and using projected sequence databases to confine the search and the growth of subsequence fragments. It scans the database three times. Algorithm PrefixSpan[3] improved from FreeSpan reduces the size of projected databases by using prefix-projection substantially. It scans database twice, which leads to efficient processing. However, the above-mentioned methods still need scan the database at least two times.

The cost is nontrivial.

[4, 12] proposed an algorithm using FP-tree, which is efficient and scalable for mining frequent patterns.

Many new methods [10, 11] on the basis of improving FP-tree are presented in some practical application. We are inspired by [10] which proposed a combination method to mining frequent patterns. [9] proposed some good ideas  on data mining. Thanks for what they have done.

In this paper, we develop a new sequential mining method, called STMFP (Sequence Tree for Mining Frequent Patterns). By improving the FP-tree structure [4], every node of the tree can store a set of items instead of one item. After scanning the database once time, the tree can store all sequences information. In addition, a novel mining method, combining nodes from leaf to root which helps mining sequential patterns, is proposed. The cost of mining sequential patterns is divided into two parts. The first part is constructing STMFP Tree. The cost of this part associates with the size of sequential database. The second part is to find all combinations from leaf to root node in every path of STMFP tree. Because the maximal length of path is bounded by the maximal length of one transaction, and there are exiting common nodes which help reduce the number of leaf nodes, so the cost of this part must be much less than the size of the database. By contrast with other   DOI 10.1109/SNPD.2008.161    DOI 10.1109/SNPD.2008.161     methods, such as Apriori-like, FreeSpan, PrefixSpan which are needed to scan the database many times, the cost of our method must be less than two pass of the database. Through the whole mining process, it only needs scan the sequential database once time. Our performance study shows that STMFP algorithm mines the complete set of patterns.

The remaining of the paper is organized as follows.

In Section 2, we present our new method STMFP. In Section 3, we present the performance study and experiment results. We summarize our study in Section 4.

2. STMFP Algorithm 2.1. Terminology  Definition 1(STMFP-tree) STMFP-tree consists of one root node labeled as ?root?, a set of itemset subtrees as children of ?root?. Each node in the itemset subtree represents one itemset of sequence, we called it itemset node.

Definition 2 (itemset node) Itemset node in the itemset subtree consists of three fields: parent, itemset, child, where parent links to its parent node in the STMFP-tree; itemset is pointing to a item chain table which consists of three fields: name, count and next, where name represents item?s mark, count registers the number of transactions represented by the portion of the path reaching this itemset node, and next links to the next item which also belongs to the same node; child is a pointer pointing to a chain table which consists of two fields: node and next, where node links to its one child node in the STMFP-tree, next links to its next child.

By adding field itemset, one node in this tree can indicate itemset of the sequence and number of this itemset.

Definition 3 Supposed that the number of item one itemset node includes is n, then we can denote the itemset node as (name1-name2-?-namei-?-namen : count1-count2-?-counti-?-countn), namei and count i respectively stand for name and count of the item i in the itemset node. For example, one itemset is denoted as (I1-I5:4-1), which shows that the number of the itemset (I1-I5) reaching this node is one, the number of itemset I1 reaching this node is three.

Definition 4 (combination of nodes in the STMFP-tree path) It consists of  random assembled nodes from leaf node N to ?root? but except ?root? in the same path. We combine these nodes from top to bottom in the growth direction of the STMFP-tree. We denote one combination of nodes in the STMFP-tree path L as C(node1, node2, ? ,nodei, ? ,noden)count (n<=length(L)). The nodei registers the name of itemset node i in the path L. We set the value of count  is noden?s count. If one item?s count in nodei is less than the count of C, we omit this item in the nodei.

Supposed that STMFP-tree shows in figure 1:   Fig 1.  Structure of STMFP-tree  Example 1. For leaf itemset node I4, it can generate a set of combinations  as follow: (I1-I5 I2 I3 I4)2  (I1-I5 I2)2  (I1-I5 I3)2  (I1-I5 I4)2  (I2 I3)2  (I2 I4)2  (I3 I4)2 (I1-I5 I2 I3)2  (I2 I3 I4)2 ( I1-I5 I2 I4)2  (I1-I5 I3 I4)2.

Since the count of item I5 in the itemset node (I1-I5:4- 1) is less than the count of combinations we omit item I5, then the set of  combinations in final follows as: (I1 I2 I3 I4)2?(I1 I2)2 ?(I1 I3)2?(I1 I4)2?(I2 I3)2?(I2 I4)2?(I3 I4)2?(I1 I2 I3)2?(I2 I3 I4)2 ?(I1 I2 I4)2? (I1 I3 I4)2.

Definition 5 (decomposing C) Supposed C(node1, node2, ? ,nodei, ? ,noden)count  (n<=length(L))), when nodei has no less than one item, for example, nodei can be denoted as namei1-namei2-? -nameij , we decompose C to a set  as follows:  (node1, node2,?,namei1,?,noden)count , (node1, node2,?,namei2,?,noden)count, ,?, (node1, node2,?,nameij,?,noden)count  , and then for  each combination in this set ,we repeat this step until there is no nodei having more than one item.

2.2. The idea and process of STMFP algorithm 2.2.1. The construction of the STMFP-tree. The mission in this phase is to construct the branches in the STMFP-tree by scanning the database once time. The STMFP-tree can be made in following steps. Getting the current itemset in the transaction, if current itemset node?s child has items which are a subset of the current itemset, we increment this child node?s count by 1 and add remaining items in the current itemset to the item chain table of this itemset node, otherwise we create a new node, with its count initialized to 1, its parent linked to current itemset node, and its item linked to chain table initialized by items belong to the curremt itemset. And we make the new node as current itemset node. Then we get next itemset in the transaction, and repeat until all itemsets in one transaction have been     stored. We treat every transaction in this way. So far, STMFP-tree contains the complete information for frequent-pattern mining.

Example 2. For sequence database DB in Table 1 with min_supp=2, firstly, the root of the tree is created and labeled with ?root?. Secondly, scanning the first transaction leads to the construction of the first branch of the tree: <(I1-I5:1-1), (I2:1), (I3:1), (I4:1)>. Itemset node (I1-I5:1-1) has item chain table which is composed of items I1 and I5. For the second transaction <{I1} {I3} {I4} {I3 I5}>, since its first itemset shares a common item name I1 in itemset node(I1-I5:1-1), we increment the count of common item I1 by 1.Then we create a new nodes (I3:1) and link it to node (I1-I5:1-1) as a child. As well, a new node (I4:1) is created and linked as the child of (I3:1), a new node (I3-I5:1,1) is created and linked as the child of (I4:1). For the third transaction <{I1} {I2} {I3} {I4}>, since there is existing path <(I1-I5:2- 1),(I2:1),(I3:1),(I4:1)>, that is to say, there are four shared nodes, we just need increment their counts by 1 respectively. The result is changing the path into <(I1- I5:3-1),(I2:2),(I3:2),(I4:2)>. When scanning of the fourth transaction, the common node (I1-I5:3-1) is changed to (I1-I5:4-1), and the common node (I3:1) is changed to.(I3:2). An new node (I5:1) is created as a child node of (I4:1). For the last transaction, we can generate another branch in the STMFP-tree <(I4:1),(I5:1)>. The STMFP-tree is shown in Fig 2.

Fig. 2.  STMFP-tree of Sequence DB  2.2.2. Mining the STMFP-tree. For every leaf node in the STMFP-tree, we can get the path form it to  ?root?. See from definition 4, we generate a set of combinations CF. See from definition 5, we decompose some combinations and then we check the set CF. If there have been the same combinations in CF, then we merge their count. Otherwise, we put them into the set CF. Finally, compared with the value of minsup, we can omit those combinations whose counts are less than minsupp, and then we can mine the complete patterns.

Example3 Mining the STMFP-tree(shown in Figure 2). For leaf itemset node (I3-I5:1-1), we generate combinations as follows: (I1 I3)2  (I1-I5 I3- I5)1  (I1-I5 I4)1  (I3 I4)1  (I3 I3-I5)1  (I4 I3-I5)1  (I1-I5 I3 I4)1 (I1-I5 I4 I3-I5)1 (I3 I4 I3-I5)1 (I1-I5 I3 I4 I3- I5)1 .We put all of them into a set CF. For those combinations met definition 5, we decompose them.

The decomposed combinations are: (I1 I3)1 (I1 I5)1 (I5 I3)1 (I5 I5)1 (I1 I4)1 (I5 I4)1 (I3 I3)1 (I3 I5)1 (I4 I3)1 (I4 I5)1 (I1 I3 I4)1 (I5 I3 I4)1 (I1 I4 I3)1 (I1 I4 I5)1 (I5 I4 I3)1 (I5 I4 I5)1 (I3 I4 I3)1 (I3 I4 I5)1 (I1 I3 I4 I3)1 (I1 I3 I4 I5)1 (I5 I3 I4 I3)1 (I5 I3 I4 I5)1. For those having been in the set CF, we merge their count. For those not having been in the set CF, we put them into the set CF.

At last step, by comparing with the value of minsupp, we delete those combinations whose counts are less than minsupp. For the remaining leaves, we repeat this step. In final, we can get the completed sequential patterns. For this example, the sequential patterns we can get are: (I1 I2)2 (I1 I3)4 (I2 I3)2 (I1 I2 I3)2 (I1 I4)3 (I2 I4)2 (I3 I4)3 (I1 I2 I4)2 (I1 I3 I4)3 (I2 I3 I4)2 (I1 I2 I3 I4)2 (I1 I5)2 (I3 I5)2 (I3 I5)2 (I4 I5)3 (I1 I3 I5)2   2.3. STMFP algorithm 1) Algorithm 1(STMFP-tree construction) Input: A transaction database DB Output: The root of STMFP-tree Method: The STMFP-tree is constructed as follows.

Create the root of an STMFP-tree, and label it as ?root?; Open DB; while(not EOF) {  Let the Trans be [p|P], where p is the first itemset and P is the remaining list; call insert-tree([p|P],root); point the next trans;  } Procedure insert-tree([p|P],root_nod) {  While (p<>?){  TABLE I SEQUENCE DB  TID Customer Sequence  T001 <{1 5} {2} {3} {4}> T002 <{1} {3} {4} {3 5}> T003 <{1} {2} {3} {4}> T004 <{1} {3} {5}> T005 <{4} {5}>     flag=false? for(every childi of root_nod)/**denote child node of root_nod as childi*/ { flag=Find(childi, p); /**if there is a childi node which has the same item with the item of p, we increment the childi?s count by 1 and flag=true*/ if(flag){ InsertItem (childi, p); /**we add remainder in p to the item chain table of childi */ } else newNode=root_nod->InsertNode (p) ; /**create new node */ childi=newNode; } p=the next itemset in P, P=the remaining itemsets in P; insert-tree ?[p|P], childi?; } }  2) Algorithm 2 (STMFP-growth: Mining sequential patterns with STMFP-tree in way of combination) Input: The root of STMFP-tree and the minimum threshold ? Output: The complete set of sequential patterns.

Method: call STMFP-growth (root, ?) Procedure STMFP-growth (root, ?) {  For(every leaf node N in the STMFP-tree) {  Get random assembled combinations C1, C2 ,?, Cm from the leaf node N to root  except root;  For(i=1;i<=m;i++) { For(for every itemset ?i in Ci) { Delete (?i.item);/**if there exists item having less count than N, we delete this item in Ci */ } Ci.count=N.count;  InsertCF(CF, Ci);  /**if there exists the same Ci in the set CF, we merge their count, otherwise we store Ci */ decompose Ci into Ci?; InsertCF(CF, Ci ? ); /**if there exists the same Ci ? in the set CF, we merge their count, otherwise we store Ci in the set CF*/ } } delete those whose count is less than ? ; }   3. Performance Study and Experimental Results  In this section, we report our experimental results on the performance of STMFP in comparison with PrefixSpan, FreeSpan. It shows that STMFP outperforms other previously proposed methods and is efficient and scalable for mining sequential patterns in large databases.

3.1. Demonstrating the validity of the better performance of STMFP algorithm  Lemma. Given a transaction database DB and a support threshold ? . The cost of constructing STMFP- tree is ?(|DB|), the cost of generating combinations is ?(m*height (STMFP-tree)), where the height of the tree is bounded by max T?DB|Trans|,, m is the number of the leave nodes in the tree(m<<|DB|), the cost of searching combinations can be reduced by distributed computing.

Rationale. The cost of mining pattern sequence is divided into two parts. One is to construct STMFP Tree. The cost of this part associates with the size of sequential database. Another one is to find all combinations from leaf node to root node in every path of STMFP tree. Because the maximal length of path is bounded by the maximal length of one transaction, and there are exiting common nodes which help reduce the number of leaf nodes, so the cost of this part must be much less than the size of the database. Compared with other methods which need to scan the sequential database many times, the cost of our method must be less than two pass of the database. Through the whole mining process, it only needs scan the database once time.

3.2. Experiment Results  The synthetic datasets we used for our experiments were generated using standard procedure describe in [2]. All the experiments are performed on 2.40GHZ Pentium PC machine with 256 megabytes     main memory, running Microsoft Windows/NT.

STMFP algorithm is implemented using C++ language. The experiments show that STMFP-tree can mine complete set of patterns. We use C10T8S8I8 as input dataset and set the minsupp=0.5%. We can get complete set of patterns. Because of the huge result, we cull some results as example (The part in front of colon is sequential pattern, and the other part is the support value).

(5563) (3889) (1772) (1937) : 0.010594 (5563) (3889) (1772 6943) : 0.011463 (5563) (3889) (1772) (7372) : 0.010606 (5563) (3889) (1772) (1937 7372) : 0.010564 (5563) (3889) (1772 6943) (1937) : 0.010575 (5563) (3889) (1772 6943) (7372) : 0.010587 (5563) (3889) (1772 6943) (1937 7372): 0.010547 (5563) (3889) (1937 7372) : 0.011365 (5563) (3889) (6943) (1937) : 0.010593 (5563) (3889) (6943) (7372) : 0.010606 (5563) (3889) (6943) (1937 7372) : 0.010562 (5563) (6943) (1937) : 0.011085 (5563) (6943) (7372) : 0.011108 (5563) (6943) (1937 7372) : 0.011049 (5577) (1258) : 0.013809 (5577) (3279) : 0.014292 (5577 5612) : 0.022377 (5577) (6150) : 0.014085 (5577) (7708) : 0.014006 (5577) (8210) : 0.014053 (5577 8526) : 0.022358   4. Conclusions   In this paper, we present a new sequential mining method, called STMFP (Sequence Tree for Mining Frequent Patterns). It bases on the improved FP-tree structure to store sequences after once scanning the database. And then a novel mining method in combination is proposed. After whole mining process, we can mine the complete sequential patterns. The most important point is that we only need scan the database once time. Our performance study shows that STMFP algorithm has better performance when the  database is large. STMFP algorithm is efficient and can mining the complete frequent patterns.

5. References  [1]Rekesh Agrawal, Ramakrishnam Srikant. Mining  Sequential Patterns. Proceeding of 11th Conference of Data Engineering, Taipei, Taiwan, 1995. 3~14.

[2]Jiawei Han, Jian Pei. FreeSpan: Frequent Pattern- projected Sequential Pattern Mining[A]. Proc 2000 Int Conf Knowledge Discovery and Data Mining?KDD? 00?[C]. Boston: MAACM Press,2000. 355~359.

[3]Jiawei Han, Jian Pei. PrefixSpan: Mining Sequential Patterns Efficiently by Prefix-Projected Pattern Engineering, 2004.1~17.

[4]Jiawei Han, Jian Pei, Yiwen Yin. Mining Frequent Patterns Without Candidate Generation. Proceedings of ACM SIGMOD Intl. Conferenceon Management of Data, Weidong Chen, Jeffery Naughton, Philip A. Bernstein eds. ACM Press,2000. 1~12  [5]Rekesh Agrawal, Ramakrishnam Srikant. Mining sequential patterns: Generalization and performance improvement C. In: Proc of the 5th International Conference on Extending Database Technology (EDB T96). Berlin: Springer Verlog, 1996. 3~17  [6]H.mannila, H Toivonen, and A.I. Verkamo. Discovery of frequent episodes in event sequences. Data Mining and Knowledge Discovery, 1:259~289,1997.

[7]Rekesh Agrawal, Ramakrishnam Srikant. Mining quantitative association rules in large relational tables. In proc. 1996 ACM-SIGMOD Int.Conf. Management of Data, pages 1~12,Montreal, Canada,june 1996.

[8]MJ  Zaki. SPADE: An efficeient algorithm for mining frequent sequences. Machine Learning (J), 2001, 42(1~2): 31~60.

[9] Shao Fengjing, Sun Rencheng, Yu Zhongqing. An Outlier-analysis Algorithm Based on the Reduction of Boundary Cells Influence Proc. Of the 8th Joint International Computer Conference,2002,536-540.

[10]Gao Jun, Shi Bai-Le. Research on Fast Association Rule Mining Algorithm. Computer Science Journal. 2005 Vol.32 No.3.

[11]Yu-Chiang Li, Chin-Chen Chang. A New FP-Tree Algorithm for Mining Frequent Itemsets. AWCC 2004.

LNCS 3309, pages 26~277,2004.

[12]J.Han, J.Pei, Y.Yin and R.Mao: Mining frequent patterns without candidate generation: A Frequent pattern tree approach. Data Mining and knowledge Discovery 8 (2004), 53~87.

