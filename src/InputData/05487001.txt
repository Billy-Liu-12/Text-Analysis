

Abstract?The real time online analysis system that works  under the network condition needs to synchronize and  harmonize data transmit/receive process and the data handler,  especially when facing huge capacity data with at a high  transmit/receive/handle speed. Combined with practical  experience, the paper puts forward a circular data buffer  cache technology and a multi-threading message passing  mechanism. The core of the solution is to: (1) usage of data  cache and multi-threading technology to make the data  transmit/receive process running at a high speed; (2) take the  data cache as a connection bridge to link the data transition  and reception two processes by message passing mechanisms  with an interactive scheduling management, thus the two  processes stand-alone that are closely interrelated may be able  to run simultaneously in one system completed the required work, not only interrelated,  but also interact with each other.

In the end of the paper, an example of real-time flying  objects monitoring system is presented to illustrate the  feasibility and the practicability of the technique, and the  result shows that the strategy for continuously big capacity  data transmit/receive process handling in real-time can boost  the efficiency and speed of data access, enhancing data security and the whole system adaptability.

Keywords- circular data buffer; transmit/receive ; synchronize and harmonize; multi-thread; GIS; rea- time;

I. INTRODUCTION  In automatic, on-line fault diagnosis, target tracking and some other computer application fields, big capacity observation or testing data needs to pass through the network (mainly LAN) with a high speed in real-time, continuously swarming into transmit/receive process terminal, realizing real-time online data analytical processing work. In this case, system design and development will face two key issues need to be addressed: (1) synchronization problem of data transmitting and receiving. In such a high-speed continuous scenario, if we adopt the conventional software handshaking mode as the transmitter and receiver synchronous response mechanism, the actual transmission efficiency would be   greatly reduced. Practice has proved that in many cases, this method can not meet the strict speed requirements for data transmission; (2) for the receiving process terminal, completing the rapid data reception on one hand; it often has to bear the heavy load of data sorting, calculation, analysis, preservation and displaying a series of continuous work.

Therefore, synchronization problem (or consistency) exists between data reception and following treatment. If it is not well resolved, data lost can not be avoided. Especially when the intermediate process becomes much more complex, requiring longer time, problem may seem more prominent.



II. PROBLEM-SOLVING TECHNIQUES AND METHODS  The two key issues described above are interrelated and interacted with each other, referring transmit/receive two process terminal. However, taking into the account of independence of the respective terminal (sometimes we can not even make too many demands and restrictions to the transmit process), the main algorithm optimization and performance improvement to solve the problem should be focused on the receive process terminal.

As can be seen from the above statement, the core  problem for the receive process terminal is that in a real-time system, completing the rapid data reception meeting system speed requirements, and solving unsynchronized problems between transmit/receive process terminal at the same time.

The first step of solution is to improve the data reception  speed effectively; in this paper we use a direct way of listening the network ports. In practice, a scheduling control thread is designed, specializing in network port monitoring and scheduling control. When the data arrives, it receives data and quickly save it to the data buffer cache according to the pre-settings orderly, and then sends a message to notify the other relevant thread the arrival of new data in order to complete a data reception process. For the mandate of the single thread, independence of other data handling threads, therefore, it not only complete the rapid data reception with a relative high speed, but also ensure the integrity of the data effectively, data loss phenomenon will not happen.

Secondly, data non-synchronized phenomenon between  receive/handle process modules should be emphasized. In an ideal situation, data receiving and handling process module should be carried out one by one sequentially. However,     when facing big capacity transmission data situation, the two process modules will not be synchronized for their speed difference. If the receive process shows a high speed, the data handling process module will be significantly delayed.

Therefore, some special technical methods needed to be adopted to coordinate the two process module to be synchronized. In the system design, a message triggered and management mechanism is adopted. Process is as follows: Data receiving module receives "MessageCustom" message (sent by the transmit thread), and if the data handling module is idle, it will immediately read out the latest instruction string and start handling; if the processing module is under way at this time, and there is no time to handle the latest data request, then request will waits in message queue waiting to be handled. Coupled with data buffer cache mechanism, synchronization problem between the two process modules may be well fixed stably and effectively.



III. SYSTEM STRUCTURE AND IMPLEMENTATION  To sum up, the core of the solution method is to: (1) usage of data cache and multi-threading technology to make the data transmit/receive process running at a high speed; (2) take the data cache as a connection bridge to link the data transition and reception two processes by message passing mechanisms with an interactive scheduling management, thus the two processes stand-alone that are closely interrelated may be able to run simultaneously in one system completed the required work, not only interrelated, but also interact with each other.

A. Data sending process  The system architecture is mainly divided into the radar data sending server and the console data receive/process terminal two parts. The data sending server writes a string of commands data to the shared memory and then sends a message to data handling thread, waiting for another new instructions coming. The console terminal reads out each instruction that is stored in the shared memory in turn after receiving the ?MessageCustom?(see Figure 1).

Fig. 1 Data flow chart of the client  1) Creating memory image file Actually, the 32-bit Windows system is capable of  imaging the physical memory to the page file or the swap file.

By imaging the physical memory, including system page itself, the application could be able to expand this capability.

Image file provides a faster and much more convenient file access method, as well as memory sharing.

In the system development, CreateFileMapping() method  is used to create an image file as a data buffer cache. The size of image file depends on the speed difference between the transmit/receive processes performance in the system.

The optimal size can be fixed after actual test. Generally speaking, the greater speed the difference between the two processes, the larger the image file will be.

When creating memory image file, CreateFileMapping()  function must be called to at first, and then MapViewOfFile() function is called to image the image file to the process address space. Functional pseudo-code lists as follows:  hMapFile=CreateFileMapping((HANDLE)(0xFFFFFFF F), NULL,PAGE_READWRITE, 0, Recorder_MaxNum * One_Recorder_MaxLength, "WinSock_MappingFile");  if(hMapFile != NULL){ pMapFile=MapViewOfFile(hMapFile, FILE_MAP_ALL_ACCESS, 0, 0, 0);  }  2) Organizing the image file into a circular data buffer  queue In the paper, the memory image file is organized into a  circular data buffer queue data structure [1] (see Figure 2).

Fig. 2 Circular buffer queue for the memory mapping files  Bytes segment in circular data buffer queue is set "used", "unused" logo points, that is "0" indicates the bytes segment is not in use, on the contrary, "1" may indicate that the bytes segment is already occupied, and can not be overwritten. At the first, the following pseudo-code is executed to mark the new image file with " used " sign:  while(n<Recorder_MaxNum){ address=PChar(pMapFile)+  n*One_Recorder_MaxLength; *(PChar(address)) = '0'; n++;  }  Sometimes, in order to avoid frequent single instruction string sending operations, we adopt a data pre-processing operation strategy. That is: combine the single instruction string into a long instruction string, numbers of instructions to be combined should be in accordance with the actual situation. Functional pseudo-code lists as follows:     while(m<=Read_RecorderMaxNum_OneTime){ //Read_RecorderMaxNum_OneTime Address=PChar(pMapFile) +n * One_Recorder_MaxLength;  cs = *(PChar(address)); if(cs == '1'){ //an available data *(PChar(address)) = '0'; address1=PChar(pMapFile) + n * One_Recorder_MaxLength + 1; s = *(PString(address1)); m++;  } else{ break; } n++; if(n >= Recorder_MaxNum){ //when reach the queue rear, point current reset n =0;  } }  3) Sending customed messages to inform the processing  thread Instruction string sending under network circumstance  needs to call the Windows Socket application send() function module, the function prototype lists as follows [2]:  int SendInstruction(SOCKET s, const char FAR*buf, int len, int flags);  While sending instruction string, the data sending thread needs to send a custom message out to inform the receive/process scheduling control thread at the same time.

At the very beginning, the custom message variable ?MessageCustom? should be defined in the application header file so as to indicate that this message is a user- defined message that will be used:  const int WM_USER = 0x0400; const int MessageCustom= WM_USER + 123;  At the same time, the following message map statement will be added to the application's message map table, linking the user-defined message ?MessageCustom? with its corresponding custom message responsing function module RecvAndDeal(WPARAM wParam, LPARAM lParam):  MESSAGE void RecvAndDeal(WPARAM wParam,LPARAM lParam);  BEGIN_MESSAGE_MAP VCL_MESSAGE_HANDLER(MessageCustom,  TMessage, RecvAndDeal); END_MESSAGE_MAP(TForm)  After that, the SendNotifyMessage() function will be called to send the "MessageCustom" message out, SendNotifyMessage() function prototype lists as follows:  BOOL SendNotifyMessage(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam);  Usage of SendNotifyMessage() function will broadcast the "MessageCustom" message to the console terminal?s main window through network, waiting for response.

SendNotifyMessage(hwnd, MessageForWinSock, (WPARAM)CircularBuf,0)  B. Data-processing working processe  Because of its less memory possession and a relative high working efficiency in the multi-threading implementation, multi-threading technology is frequently used to solve the corresponding problem in the practical system development [3]. Three basic function modules can be divided in the system as: the data reception module, the data handling module, as well as the receive/process scheduling control module, intercommunicating with the use of multi-threading message passing mechanism, each module is independent but working in parallel, meeting the real-time requirements (see Figure 3).

Fig. 3 Thread diagram for system processing  The message listening thread will be started in the main thread process at the very beginning. After starting it will begin capturing the user-defined message ?MessageCustom?.

Data accessing receiving and interpreting work defined in function RecvAndDeal():  void RecvAndDeal(WPARAM wParam, LPARAM lParam) {}  It needs to explain that: the two parameters ?wParam? and ?lParam? of the RecvAndDeal() function have been defined default by the Windows system, attaching additional message illustration. Since the fourth parameter ?lParam? is set to be zero here, the additional message illustration (i.e., the specific content of the data sending) shall be carried out by another parameter ?wParam?.

As a means of system coordination method between the  different functional modules, the message scheduling trigger mechanism can be applied directly provided by the Windows system simple itself with a less complicated in the control structure, however, specific data structure and message passing mechanism is required facing extreme condition, an example of this should be the timer combination of public memory usage.



IV. THE OPERATION APPLICATION  In accordance with the above steps, the system adopted a client/server model design pattern [4], with the radar data sending server, and the final console data receive/process terminal two parts, TCP/IP network SOCKET is used with a flow of about 30MB/sec (about 200 records per second, each record nearly 150Bytes).

On the radar simulation server side, the console terminal  IP address is set for network communication. Radar data automatically send after setting the maximum number of flying targets, and the data transmission interval of time (in milliseconds). Data string format can be customized, the general items should include: data ID, flight target longitude, dimensions, height, sending time, and so on. Data string can be encrypted before sending, after informing the console terminal with specific encrypted format, the console program start the data analytic processing. Radar simulation program interface as shown in Figure 4:  Fig.4 Radar simulation program interface  Radar data in the circular buffer queue is read out and removed by the data handling thread following data parse and display. GIS (Geographic Information System) technology provides effective tools for the handling, integrating and visualizing diverse spatial data sets [5]. The use of GIS for the flying targets management provides a visual data solution. Parameters such as spatial location speed and attitude parameters, etc. is graphically displayed in real time, making the data shown much more intuitive. The system is not subject to weather, climate and ultra-horizon objective external conditions impact, providing researchers with vivid and intuitive information to help them understand  and grasp the field condition, hence to conduct real-time monitoring and decision making. The final console simulation program interface we developed as shown in Figure 5:  Fig.5 Console simulation program interface

V. CONCLUSIONS  In practical applications development, big capacity data acquired from a variety of automatic detections or the monitoring instrumentations will be sent under network condition continuously in real time. The console program is responsible for receiving these sending data, analyzing, and final displaying processes, a series of continuous works.

Strategy described in this paper meets practical application requirements, and achieves a satisfactory result. Combined with the secondary data preservation technology, in case of interruption or even halt of the system processing, stable data reception and procession operation can also be guaranteed, enhancing data security and the whole system adaptability.

