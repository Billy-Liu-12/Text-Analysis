A Novel Key Generation Algorithm from Twitter Data Stream for Secure Communication in IoT

Abstract?Secure wireless communication based applications in IoT typically require very short sessions. Stream ciphers constitute a popular choice for ensuring security of data commu- nications in such applications. To keep the cost, complexity and energy expenditure in the implementation of such stream cipher algorithms low, the short duration of the wireless communication sessions are often exploited by using a lightweight cryptographic (LWC) algorithm. Such an LWC algorithm will provide the desired security during the short session at the required speed, and a new key will be used for the next session so that an adversary would not have enough time to decipher the key of any session. In this paper, we propose a technique based on generating stream of random keys from streaming twitter data. The sequence of random keys generated by the proposed tweet-based key generation (TBKG) algorithm has been tested by the NIST statistical test suite for randomness. The test results show that TBKG algorithm passes all the fifteen tests for randomness. Also, the period of the key values is quite high, thus making it suitable for use over short sessions involving communication of 350 MB data through the wireless network. The unpredictability of the generated random key values is governed by the unpredictable nature of the tweets from thousands of individuals. The algorithm is very simple to implement with low computational and energy overhead.

Index Terms?Stream cipher; key generation; lightweight cryp- tography; wireless communication; mobile transactions; wireless sensor networks; Internet of Things.



I. INTRODUCTION  The Internet of Things (IoT) is expected to revolutionize the future of computing and communication. However, with the explosion in data generation, communication and analysis in the Internet of Things, security has never been more important before. While the new security concerns open a lot of new challenges, the basic issue in this area finally boils down to secure communication between two parties over a public channel. The main security issues in IoT can be broadly explained as follows: i) security must be the fundamental enabler for IoT, ii) there is currently no consensus on how to implement security in IoT on the device, iii) a prevalent and unrealistic expectation is that it is somehow possible to compress 25 years of security evolution into novel IoT devices, iv) there is no silver bullet that can effectively mitigate all the threats.

For IoT, it is extremely important to design stream ciphers that are lightweight due to the computational and energy  resrouce constraints on typical IoT devices. Moreover, due to online communication requirements, it is often not possible to use very complex and time-consuming encryption/decryption algorithms for such secure communication. Stream cipher algorithms have been a popular choice to ensure the security of data communication sessions in such networks [1], [2], [3], [4], [5], [6].

Among the stream ciphers, RC4 [7] is one of the widely used stream ciphers. The hardware implementations of RC4 are much more efficient in terms of keystream throughput, than their software implementations [8]. However, the cost and complexity of the required hardware is very high and may not be suitable for the resource constrained computing devices of wireless networks. RC4 is being used in network protocols such as SSL, TLS, WEP, and WPA. Although a few other more efficient and secure stream ciphers have been discovered after RC4 [9], [10], it is still the most popular stream cipher algorithm due to its simplicity, ease of implementation and speed. Notwithstanding several cryptanalysis attempts on RC4 [11], [12], the cipher remains secure, if used appropriately.

Apart from security, the other key concerns for an ef- fective stream cipher algorithm for use in secure wireless communication in IoT are the cost and complexity of the hardware/software implementation, operating speed and en- ergy consumption for encryption/decryption. However, one good thing for most IoT applications involving stream cipher algorithms is that the transaction sessions requiring fast and secure wireless communication are usually very short. Thus, the encryption keys can be renewed in each session, making the task for an adversary very difficult to break the key. This fact allows us to design relatively simpler cryptographic algo- rithms with sufficiently high speed of encryption/decryption, low cost and complexity of implementation and low energy overhead, yet providing the desired level of security during these short sessions. These are often termed in the literature as the lightweight cryptographic (LWC) algorithms. Once a key K is generated by an LWC algorithm, the bits of the original message M are EX-ORed with the bits of the key K to compute the cipher message C.

Basically, generation of the key K constitutes the main concern of a stream cipher algorithm. The key K used to encrypt a message must meet some stringent requirements.

2ND IEEE PERCOM Workshop On Security Privacy And Trust In The Internet of Things 2017     For example, it is desirable that the key values should be: ? Random, i.e., non-deterministic.

? Unpredictable, which means that if we know some or all  the key values up to a certain point in a sequence of the keys, we should not be able to predict the next one (or any of the future ones).

? Non-repeatable, which means that the same key value will not be repeated in a sequence of a given length.

One easy technique for generating the key values to meet the above requirements would have been to devise a true random number generator (TRNG) which might be derived from some natural source of randomness, e.g., thermal noise in electronic components, frequency instability of electronic oscillators, direct and indirect consequences of human interactions with the computers/computer network; chaotic circuits, Brownian motion of particles in a fluid, etc. If such a TRNG could be devised with a low cost and complexity of hardware/software implementation at the required operating speed with a very low computational overhead, i.e., low energy requirement, then that would have been potentially a very good candidate for generating the keys to be used by a lightweight cryptographic technique for secure wireless communication.



II. OUR CONTRIBUTION In this paper, we propose a novel keystream generator  algorithm for designing lightweight stream cipher algorithm suitable for IoT applications. Our approach is based on the hy- pothesis that tweets generated independently by thousands of individuals in a social network will possess sufficient diversity in topic and content. The proposed random number generator algorithm targets to exploit twitter stream as a potential source of naturally occurring random sequence of characters/bits.

We propose a technique in which we periodically create a large corpus of recent tweets using the twitter streaming API, pre-process these tweets by eliminating retweets, stop words, whitespaces, punctuations, URLs and other frequently occurring words from them (which will also possibly include the keywords related to the basic theme of the recent event), and finally generate a sequence of random keys by running our proposed random number generator algorithm, termed as tweet-based key generation (TBKG) algorithm on the bag of characters formed by concatenating these processed tweets.

The security of the proposed TBKG algorithm has been tested thoroughly. We test the randomness property of the keystream generated by TBKG algorithm using the NIST statistical test suite [13]. The test results show that the pro- posed TBKG algorithm passes all the fifteen tests of the NIST test suite successfully for key size of 4 bytes and above.

The unpredictability of the generated keys follows from the unpredictable behavior of the sequence of characters gathered from tweets from the social media. The proposed TBKG algorithm also shows large values of periods with key sizes above 4 bytes.

Our results show that the keystream generated by the proposed TBKG algorithm would be particularly well suited for use in applications that involve short duration transactions.

Algorithm 1: TBKG Input: Set of recent tweets, fmax, M = no. of  characters in the set of processed tweets, key-size S, N = number of keys to be generated.

Output: Sequence of random keys K1,K2, ? ? ? ,KN each of size S bytes.

Step 1: Set tweet set size = 0; Set T = ?. /* T is the set of characters to be generated from the tweets */  Step 2 : while tweet set size < M do Step 2.1 : For each collected tweet, eliminate stop words, whitespaces, punctuations, emoticons, URLs and other frequently occurring words in the tweet, whose frequency of occurrence will be greater than or equal to fmax. Count the number of characters left in the tweet after this elimination. Let it be count. Concatenate all these characters in the tweet to the set T .

Step 2.2 : Set tweet set size = tweet set size + count.

Step 3: Keep only the first M characters (from left) in T so that T now consists of the characters c1, c2, ? ? ? , cM in order, i.e., T = < c1, c2, ? ? ? , cM > ;  Step 4 :for p = 1 to N do Step 4.1 : for r = 0 to S ? 1 do  generate a random number i, 1 ? i ?M with uniform distribution;  generate a random number j, 0 ? j ? 6 with uniform distribution;  set Kp(r)? jth bit of the ASCII code of the character ci ? T ;  Sessions with such characteristics are found quite often in IoT.

With the computed periodicity of the key values generated by TBKG, it would also be sufficiently strong for most short-lived IoT applications such as those found in process control and, sensing and actuation systems. In such IoT applications, by the time an adversary compromises a key, the necessary data or action would have already lost its timeliness.



III. PROPOSED KEY GENERATION ALGORITHM  Let us assume that we generate the keys with each key having S bits. Assume that the generated key sequence is K1,K2,K3, ? ? ? ,KN . Let the rth bit, 0 ? r ? S? 1 of a key Kp, 1 ? p ? N be denoted by Kp(r). Let T be the sequence of M characters, c1, c2, ? ? ? , cM chosen from the recent tweets after some pre-processing, i.e., T = < c1, c2, ? ? ? , cM >.

We periodically create a large corpus of tweets collected using the twitter streaming API after removing retweets and tweets that are very similar (e.g., copy-paste) of already collected tweets in the current corpus. Once, a corpus is created, a pre-processing of the tweets is done to increase the randomness by eliminating all stop words, whitespaces, punc- tuations, emoticons, URLs and, other words whose frequency of occurrence is greater than or equal to some maximum value,  2ND IEEE PERCOM Workshop On Security Privacy And Trust In The Internet of Things 2017    say fmax. Typically, we may choose fmax to be equal to 10, for a tweet of maximum size of 140. By eliminating such words of high frequency of occurrence, we may effectively delete the keywords bearing the theme of the event (which caused the insertion of tweets by an individual in the social media), as such key words are used very frequently in the tweets. We now describe our proposed random key generation algorithm TBKG as given in Algorithm 1.

The keystreams generated from this TBKG algorithm will be XORed with the succesive bits of a plaintext message to produce the required ciphertext message.



IV. SECURITY ANALYSIS OF THE PROPOSED TBKG  Any random number generation algorithm to be used by a stream cipher should possess the following two important properties, viz., randomness: to approximate the properties of a truly random sequence, and large period: to ensure that the length of the generated sequence is not less than the plaintext message length.

In addition, a cryptographically secure stream cipher must use an unpredictable random number generator algorithm in the sense that, from a sequence of known output keystream bits of the random number generator algorithm, it should be computationally difficult to predict the preceding bits or the successive bits in the sequence. In the following subsections, we analyze the above mentioned security properties of the proposed TBKG in the context of short term wireless com- munications.

A. Randomness Test  There are a good number of statistical test suites in the literature [13], [14], each of which defines different sets of test statistic parameters for examining different randomness properties of a pseudo-random number generation algorithm.

Among these, the NIST statistical test suite [13] is the most widely used one in the field of cryptography, which we have used for testing randomness of TBKG.

The results of our experiment are shown in table I with M , the number of characters in the set T of processed tweets as equal to 40,000. The leftmost column in table I mentions all the 15 statistical tests defined by NIST and the figures under the column headings TBKG show the proportions of the sequences passing the respective tests for key sizes of 1, 2, 4, 8, 16, 32, 128, 256 bytes, respectively.

The proportion of sequences passing a test is directly dependent on the value of the significance level (?) used by NIST. For the default value of ? = 0.01 as used for the results shown in table I, the expected value of this proportion is 0.99, and the lower bound on the proportions is 0.96015. From our experiment, we see that this requirement is met with key size of 32 bytes and above.

To check the effectiveness of our proposed algorithm (TBKG) on random key generation, we develop another simple process to generate the keys of same size from the same set of tweet data used for TBKG. After processing the tweet dataset following the steps 1 to 3 in algorithm TBKG, we generate  a uniform random number i, 1 ? i ? M to peak random characters from the tweet as given in the first statement of step 4.1 of the algorithm TBKG. Then instead of generating the second random number for picking the jth bit of the chosen character as given in the second statement of step 4.1, we include all the 7 bits of ASCII code of the chosen character to form a part of the key until the key of the required size S is generated. Thus, in effect, we change only the last two statements of step 4.1 of algorithm TBKG to generate the keys. After undergoing through the randomness test by the NIST test suite on these generated sequence of keys, we get the results as shown in Table II. Comparing the corresponding figures in tables I and II for the same value of ? = 0.01, we see that the performance with the above modification on algorithm TBKG will be always poorer than that of the proposed TBKG algorithm. For example, for the key size of 256-byte, the upper bound on the proportions passing the tests is only 0.92 which is approximately 7% lower than the upper bound of 0.99 obtained through TBKG. Similarly, the lower bound on the proportions is 0.86 which is approximately 11% lower than the lower bound on the proportions obtained through TBKG.

To find the dependence of the randomness property on the size M of the set T of characters taken from the processed tweets, we vary the value of M in the range of 10,000 to 40,000 to generate the keys by the proposed TBKG algorithm and then perform the randomness test by the NIST test suite.

The results of these tests are shown in tables III, IV, V and I for M = 10,000, 20,000, 30,000 and 40,000, respectively, for different key sizes. These results show that the randomness of the generated sequence of keys increases with the number M of characters. With a dataset having only 10, 000 characters, we get very low proportion values even for large key words.

However, as the number of characters increases in data set, the proportion values passing the tests always increase.

B. Period Measurement  We have measured the periods of the keys generated by TBKG through experiment for three different key sizes of 2, 3 and 4 bytes. From table VI, the minimum and maximum periods are 2132 and 23761 respectively for key size of 2 bytes. The minimum and maximum periods are 331966 and 17614227, respectively for key size of 3 bytes and 87862503 and 156212463 respectively, for key size of 4 bytes. This implies that the period increases with the size of key. Thus, it follows from these results that with a key of size 4 bytes, the minimum period is 87862503, allowing thereby transmission of 4 ? 87862503 = 351450012 bytes, i.e., around 350 MB data during one session with a single key.

C. Unpredictability  Unpredictability involves inability to predict a bit of the key depending on one or more of the previous bits in the key sequence. The first source of unpredictability in our proposed technique is through the random tweets from thousands of individuals received in any possible order. Also, out of these tweets, we choose only those words which appear relatively  2ND IEEE PERCOM Workshop On Security Privacy And Trust In The Internet of Things 2017    TABLE I RANDOMNESS TEST RESULTS USING TBKG  Key Size Test 1 byte 2 bytes 4 bytes 8 bytes 16 bytes 32 bytes 64 bytes 128 bytes 256 bytes  Frequency 0.875 0.937 0.952 0.968 0.992 0.984 0.99 0.993 0.99 BlockFrequency 0.75 0.875 0.912 0.937 0.984 0.992 0.98 1.00 0.99 CumulativeSums 0.875 0.815 0.968 0.875 0.97 0.976 0.97 0.98 0.99  Runs 0.875 0.875 0.992 0.906 0.98 0.976 0.96 0.98 0.98 LongestRun 0.875 0.812 0.906 0.937 0.984 0.986 0.983 0.988 0.99  Rank 0.75 0.937 0.968 0.968 0.972 0.976 0.983 0.99 0.99 FFT 0.875 0.875 0.968 0.875 0.984 0.984 0.994 0.99 0.99  Non overlappingTemplate 0.875 0.812 0.931 0.906 0.922 0.968 0.987 0.99 0.99 OverlappingTemplate 0.875 0.875 0.906 0.968 0.96 0.992 0.978 0.99 0.99  Universal 0.75 0.937 0.960 0.968 0.992 0.992 0.99 0.995 0.99 ApproximateEntropy 0.875 0.812 0.978 0.937 0.98 0.984 0.98 0.99 0.99 RandomExcursions 0.875 0.875 0.906 0.937 0.92 0.968 0.96 0.97 0.99  RandomExcursionsVariant 0.75 0.812 0.971 0.968 0.99 0.976 0.98 0.98 0.99 Serial 0.875 0.912 0.968 0.968 0.98 0.976 0.97 0.995 0.99  LinearComplexity 0.875 0.875 0.921 0.937 0.984 0.992 0.99 0.99 0.99  TABLE II RANDOMNESS TEST RESULTS  Key Size Test 1 byte 2 bytes 4 bytes 8 bytes 16 bytes 32 bytes 64 bytes 128 bytes 256 bytes  Frequency 0.75 0.71 0.75 0.73 0.80 0.82 0.89 0.90 0.92 BlockFrequency 0.81 0.75 0.77 0.79 0.70 0.73 0.88 0.86 0.92 CumulativeSums 0.50 0.56 0.79 0.79 0.63 0.74 0.88 0.88 0.91  Runs 0.56 0.71 0.82 0.90 0.72 0.74 0.88 0.86 0.88 LongestRun 0.56 0.90 0.60 0.65 0.70 0.66 0.93 0.80 0.88  Rank 0.81 0.81 0.72 0.79 0.63 0.74 0.76 0.83 0.90 FFT 0.62 0.71 0.81 0.76 0.93 0.94 0.93 0.92 0.92  Non overlappingTemplate 0.50 0.72 0.72 0.73 0.62 0.74 0.76 0.86 0.91 OverlappingTemplate 0.50 0.75 0.66 0.73 0.63 0.74 0.84 0.83 0.86  Universal 0.63 0.72 0.74 0.91 0.63 0.81 0.76 0.88 0.92 ApproximateEntropy 0.56 0.78 0.81 0.81 0.63 0.64 0.76 0.86 0.92 RandomExcursions 0.81 0.71 0.80 0.79 0.81 0.73 0.88 0.86 0.86  RandomExcursionsVariant 0.67 0.65 0.73 0.73 0.72 0.73 0.76 0.88 0.88 Serial 0.62 0.71 0.75 0.93 0.63 0.73 0.84 0.92 0.92  LinearComplexity 0.68 0.65 0.79 0.73 0.63 0.77 0.82 0.88 0.90  TABLE III RANDOMNESS TEST RESULTS WITH 10,000 CHARACTERS  Key Size Test 1 byte 2 bytes 4 bytes 8 bytes 16 bytes 32 bytes 64 bytes 128 bytes 256 bytes  Frequency 0.625 0.75 0.843 0.89 0.914 0.937 0.939 0.942 0.945 BlockFrequency 0.75 0.875 0.906 0.92 0.89 0.910 0.906 0.935 0.89 CumulativeSums 0.875 0.812 0.875 0.86 0.937 0.964 0.956 0.941 0.906  Runs 0.625 0.875 0.937 0.906 0.843 0.89 0.857 0.95 0.956 LongestRun 0.50 0.687 0.875 0.95 0.937 0.941 0.906 0.942 0.913  Rank 0.75 0.812 0.906 0.92 0.843 0.86 0.93 0.935 0.95 FFT 0.50 0.875 0.843 0.906 0.89 0.910 0.89 0.92 0.89  Non overlappingTemplate 0.75 0.812 0.875 0.89 0.858 0.917 0.916 0.941 0.962 OverlappingTemplate 0.625 0.75 0.812 0.906 0.906 0.89 0.93 0.901 0.906  Universal 0.75 0.687 0.843 0.92 0.89 0.910 0.89 0.901 0.906 ApproximateEntropy 0.75 0.512 0.875 0.875 0.889 0.910 0.93 0.892 0.945 RandomExcursions 0.875 0.75 0.937 0.92 0.922 0.94 0.906 0.935 0.913  RandomExcursionsVariant 0.625 0.812 0.875 0.89 0.89 0.89 0.85 0.90 0.906 Serial 0.875 0.812 0.875 0.95 0.94 0.91 0.955 0.92 0.926  LinearComplexity 0.75 0.875 0.812 0.906 0.94 0.941 0.93 0.935 0.913  2ND IEEE PERCOM Workshop On Security Privacy And Trust In The Internet of Things 2017    TABLE IV RANDOMNESS TEST RESULTS WITH 20,000 CHARACTERS  Key Size Test 1 byte 2 bytes 4 bytes 8 bytes 16 bytes 32 bytes 64 bytes 128 bytes 256 bytes  Frequency 0.875 0.812 0.875 0.906 0.929 0.957 0.98 0.99 0.99 BlockFrequency 0.875 0.75 0.812 0.875 0.906 0.910 0.98 0.98 0.99 CumulativeSums 0.75 0.87 0.87 0.921 0.97 0.968 0.96 0.97 0.96  Runs 0.875 0.875 0.84 0.906 0.906 0.964 0.98 0.988 0.97 LongestRun 0.75 0.937 0.843 0.875 0.929 0.957 0.976 0.99 0.99  Rank 0.875 0.875 0.906 0.921 0.945 0.976 0.98 0.995 0.98 FFT 0.75 0.875 0.84 0.906 0.945 0.964 0.99 0.986 0.98  Non overlappingTemplate 0.75 0.875 0.875 0.906 0.929 0.910 0.99 0.994 0.99 OverlappingTemplate 0.625 0.75 0.812 0.906 0.945 0.968 0.99 0.991 0.99  Universal 0.875 0.875 0.906 0.856 0.929 0.964 0.976 0.991 0.99 ApproximateEntropy 0.875 0.875 0.781 0.906 0.96 0.957 0.996 0.988 0.98 RandomExcursions 0.875 0.75 0.812 0.906 0.929 0.972 0.98 0.97 0.97  RandomExcursionsVariant 0.625 0.93 0.875 0.921 0.945 0.976 0.99 0.98 0.99 Serial 0.875 0.812 0.812 0.937 0.97 0.976 0.976 0.98 0.99  LinearComplexity 0.75 0.875 0.906 0.921 0.945 0.968 0.99 0.97 0.99  TABLE V RANDOMNESS TEST RESULTS WITH 30,000 CHARACTERS  Key Size Test 1 byte 2 bytes 4 bytes 8 bytes 16 bytes 32 bytes 64 bytes 128 bytes 256 bytes  Frequency 0.875 0.875 0.912 0.952 0.984 0.992 0.99 0.99 0.99 BlockFrequency 0.875 0.812 0.952 0.968 0.97 0.986 0.983 0.98 0.98 CumulativeSums 0.875 0.937 0.931 0.937 0.97 0.986 0.994 0.97 0.98  Runs 0.875 0.875 0.968 0.968 0.984 0.992 0.96 0.99 0.99 LongestRun 0.75 0.937 0.912 0.975 0.972 0.976 0.994 0.99 0.97  Rank 0.75 0.875 0.992 0.968 0.98 0.992 0.994 0.98 0.99 FFT 0.875 0.875 0.982 0.952 0.972 0.992 0.96 0.97 0.99  Non overlappingTemplate 0.75 0.87 0.968 0.906 0.984 0.968 0.98 0.99 0.97 OverlappingTemplate 0.875 0.937 0.992 0.906 0.992 0.976 0.97 0.99 0.99  Universal 0.875 0.937 0.960 0.968 0.992 0.992 0.994 0.97 0.98 ApproximateEntropy 0.875 0.937 0.906 0.937 0.984 0.968 0.994 0.98 0.96 RandomExcursions 0.875 0.875 0.978 0.968 0.96 0.986 0.98 0.98 0.97  RandomExcursionsVariant 0.75 0.937 0.978 0.937 0.992 0.986 0.99 0.99 0.99 Serial 0.875 0.937 0.971 0.968 0.972 0.992 0.96 0.97 0.99  LinearComplexity 0.875 0.937 0.968 0.98 0.992 0.986 0.983 0.99 0.98  TABLE VI COMPARISON OF PERIOD VALUES FOR KEY SIZES OF 2, 3 AND 4 BYTES  Period Values for Different Key Sizes Key Size 2 bytes Key Size 3 bytes Key Size 4 bytes  Minimum Period 2132 331966 87862503 Maximum Period 23761 17614227 156212463  Average Period 12946 8973100 122037484 Standard Deviation of Periods 3822 433496 7883456  infrequently, to form the character set T . Thus, there is a lot of unpredictability in the sequence T of characters. The relative frequencies of different characters chosen in the set T may vary widely in different choices and is also unpredictable.

Secondly, out of the M characters, we choose S characters one by one through a random permutation on the characters in the set T to form a key of size S. Since M is very large of the order of 40,000 or above, the total number  ( M S  ) of such  choices is extremely large.

Finally, out of every chosen character from T , we take only  one randomly chosen bit to include in a specific key, increasing the unpredictability of the bits of the generated keys further.



V. ALGORITHMIC COMPLEXITY  It appears from the algorithm TBKG that Steps 1 to 3 are computed only once for generating the whole sequence of N keys, where N can be very large. Thus, the total computational overhead in executing these three steps will be distributed over all the N keys to be generated, making the overhead per key generation very small. Further, to generate a key of  2ND IEEE PERCOM Workshop On Security Privacy And Trust In The Internet of Things 2017    size S bits, the three statements of step 4.1, each of which takes constant time, need to be executed S times. For S = 32 (key size = 4 bytes) for which both the randomness tests and period measurement yield favorable values, the execution time as well as the overhead in energy for computing a key for a session transmitting 350 MB data appear to be negligibly small. For values of S upto 2048 (key size of 256 bytes), these values of computation time as well as energy requirements for computation will be very insignificant, making the proposed TBKG algorithm very suitable for random key generation in applications involving secure wireless communication.



VI. CONCLUSION  We have proposed a novel keystream generator algorithm TBKG that is significantly lightweight, yet secure in the context of wireless applications that use short sessions. The strength of TBKG has been established through statistical randomness tests by the standard NIST test suite, large period and high unpredictability due to the nature of tweets generated independently by thousands of people in social media. The proposed TBKG algorithm is very simple to implement in software and requires very small overhead in terms of compu- tation time and energy which make it particularly suitable for applications involving short secure wireless communication sessions such as in IoT. As future work, we intend to explore TBKG further in terms of improving its keystream generation rate, randomness and periodicity properties, computational, space and energy requirements.

