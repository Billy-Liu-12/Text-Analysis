Pre-Processing Structured Data for   Standard Machine Learning Algorithms by

Abstract - Graph propositionalization methods can be used to transform structured and relational data into fixed-length feature vectors, enabling standard machine learning algorithms to be used for generating predictive models. It is however not clear how well different propositionalization methods work in conjunction with different standard machine learning algorithms. Three different graph propositionalization methods are investigated in conjunction with three standard learning algorithms: random forests, support vector machines and nearest neighbor classifiers.

An experiment on 21 datasets from the domain of medicinal chemistry shows that the choice of propositionalization method may have a significant impact on the resulting accuracy. The empirical investigation further shows that for datasets from this domain, the use of the maximal frequent item set approach for propositionalization results in the most accurate classifiers, significantly outperforming the two other graph propositionalization methods considered in this study, SUBDUE and MOSS, for all three learning methods.

Key words ? structured data, graph propositionalization, random forests, support-vector machines, k-nearest neighbor, medicinal chemistry

I.    INTRODUCTION  Standard machine learning algorithms require data to be represented in an attribute-value format, where the examples are represented using feature vectors of fixed length [1]. However, in many cases, relevant information cannot easily be represented in a single table, since relations between the attributes are frequently occurring [2]. Therefore, in order to apply standard learning algorithms in such domains, either the relational aspects have to be omitted or some suitable transformation of the relations into an attribute-value format is required. To avoid loss of information, the latter approach should be adopted if possible, hence requiring an appropriate preprocessing method for including the structural information into the attribute-value format.

Propositionalization concerns enabling propositional (attribute-value) learners to handle relational learning problems [3].  A typical propositionalization method results in a feature vector representation, where the features encode relations [4]. A relational learner based on propositionalization first computes a set of propositional features and then uses a (standard) machine learning algorithm for model generation [5]. The decoupling of feature generation and model development hence enables standard learning algorithms to be used also for relational learning [3]. Graph propositionalization methods are a subclass of these methods that consider examples represented as graphs and in some way convert these into fixed-length feature vectors. Several approaches for generating classification models through propositionalization have been proposed in the past [3,4,5,6,7]. The propositionalization methods are usually embedded in discovery, prediction or classification methods, and are therefore seldom evaluated separately as pre-processing methods for standard learning algorithms.

In particular, it has so far not been carefully investigated in what way the predictive performance is affected by the choice of propositionalization method to use together with some selected standard machine learning algorithm. This study aims to shed more light on this question.

Commonly employed datasets for evaluating machine learning methods, such as those in the UCI repository [9], mostly concern non-relational problems and are hence not useful in large-scale evaluations of different graph propositionalization methods. In this study, we instead turn to the field of medicinal chemistry, in particular to the prediction of biological effects of chemical compounds. Several datasets from this domain are publicly available and they concern modeling tasks of various biochemical activities, such as absorption, distribution, metabolism, excretion and toxicity (ADMET) [10]. What is particularly interesting with these datasets from our perspective is that chemical compounds   DOI 10.1109/ICMLA.2010.128     are naturally represented as graphs, and hence they could serve as a test bed for propositionalization methods. In this study, we will empirically evaluate propositionalization methods when used in conjunction with different standard machine learning algorithms on datasets from the domain of medicinal chemistry.

The rest of the paper is organized as follows. In the next section, the three graph propositionalization approaches that will be evaluated in this study are presented. In section three, the experimental setup for the evaluation of these methods in the domain of medicinal chemistry is presented. In section four, the experimental results are shown and analyzed, and finally, the main conclusions and directions for future work are given in section five.



II.    GRAPH PROPOSITIONALIZATION METHODS   Graphs are natural data structures for structured or relational data, where nodes represent objects and edges represent relations. For example, a dataset containing web data may be represented as a set of graphs, where the nodes represent web pages and the edges represent links between the web pages. The graph propositionalization methods we consider in this study assume that nodes and edges are labeled, e.g., a node representing a web page could be labeled ?student?, while an edge representing a link could be labeled ?title?. We follow the graph propositionalization approach in [6], by which each example is represented by a set of triples on the form (Li,Lj,Ek), such that there is an edge, which has a label Ek in the graph of the example between nodes i and j that are labeled Li and Lj respectively. Following [6], such a set is referred to as a fingerprint. We further assume that each fingerprint has been assigned a class label, e.g., ?positive? or ?negative?.

The graph propositionalization methods considered in this study generate feature vectors where each feature corresponds to a sub-graph. We have selected two state- of-the-art methods for sub-graph mining; SUBDUE [11] and MOSS [12]. SUBDUE is a generic method for sub- graph discovery, while MOSS is a domain-specific sub- graph discovery method for chemo-informatics. In this study, we also consider another domain-independent graph propositionalization method that uses the algorithm for maximal frequent itemset mining [13,14] on the fingerprint representation described above. All these three methods, which are described below, may take labeled graphs as input.

SUBDUE ? SUBDUE [11] is a graph-based knowledge discovery system that finds structural and relational patterns in data representing entities and relationships.

SUBDUE represents relational data using labeled,  directed graphs, where the entities are represented by labeled vertices or sub-graphs, and relationships are represented by labeled edges between the entities [11]. It uses the minimum description length (MDL) principle to measure the interestingness of the sub-graphs discovered.

SUBDUE employs a step-by-step procedure, which starts from single nodes and performs a computationally constrained beam search in order to expand it by another node or edge, which results in a sub-graph. Therefore it typically generates a small number of sub-graphs that best compress the dataset. We have chosen SUBDUE as a reference method, since it is publicly available and the sub-graphs discovered by SUBDUE could be used as (propositional) features for standard machine learning algorithms. We have used the implementation of SUBDUE described in [15]. In order to discover sub- graphs efficiently, we have used the parameters eval=2 and prune, as described in [15].

MOSS ? MOSS [12] is an algorithm that can be used for discovering frequent molecular fragments in chemo- informatics databases. In doing so, MOSS also views molecules as graphs, where the atoms are the nodes and the bonds between atoms are the edges of the graph. The molecular fragment discovery algorithm of MOSS discovers molecular fragments that are referred to as sub- graphs, which best separate molecules that belong to different classes. The MOSS algorithm searches for arbitrarily connected sub-graphs, avoiding frequent embeddings of previously discovered sub-graphs by using a specific search strategy. The algorithm maintains parallel embeddings of a fragment into all molecules throughout the growth process and exploits a local order of the atoms and bonds of a fragment to effectively prune the search tree, which allows for a restricted depth-first search algorithm, similar to the Eclat association rule mining algorithm [12]. MOSS selects substructures that have a certain minimum support in a given set of molecules, i.e., are part of at least a certain percentage of the molecules. However, in order to restrict the search space, the algorithm considers only connected substructures, i.e., sub-graphs containing nodes that are connected to at least one other node. Similar to SUBDUE, MOSS has been included as a reference method, since it is publicly available and appears to be suitable in particular for the medicinal chemistry domain, where the frequent fragments discovered by MOSS can be used as features. The publicly available implementation of MOSS is used in our experiments together with the default parameter settings [16].

Supervised maximum frequent itemsets (SMFI) ? The popular Apriori algorithm for finding association rules was first introduced in [17]. This algorithm is based on analyzing common item sets in a set of transactions, which is technically referred to as frequent itemset     mining. The search space of this problem, which is all frequent item sets, is typically huge. Several approaches to efficiently explore the search space have been proposed that only consider a sufficiently large subset of all frequent itemsets. Among these, methods for finding the set of all closed or maximal itemsets are the most popular [18]. Given below is the definition of frequent itemset mining and maximal frequent itemset mining [13,14]:  Definition: maximal frequent itemset: Suppose we are given a set of items I, which is a set of literals. An item- set I ? I is some subset of items. For itemset I, a transaction including I is called an occurrence of I. The denotation of I, denoted by T(I) is the set of the occurrences of  I. |T (I)| is called the frequency of I; and denoted by frq(I): For a given constant ?, called a minimum support, itemset I is frequent if frq(I) ??. If a frequent itemset I is included in no other frequent itemset, I is called maximal.

When adapting this method for feature selection, a triplet (Li,Lj,Ek) described above is considered as an item in the itemset and a fingerprint is considered as a single transaction. Therefore, the maximal frequent item set  lI  ? Il, is defined in such a way that  Il is the collection of all triples in the input graphs with respect to the class l.

The maximal frequent itemset with respect to class l is generated using maximal frequent item set mining algorithm as defined in [14].  The collection of all the  discovered maximum frequent itemsets ? n  lI  with  respect to each class are taken together as the feature set discovered by the method. This approach is an extension to the unsupervised way of finding maximal frequent itemsets in [19], which considered all the input graphs in the maximal frequent itemset mining algorithm irrespective of the class.

In the experiments, we have used the maximal frequent itemset mining algorithm as implemented in MAFIA [18], together with 6 levels of support, namely 0.5, 0.4, 0.2, 0.1, 0.025 and 0.01. SMFI does not have an inbuilt pruning method, similar to the MDL principle employed in SUBDUE or minimum support employed in MOSS.

Instead, discrete levels of support are applied, which may not be fully optimal. The training set is partitioned into subsets according to class membership and the maximal frequent itemset mining algorithm is applied to each of these subsets of examples separately. The discovered itemsets with respect to all the classes are combined together as the feature set. 10-fold cross-validation is employed on the training set to investigate which of the above parameter setting gives the highest accuracy, and  this level of support is used for generating a model from the entire training set.



III.   EXPERIMENTAL SETUP  A. Methods The feature sets generated by each of the three propositionalization methods, SUBDUE, MOSS and SMFI, which were described in the previous section, are used in conjunction with three popular machine learning algorithms, as implemented in the WEKA data mining toolkit [20], namely random forests (RF) [21], support vector machines (the SMO algorithm) [22] and the k- nearest neighbor algorithm [23]. The number of trees generated by the random forest algorithm is set to 50. The parameters for the SMO algorithm are the RBF kernel with complexity 2. The IBk algorithm with the number of nearest neighbors k = 3 is used as the nearest neighbor classifier. We consider accuracy as the performance criterion, which is estimated using 10-fold cross- validation.

B.   Data sets 21 publicly available compound sets from the domain of medicinal chemistry [24] are used to test the null hypothesis, i.e., there is no difference in performance between the propositionalization methods. The compounds in each set have associated binary class labels, representing whether a molecule is active or not with respect to some measure of biological activity. The compounds in these datasets are represented by graphs, i.e., each atom in a molecule is a node of the corre- sponding graph and the arcs represent bonds among atoms.

It has been suggested in the past, e.g., in [3,25], that using the domain specific feature sets in conjunction with the machine learning approaches could help increasing the classifier accuracy. Therefore in addition to the features generated by the propositionalization methods, we also have used publicly available chemical descriptors as input features in conjunction with the generated features. The SELMA [26] descriptors consist of 94 different global properties of molecules and the Scitegic Extended Connectivity Fingerprints (ECFI) [27] descriptors consist of presence and non-presence of 1024 different molecular fragments. These descriptors are represented in attribute- value format and they have been used in conjunction with the feature sets generated by the three graph propositionalization methods.



IV.   EXPERIMENTAL RESULTS  The results from employing 10-fold cross-validation on the 21 data sets using the standard random forest algorithm, support vector machines and the nearest neighbor classifier in conjunction with the three different propositionalization methods are shown in Table I, II and III below. Each of the three tables corresponds to one of the learning algorithms, and the names of the data sets are given in the first column of each table. The subsequent columns contain results for the three propositionalization methods, when these features are used on their own (generated features only), when they are used in conjunction with SELMA descriptors (features+selma), and together with the ECFI descriptors (features+ecfi), respectively.

A.     Hypothesis tests  In testing the null hypothesis, the predictive performances of the three learning algorithms are analyzed separately.

For each algorithm, the results of different feature sets, i.e., generated features only, features+selma and features+ecfi, are also analyzed separately.  Therefore the same null hypothesis is tested in nine cases. For each case, the significance of the differences of the accuracies yielded by the three propositionalization methods is tested using the Friedman test [28]. The accuracies of the three methods are ranked and the average ranks are used for pair-wise tests according to [28].  A propositionalization method that fails to produce a feature set is assigned the lowest rank. Table IV gives the ranking of each method for all the nine cases. A single case corresponds to one feature set given in column 1 and one learning algorithm given in column 3, 4 or 5. Therefore the ranks given in Table IV are the relative performance of SMFI, SUBDUE and MOSS for the respective feature set and classifier algorithm.

Table IV: AVERAGE RANKINGS OF THE THREE METHODS   Method RF SMO IBk Features only smfi 1.24 1.10  1.30  subdue 2.14 2.24 2.10 moss 2.62 2.67 2.62  Features+ Selma  smfi 1.50  1.60  1.64 subdue 2.21 2.26 1.76 moss 2.29 2.14 2.60  Features+ecfi smfi 1.83 1.74 1.64 subdue 1.83 2.14 1.76 moss 2.33 2.12 2.60   The null hypothesis is not rejected when the generated features are used with the ECFI descriptors in conjunction with random forests and support vector machines. The pairs of methods for which one can conclude that there is a significant difference of ranks is summarized in Table V  below.  The winning method is given in boldface in Table V.

TABLE V: RESULTS OF PAIR-WISE STATISTICAL TESTS FOR THE THREE PROPOSITIONALIZATION METHODS    It is interesting to note that the classifier accuracy for SMFI is significantly better than for SUBDUE and MOSS, when the features generated by the methods are considered alone in the classification (features only). The differences between the methods are not as emphasized when they are considered in conjunction with existing chemical descriptors. In particular, the differences are not significant at all when the ECFI descriptors are used with random forests and SMO.

The method SMFI was able to discover at least one important feature with respect to all the 21 datasets, whereas SUBDUE and MOSS fails to do so for some datasets. It is worth noting that MOSS could not discover any feature for 6 out of 21 datasets, which is also reflected by its low performance. One reason for the inability to generate features in some cases could be that MOSS considers only sub-graphs that are connected.  In contrast, the discovered patterns of SUBDUE could contain even a single node, while the feature discovery approach of SMFI naturally allows discovering sets of sub-graphs that are not connected. For example, a feature discovered by SMFI such as {S-c, c-O, c-c, c-N, c-c}, which is a collection of molecular fragments, could either be inter- connected or disconnected. The other two methods will not include such a set of sub-graphs in one feature. The success of SMFI indicates that features of this type may be quite important for the type of datasets considered in this study. It is also worthwhile to note that SMFI is a na?ve kernel which simply computes the average kernel between all pairs of edges. [8] suggests that such a na?ve kernel could perform comparable to sophisticated kernel methods.



V.    CONCLUDING REMARKS  Graph propositionalization methods can be used as pre- processing methods for standard machine learning algorithms, transforming structured data into fixed-length feature vectors. In this study, three propositionalization  Classifier features only features+selma features+ecfi RF   smfi  vs subdue smfi  vs moss  smfi  vs subdue smfi vs moss  Null hypothesis is not rejected.

SMO smfi  vs subdue smfi  vs moss  smfi  vs subdue smfi vs moss  Null hypothesis is not rejected.

IBk smfi  vs subdue smfi  vs moss subdue vs moss  smfi vs moss subdue vs moss  smfi vs moss subdue vs moss     methods, MOSS, SUBDUE and SMFI, have been studied in conjunction with three standard machine learning algorithms, namely random forests, support vector machines and nearest neighbor classifiers. An empirical evaluation on 21 data sets from the domain of medicinal chemistry showed that the choice of propositionalization method may have a significant impact on the resulting accuracy. The experiment further showed that the SMFI method outperformed the other two graph propositionaliz- ation methods, SUBDUE and MOSS, for all the three learning algorithms that were considered in this study.

As a further improvement to the graph propositionali- zation using SMFI, one could employ a suitable technique for finding the optimal threshold for the mfi algorithm in [18]. This contrasts to the approach employed in this study, which selects parameter values from a finite set based on cross-validation on the training set. It could also be interesting to investigate the classifier performance with different feature sets merged in one feature vector.

For example, different molecular descriptors, features discovered by subgraphs, kernels, ILP or boosting methods could be used in one such feature vector.

Another direction for future work, which would be interesting from a medicinal chemistry perspective, is to compare the predictive performance of the classifiers obtained from using only the existing molecular descriptors to those generated from the extended feature sets, and investigate to what extent QSAR modeling with the standard molecular descriptors could be improved by using them in conjunction with graph propositionalization methods. One other possible direction for further studies is to carry out a similar experiment on data from other domains, such as web document classification. One could also combine different feature sets derived by different feature discovery methods and investigate in which way the combinations of such feature set affect the performance.

