Finding Cross-Object Relationships from Large Databases

abstract While traditional association rules demonstrate strong potential values such as to improve market strategies for retail industry, they are limited to finding associations among items within the same transaction. Consider a database of supermarket transactions, the traditional association rules can represent such knowledge as ?80% of customers who buy Chinese tea also buy teapot at the same time.? However, they fail to represent some more interesting rules like ?If a customer buys Chinese tea, s/he may most likely buy teapot within 3 days?, where the association may span across different transactions. To capture this contextual semantics which are also vital to the validation of associations, in this study, we introduce the notion of cross-object relationships. Two algorithms for mining cross-object association rules from large databases are developed by extension of Apriori algorithm. We show that traditional associations can be treated as a special case of cross-object relationships from both conceptual and algorithmic point of view.

1 INTRODUCTION Since the problem of mining association rules was introduced in [l], a large amount of work has been done in various directions, including ef- ficient, Apriori-like mining methods [2, 9, 18, 15, 16, 22, 24, 51, mining generalized, multi-level, or quantitative association rules [19, 20, 6,  12, 10, 81, association rule mining query languages [ 11, 231, constraint-based rule mining [13, 21, 23, 3, 71, incremental maintenance of discovered associ- ation rules [4], cyclic and interesting association rule mining [14, 171, etc. Despite these efforts, there is an important form of association rules which are useful but could not be discovered with existing association rule mining framework.

Consider a database of supermarket trans- actions, the traditional association rules can  0-7803-5731-0/9!&$10.00 01999 IEEE  represent such knowledge as ?lSO% of customers who buy Chinese tea also buy teapot at the same time.? However, they fail to represent some more interesting rules like ?If a customer buys Chinese tea, s/he may most likely buy teapot within 3 days?, where the association may span across different transactions. In order to capture this contextual semantics into the association rules, in this paper, we introduce the notion of cross-object association rules. Two algorithms for mining cross-object relationships from large databases are developed by extension of Apriori algorithm.

The remainder of the paper is organized as fol- lows. In section 2, we give a formal definition of cross-object association rules. Two algorithms for mining such association rules from databases are described in section 3. We evaluate the per- formance of the algorithms on both synthetic and real-life data sets in section 4. Section 5 concludes the paper.

2 CROSS-OBJECT ASSOCIATION RULES  2.1 Preliminaries In the traditional association rule mining, the database to be mined is organized as a set of records based on transaction time. Except being largely used as record partition measurement, such transaction time has received less explo- ration.

In reality, many real-world associations do happen in certain context. Transaction time here is one kind of contextual information.

Taking supermarket as an example, we may find rules like ? i f  a customer buys Chinese tea, s/he will most likely buy teapot 3 days later.? Here, besides items, the intervals of transactions also play equally important role in the occurrence of associations. We refer to such interval as one kind of context.

In addition to time property, we can integrate other contextual information like location into  V -8776    TID dimensional attribute item list a, b, c c, d, e  T3  day3 a, b  Table 1: A single-dimensional database  association rule mining as well. Virtually, we can enhance the traditional transaction model by a set of dimensional attributes, describing the con- text where the transaction happens. The dimen- sional attributes can be any kind of attributes as long as they are meaningful to  the applications.

Time, distance, temperature, latitude, etc., are typical dimensional attributes.

In this paper, we focus on single-dimensional context, where only one dimensional attribute is used. Assume that the domain of the dimen- sional attribute is ordinal and can be divided into equal-sized intervals. For instance, time can be divided into day, week, month, etc., and dis- tance into meter, mile, etc. We use a to describe the relative difference between two transactions represented by the dimensional attribute, such as a day, a kilometer, etc.. When a=O, the cross- object association rules become the traditional association rules.

2.2 Definitions Let Z = {il, is,. . . , is} denote a set of literals, called items. Let C = ( ~ 1 ~ ~ 2 , .  .. , c m }  be the domain of the dimensional attribute. Each element of C can be thought of as an address in the context. A transaction Ti is defined to be a set of items Ii (Ii 2 Z) happening in ci (ci E C), denoted by Ti.(ci, I*). For example, the price of stock A rises on January 4, shop B is opened in the suburb, plant C blooms 2500 metres above sea level, etc. A simple one-dimensional database is shown in Table 1.

For each item, we can similarly attach an ad- dress, stating where the item occurs. Here, item address can be in two different formats: (1) ab- solute address, denoted by i.(c), indicates that item i appears at the address c; ( 2 )  relative ad- dress, denoted by i(Ai), indicates that i appears Ai away from a reference base point. If the base address is a, the absolute address of i is + Ai.

In the following, we refer to an item with its rel- ative address as an extended item. Note that, with the same base address a, two extended  items a(0) and 4 2 )  are different, although both of them have the same item a .  We use Z? to represent the set of all the possible extended items. Similarly, we call a set of extended items as extended itemset. For simplicity, we use extended itemset and itemset interchangeably.

With the above notations, we are now in a posi- tion to  define the cross-object association rules.

Definition 1 Given a set of transactions T = {Ti-(ci,Ii), T2.(Cz712), . . . , Tk.(Ck,In)) and an extended itemset X = {il(Al), i2(A2>, ..., im(Am)}, T is said to contain X if and only if there exists a base address Q (Q E C ) , such that for every i,(A,) E 2?, there exists Tj.(cj, I j )  E T, SO that (1) CO + A, = Cj; and (2) i, E Ij  In the example database shown in Table 1, the transaction set (T2, T3, T4} contains extended itemset {c(O), a(l), a(2 ) } ,  with respect to the reference base address day2  Definition 2 A cross-object association rule is an implication of the form X + Y , where X c Z?, Y c Z?, and X n Y = 8.

Based on this definition, a rule that predicts the stock price movement, ?if the price of stock A increases one day, and the price of stock C in- creases the following day, then most probably the price of stock B will increase on the third day? can be expressed by a cross-object association rule as: a(O),c(l) + b(2).

Similar to traditional association rules, we use support and confidence as two major cross-object association rule measurements.

Definition 3 Let T,, be the set of transaction sets containing extended itemsets X U Y, T, be the set of transaction sets containing X, and 101 be the total number of transactions in the database. The support and confidence of a cross-object association rule are defined as:  cmfidence(X + Y) = lTz,l/lT,l.

s2lppart(X * Y )  = lTzyl/l~l  3 MINING CROSS-OBJECT ASSOCIATION RULES  Similar to the traditional association rule mining, we first discover the frequent itemsets which have transaction support above a pre- determined minimum support; and then use the frequent itemsets to generate cross-object association rules.

V -877    Under the framework of cross-object as- sociation rules, a k-itemset is of the form {ii(A1),i2(A2), . . . , i k ( h k ) } ,  where item i j , 1 5 j 5 k, is attached by a non-negative value Aj indicating the relative address with respect to the base address of the set. For example, a 3-itemset {a(O), b(l), ~ ( 3 ) )  contains three items expressed in relative addresses along the dimension. That is, taking a transaction containing item a as the base transaction, b(1) denotes an item b contained in a transaction with 1 unit distance away from the base transaction, and c(3) represents an item c in a transaction 3 unit distances away from the base transaction. This is quite different from the classical definition of itemset { i l ,  i ~ ,  . . . , i k }  in which all items lie within the same transactions.

To find the frequent itemsets, two algorithms, E-Apriori and EH-Apriori, were implemented which are extensions of Apriori-based algorithms [2, 151. Let Lk represent the set of frequent k- itemsets, and ck the set of candidate k-itemsets.

Both algorithms make multiple passes over the database. Each pass consists of two phases.

First, the set of all frequent (Ic-1)-itemsets L k - 1 , found in the (k-1)th pass, is used to generate the candidate itemset c k .  The candidate generation procedure ensures that c k  is a superset of the set of all frequent k-itemsets. The algorithms now scan the database. For each list of consecutive transactions, they determine which candidates in c k  are contained and increment their counts.

At the end of the pass, c k  is examined to check which of the candidates are actually frequent, yielding Lk. The algorithms terminate when Lk becomes empty.

As previously reported in [15], the processing cost of the first two iterations (i.e., obtaining L1 and L2) dominates the total mining cost. The reason is that, for a given minimum support, we usually have a very large L1, which in turn results in a huge number of itemsets in C2 to process. In the cross-object association rules, this situation becomes much more serious as a lot of additional 2-itemsets like {a(O),a(l)} may be added into C2, thus leading to a huge amount of IC2 I .  In order to construct a significantly smaller C2, EH-Apriori adopts a similar technique of hashing as [15] to  filter out unnecessary candi- date 2-itemsets. When the support of candidate C1 is counted by scanning the database, EH- Apriori accumulates information about candi- date 2-itemsets in advance in such a way that all possible 2-itemsets are hashed to a hash table.

Each bucket in the hash table consists of a num- ber to represent how many itemsets have been hashed to  this bucket thus far. Such resulting hash table can be used to greatly reduce the number of 2-itemsets in C2.

4 PERFORMANCE STUDY To assess the performance of the mining algo- rithms, we conducted a series of experiments on both synthetic data and real-life data.

4.1 Generation of Synthetic Data The method used by this study to  generate syn- thetic data is similar to the one used in [2] with some modifications noted below. Table 2 sum- marizes the parameters used and their settings.

We first generate a set L of the potentially frequent itemsets, which may span several transactions, e.g., {a(O), b(l), c(2)}, and then assign a frequent itemset from L to transactions.

Items and their relative addresses (intervals) in the first frequent itemset are chosen randomly, where item is picked up from 1 to N ,  and its interval is picked up from 0 to W .  To model the phenomenon that frequent itemsets often have common items and intervals, some fraction of items and their intervals in subsequent itemsets are chosen from the previous itemset generated.

We use an exponentially distributed random variable with mean equal to  the correlation level to  decide this fraction for each itemset. The remaining items and their intervals are picked at random. After generating all the items and intervals for a frequent itemset, we revise each of its intervals by subtracting the minimum interval value of this frequent itemset. In this way, the minimum interval of each potentially frequent itemset is always 0.

After generating the set L of potentially fre- quent itemsets, we then generate transactions in the database. Each transaction is assigned a series of potentially frequent itemsets. How- ever, upon the generation of one transaction, we need consider a list of consecutive ones start- ing from this transaction, as items in a frequent itemset may span across different transactions.

For example, after selecting the frequent itemset {a(O), b ( l ) ,  4 2 ) )  for current transaction T,, we should assign item a to T,, item b to  its next transaction Tc+l, and item c to Tc+2. If the frequent itemset picked on hand does not fit in the current or any one of its successive transac- tions, this itemset is put in these transactions  v -878    Parameter Meaning number of transactions average size of the transactions maximum size of the transactions number of potentially frequent itemsets average size of the potentially frequent itemsets maximum size of the potentially frequent itemsets  P I IT1 IMTl ILI lMIl N number of items R maximum interval of itemsets  anyway in half the cases, and the itemset enters an unfit queue for the next transaction the rest of the cases. Each time, we pick itemsets from this queue first according to the first-in-first-out principle. Only when the queue is empty, do we perform random selection from the set L.

4.2 Experiments on Synthetic  Figure 1 shows the basic behavior of the algo- rithms when the minimum support changes.

When the minimum support increases, the execution times of both E-Apriori and EH- Apriori decrease because of reduction in the total number of candidate and frequent itemsets. Throughout the experiments, EH- Apriori is always far superior over E-Apriori.

For example, in Figure l(a), when minimum support is 0.7%, the mining time of EH-Apriori is about 23 seconds while that of E-Apriori is about 226 seconds. The former only needs to spend 10% time of the latter in getting the same cross-object association rules. This is due to the fact that, although the execution time of the first pass of EH-Apriori is slightly longer than that of E-Apriori due to the extra overhead required for building HashTabZe, it incurs significantly smalled execution time than E-Apriori in later Pass 2, as IC21 is decreased greatly. By checking the detailed experimental records, we find that the number of candidate 2-itemsets reduces from 305283 to 17403 by means of hash filtering (at T5-13-W3-N500-D10K7 minimum support=0.7%). Less IC21 results in much less time to test against each transaction of the database. Because the execution time of the first two passes dominates the total execution time for mining cross-object association rules, we employ hash techniques only in the early Pass 2 to achieve performance improvement.

Data  Setting 5000 - 25000 4 - 8 7 -  11 1.5, 3 4, 7 300 - 500 0 - 3  From this preliminary experiment, we note that strategies aiming at  pruning unnecessary candidates for the cross-object association rules can offer much more benefits than for the traditional association rules.

4.3 Experiments on Real Data To test the applicability of cross-object association rules, we run the algorithms against a data set collected from Singapore Stock Exchange (SSE), from which we create a LOSER set that contains the counters whose closing prices are less than the previous closing prices. We like to have the complete data set for every trading day of 1996. As the result, we have 250 records corresponding to 250 trading days in 1996. Although there are a few hundred counters in SSE, we only have complete data for 84 counters. Furthermore, as the major trend for SSE in 1996 is down side, the average transaction size of LOSER is pretty large (more than 70).

Figure 2 shows the experimental results on the LOSER data set, from which one example rule found is UOL(O),SIA(l) j DBS(2).  It says that, if UOL goes down and SIA goes down the following day, DBS will go down on the third day with confidence more than 99%. (Here, UOL stock represents lands market, S I A  stock repre- sents loans and debentures, and DBS represents banking market.) This rule reveals the closely causal relationships among three major stocks in Singapore. As known, the land properties in Singapore play an important role in national economic development. The decaying of land properties inevitably leads to bad performance of loans and debentures and bank. From such discovered rule, we may get to know some char- acteristics of economic structure in Singapore more or less.

v -879    0.6 0.7 0.8 0.9 1 Minimum Suppm (%)  (a) T5-13-W3-N500-D10K  EH-Apriori E-Apriori - 9.-  0.6 0.7 0.8 0.9 1 Minimum Support (%)  (d) T8-11.5-W3-N500-D10K  Figure 1: Minimum support versus execution time  I 40   Separate Joint  @Pass 1 =Pass 2 OPass 2 m0 Pass 4 ~=98% ~=96%  Separate Joint  Figure 2: Execution time on LOSER data set, support=98%  Our study using stock movement data is on- going. The results obtained so far do indicate , that, with cross-object association rules, we can discover more comprehensive and interesting knowledge, and EH-Apriori algorithm can always achieve better performance than E- Apriori algorithm regardless of large or small average transaction size.

5 CONCLUSION In this paper, we introduce the notion of cross-object association rules. These rules can represent not only the associations of items within transactions, but also associations of items among different transactions. The classical association rules can be viewed as a special case of the cross-object association rules.

We implement two algorithms for finding such association rules by extension of Apriori. Our performance studies on both synthetic and real- life data sets show that the strategies to  prune unnecessary 2-itemsets from the candidate set  C, is more beneficial to the overall performance than it is in the case of traditional association rules.

As we only consider single-dimensional mining context in this paper, one future work is to incor- porate multiple dimensional attributes into the mining process. Performing distributed and/or parallel cross-ob ject association rules mining is another further work we are interested in.

Acknowledge This work is supported by Hong Kong Govern- ment University Grants Council - CERG PolyU 50741983.

