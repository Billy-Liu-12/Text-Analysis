Performance Tuning of Steganography Algorithm

Abstract- Privacy and security issues in data mining become an  important property in any data mining system. A considerable  research has focused on developing new data mining algorithms  that incorporate privacy constraints. In this paper, we focus on  privately mining association rules in vertically partitioned data  where the problem has been reduced to privately computing  Boolean scalar products. We propose a modification of  steganography-based multiparty protocols for this problem. The  proposed modification fine tune the performance to be faster in  case of very large database, with acceptable level of reduction in  privacy.



I. INTRODUCTION  Privacy preserving data mining is an important property  that any mining system must satisfy. There are many methods  for privacy preserving distributed association rule mining  across private databases. So these methods try to compute the  answer to the mining without revealing any additional  information about user privacy. An application that needs  privacy preserving distributed association rule mining across  private databases, like medical research. There are some  existing techniques that one might use for building this  application, but they are inadequate related to some  disadvantages. One from these techniques is trusted third  party. The main parties give the data to a ?trusted? third party  and have the third party do the computation [1]. However, the  third party has to be completely trusted, both with respect to  intent and competence against security breaches. The level of  trust required is too high for this solution to be acceptable.

Also data perturbation technique has different idea, the idea is  that the distorted data does not reveal private information,  and thus is ?safe? to use for mining. The key result is that the  distorted data, and information on the distribution of the  random data used to distort the data, can be used to generate  an approximation to the original data distribution, without  revealing the original data values. The distribution is used to  improve mining results over mining the distorted data  directly, primarily through selection of split points to ?bin?  continuous data. Later refinement of this approach tightened  the bounds on what private information is disclosed, by  showing that the ability to reconstruct the distribution can be  used to tighten estimates of original values based on the  distorted data [2].

Another approach is secure multi-party computation. In this  approach given two parties with inputs x and y respectively, the goal  of secure multi-party computation is to compute a function f(x,y)  such that the two parties learn only f(x,y), and nothing else [3]. In [4]  an efficient protocol for Yao?s millionaires? problem showed that  any multi-party computation can be solved by building a  combinatorial circuit, and simulating that circuit. A variant of Yao?s  protocol is presented in [5] where the oblivious transfers is used to  make secure decision tree learning using ID3 with efficient  cryptographic protocol. There are many methods for privacy  preserving distributed association rule mining across private  databases when databases partitioned vertically. The problem is  reduced to compute scalar product between these databases [6]. Any  one can use set-intersection protocols for online recommendation  services, online dating services, medical databases, and many other  applications and also for mining over vertical data bases. There are  some existing techniques that one might use for solving the problem  of private scalar product but they have some problem like increasing  the running time of computing the scalar product [7]. In any method  of the above, the main concentration is to make better privacy  preserving with high performance. When the data base goes large  the overhead of adding the privacy will degrades the performance,  so some algorithms are proposed to solve this problem of mining  very large databases as in [8],[9]. To gain high performance with  acceptable level of privacy in case of large database, we need fast  technique for computing scalar product. So we try to reduce the  computation time of computing scalar product, by using smaller  matrix to hide the vectors used in computing the scalar product. In  this work we propose a modification of steganography-based  multiparty protocol for computing scalar product. Our modification  gives suitable solution for tradeoff between the performance and  privacy.

The organization of this paper is as follows. An overview about  the problem and related work in the area of privacy preserving data  mining for association rule mining on distributed heterogeneous  (vertically partitioned) databases given in section 2. Section 3 shows  the details of modified algorithm of computing the scalar product,  illustrative examples, and security analysis and evaluation metrics  are presented. Section 4 describes the implementation and results of  modified an algorithm verse the old algorithm. Finally, some  conclusions are put forward in Section 5.



II. DISTRIBUTED ASSOCIATION RULE MINING AND PROBLEM DEFINITION  Association rule mining is one of the most important data mining techniques used in many real life applications. It is used to reveal unexpected relationships in the data. By assuming heterogeneous databases: each site has different schema. The goal is to produce association rules that hold globally, while limiting the information shared about each site to preserve the privacy of data in each site.

Let there be k parties S1, S2, . . . , Sk. We consider a  heterogeneous database scenario, a vertical partitioning of the  database between the k parties. The association rule mining  978-2-9532443-0-4 ? 2008 ESRGroups France 1    problem can be formally stated as follows: Let I = {i1, i2, ? ? ? ,  in} be a set of literals, called items. Let D be a set of  transactions, where each transaction T is a set of items such  that T? I. Associated with each transaction is a unique identifier, called its TID. We say that a transaction T contains  X, a set of some items in I, if X?T. An association rule is an implication of the form X Y , where X ?I, Y? I, and X ?Y =?.  The rule X Y holds in the transaction set D with confidence c if c% of transactions in D that contain X also  contain Y . The rule X Y has support s in D if s% of the  transactions in D contains X ?Y.

The association rule mining problem can be decomposed  into two distinct sub problems first generate all combinations  of items that have support at least minimum support then for  every frequent found in the first step, generate all rules from  it with minimum confidence. Most of the work done so far  has focused on the first problem since generating the  corresponding association rules from the frequent itemsets is  a not difficult task. The most known algorithm for mining  frequent itemsets is the Apriori algorithm [10]. With in this  algorithm, the set of transactions is viewed as a database D  with n rows and m columns, every row corresponding to a  transaction and every column corresponding to an item. Each  entry in the database is 0 or 1, specifying the absence or  presence of items in the set of transactions. In other words, if  the i th  row in the database corresponds to transaction ti and  the j th  column corresponds to item Ij, then the j th  entry in row i  (denoted by ti[j]) indicate whether or not ti contains Ij .

There are two main partitioning methods for distributed  data base are horizontal and vertical partitioning. For  studying privacy-preserving data mining it is useful to  consider how data may be partitioned among the involved  parties. In some cases, organizations may collect the same  kind of data about different entities (for example people,  traffic, etc.). From a database perspective, we may then say  that the data is partitioned horizontally; that is, the same  schema is used to store the data at each site. In other cases,  organizations may organize data using different schemas,  meaning that they collect different kinds of data, perhaps on  the same entities. We then say that the data is partitioned  vertically.

Consider the database is partitioned vertically into two  sets of columns, the first set (denoted by DB1) consisting of  the first a columns (more precisely, the columns  corresponding to items (I1, I2, . . . , Iz), and the second one  (denoted by DB2) consisting of the remaining (m-z) columns  (i.e., the columns corresponding to ( Iz+1, Iz+2, . . . , Im). Also,  consider that we have two parties A and B, such that DB1  belongs to party A and DB2 belongs to party B. The two  parties want to collaboratively find the frequent itemsets in  DB = DB1?DB2 without any party revealing its own database this can computed as in figure 1 [2]. Assume that the  two parties want to find out if the itemset { Ia1, Ia2, . . . , Iap,Ib1,  Ib2, . . . , Ibq } is frequent, where { Ia1, Ia2, . . . , Iap } ?  {I1, I2, . . . , Ia} and { Ib1, Ib2, . . . , Ibq } ?  {Ia+1, Ia+2, . . . , Im}. First, party A forms an n-dimensional column vector  ? X , whereas  party B forms an n-dimensional column vector ? Y  , such that  the i th  component of ? X  (denoted by  ? X [i]) is as equation 1.

And the i th  component of ? Y  (denoted by  ? Y  [i]) is as  equation 2. Where tA,i is the i th  transaction in database DB1  and tB,i is the i th  transaction in database DB2.

? = ?  = p  j jiA atiX  1 , ][][                            (1)  ? = ?  = p j jiB  btiY 1 ,  ][][                             (2)  ?? YX .  =  ?  =  ? ][].[  iYiX  n  i  (3)  The scalar product between ? X and  ? Y is defined as in  equation 3.

input: DB1 and DB2  output: the frequent itemsets in DB = DB1?DB2 L1={large 1-itemsets} K= 2  while Lk 1 ?? do Ck =Apriori-gen(Lk 1)  for all candidates c ? Ck do If all the items in c are entirely at A or B Then  that party independently computes c.count  else Let A have items Ia1, Ia2, . . . , Iap and B  have the remaining items Ib1, Ib2, . . . , Ibq.

? = ?  = p j jiA  atiX 1 ,  ][][ for all I =1,?..,n  ? = ?  = p j jiB  btiY 1 ,  ][][ for all I =1,?..,n  c.count = ?? YX .

end if  end for  Lk=Lk ? {c | c.count ?  minimum support} K= k + 1  end while  return L1 ?. ..? Lk 2  Figure 1. Apriori Algorithm for Vertically Partitioned Data  Determining if the itemset { Ia1, Ia2, . . . , Iap,Ib1, Ib2, . . . ,  Ibq }is frequent reduces to testing if ?? YX . ?  minimum  support. Thus, the two parties want to compute the scalar  product ?? YX .  without any party revealing its own vector.

This idea can be easily incorporated into the Apriori  algorithm. Also this idea can be easily extended to more than  two parties.

A. Related Work  Within the context of privacy-preserving data mining [11],  several private shared scalar product protocols have been  proposed. The goal is that one of the participants obtains the  scalar product of the private vectors of all parties.

Additionally, it is often required that no information about the  private vectors, except what can be deduced from the scalar  product, will be revealed during the protocol. Moreover,  since data mining applications work with a huge amount of  data [8], it is desirable that the scalar product protocol is also  very efficient. A secure scalar product protocol has various  applications in privacy preserving data mining, starting with  privacy-preserving frequent pattern mining on vertically  distributed database and ending with privacy-preserving  cooperative statistical analysis .

B. Fast Steganography-based Multi-Party Protocols for  Privacy-Preserving Association Rule Mining in  Vertically Partitioned Data  Steganography [17] is the science of hiding secret messages in other messages. So this prevents an observer from learning anything unusual is taking place. Some     methods use this concept in the context of computing scalar products under privacy constraints.

In [12] proposed a method for computing the scalar  protocol. Main idea is to hide the data of all sites in the  protocol in a large matrix with the use of some random  variables. These variables used to mark the needed values to  obtain the final results. The method working as following.

Let P1,P2,. . . ,Pk be k parties, and let ? Xi be the Boolean  column vector corresponding to party Pi (all vectors have the  same size n). Also, consider that Pk is the initiator of the  protocol. The parties want to collaboratively compute the  scalar product ?  1X * ?  2X * ?  3X *?* ?  Xk  without any party  revealing it own vector to the other parties. First, Pk forms a  Boolean matrix Mk such that ?  Xk is the t th  column in Mk, and  the rest of the columns in Mk are randomly generated. The  number of columns in Mk (denoted by q) is fixed by party Pk (or can be considered as an input parameter for the  protocol).

The important thing here is that t is randomly generated by Pk and not revealed to the other parties. Then, for each i = k, k  1, . . . , 2 party Pi sends Mi to party Pi 1. When Pi 1 receives Mi,  it forms a new matrix Mi 1, such that Mi 1[l, c] = Mi[l, c] ? Xi .

Finally, party P1 sends to party Pk a tuple (p1, p2, . . . , pq),  where pj is the number of 1?s in the  j th  column of M1. At this point, party Pk knows that  pt= ?  1X * ?  2X * ?  3X *?* ?  Xk . From point of view for security  analysis in this protocol we find that the site k-1 can know the  data of site k with probability 1/q. In the same paper a  modification is presented  by instead of inserting ?  Xk as one  column, they put entry i in any column of  row i and the size  of matrix M is 2 n  columns and n rows such that n is number  of entries in vector ?  Xk . The improvement is more secure but  with partial information loss because we now certain that  entry number i is in row number i . But site k-1 can know the  data of site k with probability 1/2 n .

In the same area of privacy preserving association rule  mining over vertical data bases there is a lot of work done  like in [13] they showed how to make minimal information  sharing across private databases, and develop protocols for  intersection, equijoin, intersection size, and equijoin size. In  [14] consider the problem of computing the intersection of  private datasets of two parties, where the datasets contain lists  of elements taken from a large domain. In [15] describe a  provably private scalar product protocol that is based on  homomorphic encryption and improve its efficiency so that it  can also be used on massive datasets, in [7] proposed an  algorithm that make privacy preserving association rule  mining over vertical data bases using cryptography and in [16]  some modification are presented to the protocol in [12] to  increase security, but using cryptography .



III. Proposed NEW algorithm and illustrative example  A. proposed new algorithm  To improve the performance of the protocol which  described above in [12], we need to reduce the size of matrix  used to hide the information in it, to enhance the performance.

Our main idea is to reduce the number of columns. Divide the  vector of any site to x sub-vectors and each sub-vector has  size (n/x) elements. the matrix that will used to hide the  vectors during the protocol has size n x 2 x  where n is the  number of elements in any one of vectors used in computing  the scalar product and x is number of sub-vectors. Then apply  the algorithm as in figure 2.

Protocol  : protocol for computing size of intersection between K sites  Require: k > 3 sites numbered i: 1 . . . k, each having a local Boolean vector LVi, all LVi elements is 0 or 1, x is number of sub vectors .

Step1: all sites divide it?s local vector to x sub vectors  at site 1 :  construct M with Size n x 2x  generate x random variables r1,r2,r3,?,rx for each sub vector i M[ j][ri] =LV[((i-1)*(n/x))+j] //i =1,2,...,x   and  j=1,2,3,?.,n/x  end for  fill all other values by (0 or 1) Step 2: computing the product between all sites  for each site i do  //i:2??.k receive M  from site i-1  multiply  M with LVi send M  to site i+1  end for  send M to site 1 Step 3: compute the intersection  construct vector P that P[(i-1)*x)+j]= M[j][ri]  //i =1,2,...,x and  j=1,2,3,?.,n/x  publish the product P =  =  n  i  iP  ][  Figure 2. proposed new algorithm  B. Illustrative Examples  We describe the new protocol by considering a running  example involving three parties. The extension to more than  three parties follows the same idea. Let P1, P2, P3 be three  parties that want to collaboratively compute the scalar  product LV 1 LV 2 LV3, where  =       1LV 15 x =       2LV 15 x =       3LV 15 x  are the vectors associated with P1, P2, P3, respectively. Each  of the vectors has size n = 5. Let P1 be the initiator of the  protocol. The protocol makes use of a randomly generated  parameter, denoted by r, which is available only to the  initiator of the protocol (in our case, P1), and is used to hide  the input vectors within the matrices constructed during the  protocol. In our running example, we choose the number of  sub vectors is x = 3 then we need three random number  r1=2,r2=4,r3=3 and the size of the sub vector is n/x.

Step 1. First, P1 forms an (n  2 x ) matrix where the r1  th  column of M is first sub-vector and  r2 th  column of M is  second sub-vector and r3 th  column of M is third sub-vector  and the rest of the entries are randomly generated Then, P1  sends M to P2.?  =         85 xM  Step 2. Upon receiving M from P1, P2 forms an (n  2 x )  matrix where?M[l][ c] = X2[l] *  M[l][ c]  for all l, c. Then, P2 sends M to P3. And when received at P3 make the same thing as in P2.

At site 2:  =         85 xM  At site 3:  =         85 xM  Finally send M to P1.

Step 3. Construct vector P that P[(i-1)*x)+j]= M[j][ri]  //i =1,2,...,x and  j=1,2,3,?.,n/x  Then publish the product P =  =  n  i  iP  ][  =       15 xP  We can extend the above idea by using larger vectors.

Suppose that we have five vectors with number of elements  equal to 256. We choose size of sub-vectors to be 4 then we  have 64 sub-vectors. The matrix used to hide the vectors will  be 256 x 2  . As above we will insert the sub-vectors of first  site in the new matrix and apply the above algorithm as in  figure 2.

C.   Security Analysis and evaluation metrics  To ensure that our protocol preserve the privacy we need  to proof that. In addition to privacy we also measure  performance to evaluate our protocol using the computation  cost of running the algorithm.

? Security Analysis  Theorem 1: Our algorithm privately computes the scalar  product of any number of vectors  present in the database  without revealing any private information about users of data  base .

Proof. To show that our algorithm preserves the privacy  can be done by using the idea of simulating every thing  during the protocol running to know what data every site see  in running the protocol [3]. The proof as following. During  the protocol all values in M is random based in choosing X  and Z so we will compare our method with old one using the  probability that k-1 can know the data of site k. For our  protocol the probability is (1/2 x * n/x) instead in [12] is (1/2n ).

We can say that our new protocol is faster and also with  acceptable level of privacy in large data bases.

? Evaluation metrics  To measure the performance of our method we use  computation cost as performance metrics. Cost estimation for  association rule mining using the method we have presented  can be computed as following: The number of sites is k. Let  the total number entries in local vector LV is n. The factor  that used to make sub-vectors is n/x. Then total computation  cost for our protocol is O(k*n*2 x ) and the algorithm in [12]  need O(k*n*2 n ) and 2  n is number of columns in message of  the protocol. So if 2 n and 2  x are close then the two algorithms  have the same running time. Our algorithm gives a suitable  solution for trade off between the performance and privacy.

From this we can say that our protocol is flexible in the size  of matrix used to hide the data during the protocol. In very  large scale data bases we can use appropriate matrix size to  gain better performance.



IV. IMPLEMENTATION AND RESULTS OF PROPOSED METHOD  We implement our new method and algorithm in [12]  using java. Our test in data that represent based on 0/1 matrix.

By running  the new algorithm 500 tests done, and 600 tests  for old algorithm on  heterogamous  data bases with different  size from 1000 bytes to 60000 bytes with number of  attributes 5 and 10 by 10 tests for every data base. The 10  values for every test are very closed to each other. The values  listed in figure 3 are the average values. Testing done by  using P4 (2.8 GHZ) with Java (SDK 1.6). In testing we  choose our new algorithm with sub-vector size (n/x) equal to  20,10,5,3,and 2.

(a) n/x =2  K N Algorithm in [12] New Algorithm   1000 0.015476995 0.006199643  5000 0.091357644 0.046743371  10000 0.156267739 0.093134072  20000 0.345647536 0.197512594  50000 1.0527975 0.539032216  60000 1.138129 0.623802   1000 0.018204381 0.010225043  5000 0.115394613 0.065111794  10000 0.236252681 0.142883324  20000 0.467338339 0.280670675  50000 1.33382765 0.749534475  60000 1.517329 0.855766  (b) n/x = 3  K N Algorithm in [12] New Algorithm   1000 0.011710148 0.004915597  5000 0.07957408 0.029405301  10000 0.171128647 0.059467752  20000 0.356596273 0.120056515  50000 0.932710185 0.302567231  60000 1.1737853 0.411942522   1000 0.018929445 0.007384402  5000 0.124361949 0.039841181  10000 0.225873788 0.085167362  20000 0.460194522 0.171485284  50000 1.3396462 0.485033439  60000 1.63570226 0.594194932  (c) n/x = 5  K N Algorithm in [12] New Algorithm   1000 0.013953 0.002424  5000 0.08589 0.013833  10000 0.174361 0.023797  20000 0.342353 0.051143  50000 1.010554 0.136987  60000 1.106744 0.177291   1000 0.032366 0.003964  5000 0.181384 0.024516  10000 0.345825 0.051007  20000 0.719146 0.108774  50000 1.086134 0.142801  60000 1.609831 0.271111     (d) n/x = 10  K N Algorithm in [12] New Algorithm   1000 0.012165122 0.001155985  5000 0.089738026 0.007085006  10000 0.17616658 0.010351511  20000 0.353628322 0.024526581  50000 0.958005674 0.056325957  60000 1.130011 0.07027   1000 0.018034471 0.001876412  5000 0.124111921 0.009001479  10000 0.239321253 0.017106197  20000 0.473377098 0.03369973  50000 1.24739011 0.092951673  60000 1.584818 0.124992  (e) n/x = 20  N Algorithm in [12] New Algorithm   1000 0.012501561 0.000638126  5000 0.079840342 0.005237984  10000 0.169869386 0.005306987  20000 0.343034524 0.00994185  50000 1.009675464 0.026779689  60000 1.136199 0.040204   1000 0.019524269 0.000834073  5000 0.125495585 0.004794604  10000 0.235693778 0.00836556  20000 0.474539147 0.017809666  50000 1.27333543 0.051526967  60000 1.537006 0.059959  Figure 3.  Comparison execution time of new algorithm verse old algorithm in seconds  Figure 4. Percentage time of new algorithm related to old algorithm when  K=10  Figure 5. Percentage time of new algorithm related to old algorithm when  K=5

V. CONCLUSION AND FURTHER WORK?  In this paper we presented privacy preserving association  rule mining algorithms of have been recently introduced with  the aim of preventing the discovery of sensible information.

The new algorithm is stenography based. We modify an  algorithm of privacy preserving association rule mining on  distributed heterogeneous data by optimize the computation  required  for all sites. The results showed that our algorithm  solving the trade off between performance and privacy in  large data base. Also an implementation for modified  algorithm is presented. From the results obtained we can say  that our algorithm is good privacy preserving algorithm with  better performance. In our work we test the new algorithm  with data up to 60000 row, for future we can make more tests  in large data base up to 1 million row.

