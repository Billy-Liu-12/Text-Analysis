

Bitmap Techniques for Optimizing Decision Support Queries  and Association Rule Algorithms  Xiaohua Hu                              T.Y.Lin                                 Eric Louie  College of Info.  Science   Dept. of Computer Science        IBM Almaden Research Center  Drexel University              San Jose State University          650 Harry Road  Philadelphia, PA 19104   San Jose, California 95192        San Jose, CA 95120  thu@cis.drexel.edu           tylin@cs.sjsu.edu                      ewlouie@almaden.ibm.com  Abstract  In this paper, we discuss some new bitmap tech-  niques for optimizing decision support queries and as-  sociation rule algorithm.  We first show how to use a  new type of predefined bitmap join index (pre-  join_bitmap_index) to efficiently execute complex deci-  sion support queries with multiple outer join operations  involved and push the outer join operations from the  data flow level to the bitmap level and achieve signifi-  cant performance gain. Then we discuss a bitmap based  association rule algorithm. Our bitmap based associa-  tion rule algorithm Bit-AssocRule doesn?t follow the  generation-and-test strategy of Apriori algorithm and  adopts the divide-and-conquer strategy, thus avoids the  time-consuming table scan to find and prune the item-  sets, all the operations of finding large itemsets from the  datasets are the fast bit operations. The experimental  results show Bit-AssocRule is 2 to 3 orders of magnitude  faster than Apriori and AprioirHybrid algorithms. Our  results indicate that bitmap techniques can greatly im-  prove the performance of decision support queries and  association rule algorithm, and bitmap techniques are  very promising for the decision support query optimiza-  tion and data mining applications.

1. Introduction  In this paper we present some novel bitmap techniques  in two new areas. We first present a new method to use  bitmap join indexes to efficiently execute complex DSS  queries with multi-tables with outer join conditions, and  then we discuss a bitmap-based algorithm in finding as-  sociation rules from large databases. In DSS application,  for multi-table joins with outer join operations, no work  is done to use the performance advantages of the bitmap  indexes, all the execution of the complex queries with  outer join operations are done in the data flow level in  an ?as written? manner. With the outer join operations  are becoming more and more frequent in the DSS and  DM queries, it is very important to push down part of  the join operations to the bitmap join indexes level to  take the advantage of the efficiency of the bitmap join  indexes to efficiently execute common multi-table joins  with outer join operation involved.  In our method, a  predefined join table (prejoin table) is created for multi-  table join based on the full outer join conditions. A set  of prejoin_bitmap_indexes is created corresponding to  the full outer join conditions in the multi-table joins. An  efficient method to calculate the foundset for the multi  table outer joins by using prejoin_bitmap_indexes for  multiple outer join operations is proposed. Our method  uses prejoin_bitmap_indexes, which can resolve join  predicates using the bitmap indexes to determine a  found set very efficiently.  Next we present a bitmap-  based algorithm Bit-AssocRule for finding association  rules from large databases. Traditional Apriori algo-  rithms require multiple full table scans and generates  and tests the itemsets in order to find association rules  from large database. Our Bit-AssocRule avoids these  time-consuming operations and relies on the fast bit op-  erations to find the large itemsets.  With bitmap tech-  niques, we can greatly improve the performance of the  association rule algorithms.

The rest of the paper is organized as follows: we  give an overview of bitmap indexes and introduce the  new bitmap techniques in Section 2. In Section 3 we  present the prejoin_bitmap_index based algorithm for  outer join DSS queries optimization with some exam-  ples. In section 4 we present the bitmap-based associa-  Proceedings of the Seventh International Database Engineering and Applications Symposium (IDEAS?03)      tion algorithm Bit-AssocRule and the comparison re-  sults of Bit-AssocRule with Apriori and AprioriHybrid.

Section 5 concludes the paper with some discussions  2. Bitmap Indexes and New Bitmap Tech-  niques  Various bitmap techniques have been studied exten-  sively and applied successfully in various application  domains [5,12,14,15,16,19,20,22,23,27,28,30,31,32].

In our study we noticed that there is a relationship be-  tween a column?s cardinality (i.e., the number of distinct  values) and its usage within the SQL language and the  DSS & DM usage model. A column that has a low car-  dinality tends to be used most frequently in DSS within  SQL WHERE clauses and GROUP BY clause. When  use in SQL WHERE clause, a high cardinality column is  usually a range predicate []. Based on this consideration,  we propose a hybrid bitmap technique which uses pro-  jection indexes, B-Tree indexes, traditional bitmap in-  dexes, and advanced high-cardinality bitwise indexes to  store and manipulate all data.

Our implementation of the low cardinality indexing  technique differs from other implementation in several  ways. Most implementations, including the one used by  Oracle, are only useful at the very low end. This is be-  cause as the cardinality increases, so does the size of the  index. What basically occurs is that the number of zero  bits in the bitmaps increases with the cardinality. The  number of 1 bits increases with the number of rows.

Hence, as the cardinality increases with the same num-  ber of rows, more and more zero bits occur with the  same number of 1 bit. The increasing popular zero bits  allow the compression to get better and better. Using  this technique we have been able to extend the range of  usable cardinality to a very large number.

A problem with using bitmap indexes for a column with  high cardinality is its high storage costs and potentially  high expression evaluation costs.  One method for deal-  ing with the problem of using bitmap index on high-  cardinality attributes is to compress the bitmap. The  form of compression is the most crucial aspect of such  an implementation, since it must be designed both to  save disk space for sparse bitmaps, and also to effi-  ciently perform the operations AND, OR, NOT and  COUNT. [21]. We have two types of bitmap indexes:  index for high cardinality column with symbolic values,  index for high cardinality column with numeric values.

In this approach, the data column is broken up into N  number of separate bitmaps. One bitmap for each bit of  precision in the quantity being indexed.  Organizing the  data in this way greatly reduces the size of the data. A  considerable body of work has been devoted to the study  of bitmap index compression. The use of bitmap com-  pression has many potential performance advantages:  less disk space is required to store the indexes, the in-  dexes can be read from disk into memory fast, and more  indexes can be cached in memory.  A wide variety bit-  map representations and compressions have been pro-  posed, such as Verbatim, Run Length Encoding (RLE),  Gzip, ExpGol and BBC [4]. Our bitmap techniques ex-  tend the range of the unique value of a column to >  10000, by combining bitmap and compression. As the  number of values increases, the amount of compression  increases. The bitwise index proposed by O?Neil [21] is  close to our High cardinality indexes  3. A Prejoin_Bitmap_Index Based Algo-  rithm for Outer Join DSS Query Optimiza-  tion  In this section we will discuss our new pre-  join_bitmap_index based algorithm for outer join DSS  queries optimization and the integration of it into a  commercial data flow based query engine. For explana-  tion purpose, we use a Volcano style data flow based  query engine [12] as the underlying query engine to im-  plement our algorithm. Each query plan in the query en-  gine is a tree of operators, all operators are implemented  as iterators, i.e., they support a simple open-next-close  protocol, but our algorithm is easily extended to any  other data flow based query engine.

We have implemented various types of bitmap indexes  based on the cardinality of the data columns described in  Section 2.  Based on the query at hand, the best index  can be chosen to run the query fast. The factors in  choosing the proper bitmap index for attributes depend  on the number of distinct values of the attribute, type of  the queries the attributes will most likely to be involved  [3].  Optimizer will choose the correct index when  evaluating a query. The type of indexes chosen would  be based on how a column will be used in general and  not on specific queries.

3.1 Some Limitations of the Current Database  Systems for DSS Queries Optimization  Currently there are two approaches to process complex  decision support queries with multi-table joins to im-  Proceedings of the Seventh International Database Engineering and Applications Symposium (IDEAS?03)      prove query performance: (1) to create join indexes  or/and (2) to store the join result of two or more tables  in advance which is often used in the queries. Join index  [20,23,30] can be used to avoid actual joins of tables, or  to greatly reduce the volume of the data. This join tech-  nique speeds join processing by processing multiple bit  vector indexes and has been used in some commercial  RDBMS. For example, Informix/Red Brick (now part of  IBM) RDBMS adopts the first approach to create  STARindex [27,28] for multi table joins and dramati-  cally accelerate join performance. These two approaches  work very well in multi table joins without multi outer  join operations because outer join operations need to re-  serve those rows even though they don?t satisfy the join  conditions. If these tables are joined together through  outer join conditions, then these methods will not gener-  ate the correct answers because all of them rely on AND  or OR the bitmap indexes involved in the join conditions  (inner join, natural joins and so on), but the semantic  meaning of outer joins is so different, just ANDed or  ORed these bitmap indexes is not enough to get the cor-  rect answer.

To enable the current RDBMS to support outer join op-  erations through bitmap indexes, some modifications  and extensions are needed because of the following  limitations of the current data flow based query engine:  (1) In the current data flow engine; the execution order  of the predicate is not exactly the same sequence as  predicates appear in the query statement. The execution  order of the predicates is determined by the cost of se-  lectivity in most systems. This is fine and actually can  improve query performance in a lot of circumstances  without outer join involved because changing the execu-  tion orders of predicates would not affect the semantic  meaning of the query, so the results are the same. But  for multi table joins with outer join conditions, the story  is totally different. It is essential to reserve the predicate  orders in order to guarantee the correct results because  outer joins are not commutative, so we need to find the  found set for the outer joins based on the strictly order  of the join conditions in the query plan tree. For multi  table joins with outer join operations, the order of the  join indexes access must have the same order as the  outer joins in the original join sequences.

(2) For join conditions on an outer join, these will be  bitmap join indexes, which are the bitmaps for that join  conditions for inner, right outer and left outer. These are  then ANDed and ORed with the current found set. The  rules for ANDing and Oring these bitmap indexes for  the leaf joins in the join tree and for higher level joins  need to be different to not lose outers from earlier joins  in the join sequences. This requires that a bitmap join  index need to know whether its child at each side is an-  other join or base table. But of the current bitmap in-  dexes for join nodes, there is no mechanism to tell the  difference and store the essential information. All cur-  rent bitmap join indexes such as STARindex of Infor-  mix and bitmap join index of O?Neil [20] point to two  base tables only, thus could not deal with multiple outer  join operations. For all commercial RDBMSs products,  complex queries with outer joins are executed by the  query engine in an ?as written? manner. This requires  that a bitmap join index needs to know whether its child  at each side is another join or a base table.

3.2 Predefined Join Table and Pre-  join_Bitmap_Indexes  A new type of bitmap join index called pre-  join_bitmap_index is proposed to solve the problems  discussed above. A predefined join table (prejoin table  for short) is a full denormalized table of all columns  from participating tables from full outer joins. A prejoin  table can join more than two tables in a single operation,  so it overcomes the problems that plaque traditional  OLTP RDBMS products. All the predicates local to the  prejoin table can be solved using the pre-  join_bitmap_indexes.

Definition 1: A Prejoin Table is a denormalized table  storing and indexing the full denormalized result set  of all columns from participating tables from full  outer join.

The prejoin table has the following characteristics:  Join more than two tables  Support full outer joins in a star relationship as  well as linear join chain  Multi-column join keys  Multi-table join queries with more than one  outer joins.

For each join relation in the prejoin table, a set of pre-  join_bitmap_index is created. Since the results of a full  outer join of two tables can be perceived as three parts:  INNER, LEFT and RIGHT. The INNER part is those  rows from both tables which match the join conditions,  The LEFT part is those rows from the first table which  fails the join conditions while the RIGHT part is those  Proceedings of the Seventh International Database Engineering and Applications Symposium (IDEAS?03)      rows from the second table. So it is natural to define  three bitmap indexes for a full outer join relation. If  there are multiple join relations, the join relation should  tell whether the tables involved in the join relation are  base tables or not because this information determines  the semantic meaning of how the bitmap indexes of this  join relation should be used. A prejoin_bitmap_index is  able to point to the derived tables, not just the base table.

This is one of the advantages of our pre-  join_bitmap_index over STARindex or the bitmap index  proposed in [3,20,23,30,31, 32].

Each prejoin_bitmap_index consists of three bitmaps as  follow:  IJIndex: The inner join of the result of the two tables  with all conditions applied.

LJIndex: All rows from the left table not included in  the IJIndex, extended with NUL values for each column  of the right table.

RJIndex: All rows from the right table not included in  the IJIndex, extended with NULL values for each col-  umn of the left table.

Suppose we have a Create Prejoin Table command as  follow: Create Prejoin Table FT1T2 as ((F Full Outer  Join T1 On A2=A1) Full Outer Join T2 on A3=A6)  For this prejoin table FT1T2, two pre-  join_bitmap_indexes are created (Table 3). Jindex1 cor-  responds the join relation between base tables F and T1  on join condition A2=A1, Jindex2 corresponds to the join  relation between the derived table (the result of F Full  Outer Join T1 on join condition A2=A1) and the base ta-  ble T2 on join condition A3=A6.  For each type of outer  join (left, right, full), just put the proper ?pieces? to-  gether using UNION All by using the corresponding  prejoin_bitmap_index.

Example 3.1: to compute the foundset FS of (F Left  Outer Join T1 On A2=A1), just ORed the two bitmaps  LJIndex of Jindex1: FS=LJIndex OR IJIndex = (0 0 0 0  0 1 1 0 0) OR (1 1 1 1 1 0 0 0 0) = (1 1 1 1 1 1 1 0 0).

For foundset of (F Full Outer Join T1 On A2=A1), just  ORed all the three bitmaps of Jindex1: FS=(0 0 0 0 0 1 1  0 0) OR ( 1 1 1 1 1 0 0 0 0) OR (0  0 0 0 0 0 0 1 0)=(1 1  1 1 1 1 1 1 0)  A1 a  b  d  e  Table T1  A6 A7 2 4  3 2  3 5  8 1  Table T2  A8 u  v  w  x  TableT3  A2 A3 A4 A5  a 1 u o  b 2 v o  d 3 w p  d 4 x q  f 5 z t  g 7 z s  Table F  No. A2 A3 A4 A5 A1 A6 A7  1 a 1 u o a null null  2 b 2 v o b 2 4  3 d 3 w p d 3 2  4 d 3 w p d 3 5  5 d 4 x q d null null  6 f 5 z t null null null  7 g 7 z s null null null  8 null null null null e null null  9 null null null null null 8 1  Table 2: FT1T2                                                        Proceedings of the Seventh International Database Engineering and Applications Symposium (IDEAS?03)      LJIndex     IJIndex       RJIndex       LJIndex    IJIndex  RJin-  dex  Table 3: Prejoin_bitmap_index  Jindex1     &  Jindex2  3.3 Finding the Prejoin Table in the Query Exe-  cution Plan  In order to use prejoin_bitmap_index in the data flow  query engine, we simply add a new type of data flow  node, called prejoin table node, which also follows the  open-next-close interface of Volcano style engine [12].

In the query execution plan, a prejoin table is a subclass  of the table node, but a table node only refers to one  base table while a prejoin table can refers to two or more  tables depending on the number of tables involved in the  full outer join. Also there is an additional member for  the prejoin table node: Join_Relation_Tree.

Join_Relation_Tree is the join sequence tree, which  matches the join order specified in the prejoin table  command and is used to control the construction of the  foundset bitmap (FSBM) for the prejoin table node. For  each join node in the Join_Relation_Tree, there is a pre-  join_bitmap_index, which consists of 3 parts: IJIndex,  LJIndex and RJIndex. Four different join results can  be derived based on the different combinations of these  three bitmap indexes. For example, the IJIndex is the in-  ner join result of this join node, the union of LJIndex  and IJIndex is the left outer join of this join node, the  union of the IJIndex and RJIndex are the right outer join  while the union of IJIndex, LJIndex and RJIndex are the  full outer join of the join node.

For each join node in the query execution plan, we asso-  ciate it with three members: Join_Key_Type,  Join_Predicate_Vector and Join_Operator, which  will help us to find whether the join node is part of a  prejoin table or not. The Join_Key_Type is set to Ta-  ble_Table if the join node links two base tables. It is set  to Join-Table if the left child of the join node is a join  node (also called derived table) and the right child is a  base table. If the left child is a Table node and the right  child is a join node, the Join_Key_Type is set to Table-  Join. The Join_Predicate_Vector is used to store the join  predicates. A prejoin match is found if the  Join_Key_Type, Join_Predicate_Vector of the join  nodes matches with the prejoin table definition. The  Join_Operator is set to Inner, LOuteror ROuter or  FOuter if the join node type is inner join, left outer join  and full outer join respectively.

Example 3.2: Suppose we have a query Select * from  ((F Left Outer Join T1 On A2=A1) Right Outer Join T2  On A3=A6) Full Outer Join T3 On A4=A8)  The query plan tree for this query is shown in Figure 4:      Figure 1  Our optimizer can identify that part of the outer join op-  erations (F Left Outer Join T1 On A2=A1) Right Outer  Join T2 On A3=A6) involved in the multi-table joins  matches with our prejoin table FT1T2, so we can replace  that part in the plan tree with the prejoin table node  FT1T2. A modified plan tree is as follow (Figure 2).

Figure 2  Since the prejoin table is based on the full outer join  condition, the prejoin table node FT1T2 contains more  rows than (F Left Outer Join T1 On A2=A1) Right Outer  Join T2 On A3=A6, so we need to get rid of the extra  rows introduced by the full outer join in order to get the  correct answer. We can use the prejoin_bitmap_indexes  associated with the Join_Relation_Tree of the prejoin  Join  Join  Table T2 Join  Table T1 Table F  Table T3  Join-Table  FOuter  A4=A8  Join-Table  ROuter  A3=A6  Table-  Table  LOuter  A A  Join  Table T3 Prejoin Table FT1T2  Table-Table  FOuter  A4=A8  Proceedings of the Seventh International Database Engineering and Applications Symposium (IDEAS?03)      table, the Join_Operator of the join nodes in the  Join_Relation_Tree and put the proper ?Pieces? together  to construct the correct foundset bitmap for the prejoin  table node in the modified plan tree. These are then  ANDed and ORed with the current foundset. The rules  for ANDing and Oring these bitmaps for the leaf joins in  the join tree and for higher level joins are different in  order to reserve outers from earlier joins in the join se-  quence.

Algorithm 1: Executing the Prejoin Table Node in  the Query Execution Plan  traverse the Join_Relation_Tree of the prejoin table in  breadth first order {  df_joinnode * current_node= node of the  Join_Relation_Tree  IF current_node is a join node {  Bitmap I_index = current_node IJIndex  Bitmap L_index = current_node LJIndex  Bitmap R_index = current_node RJIndex  IF the current_node is the root of the  Join_Relation_Tree ) {  Case (Join_Operator) {  Inner:     FSBM = I_index  LOuter: FSBM = I_index OR L_index  ROuter: FSBM = I_index OR R_index  FOuter: FSBM = I_index OR L_index OR  R_index }}  Else {  Case (Join_Operator) {  Inner:   FSBM = FSBM AND (NOT (L_index OR  R_index))  LOuter: FSBM = FSBM AND (NOT R_index)  ROuter: FSBM = FSBM AND (NOT L_index)  FOuter:  no change }}}  current_node = next node of the Join_Relation_Tree }  Example 3.3: For the modified plan tree in Figure 2, we  compute the found set FSBM for prejoin table node  FT1T2 starting form the top node of the  Join_Relation_Tree (the part inside the dash curve in  Figure 1). The root join node is a right outer join (the  corresponding join index is Jindex2), then we combine  the two pieces IJIndex and RJIndex: FSBM1 = IJIndex  OR RJIndex = ( 0 1 1 1 0 0 0 0 0) OR (0 0 0 0 0 0 0 0 1)  = (0 1 1 1 0 0 0 0 1), the next join node is a left outer  join (the corresponding join index Is Jindex1), we  should remove those extra rows introduced from the  right side (use the RJIndex of Jindex1). FSBM2 =  FSBM1 AND (NOT (RJIndex)) = FSBM1 and (NOT (0  0 0 0 0 0 0 1 0) = FSBM1 AND ( 1 1 1 1 1 1 1 0 1) = (0  1 1 1 0 0 0 0 1) AND ( 1 1 1 1 1 1 1 0 1) = ( 0 1 1 1 0 0  0 0 1), so foundset bitmap corresponding to ((F Left  Outer Join T1 On A2=A1) Right Outer Join T2 On  A3=A6) is (0 1 1 1 0 0 0 0 1), then we can project out the  corresponding rows of the foundset (as shown in Table  4) and pass the rows to the join node above  A2 A3 A4 A5 A1 A6 A7  b 2 v o b 2 4  d 3 w p d 3 2  d 3 w p d 3 5  null null null null null 8 1  Table 4: Rows of Prejoin Table Node  We can choose any one of the join algorithms (like  nested-loop join, hash-join, sort-merge join and so on)  and apply it to the Table T3 and then we obtain the final  result Table 5 for the query.

The prejoin table match method and pre-  join_bitmap_index based outer join optimization tech-  niques have been implemented in a commercial data-  base?s query engine. It took only 6 man-months to have  our techniques seamlessly integrated into the existing  system. The initial test on TPCD benchmark data set us-  ing query Q5 and Q8 [29] showed an average 30 times  fast on scale 10 (10 Gigabytes).

A2 A3 A4 A5 A1 A6 A7 A8 b 2 v o b 2 4 v  d 3 w p d 3 2 w  d 3 w p d 3 5 w  null null null null null 8 1 null  null null null null null null null u  null null null null null null null x  Table 5: Result of the Query.

4.  A Bitmap-Based Association Rule Algo-  rithm Bit-AssocRule  Though most of data mining algorithms assume all data  are stored in a flat relation, in reality data are stored in  various normal forms. So the techniques of previous  sections are extremely important in supporting data min-  ing; we rely on them to generate a virtual flat relation.

We have adopted the layered view, so in this section, we  will only discuss the algorithms based on the flat rela-  tion without examining the detail interaction; we will  defer it on later papers on data warehouse. Our focus in  this section is to present a bitmap-based algorithm Bit-  AssocRule to find association rule efficiently from large  databases.

Proceedings of the Seventh International Database Engineering and Applications Symposium (IDEAS?03)      Given a set of transaction D, the problem of mining as-  sociation rules is to generate all associations that meet  certain user-specific minimum support and confidence.

The problem can be decomposed into two subproblems:  (1) finding all combinations of items that have transac-  tion support above the minimum support, (2) use the  large itemsets to generate the desired rules. The chal-  lenging issues of association rule algorithms are multi-  ple scans of transaction databases and huge number of  candidates. There have been many association rule algo-  rithms [1,2,5,13,24,27,33] developed to reduce passes of  transaction database scans and shrink number of candi-  dates, which can be classified into two categories: (1)  candidate-generation-and-test approach such as Apriori  [2,5,13], (2) pattern-growth approach [24,27,33]. The  most influential algorithm Apriori developed by Rakesh  etc [1,2] generates the k-candidate by combining two (k-  1)-itemsets. A new k-candidate becomes a k large item-  set if every (k-1)-subset of the k-candidate is a large  itemset otherwise it is removed, the process is very time  consuming.

The use of bitmaps improves the performance to find as-  sociation rules. The bit representation of bitmaps offers  efficient storage while the intersection of bitmaps offers  fast computation in finding association rules. The AND,  SHIFT, and COUNT operations among bitmaps are ex-  tremely fast. Unlike the traditional Apriori algorithm  which generates k-candidate by combining two (k-1)  large itemset.  Our Bit-AssocRule algorithm generates  k-candidate by intersecting the bitmap of 1 attribute  value with bitmaps of other (k-1) attribute values.  The  algorithm starts with a list L1, which contains attribute  values (also called 1-itemset, all the counts of the bit-  maps of these 1-itemset are greater than the minimal  counter number). The k-candidates consist of k attribute  values (X1,t1, X2,t2, ?, Xk-1,tk-1, Xij) from k attributes. Us-  ing bitmap techniques, the candidate is a large itemset if  the bit count on the intersection of all the bitmaps  B1 B2  ? Bk  (suppose Bj is the bitmap of the Xk,tj) is  equal or greater than the minimal count. The bit count is  the number of 1?s in the bitmap indexes from the result  of the intersection of the bitmaps.

During each cycle, combinations of length k, or in short,  k-candidates are generated. When intersecting the bit-  maps, the size of the bitmaps may be large. Thus, slices  of the bitmaps are read and processed until all slices of  the bitmaps are done. In the end, if the intersection of  bitmaps in the k-candidate results in a count that meets  or exceeds the minimal count, the candidate is a large  itemset, and it is saved. At the end of the cycle, if any k-  candidates are declared as large itemsets, new candi-  dates of length k+1 are generated for the next cycle. The  cycle stops when no k-candidates are found to be large  itemset or if no new (k+1)-candidate can be generated  from the discovered k large itemset. When making k-  candidates, all the 1-itemsets in the list L1 are verified if  they exist as elements in any (k-1)-itemset.  If a 1-  itemset does not exist in any (k-1)-itemset, it is removed  from the list L1. Next, new k-candidates are created by  joining a (k-1)-itemset with 1-itemset in L1 that has an  attribute index greater than all attribute indexes of ele-  ments in that (k-1)-itemset. Only the new k large itemset  are kept.  Below is the algorithm  Algorithm 2: Bit-AssocRule  L1 = {bitmaps of large 1-itemset}  For ( k=2; Lk-1  ; k++) Do Begin  Remove those 1-itemsets in L1 which are not included  in any itemset of  Lk-1 //prune  L1 Ck = { Join the 1-itemset in L1 that is larger than any  elements in the (k-1) large item set  with the itemset in Lk-1}  // new candidate  Lk = {c  Ck | bitmap count of  c >= minsup}  End  Answer = kLk  Theorem 1:  If the count of the intersection of the  bitmap of 1-itemset Xij with the bitmap of  (k-1)-  itemset (X1,t1, X2,t2, ?, Xk-1,tk-1) is large (namely  greater than or equal to the minimum support count  C), then it is guaranteed that the newly k-candidate  (X1,t1, X2,t2, ?, Xk-1,tk-1, Xij)  is a large item.

Proof: Suppose Bk denotes the bitmap of the 1-itemset  Xij and B1, B2,?Bk-1 bitmaps of X1,t1, X2,t2, ?, Xk-1,tk-1  respectively.   If the count of the intersection of the bit-  map  Bk  of 1-itemset Xij with the bitmaps  B1 B2 ? Bk-1 of  (k-1)-itemset (X1,t1, X2,t2, ?, Xk-1,tk-  1) is large (namely greater than or equal to the minimum  support count C), that means: Count( B1 B2 B3? Bk-  1 Bk ) > C .  Based on the logical bit And operations, it  means that there must exists at least C positions (sup-  pose these positions are p1, p2, p3,..pC) in the bitmaps B1,  B2,?Bk-1, Bk such that  B1[p1] = B2[p1] =? Bk-1[p1]=?=Bk[p1]=1  B1[p2] = B2[p2] =? Bk-1[p2]=?=Bk[p2]=1  ????????????????..

Proceedings of the Seventh International Database Engineering and Applications Symposium (IDEAS?03)      B1[pC] = B2[pC] =? Bk-1[pC]=?=Bk[pC]=1  Then based on the bit And operation, for any (k-1) sub-  set from the k-candidate (X1,t1, X2,t2, ?, Xk-1,t-1, Xij), the  count of their bitmap intersection must be also greater  than or equal to C, thus any (k-1) subset is a large item  set, so the newly k-candidate is a large item set.

This theorem says that Our Bit-AssocRule algorithm  doesn?t need to check the (k-1)-subset of the new k-  candidate. If the count of the bitmap of  (X1,t1, X2,t2, ?,  Xk-1,tk-1, Xij)   is greater than C, there is no need to check  whether any  (k-1)-subset of (X1,t1, X2,t2, ?, Xk-1,tk-1, Xij)  is also a large item set  because we are sure the newly k-  candidate is an k large item set.  This property of our  Bit-AssocRule algorithm is a significant improvement  over the Aprior algorithm because the Apriori algorithm  spends a huge amount of time to check all the  (k-1)  subsets of the newly k-candidate. Only after all the (k-  1)-subsets of the k-candidate is checked then it can de-  cide whether the new k-candidate is a large itemset or it  should be removed. Our Bit-AssocRule eliminates this  expensive step in the procedure, thus saves a lot of run-  ning time.

Four synthetic data sets are generated to compare the  run time on these algorithms to find association rules.

The program for Apriori and AprioriHybrid are our  honest implementations of the algorithms in [2].  In the  implementation, we use some buffer scheme to speedup  read/write for all algorithms. The tests were conducted  using an IBM PC with 933Mhz CPU, 512MB memory  under Window 2000. The program is coded in C++.

Data  set  Rows Col-  umn  #of  items  Table  size  Bitmap  size  Min  Sup DS1 400K 16 199 25.6M  B  10.6MB 20K  DS2 800K 20 247 64MB 25.0MB 40K  DS3 1.6M 30 709 140M  B  62MB 50K  DS4 3.0M 30 303 361M  B  91MB 80K  Table 6: 4 data sets  Data  set  Length of  candidate  # of candi-  dates  #of item-  sets  Bit-AssocRule Apriori Hy-  brid  Apriori  DS1  1 199 188 3.966s 4.106s 4.105s  2 16333 103 18.426s 1402.977s 1403.438s  3 92 10 0.111s 1.833s 5.979s  4 0 0 0s 0s 0  Total time   22.503s 1408.916s 1413.522s  DS2  1 247 235 10.375s 10.275s 10.786s  2 26033 88 56.371s 4496.245s 4496.405s  3 0 0 0s 0.01s 0s  Total time   66.746s 4506.530s 4507.191s  DS3  1 303 303 24.816s 9.894s 9.904s  2 43996 2681 99.162s 11245.120s 11231.390s  3 614 924 46.117s 5368.569s 9391.324s  4 0 0 0.03 25.487s 1658.455s  Total time   171.401s 16649.070s 22291.073s  DS4  1 244 244 49.021s 25.557s 20.059  2 28430 3920 153.080s 13979.431s 13682.575s  3 55467 2586 308.593s 28294.946s 45159.676s  4 3152 108 20.109s 455.155s 58274.374s  5 0 0 0 0.000s 180.209s  Total time   530.803s 42755.089s 117316.893s  Table 7: Experimental Run of 4 Data Sets  Proceedings of the Seventh International Database Engineering and Applications Symposium (IDEAS?03)      Here are some observations and explanations on the re-  sults  (1). The total time of our comparison includes the time  to write the association rules to a file; Bit-AssocRule is  2 to 3 orders of magnitude faster than the various Apri-  ori algorithms (64-221 times faster). The big the test  data set, the big the time difference between the Bit-  AssocRule and the various Apriori algorithms. We ha-  ven?t compared our algorithm with some of the other as-  sociation rule algorithms such as VIPER [27], CHARM  [33], CLOSE [13,24] (CHARM and CLOSE are based  on the closed frequent itemsets concept), but based on  their published comparison results with Apriori, our Bit-  AssocRule is very competitive compared to them and a  direct comparison will be conducted and reported in the  near future.

(2) Bit-AssocRule takes the same or litter longer time  than the various Apriori algorithms in constructing the  1-itemsets because of the extra cost of building the bit-  maps for the 1-itemsets. But after the 1-itsemtset is  done, Bit-AssocRule is significant faster than the Apri-  ori algorithms in constructing large frequent itemsets  because it only uses the fast bit operations (AND,  COUNT and SHIFT) and doesn?t need to test the sub-  sets of the newly candidate  (3) Bit-AssocRule only stores the bitmaps of the fre-  quent items, and the bitmap storage (uncompressed) is  less than the original data set (1/2 to 1/4 of the original  data size).

The main reasons that Bit-AssocRule algorithm is sig-  nificant faster than Apriori and its variations are  (1) Bit-AssocRule adopts the divide-and-conquer strat-  egy, the transaction is decompose into vertical bitmap  format and leads to focused search of smaller domain.

There is no repeated scan of entire database in Bit-  AssocRule.

(2) Bit-AssocRule doesn?t follow the traditional candi-  date-generate-and test approach, thus saves significant  amount of time to test the candidates  (3)  In Bit-AssocRule, the basic operations are bit Count  and bit And operations, which are extremely faster than  the pattern search and matching operations used in Ap-  riori and its variations  5. Conclusion  The contributions of this paper are in two aspects:  we  extend the application domains of bitmap techniques  and introduce the bitmap techniques for complex DSS  query optimization and association algorithm. We pre-  sent a bitmap based query optimization algorithm to op-  timize complex query with multiple table join based on  outer join operations and push the outer join operations  from the data flow level to the bitmap level and achieve  significant performance gain.   We introduce a novel al-  gorithm to calculate the foundset for those tables in-  volved in the prejoin table by using pre-  join_bitmap_indexes and integrate this algorithm into  the current commercial data flow based query engine  seamlessly. Our query optimization can achieve an order  of magnitude faster than conventional query engine.

Secondly we introduce the bitmap technique to the data  mining procedure and develop a bitmap-based algorithm  Bit-AssocRule to find association rules. Our Bit-  AssocRule avoids the time-consuming table scan to find  and prune the itemsets, all the operations of finding  large itemsets from the datasets are the fast bit opera-  tions. The experimental result of our Bit-AssocRule al-  gorithm with Apriori and AprioirHybrid algorithms  shows Bit-AssocRule is2 to 3 orders of magnitude  faster. This research indicates that bitmap technique can  greatly enhance the performance for decision support  queries and finding association rule, and bitmap tech-  niques are very promising for the decision support query  optimization and DM applications.

Bitmap technique is only one way to improve the per-  formance of complex DSS queries and DM algorithm.

Parallelism is another crucial factor to improve the per-  formance of DSS and data mining.  We are currently  working on paralleling the bitmap-based algorithms and  hope to report our findings in the near future.

6. References  [1] Agrawal R. Srikant R., ?Fast algorithm for mining association rules?, Prod. of the 20th VLDB Conf. 1994  [2]   Agrawal R., Mannila H., Srikant R., Toivonen H., Verkamo A., ?Fast discovery of  association rules?, in Advances in Knowledge Discovery and Data Mining, MIT 1996  [3] AIPD Technical Publications. In Sybase IQ Administration Guide, Sybase IQ Release  11.2 Collection, Sybase Inc  Proceedings of the Seventh International Database Engineering and Applications Symposium (IDEAS?03)      [4] Amer-Yahia S., Johnson T., ?Optimizing que- ries on compressed bitmaps?, Prod. of the 20th  VLDB  Conf.

[5] Bayardo R.J.Jr.,  Agrawal, R., Gunopulos D., "Constraint-based rule mining in large, dense data- bases", Proc. of the 15th Int'l Conf. on Data Engineering (ICDE1999)  [6] Bertino E., Ooi B.C., Sacks-Davis R. etc, ?In- dexing techniques for advanced database systems?, Kluwer Academic Publishers.

[7]  Chan C., Ioannidis Y., ?Bitmap index design and evaluation?, Prod of the  SIGMOD-96  [8]  Chatziantoniou D., Akinde  M, Johnson T, Kim  S, ?The md-join: an operator for complex olap?. Prod of the 18th  Int?l Conference on Data Engineering (ICDE2001)  [9] Data, C.J., ?The outer join?, Prod. of the 2nd International Conf. on Databases,  [10]  French C., ? ?One size fits all? database archi- tecture do not work for dss?, Prof of the  SIG- MOD-95  [11]  Galindo-Legaria, C and Rosenthal, A., ?Outer join simplification and reordering for query opti- mization?, ACM TODS, 22(1), 1997  [12] Graefe G., ?Volcano, an extensible and paral- lel query evaluation system?, IEEE Transaction on Knowledge and Data Engineering, 6(6), 1994  [13] Han, J. Pei, J. Yin. Y., "Mining frequent pat- terns without candidate generation", Prod of the SIGMOD-2002  [14]   Hanusa R., ?A lesson in outer joins (learned the hard way!)?, Teradata Review, Spring 1998  [15] Jermaine C., Data A, ?A novel index support- ing high volume data warehouse insertion? Prod.

of the 25th VLDB Conf.

[16] Johnson T , ?Performance measurements of compressed bitmap indices? Prod. of the 25th VLDB conf  [17] Lin T.Y., ?Data mining and machine oriented modeling: a granular computing approach?, Jour- nal of Applied Intelligence, Oct. 2000  [18] Louie E., Lin T.Y., ?Finding association rules using fast bit computation: machine-oriented mod- eling? ISMIS-2000  [19] Morzy T., Zakrzewicz M., ?Group bitmap in- dex: a structure for association rules retrieval?, Prod. of the 4th Int?l Conf. on Knowledge Discov- ery and Data Mining (KDD-98)  [20] O?Neil P., Graefe G., ?Multi-table joins through bitmapped join indexes?, SIGMOD Sep- tember 1995, 8-11  [21]  O?Neil P., Quass D., ?Improved query per- formance with variant indexes?, Prod of the SIG- MOD-1997  [22] O?Neil P., Informix and indexing support for data warehouses,  Informix Whitepaper  [23] Oracle 9i bitmap join index , http://technet.oracle.com/products/oracle9i/daily/a pr09.html  [24]  Pei, J. Han, H. Lu, S. Nishio, S. Tang, and D.

Yang. "H-mine: hyper-structure mining of frequent  patterns in large databases", Proc. The 2001 IEEE Int?l Conference on Data Mining  [25]  Rinfret D,   O?Neil P.,  O?Neil E.,  ?Bit- Sliced Index Arithmetic?, Prod of the SIGMOD-  [26]   Savasere , A. Omiecinski E., Navathe S., ?An efficient algorithm for mining association rules in large databases?, in Prod. of the 21st  VLDB conf.

