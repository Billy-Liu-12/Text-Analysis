A Tool for Extracting XML Association Rules

Abstract  The recent success of XML as a standard to represent semi-structured data, and the increasing amount of avail- able XML data, pose new challenges to the data mining  community. In this paper we present the X MINE operator a tool we developed to extract XML association rules for XML documents. The operator; that is based on XPath and  inspired by the syntax ofXQuery, allows us to express com-  plex mining tasks, compactly and intuitively. X MINE can be used to specify indifferently ( and simultaneously) mining  tasks both on the content and on the structure of the data, since the distinction in XML is slight.

changed among data mining tools (e.g., PMML [8]); but there are no significant extensions of data mining research taking full advantage of the intrinsic properties of XML.

However, it is easy to foresee that the spreading of XML will cause an increasing interest on this subject, going be-  yond a mere syntactic adaptation to XML of data mining artifacts and techniques.

In this paper, we present the X MINE operator, a tool that can be used to extract association rules from native XML  documents, shortly "XML association rules", which we first introduced in [6, 5]. The paper is organized as follows. In Section 2 we overview association rules in the context of  relational databases. In Section 3 we shortly discuss the no- tion of association rules for XML while we refer the read- ers to [6, 5] for additional details about the their theoretical  foundations. In Section 4 we present the X MINE operator through a serie of intuitive examples. In Section 5 we intro- duce some basic concepts needed to discuss implementa- tion details. In Section 6 we discuss how XML association rules are extracted from an XML document through XMINE  by composing an execution environment for XPath expres- sions and an algorithm for discovering frequent itemsets. In Section 7 we give some implementation details discussing the current state of the prototype we developed and an out- line of the planned future development. We conclude the paper with a discussion of future research directions.

1. Introduction  Knowledge discovery in databases (KDD) deals with the process of extracting interesting knowledge from  large amounts of data, usually stored in large (relational) databases. Knowledge can be represented in many different  ways (clusters, decision trees, decision rules, etc.). Among the others, association rules [4] proved effective in discov-  ering interesting relations in massive amounts of relational data. The recent years have seen the dramatic development of the eXtensible Markup Language (XML) [12] as a major  standard for storing and exchanging information. XML en- ables the self-description of hierarchies of semi-structured  information, by intermixing data content with semantic tags which describe such content. At the moment, the use of XML within the data mining community is still quite lim-  ited; there are some proposals to exploit the XML syntax to express interfaces to knowledge representation artifacts,  including association rules, so that they can be easily ex-  .Artificial Intelligence and Robotics Laboratory (AirLab) http://airlab.elet.polimi.it  2. Relational Association Rules  Association rules [4] are implications of the form X ~ y  where the rule body X and the rule head y are subsets of the set 1 of items (1 = {1) , ...,In} ) within a set of transac-  tions 1). The rule X ~ y states that the transactions T E 1) which contain the items in X (X C T) are likely to contain  also the items in y (y C T). Association rules are charac- terized by two measures: the support, which measures the  0-7695-1849-4/02 $17.00 @ 2002 IEEE     (b)  Figure 1. An example of source data (a) and association rules generated from the data (b).

percentage of transactions that contain both items X and Y; the confidence, which measures the percentage of transac-  tions that contain the items y within the transactions that also contain the items in X. More formally, given the func- tionfreq(X, V). denoting the percentage of transactions in V which contains X, we define:  support(X =} r) = freq(X u r, V)  confidence(X =} r) = freq(X u r, V) / freq(X , V)  <DEPARTMENT>  <PhDCourses>  <Courseteacher='fpl' title='Advanced. ..'>  <TimeTable>...</TimeTable>  <Student ref='psl' />  <Student ref='ps2' />  </Course>  <Course teacher='fp3' title='XML. ..'>  <TimeTable>. ..</TimeTable>  <Student ref='ps2' />  <Student ref='ps3' />  </Course>  </PhDCourses>  <People> <PhDStudent id='ps2' advisor-'fp3'>  <PersonalInfo email='fp3@atlantis.edu'>  <.Name>. ..</Name>  <IPersonallnfo>  <Subscription year='200l' />  <Publications> ...</Publications>  </PhDStudent> <FullProfessor id='fp3'>  <Personallnfo email='fp3@atlantis.edu'>  (Name> ...</Name>  <IPersonalInfo>  <Publications>  <Article title='Golden Data Mines...'>  <Author>. ..</Author>  <Conference name='VLDB' year='200l' />  </Article>  <Article title='P=NP -The Final Chapter'>  <Author>. ..</Author>  <Journal year='2000' month='4' volume2'4'  namez'DMKD' publisher='Kluwer' I>  </Article>  <Book yearz'200l' title='XML ...'>  <Author>.. .</Author>  <Publisher>. ..</Publisher>  <Keyword>XML</Keyword>  <Keyword>XQuery</Keyword> </Book>  <Ipublications>  <Award yearz'200l' societyz'IEEE'>. ..<IAward>  <IFullProfessor>  </People> <IDEPARTMENT>  Suppose there is an association rule "bread, butter =} milk" with confidence 0.9 and support 0.05. The rule states that customers who buy bread and butter, also buy milk in 90% of the cases and that this rule holds in 5% of the transac- tions.

The problem of mining association rules consists of find-  ing all the association rules, from a set of transactions 1), that have support and confidence greater than the two de-  fined thresholds: the minimum support (minsupp) and the minimum confidence (mincon.f). Association rules assume a relational representation of data (e.g., [4]), in which the  transactions T E 1) correspond to tuples, while the items I E I correspond to binary attributes. For instance, a rather  typical although simple example of source data is depicted in Figure l(a). The attributes A, B, C represent the set of items I; the tuples represent the transactions, in particular the first tuple ( 1,0,0) represents a transaction with only the item A; the last tuple (0, 1, 1) represents a transaction with both the items B and C. Some association rules extracted from the data in Figure l(a) are shown in Figure l(b). For  instance, the first rule A =} B states that in 25% of the tu- ples, item A and item B appear together and that the 33% of tuples which contain A contain also B. To support the specification of complex association rule mining tasks, a number of query languages have been proposed. In partic-  ular, [10] introduced the MINE RULE operator, an extension of SQL specifically designed for modeling the problem of  mining association rules from relational data.

Figure 2. A sample document contain-  ing variolJs information about the re- search activities of a university department  (http://www.atlantis.edu/research.xml).

3. Association Rules for XML Documents  In this section we overview the basic concepts of as-  sociation rules for XML documents, shortly "XML as- sociation rules" [6, 5]; we refer the interest reader to [6, 5] for further details. Let us consider the XML docu- ment depicted in Figure 2 where various information about a department are represented, e.g., the available Ph.D.

courses (identified by the tag <PhDCourse> ) and the peo-  pie in the department ( <People> ). These can be either  students ( <PhDStudent> ) or professors ( <FullProfessor> ).

For each of them, some personal information are stored  ( <Personallnfo> ) as well as the list of works published      <DEPARTMENT>  \  ( <Publications> ), e.g., books ( <Book> ), journal papers, or conference papers ( <Article> ). Consider the problem of mining frequent associations among people that appear as coauthors in the publications represented in the document  research. xml in Figure 2. In practice, we are interested in finding associations of the form:  "Wilson =? Holmes"  which states that, in the department, the papers which are authored by Wilson are also likely to have Holmes as au- thor. Since any part of an XML document is a tree, usu- ally called XMLfragment, both 1) and I are collections of trees. In particular, the transactions T E 1) are the XML  fragments that define the context in which the items I E I must be counted; the items I E I are the fragments that must be counted. If we consider the problem of mining  association rules among authors appearing in the same pa- pers, we have that 1) are the set of trees (i.e., fragments) of all the publications authored by people within the de-  partment. The items I E I are lhe sel of fragments of all the authors who appear in the works published by people within the department. This situation is depicted in Fig- ure 3 where an example of the research. xml document is  represented. The overall document is represented by the grey triangle. The white triangles represent the fragments corresponding to the various publications authored by peo- ple of the department. The black triangles represent the  fragments corresponding to the authors who appear in var- ious publications. Note that, the value of the <Author> tag  is depicted at the bottom of the black triangle, thus a black  triangle labeled Wilson is equivalent to the XML fragment <Author>Wilson</Author>. While the value of a white tri- angle, corresponding to a <Book> lag or lo a <Article> lags, represents an entire XML fragment which corresponds to a book or to an article, e.g.:  ch-icc vcc ',c  \\ '\, y c :,  \ ,~ \ ,  <AIt-I> ,  (! \  .!~ ~~k>k Hol~1 I ~  I \ "  Stolzmann..A.

Wolson  Figure 3. A graphical representation ot the XIML document described in Figure 2.

appear together in two white triangles out of four, i.e., in 50% of the cases. Likewise,!req( {Wilson},'D) is 0.75 since  the fragment <Author>Wilson</Author> appears in three white triangles out of four, i.e., in 75% of the cases. There- fore we can now compute the confidence of the (XML) as- sociation rule:  Wilson::;.. Holmes  as:  freq( { Wilson, Holmes} ,1))  freq(wil-;:0~}:tjj}  which returns 0.66, i.e., in 66% of papers published by Wilson appears also Holmes or, in the XML context, in 66% of the fragments in 1) in which appears the frag-  ment <Author>Wilson</Author> appears also the fragment <Author>Holmes</Author>. While the support of the asso- ciation rule is computed as:  <Article title="Classifier Fitness. ..">  <Author>Wilson<IAuthor>  <Journal year="1995" month="4" volume="4"  name="Evolutionary Computation"  publisher="MIT Press" 1>  </Article>  freq({Wilson,Holmes},V) In the example in Figure 3, 1) contains the four white  triangles and I contains the the three black triangles cor- responding to the authors Holmes, Stolzmann, and Wilson.

While an itemset X C I is a set containing black trian- gles. It is now possible to compute freq(X , 1)) as the per- centage of XML fragments in 1) which contains the frag- ments in X. In particular, freq(X ,1)) is computed as the  percentage of white triangles which contain all the black triangles in X. Thus, in the example depicted in Fig- ure 3,freq({Wilson,Holmes},1)) is 0.5 since the fragments  <Author>Wilson</Author> and <Author>Holmes<Author>  which returns 0.5 since <Author>Wilson</Author> appears together with <Author>Holmes</Author>, in two white tri-  angles out of four, i.e., in 50% of the cases.

4. The X MINE Operator  We devised X MINE operator as a tool to specify com-  plex association rule mining tasks in XML documents.

,!7 rc  ccclVc, \ c\ \ C\  c cl c c c \  , c c c     clauses, "SUPPORT=O .1 " and "CONFIDENCE=O .2". The final  RETURN c]ause specifies the structure of the association ru]es  produced. An association rule is defined by a RULE tag.

with two attributes, support and confidence which specify  the support and confidence values; and two subelements, <BODY> and <HEAD>, which specify the items in the rule body and in the rule head. Some of the rules produced by the above statement on the data depicted in Figure 2 are the fol-  lowing:  X MINE allows the specification of complex mining task com-  pactly and intuitively, and puts in evidence the most rel-  evant semantic features of the problem. XMINE is based  on XPath [13], inspired to the syntax of XQuery, and to  the work on MINE RULE [10] in the context of relational databases. Following the approach of [10], we present  X MINE through a set of examples; additional examples, as well as the X MINE formal syntax and the theoretical founda-  tions ofXML association rules, can be found in [6, 5].

Example I. In this first example, we consider the problem  of mining frequent associations among people who appear as coauthors (see Section 2). With X MINE we formulate this  task with the following statement.

<RULE support="O.25" confidence="O.33">  <BODY>  <Item> <Author>Holmes<IAuthor> <lItem>  <IBODY>  <HE.W>  <Item> <Author>Stolzmann<IAuthor> <lItem;  <IHEAD>  <IRULE>  XMINE RULE  IN document (nwww.atlantis.edu/research.xml"  FOR ROOT IN //People/*/Publications/*  LET BODY := ROOT/Author,  HEAD := ROOT/Author  EXTRACTING RULES WITH  SUPPORT = 0.1 AND CONFIDENCE = 0.2  RETURN  <RULE support={ SUPPORT 1  confidence={ CONFIDENCE 1>  <BODY> { FOR $item IN BODY  RETURN <Item> { $Item 1 <Item> 1  <RULE support="0.2S" confidence="O.SO">  <BODY>  <Item> <Author>Stolzmann<IAuthor> <lItem>  <Item> <Author>Wilson<IAuthor> <lItem>  <IBODY>  <HEAD>  <Item> <Author>Holmes<IAuthor> <lItem>  <IHEAD>  <IRULE>  </BODY>  <HEAD> FOR $item IN HEAD  RETURN <Item> ( $Item <Item> }  </HEAD>  </RULE>  The statement begins with the IN clause which specifies the data source, i.e., the document found at the URL  http://www.atlantis.com/research.xml. In the FOR sec- tion, the special variable ROOT specifies the fragments which  represent the transactions T E ID by means of one (or more)  XPath expressions. In the example in Figure 3, ROOT iden-  tifies the white triangles. The next two special variables, BODY and HEAD, identify the fragments in the source data which should appear respectively in the rule body and in the rule head, i.e., the set of items I E I. Note that both  BODY and HEAD are defined with respect to the context (i.e., to the ROOT variable) since confidence and support values  have meaning only with respect to the context defined by the ROOT (i.e., the set of transactions ID). More specifi-  cal\y, BODY and HEAD are defined as Author elements appear-  ing in some Publications. Since the Author element ap-  pears both in articles and in books, Author is specified as a subelement of Publications/*. The EXTRACTING RULES WITH clause specifies constraints on the resulting rules. In the above statements, these constraints are very simple since  they only specifies the minimum support and the minimum confidence values for the output association rules with the  Where, the latter RULE fragment represents the rule with <Author>Stolzmann</Author> and <Author>Wilson</Author> as body. and <Author>Holmes</Author> as head; the rule has sup- port 0.25 and confidence 0.5. Note that in the remaining, we will omit the RETURN clause from the examples, since the one discussed above can be applied to all of them. In  addition, X MINE assumes that whenever RETURN is missing, the output association rules will be produced according to  the PMML 2.0 specification [8] .

Example 2. In the second example, we require that at least one of the authors in the body of the generated rules is a member of the department. This means that an addi- tional constraint must be added to the EXTRACTING RULES WITH clause used in the previous example. In particular. we add an XQuery predicate requiring that at least one of the authors' names (denoted by the $a variable) be contained in the Personal Info element. denoting the members of the department. In addition, we add a filtering condition, with an appropriate WHERE clause, so to restrict the source data to the publications printed in 200 1. The resulting statement is the following.

XMINE RULE  IN document("www.atlantis.edu/research.xml"  FOR ROOT IN //People/./Publications/*  LET BODY := P,OOT/Author,     ROOT/Publications/Article/Journal/@publisher,  ROOT/Publications/Article/Conference/@name,  HEAD := ROOT/Award/@society,  EXTRACTING RULES WITH  SUPPORT = 0.1 AND CONFIDENCE = 0.2  HEAD := ROOT/Author  WHERE ROOT//@year = 2001  EXTRACTING RULES WITH  SUPPORT = 0.1 AND CONFIDENCE = 0.2 AND  SOME $a IN BODY SATISFIES  not(empty(//People/*/PersonalInfo/Name[=$a]))  Example 5. In XML, there is a slight distinction between the document data and the document structure. Accord-  ingly, with XMINE we can intermix data and structural infor- mation in the same mining task. As an example, consider  the problem of discovering which kinds of awards may in- fluence the career, i.e., best correlates with the specific po- sition of the members of the department. This mining task  can be expressed through the following statement.

The WHERE clause has an obvious side effect on the gener- ated rules, since all the publications that do not satisfy the  condition are pruned before rule generation. Therefore, the resulting context is a subset of the previous one, and both  support and confidence take different values. Note that the WHERE clause is just a filtering condition, not a constraints.

This means that the WHERE clause must be considered before the association rules are generated.

Example 3. So far we presented rules in which the head  and body fragment sets are defined by the same path ex- pressions, and thus pertain to the same domain. The next  example shows instead rules mining collaborations extract- ing authors when they publish papers on the same topic.

This means that the rule HEAD will be extracted from the  Author elements, and the rule BODY from the Keyword ele- ments. A proper association between authors and keywords  imposes that the ROOT be set as /People/* /Publications/*  (all publications).

X MINE RULE  IN document(.www.atlantis.edu/research.xml.'  FOR ROOT IN /People/*  LET BODY := ROOT/Award/@society,  HEAD := ROOT/name()  EXTRACTING RULES WITH  SUPPORT = 0.1 AND CONFIDENCE = 0.2  Note that the the positions "covered" by the members are  expressed as different tagnames (that are related to the doc- ument structure), and not as regular data. In order to com- pactly denote all career of a Department's member, the HEAD definition exploits the XPath name ( ) step, that extract the  tagname of the items to which it is applied. This feature is  particularly relevant when the mining activity is addressed arbitrary tags in arbitrary positions, e.g., when documents describe the same application domain with different Dills.

Additional Features. There are other features of X MINE that are not discussed here. Probably, the most relevant is the GROUP BY clause that can be use to restructure the source data when these do not allow the specification of adequate rule context [5]. We refer the reader to [6, 5] for further details.

X MINE RULE  IN document(nwww.atlantis.edu/research.xmln)  FOR ROOT IN /People/*/Publications/*  LET BODY := ROOT/Author,  HEAD := ROOT/Keyword  EXTRACTING RULES WITH  SUPPORT = 0.1 AND CONFIDENCE = 0.2 AND  count (BODY) >= 2  5. Support and Confidence for XML Association Rules  Since the intrinsic meaning of the task is to find col-  laborations, an obvious restriction to the generated rules is that they should contain at least two authors in the body, and this is expressed by the generic XQuery predicate count (BODY) >=2, in addition to predicates defining the min- imum support and confidence.

Example 4. The next example shows the use of several path expressions. We want to discover the associations be- tween publications and awards, looking for which type of publication is mostly related to which kind of award. Since  ,the publishers are represented as attributes in Journal ele- ments and as PCDATA content in Books. while the conter-  ence types are stored as name attributes, the BODY fragment set is the set union of the nodes which three different path expressions evaluate to.

Before we can discuss how the first prototype of X MINE has been implemented we must define how the support and the confidence values of an XML association rule are com- puted. Let XR be the set of XPath expressions specified in  the ROOT section; XB be the set of XPath expressions speci- fied in the BODY section; XH be the set of XPath expressions specified in the HEAD section; XI be XB UXH. In particu- lar, let us focus on the simple case in which the BODY and  the HEAD sections have identical sets of XPath expressions, XI = XB = XH, as in the initial examples in Section 4.

Let value be a function that, given an XPath expression p  and an XML document d returns the set of XML fragments  XMINE RULE  IN document("www.atlantis.edu/research.xml")  FOR ROOT IN /People/*  LET BODY := ROOT/Publications/Book/Publisher,      in d identified by p. Let satisfy be a function that, given an XML fragment f and an XQuery where clause w, returns  one if f satisfies w, zero otherwise. Let contains be a func- tion that, given an XML fragment x and an XML fragment  y, returns one if x contains y, zero otherwise. First, we com- pute the set F'D as the collection of all the XML fragments  defined by the XPath expressions in XR, more formally:  overall process is illustrated in Figure 4. In the initial pre-  processing step (illustrated in Figure 4 with arrows from 1  to 4), the X MINE statement is processed to generate a repre- sentation of the XML mining problem as a relational table R  which can subsequently elaborated by a known association  rule mining algorithm. Then in the following mining step, association rules are extracted from R; during this phase the constraints specified in the EXTRACTING RULES clause are  exploited by the mining algorithm (Figure 4, arrow labeled 5). In the final post processing step, the association rules extracted from relation R are finally mapped into the XML  representation (Figure 4, arrow labeled 6).

F'1) = U value(p,d)  pEXR  Likewise, we compute the set F I as the collection of  XML fragments that are defined by the XPath expressions  in XI.

Preprocessing. First the sets Fq) and F I (see Section 5) are generated (Figure 6, arrow from 1 to 3). These sets contain the XML fragments addressed by the XPath expres- sions specified in the clauses ROOT (Fq), HEAD, and BODY (F I ).

In general, this step could be implemented by any of the  available XPath interpreters; in our case, we use the Java implementation ofXalan [11]. Then the sets F~ and F; con-  taining the XML fragments in Fq) and FI which satisfy the WHERE clause are generated. This step is implemented on the top of the Xalan interpreter of Xpath. Note that since there is no XQuery interpreter currently available, our initial im- plementation supports only basic WHERE conditions mainly based on XPath expressions such as: ROOT//@year=2001.

With the sets F~ and F; the relational table R is generatt;d  as follows.

F[ = U value(p,d)  pEXl  We now define F~ and F: by filtering the sets Fv and F[  through the XQuery where clause w specified in the WHERE  section. F~ and F} are defined as follows:  F~ = {I I I E Fv I\ satis.fy(I, w) }  F: = {I I I E F[ 1\.\'atis.fy(I, w)}  From the definitions of F~ and F; it is now possible to  compute thefrequency of an itemsetX. X E F;. as follows:  ECEF~ n/EXcontains( C , I) freq(X, F~) =  IFbl  Given the function freq it is then possible to extract fre-  quent (XML) itemsets from an XML document. Therefore it is possible to extract the association rules, as specified in the X MINE statement. Note that all the three functions used to define the jreq are available or easy to implement. In  particular, the function value can be directly implemented by any of the available XPath interpreter (e.g., Xalan [11]).

The function satisfy can be implemented by an XPath in- terpreter, if the conditions in the WHERE clause are simple enough; by an XQuery interpreter when this will become  available. The function contains can be again easily imple- mented on top of an XPath interpreter (see Section 6).

.R has as many attributes (i.e., columns) as is the num-  berofXML fragments in F}, i.e., R C {0, l}IFIi.

.R has as many tuples (i.e., rows) as the number of frag- ments in F~, i.e., R = { TI, ..., TIF~I } ;  .for every XML fragment Ci E F~ and every XML frag- mentfj E F;, a tuple Ti E R, Ti = (Ti,I...ri,IFll), is de- fined as Ti,j = contains(ci,fj).

From Section 5 we recall that the function contains(ci,fj) returns one if the fragment Ci contains f j. Note that the cur- rent implementations of XPath do not provide any method  to check whether a fragment appear in another fragment.

Accordingly, in our prototype the function contains is im- plemented on the top of the XPath interpreter as follows.

Given two fragments Ci and fj, their textual representation is generated exploiting the functionalities of the XPath in-  terpreter. Then it is checked whether the textual represen- tation of fj actually appear in the textual representation of Ci; if it does, one is returned, otherwise zero. This solution is indeed computationally expensive, but on the other hand, the comparison ofXML fragments is one of the major open issues in the XML community. Thus, it might be possible  in the future to reduce the complexity of this phase through some advanced technique introduced in the next versions of  6. The Architecture of X MINE  X MINE has been devised as an extension of the XML  Query language [14] and therefore it could be easily im- plemented on the top of an. XQuery interpreter. However, because of the lack of a robust XQuery execution environ- ment, the current implementation is built on the coupling of the Xalan [11] XPath interpreter and an algorithm to ex- tract association rules from relational data. The XMINE pro-  totype has been implemented as a three-step process [7],  namely, preprocessing, mining, and postprocessing. The     SOIIrt?XMl~nt  --u XJlINE RULE .-"' I I  INdoc-nt.(...) -c---:: UFOR ROOT IN. ..

LET = ~: .~ .~ -(3)- Itereddoal..nt  WRDE .~(2) DEXTRACTING RULES WITB \ SUPPORT AHD CONFIDENCE jJ  I8IaticxIalllPl8lent8tion  EJ  -(5)-- ~J  8IIodItiIIn8s  EJ  -(8)-- jJ  XMl asmaoon rulos  D  -(1)- - --  /  (.),  ~  ""-  ~~  Figure 4. The architecture of the X MINE prototype.

which have been memorized during the preprocessing, such as the correspondence between the XML fragments in F~ and F; and the attributes in R, is exploited in order to print  an XML version of the association rules generated through  the Apriori algorithm.

XPath and XQuery. Finally, the constraints specified in the EXTRACTING clause are represented so to be exploited by the association rule mining algorithm, in the next phase (Fig-  ure 6, arrow from 4).

Mining. With the table R and the constraints extracted from the EXTRACTING RULE clause in the previous phase, associa- tion rules are extracted (Figure 6, arrow from 5). In the  initial implementation presented here this phase is based on the plain Apriori algorithm. Note that among the many con- straints which might be specified, our implementation cur- rently considers only constraints concerning the composi- tion of the rules (e.g., the number of items in the rule head or body), the minimum support, and tlle minimum confidence.

In fact, some compJex constraints (e.g., those described in [5]) are currently not possible with a tabular representation- but they would require mining the XML association rules  directly from the DOM (Document Object Model) represen- tation. DOM offers a platfonn-and language-neutral API  (Application Programming Interface) allowing programs to  dynamically access and update the content, structure and style of the documents. Recently we decided to implement this mining step by using MINE RULE [10] since it allows a better specification of complex constraints. The new ver- sion of X MINE is still under implementation.

7. Notes on the Implementation  The X MINE prototype has been implemented in Java on the top of the Xalan XPath 1.0 [11] interpreter and DOM; the mining phase was initially implemented with the plain Java implementation available in Weka [3]. Efficiency has not been of our main concern in developing the initial im- plementation of X MINE. However, the first experiments of use are good thanks to the excellent performance of the Xalan XPath interpreter. In addition, our initial experi-  ments suggests that the preprocessing and postprocessing steps are reasonably fast with respect to the central min-  ing phase. Our first experiments conducted on some sim-  ple bibliographic XML documents obtained by using Bib- TeXML [2] showed that in general, association rule min-  ing is quite a complex task if compared to the simple pre- processing needed to produce the relational representation needed for mining. More specifically, in our initial exper- iments we noted that preprocessing and postprocessing to-  gether required less than the 20% of the overall computing time [7]. Note however that since the structure of source documents was quite simple with respect to that of most  Postprocessing. In the final step (depicted in Figure 6 with arrow 6), association rules extracted from relational data are mapped into the XML representation. Here the information      XML documents, these preliminary results surely lack of  generality. These considerations suggest that an efficient execution of X MINE statements is feasible with current tech-  nology as long as the statement includes only XPath expres- sions or basic XQuery WHERE conditions. Our three-step  process, which exploits an intermediate relational represen-  tation, allowed us to implement a basic prototype smoothly.

On the other hand, the lack of a robust XQuery execution environment does not allow us to compute the complex  predicates supported by the X MINE syntax on a native XML representation. The implementation we presented here (see also [7]) leaves many open issues, which must be addressed to have a fully functional and efficient implementation of  the X MINE operator. We believe that the most important open issue regards the support evaluation, which should be used to extract association rules from XML documents.

There are currently no XQuery interpreters to be used in fil- tering XML fragments and although XPath processors are quite advanced, they do not yet provide all the required functionalities either. Many of these functionalities should be included in the new XPath 2.0 version, while some oper-  ations needed for advanced options [5] are still not defined  but are still requirements of the W3C consortium. There-  fore, many required computation must be coded directly on the raw DOM representation of the documents (e.g., the fil-  tering of WHERE clauses) which causes some computational overhead. Note that in our prototype we implemented some of these functionalities on the top of DOM and XPath 1.0 Xalan interpreter, however, we do not plan to implement all the functionalities needed by X MINE. In fact, we expect re- liable XPath 2.0 and XQuery execution environments to be  available in the very near future.

