TSINGHUA SCIENCE AND TECHNOLOGY ISSNll1007-0214ll01/09llpp227?242

Abstract: Data quality is an important aspect in data application and management, and currency is one of the major  dimensions influencing its quality. In real applications, datasets timestamps are often incomplete and unavailable,  or even absent. With the increasing requirements to update real-time data, existing methods can fail to adequately  determine the currency of entities. In consideration of the velocity of big data, we propose a series of efficient  algorithms for determining the currency of dynamic datasets, which we divide into two steps. In the preprocessing  step, to better determine data currency and accelerate dataset updating, we propose the use of a topological graph  of the processing order of the entity attributes. Then, we construct an Entity Query B-Tree (EQB-Tree) structure and  an Entity Storage Dynamic Linked List (ES-DLL) to improve the querying and updating processes of both the data  currency graph and currency scores. In the currency determination step, we propose definitions of the currency  score and currency information for tuples referring to the same entity and use examples to discuss methods and  algorithms for their computation. Based on our experimental results with both real and synthetic data, we verify that  our methods can efficiently update data in the correct order of currency.

Key words: data quality management; data currency; dynamic determining  1 Introduction  With todays rapid growth in the volumes of data, data quality is becoming a crucial problem in data management. As one of the most important dimensions of data quality, data currency problems are becoming more troublesome in practical databases and information systems. Statistically speaking, about 2% of all customer business data information will be obsolete within a month[1]. In other words, about 50% of all data is rendered unavailable because it is stale.

Furthermore, out-of-date datasets may lead to incorrect decisions by decision-makers, which can result in  ?Xiaoou Ding, Hongzhi Wang, Yitong Gao, Jianzhong Li, and Hong Gao are with School of Computer Science and Technology, Harbin Institute of Technology, Harbin 150001, China. E-mail: dingxiaoou@stu.hit.edu.cn; wangzh@hit.edu.

cn; gaoyitong@163.com; lijzh@hit.edu.cn; honggao@hit.edu.

cn.

?To whom correspondence should be addressed.

Manuscript received: 2017-03-26; revised: 2017-04-06; accepted: 2017-04-11  economic losses in organizations[2]. In the United States alone, businesses are reported to suffer annual financial losses of 600 billion dollars due to data quality problems (Refs. [1, 3]). In one 2005 example, out-of- date customer information in a bank database led to thousands of completed tax forms being sent to obsolete addresses, making it possible for identity thieves to effortlessly obtain the names and bank accounts of many individuals. In another case, the Internal Revenue Service (IRS) accused some people for overdue tax caused by errors in the IRS database system[4]. With the increasing seriousness of data currency problems in this big data era, research is both necessary and urgent.

For practical applications in which timestamps are invalid or unavailable (Refs. [5, 6]), one major area of data currency research involves currency determination by the analysis of the attribute currency order of entities with reliable currency constraints. However, during the updating process of massive volumes of dynamic data, traditional static determination methods cannot adapt to the need for prompt updates in the big data and are therefore ineffective (such as the price problem in Ref. [7]). Existing currency determination methods can    228 Tsinghua Science and Technology, June 2017, 22(3): 227?242  fail to provide sufficient guidance for making timely information updates in entities.

As yet, little research has been done to determine the currency of dynamic data that lack available timestamps. The main challenges in determining data currency are as follows: ? Performance bottlenecks related to large  volumes of data. With the rapid growth in the volume and diversity of information, the performance of algorithms in determining the currency of data faces serious challenges with respect to efficiency, effectiveness, and accuracy.

? Complex conditions in dynamic data  updating. To minimize confusion in temporal dataset management, when data arrives to be updated, the corresponding entity must be queried and its tuples be maintained in their order of currency. Accordingly, different dynamic data types and sizes add to the complexity of updating the original dataset.

? High demand for real-time updating. With our  growing ability to generate and obtain data, demand for real-time information and knowledge is increasing both in business and between customers. The efficiency and quality of the data updating process is influenced by numerous factors such as the computer resources and capabilities, data volume, and algorithm performances.

? Difficulties in identifying dependable principles  for currency determination. It is not easy to identify reliable and practicable principles for analyzing the currency of dynamic datasets that lack timestamps.

In this paper, we propose a series of efficient algorithms for the dynamic and real-time determination of data currency based on the volume and velocity of large-scale dynamic data. We present examples that illustrate the motivation for this paper in Section 1.1 below.

1.1 Motivating examples  Example 1 As shown in Table 1, the personal information relational dataset named Info has two  entities that record student information when they are enrolled in college and after they graduate. The table presents recent study and work information of two students, Alice and Tom. Each tuple provides personal details including tID, eID, Name, Sex, Degree, Position, College, Address, Salary, and Status.

Here, tID and eID represent tuple ID number and entity ID number, respectively.

To rapidly update the dataset Info, while maintaining the correct order of currency of the tuples of each entity, we first preprocess the dataset Info (initial dataset) by recording the storage addresses of all entities and maintaining the currency order of the tuples in Info.

If we assume that there are no valid or complete timestamps in the entities in Info, we can then identify the following currency constraints (rules) and use them to determine the currency order in each entity.

r1: The degree in a given entity is only from Bachelor  to Master, and from Master to PhD.

r2: The status of a given entity is only from Single to  Married.

r3: The salary of a given entity only increases with  time.

r4: If a given Salary value in the same entity is the  most current, the corresponding tuple of the Address value is also most current.

We use ti ? tj to represent that tuple tj is more current than ti , and ti D tj to indicate that ti has the same currency order with tj [5]. Accordingly, the above currency rules, as shown in Definition 3, can be represented as follows: r1: 8t1; t2 2 Info;  ? t1?eID? D t2?eID? ^  .t1?Degree? D Bachelor ^ t2?Degree? D Master/  ? ?! t1 ?Degree t2;  and 8t1; t2 2 Info; ? t1?eID? D t2?eID?^.t1?Degree? D  Master ^ t2?Degree? D PhD/ ? ?! t1 ?Degree t2:  r2: 8t1; t2 2 Info; ? t1?eID? D t2?eID? ^  .t1?Status? D Single ^ t2?Status? D Married/ ? !

t1 ?Status t2:  r3: 8t1; t2 2 Info; ? t1?eID? D t2?eID? ^  Table 1 Entity relations dataset Info.

tID eID Name Sex Degree Position College Address Salary Status  t1 e1 Alice F Bachelor Student HIT 3-DP 40 Single t2 e1 Alice F Master Student HIT 15-DP 500 Single t3 e1 Alice F Master Programmer HIT Beijing 12 000 Single t1 e2 Tom M Bachelor Student HIT 1-DP 40 Single t2 e2 Tom M Master Student HIT 16-DP 500 Single t3 e2 Tom M PhD Student HIT 10-DP 1000 Married    Xiaoou Ding et al.: Efficient Currency Determination Algorithms for Dynamic Data 229  .t1?Salary? < t2?Salary?/ ? ?! t1 ?Status t2:  r4: 8t1; t2 2 Info; ? t1?eID? D t2?eID? ^ .t1 ?Status  t2/ ? ?! t1 ?Address t2:  To take the entity Alice as instance, according to the above currency rules, we can determine the currency order of each attribute of the entity Alice to be follows: (1) Degree: Bachelor ? Master; (2) Address: 3-DP ?15-DP? Beijing; (3) Salary: 40 ? 500 ? 12 000. To describe the currency order of each attribute?s value in each of the entities in the dataset, we introduce currency scores (numerical values) to compute the currency of the values of some particular attributes that have a major impact on determining the currency of the tuple. In general, the greater is this score, the more current is the attribute?s value. We discuss the relative definitions and computation process in Section 4.2.

Next, we suppose we have the need to insert a tuple tnew (as shown in Table 2) into Info as described in the following example.

Firstly, we must rapidly identify the storage address of the entity in the dataset Info corresponding to the tuple tnew. Then, using the currency rules (r1 to r4), we determine the currency of the attributes based on the tnew currency scores. Then, we efficiently insert this tnew currency information in the correct location to ensure that the dataset maintains the correct data currency.

1.2 Contributions  In this paper, we introduce a model for dynamically determining data currency and propose several efficient algorithms related mainly to preprocessing and real- time dynamic determination. We can summarize our contributions as follows: ? To the best of our knowledge, we are the first  to propose algorithms for determining the currency of dynamic data, and we also introduce an integrated process for the currency determining algorithms.

? To accelerate the entity updating process, we  introduce an efficient structure for indexing and querying dataset entities, known as the Entity Query B- Tree index (EQB-Tree) and the Entity Storage Dynamic Linked List (ES-DLL).

? We propose methods for directly determining and  computing the currency of the attributes in an entity.

This updating approach, which uses both a currency graph and currency score, accurately determines the currency of information in dynamic data.

? In a series of experiments, we verify the efficiency  of our methods and algorithms on both real-life and synthetic data.

Organization. The organization of the rest of this paper is as follows: In Section 2, we discuss related work in data currency determination and management.

In Section 3, we introduce our model for dynamic data currency determination and we discuss the algorithms used for currency determination in Section 4. We report our experimental study results in Section 5, and in Section 6, we draw our conclusions.

2 Related Work  In the data quality management literature, there is no standard definition of currency[8]. In recent years, research on data currency has mainly involved two approaches to data repair, namely currency determination methods based on available timestamps and those based on constraints and rules.

Currency determining with timestamps. Datasets that include timestamps provide clear time points for each transaction, and out-of-date records in the dataset can be easily identified via querying and computing operations. The main research focus in Refs. [9, 10] is querying the most current records based on timestamps and temporal constraints within the databases. In some papers, (e.g., Refs. [11?16]), the freshness degree of the dataset is indicated by the attribute parameter age, which is defined as the time gap between the assessment of currency and the acquisition of the attribute?s values.

Shelf life is also an indicator of value volatility and currency is calculated as a function of the age of an attribute?s value and its shelf life in the dataset. The authors in Refs. [14, 15] also proposed a probability- based metric for determining currency that estimates the decline rate based on historical data, in which a quick decline rate inevitably leads to outdated currency.

With valid, accurate, and complete timestamps, determining currency becomes much simpler and easier as the algorithms can be easily and clearly designed, which makes them highly efficient, scalable, and  Table 2 New tuple for Alice.

Name Sex Degree Position College Address Salary Status  Alice F Master Programmer HIT Shanghai 12 000 Married    230 Tsinghua Science and Technology, June 2017, 22(3): 227?242  accurate in their data currency analysis. Moreover, less expertise is required to develop these algorithms, which means lower costs related to determining currency and repairing data. However, dependence on timestamps also makes the metrics inapplicable to real information systems that have no valid timestamps due to the extensiveness of the data sources, changes in data storage, or other circumstances. Furthermore, data currency determination is not always reliable when it is based merely on the age of the data or other similar parameters in the data records. Under certain conditions, old data may not necessarily mean that it is no longer current. For example, historical meteorological information for a given location continues to be important for climate change research.

Currency determining based on constraints and rules. In view of the fact that timestamps are often incomplete or nonexistent in real applications, the authors in Ref. [5] were the first to propose a rule- based model for determining data currency. In the paper, the authors discussed theoretical issues related to several fundamental problems. To investigate data currency, they associated the partial currency orders, denial constraints[17, 18], and copy functions[13, 19] of data sources, but proposed no practical algorithms. The authors in Refs. [2,20] conducted further research based on the theory presented in Ref. [5]. In Ref. [2], the authors presented currency evaluation methods using currency constraints and redundant records on which they based the construction of a currency graph for a given entity. Then, they used a topological algorithm to determine a time series and new values of the entity for different attributes, as well as the time complexity of the algorithm in polynomial time. The authors in Ref. [20] also developed effective algorithms and top-k heuristic algorithms underlying a model for determining relative accuracy and currency. Based on the work in Ref. [2] and with a focus on improving data quality, the authors in Ref. [6] were the first to combine data quality rules and statistical techniques to improve data currency. They also proposed currency repairing rules and discussed relative problems in theory.

In other work, currency problems have been associated with other impact factors (e.g., Refs. [21? 23]) to solve data cleaning and repair problems. The authors in Refs. [21, 23] studied both data currency and consistency to achieve conflict resolution in datasets and introduced a framework and efficient algorithms  for conflict resolution that combines partial currency orders, currency constraints, and conditional functional dependencies[5].

Rule-based methods for determining data currency have wide applications in real information systems.

There is no denying that the process of determining currency is generally complex and costly. Faced with large-scale data, currency determination research involves challenges in efficiency and data updating. In Ref. [24], we proposed currency determination methods for dynamic datasets, based on the use of currency graphs and scores to determine the currency of the different tuples of entities.

Based on our work in Ref. [24], here we present further research to improve the accuracy and effectiveness of the determination of data currency. We propose the use of a topological graph of the processing order of entity attributes and discuss the preprocessing algorithms used to create an EQB-Tree and ES-DLL.

We also define the term Currency Information and present a corresponding computation and updating method.

3 Overview  In this section, we present an overview and discuss the dynamic data currency problem. In Section 3.1, we provide background knowledge and some fundamental definitions of data currency, and we propose our method framework in Section 3.2.

3.1 Definitions  The dataset and currency rules we employ in this paper for determining currency are the same as those used by the authors in Ref. [5], and we present them below as Definition 1 and Definition 2, respectively.

Definition 1 Initial Relations Dataset D Suppose the data schema R D .tID;eID; A1; :::; An/, where tID is the tuple ID number, eID is the entity ID number, and A D fA1; :::; Ang is the set of attributes. E D fe1; e2; :::; emg is the set of all the entities involved in the dataset. If ti ?eID? D tj ?eID?, then the tuples ti and tj represent the same entity, and ti ?Ak? represents the value of the attribute Ak in tuple ti . Dataset D is the set including massive instances like those in data schema R.

Definition 2 Currency Rules The currency constraints are used to determine the currency of data for which timestamps are incomplete, unreliable, or do not exist. In the set of currency    Xiaoou Ding et al.: Efficient Currency Determination Algorithms for Dynamic Data 231  rules: ?CR D fti ?eID? D tj ?eID? ^  j i; j 2 ?1; Ne?g, Ne is the number of entities in the dataset D, and represents the predicate in an instance of rules. There are mainly three main kinds of rules regarding  : '1: 8t1; t2;  ? t1?eID? D t2?eID? ^ .t1?Ak? D v1 ^  t2?Ak? D v2/ ? ?! t1 ?Ak t2I  '2: 8t1; t2; ? t1?eID? D t2?eID? ^ .t1?Ak? op t2?Ak?/  ? ?! t1 ?Ak t2; op D f>;<;>;6;D;?gI '3: 8t1; t2;  ? t1?eID? D t2?eID? ^ .t1 ?Ak t2/  ? ?!

t1 ?Am t2:  We refer to the Left-Hand Side of ?! as the LHS of 'i and the Right-Hand Side as RHS. Accordingly, we use ?1 to describe a set of instances, such as '1, ?2 to describe '2, and ?3 to describe '3 (?1; ?2, and ?3 2 ?CR). Considering the Currency Rules in the above motivating example, r1 and r2 are the instances similar to '1, r3 is an instance similar to '2, and r4 is similar to '3.

To analyze the currency of the tuples of each entity, we build a currency graph for entity ei with respect to attribute Ak according to the method used in Ref. [2], as expressed as Definition 3 below.

Definition 3 Entity?s Currency Graph The Directed Graph G.ei / = fG.ei ; Ak/ j ei 2 E ; Ak 2 Ag is the currency graph of ei , in which the vertex set V D ft j t 2 Tei g, and the edge set E D  ? .ti ; tj / j  ti ?Ak tj 2 RHS of .?/  .

3.2 Framework  In our Dynamic Data Currency Problem (DDC), our goal is to establish dynamic real-time updating of the data in the dataset, while maintaining the correct currency order of all the entities in the dataset. The dataset we use in this DDC is similar to the traditional currency problems described in Ref. [5], which occur immediately after the entity recognition process[25].

Due to the fact that the massive entities in large- scale datasets can have multiple records (tuples) for the same entity, we propose approaches for determining the data currency of dynamic data. Figure 1 shows the framework of our method, which consists of two main phases: Data Preprocessing and Dynamic Currency Determination.

As shown in Fig. 1, we propose to conduct data preprocessing offline and data currency determination online. We preprocess the initial dataset offline to obtain concise currency information and avoid duplicate computation in the following step. During the dynamic determination step, we can efficiently update online the current tuples to be inserted into the dataset in the correct currency order based on the analysis results from the preprocessing step.

(a) Preprocessing Since the original data in many applications is often disordered and unsystematic, preprocessing is necessary to achieve better DDC processing. First, we create a B-Tree index structure for querying entities (EQB-Tree) and initialize all the entities in dataset D that record the head address of each entity. Then, we create and initialize a dynamic linked list for the storage of entities (ES-DLL), which helps to reduce the time required to update data in the dynamic determination phase. Next, we create currency scores and currency graphs for the entities in D are created. Suppose that the currency graph of entity ei : G.ei / D  ? G.ei ; Ak/ j i 2 ?1; Ne?; j 2 ?1; n?   , where  G.ei ; Ak/ represents the attribute currency graph of Ak with respect to entity ei , shows the currency scores of the attribute?s values in Ak that were generated by the currency rules. We propose a definition of currency score in Definition 4 below:  Definition 4 Currency Score Suppose the entity  Create EQB-Tree Create and initialize ES-DLL for all tuples  Preprocessing  Create currency graphs  for all entities  Dynamic determination  Locate and identify storage address of updating tuple in EQB-Tree  Compute and update the currency score  Update the ES-DLL and EQB-Tree  A new updating tuple  Initialize currency information for all entities  Fig. 1 Framework for determining currency of dynamic data.

232 Tsinghua Science and Technology, June 2017, 22(3): 227?242  e is one of the entities in the relational dataset D, we express the score of the tuple ti of .ti,e/ as shown in Eq.

(1):  score.ti,e/ D nX  Ak2A;jD1  score ? ti ?Ak?  ? (1)  And the currency score of e is shown in Eq. (2): score.ei / D  X score.tj,e/; j 2 ?1; Nej ? (2)  In Eq. (1), the score of the tuple ti,e is the sum of the currency scores score  ? ti ?Ak?  ? of all attribute values  of the entity e, and all of the scores for the tuples or attribute values are in positive integer forms. The score of the least current attribute value is 1, and the more current is the attribute value ?Ak?, the larger is the currency score of ?Ak?.

After we compute both the currency graph and currency score, we can establish the currency information of entity ei , as defined in Definition 5 below:  Definition 5 Currency Information The Currency Score and Currency Graph both together comprise the Currency Information: curInfoei=  ? G.ei /, score.ei /  ? .

(b) Dynamic Determination Considering a tuple tnew to be updated, we firstly recognize the corresponding entity of tnew by appropriate entity recognition methods proposed in Ref. [26], and then find the storage address of entity ei and create its currency graph  ? G.ei /:addr  ? in EQB-Tree and put the  records and the corresponding currency graph G.ei / into the memory. After that, both the currency graph of ei and the currency scores of attributes? values of tnew are updated. Finally, the ES-DLL with tnew will be updated and the most fresh currency information of ei will be written to the external storages.

4 Algorithms for Currency Determining of Dynamic Data  In this section, we describe in detail our proposed methods and algorithms for determining data currency.

We introduce the algorithms used in offline processing in Section 4.1 and present the currency rule processes in Section 4.1.1, the creation of the EQB-Tree and ES- DLL in Section 4.1.2, and the creation of currency information for entities in Section 4.1.3. In Section 4.2, we discuss the algorithms for online currency determination, including updating the EQB-Tree and ES-DLL (Section 4.2.1), updating the currency graphs (Section 4.2.2), and updating the currency scores (Section 4.2.3). In addition, we analyze examples for  each algorithm. Table 3 lists some of the notations frequently used in this section.

4.1 Algorithms for preprocessing  4.1.1 Processing currency rules Determining whether the currency constraint (namely CSP in Refs. [5, 27]) is satisfied as well as the currency orders of attributes are essential to effectively address currency problems in data quality management, and represent the first step in the determination process.

When determining the currency of information, numerous attributes may need to be considered, which can result in high time costs. To improve the efficiency of calculating the currency of entity information, we propose the use of a topological graph showing the processing order of the entity attributes, based on Definition 6 below.

When processing currency rules ?CR, such as '1 and '2, that help to maintain tuples in the correct temporal order, only one identical attribute is contained in the LHS and RHS of '. However, the involvement of two distinct attributes in '3 does change things. For '3 D f8t1; t2;  ? t1?eID? D t2?eID? ^ .t1 ?Ak t2/  ? ?!

t1 ?Am t2g, the rules must follow a certain processing partial order between attributes Ak and Am.

Definition 6 Attributes Processing Order in Determining Currency For all attributes involved in the set of currency rules ?CR, suppose Ai , Aj 2 A, for a certain currency rule ' 2 ? form as '3 D f8t1; t2;  ? t1?eID? D t2?eID? ^ .t1 ?Ai t2/  ? ?!

t1 ?Aj t2g. As Ai is in the LHS of '3 and Aj in the RHS, Ai must be determined before Aj , and their order is represented as Ai ?curr Aj . Another two attributes, Am involved in 'm and An in 'n ('m ? 'n),  Table 3 Frequent notations.

Notation Description  E The set of entities in dataset D T .e/ The set of tuples referring to a given entity e The predicate in a currency rule ?CR The set of currency rules  G.ei ; Ak/ The currency graph of the entity ei on Ak score.ti;e/ The currency score of the tuple ti referring to e  scoree The total currency score of the entity e curInfoe The currency information of e Q? The currency processing order of attributes ?curr Independent processing order O.e/T The structure used in EQB-Tree for e O.e/L The structure used in ES-DLL for e    Xiaoou Ding et al.: Efficient Currency Determination Algorithms for Dynamic Data 233  are independent of each other when processing rules, so Am ?  curr An.

According to Definition 6, we can obtain a  topological graph of the processing order of the entity attributes. On one hand, with this processing order, the attributes not in ?CR can be filtered out to save time and avoid having to determine attributes that cannot help in the determination of currency in corresponding entities.

In addition, it provides a more efficient and reasonable attribute processing order that avoids duplication and conflict when processing ' 2 ?CR. The algorithm for generating the processing order of the attributes Q? is shown in Algorithm 1.

G.CR/ represents the topological graph of attributes  processing order, and V 0A ? VA is the set of attributes involving ?CR. After initializing G.CR/ in Line 1, we construct the graph according to the rules in ?CR (Lines 2?7). Then, after initializing Queue and Q? (Line 8), we add attributes with 0 in-degree in Queue to Q? (Lines 9?13). If in-degree of all attributes in V 0A is not  Algorithm 1 Generating the processing order of attributes Q?  Input: the set of currency rules ? CR Output: the topological graph of attributes processing order Q?  1: G.CR/ .V 0 A ; E/; V 0  A ?;E  ?  2: for each ' 2 ?CR do 3: add A including in ' into V 0  A ;  4: if ' 2 ?3 then 5: add .Ali ; Alj / into E; 6: end if 7: end for 8: Queue ?;Q?  ?; 9: for each A 2 V 0  A do do  10: if Indegree(A)= 0 then 11: add A into Queue; 12: end if 13: end for 14: while Queue.noEmpty() do 15: A= Queue.pop(); 16: add A to Q? ; 17: delete A from V 0  A and delete .A;Alj / from E;  18: for each A 2 V 0 A  do 19: if Indegree(A)= 0 then 20: add A to Queue; 21: end if 22: if all Indegree(A)? 0; A 2 V 0  A then  23: exit (?1) and adjust ? by users; 24: end if 25: end for 26: end while 27: return Q? ;  equal to 0, this indicates that the rules in ?CR conflict and ?CR will be return to be re-prepared (Lines 22 and 23). Finally, we return Q? as the processing order of attributes (Line 27).

Example 2 Consider currency rules r1; r2; r3; r4 in the motivating example. Figure 2 shows a topological graph of the processing order of the entity attributes, correspondingly.

As we can see in Fig. 2, a possible processing order of the attributes, which we can obtain from Info, is as follows:  Degree ?curr Salary ?curr Status f currAddress.

4.1.2 Creating EQB-Tree and ES-DLL To improve efficiency in querying entities and tuples in dynamic datasets, we propose EQB-Tree and ES-DLL structures in the offline data preprocessing step.

Creating EQB-Tree We designed the structure of the EQB-Tree to find the corresponding entity of the tuples to be rapidly updated and to reduce the updating response time. Consider D D fei j i 2 ?1; Ne?g. The ei node in the EQB-Tree carries important information regarding the entity ei : O.ei /T =fei :key, ei :addr, ei :curInfoAddrg. In the structure O.ei /T , ei .key represents the set of particular attribute values that help to distinguish ei from other entities in E , which can be generated by the similarity functions discussed in Ref. [28]. ei .addr represents the storage address of ei in the dataset for completely querying all the tuples of ei and ei :curInfoAddr represents the storage address of the currency graph in Ref. [2], which maintains the currency orders of the values of the different attributes of entity ei .

Algorithm 2 presents the procedure for creating the EQB-Tree TD . First, we initialize the EQB-Tree with the head node (Line 1), then we initialize the key, addr, curInfoAddr of the ei node and insert this node to TD (Lines 2?7). Lastly, we return TD as the EQB-Tree for the entities in D (Line 8).

Example 3 Suppose another dataset Employee  Degree  AddressStatus  Salary  Fig. 2 Topological graph of the processing order of the entity attributes in the motivating example.

234 Tsinghua Science and Technology, June 2017, 22(3): 227?242  Algorithm 2 Bulid EQB-Tree Input: D Output: TD  1: TD = init Tree(); 2: for each ei 2 D do 3: acquire ei :key in OTei ; 4: initialize ei :addr; 5: initialize ei :curInfoAddr; 6: insert Node.ei / to TD by ei :key; 7: end for 8: return TD  containing employee information for a company with the 21 entities that describe the employees fAlice, Carina, Dean, Edward, George, Harry, July, Kelly, Linda, Mary, Nick, Peter, Qearl, Rose, Sweety, Tom, Victor, Wendy, Xavier, Yilia, Zoeg. If ei :key = name, we can create the EQB-Tree of Employee, as shown in Fig. 3. Accordingly, information regarding a certain entity can be efficiently queried using the structure of the EQB-Tree.

Creating ES-DLL After creating the EQB-Tree of the entities, we create and initialize the ES-DLL to efficiently insert new tuples into the dataset. Each node in the ES-DLL carries information regarding the structure O.ei /L= ftj;ei , addr.tjC1;ei / j i 2 ?1; Ne?; j 2 ?1; Nt ?g, in which tj;ei represents one of the tuples in entity ei , and addr.tjC1;ei / represents the storage address of the next tuple immediately following tj;ei .

If tj;ei is the last tuple describing entity ei , then addr.tjC1;ei / D ?1: As noted above, the head address ei :addr is stored in the EQB-Tree, by which all records for ei in the ES-DLL can be acquired.

Algorithm 3 presents the procedure for creating the ES-DLL LD . First, we initialize a new external file for  LD (Line 1). Then, for each tuple of each entity in D, we initialize the ei .address with the current file pointer (Line 4) and each node of LD can be written with the format tj , addr.tjC1/, in which ?1 represents the end of entity ei and the function getNextTupleAddress() obtains the sum of the current file pointer and the length occupied by tj , which is the address tjC1 in LD (Lines 5?10). Lastly, we return LD as the initiative ES-DLL (Line 13).

Example 4 Consider the above motivating example, we can create a linked list ES-DLL of the two entities Tom and Alice using Algorithm 3, as shown in Fig. 4.

4.1.3 Creating currency information for entities Creating currency graphs and obtaining currency information is also a critical step in data preprocessing.

Furthermore, currency graphs and scores represent the most important part of dynamic determination, as they provide the correct currency order for the tuples of the  Algorithm 3 Init ES-SLL LD Input: D Output: LD  1: LD= init list(); 2: for each ei 2 D do 3: for each ti 2 T do 4: ei :address = LD :getFilePointer(); 5: if tj is the last tuple about ei then 6: addr.tjC1/ D ?1; 7: else 8: addr.tjC1/= getNextTupleAddress(); 9: end if  10: insert tj and addr.tjC1/ to LD ; 11: end for 12: end for 13: return LD  Mary  Dean, Harry Qearl, Tom, Xavier  Judy, Kelly, LindaEdward, GeorgeAlice, Carina Nick, Peter Rose, Sweety Victor, Wendy Yilia, Zoe  One Node  Alice Alice.addr  Alice.curInfoAddr  Head[T]  Fig. 3 EQB-Tree constructed in Example 3.

Xiaoou Ding et al.: Efficient Currency Determination Algorithms for Dynamic Data 235  Fig. 4 ES-DLL created in the motivating example.

same entity. Algorithm 4 shows the pseudo code for obtaining entity Currency Information.

In Algorithm 4, first, we obtain currency graphs of the attributes involved in the course of determining the currency (Lines 1?14). After creating the currency graph of e on A (Line 1), we add it to Ge (Lines 2 and 3), and compute the currency score scoree for e (Lines 4?13). During this process, each tuple (vertex) of e with zero in-degree is added into the queue (Lines 4 and 5). In Lines 6?13, tuples are added with their currency scores, and the fresher is the data, the higher is the score. We must also determine the existence of any conflicts between the currency rules. If there is no tuple with a zero in-degree (Line 10) after all the vertexes and edges in Ge are deleted (Line 8), we know that loops exist. This indicates that the currency rules ? used here  Algorithm 4 getCurInfo(e, Te, ?, Q?) Input: the entity e, the tuples? set Te , the set of currency rules  ? , and the queue of currency dependence order Q? .

Output: curInfoe  1: Ge;A  create G (e, Te , ? ) 2: for each A 2 Q? do 3: add Ge;A into Ge 4: Queue ?; count 0 5: add all t 2 V and Indegree(t / DD 0 into Queue 6: while Queue.noEmpty() do 7: t = Queue.pop() and score  ? t ?A?  ? ++count  8: delete t from V and delete (t; tx) from E // (t; tx) represents for the edge starting from t .

9: add all t 2 V and Indegree(t / DD 0 into Queue 10: if all t 2 V and Indegree(t / ? 0 then 11: exit (?1) and return ? 12: end if 13: end while 14: end for 15: for each t in Te do 16: score.t/ ?A2Q?  ? score.t ?A?/C jAj ? jQ? j  ? 17: add score.t/ into scoree 18: end for 19: curInfoe  .Ge; scoree/ 20: return curInfoe  lead to a conflicting result and ? will be returned (to domain experts).

In Lines 15?18, the currency score is computed for each tuple in Te . Some of the attributes in Q? may not be involved in the creation of the currency graph, which means that their currency cannot be determined by ? or that they have no impact on the currency of the tuple. In these cases, they are given a currency score with the least value (score D 1, generally). Finally, Ge and scoree are combined as curInfoe in Line 19.

In Algorithm 4, O.m ? jTej ? j? j/ time is required to create Ge;A (Line 1) as discussed in Ref. [2]. The total time taken by the loop (Lines 2?13) is O.m ? jTej2/.

Then, the computation of the currency score of e for all the attributes involved the costs O.jTej ? j? j/ (Lines 15?17). To put this all together, Algorithm 4 works in O ? m ? jTej ?maxfj? j; jTejg  ? time.

Example 5 Based on Definition 3 and Algorithm 4, we can compute the currency scores of the entity Alice in the motivating example as follows: (1) Degree: score(Bachelor) = 1, score(Master) = 2; (2) Address: score(3-DP) = 1, score(15-DP) = 2, score(Beijing) = 3; (3) Salary: score(40) = 1, score(500) = 2, score(12 000)= 3. We cannot determine the currency orders of other attributes of the entity Alice by the currency rules above, so the score of those attributes is 1, which is the minimal positive integer. The scores of each tuple from the same entity all contribute to the currency of the tuple. So we can calculate the sum of the score of each attribute value in Alice, except for tID, eID, and Sex as follows: (1) score(t1; Alice) = 1+1+1+1+1+1= 6, score(t2; Alice) = 2+1+1+2+2+1= 9, score(t3; Alice) = 2+1+1+3+3+1= 11. Similarly, the currency score of Tom of the attributes involved in ? are (1) Degree: score (Bachelor) = 1, score(Master) = 2, score(PhD) = 3; (2) Address: score(1-DP) = 1, score(16-DP) = 2, score(16- DP) = 3; (3) Salary: score(40) = 1, score(500) = 2, score(1000) = 3; (4) Status: score(Single) = 1, score(Married) = 2. Accordingly, we can determine the tuples? currency order as follows: (1) score(t1; Tom) = 1+1+1+1+1+1= 6, score(t2; Tom) = 2+1+1+2+2+1= 9, score(t3; Tom) = 3+1+1+3+3+2 = 13.

From the above, we find the tuple currency order of Alice to be t1; Alice ? t2; Alice ? t3; Alice. Similarly the tuple currency order of Tom is t1; Tom ? t2; Tom ? t3; Tom.

According to the above algorithms, by scanning the initial relation dataset once can we construct an EQB- Tree and ES-DLL for each entity, as well as obtain their currency graphs and scores. We propose the complete    236 Tsinghua Science and Technology, June 2017, 22(3): 227?242  preprocessing approach in Algorithm 5.

First, we initialize the index TD and the linked listLD  in Line 1, which was introduced in Algorithms 2 and 3.

In the loop from Line 2 to 14, the currency information of each entity curInfoe in the entity set E is computed by Algorithm 4 and written to the file, with the first address of the scoree in disk memory (Lines 3 and 4). The tuples in Te are sorted in ascending order, after which the head address e.addr of the first tuple of e in the ES-DLL is scanned (Lines 5 and 6). Combined with e.key and e.curInfoAddr, the node O.e/T is inserted to TD (Lines 7 and 8). In the loop from Lines 9?12, the head address of each tuple t in Te and the next tuple immediately following t are inserted into LD in proper order. The data inLD are then written to the disk (Line 13). Lastly, the TD and LD of all the entities in D are returned.

4.2 Algorithms for currency determining  As mentioned in Section 3.2, after preprocessing the initial relations dataset offline, we can determine the currency information of the entities. Both different entities and tuples that refer to the same entities can be queried efficiently by the EQB-Tree and ES- DLL. We discuss our proposed updating and currency determination methods below.

4.2.1 Updating EQB-Tree and ES-DLL When updating new tuples of entity ei , first, we try to match it with an exist entity in the EQB-Tree. If ei is an new entity not found in E , the tuple is inserted into the file tail of ES-DLL, and the EQB-Tree is rebuilt.

If ei is found in the EQB-Tree of the initial dataset,  Algorithm 5 Preprocessing Input: D, ? , Q? Output: TD , LD  1: TD WD bulid EQB-Tree(); LD WD init ES-DLL(); 2: for each e 2 E do 3: curInfo(e) getCurInfo(); 4: write curInfo(e) into curInfoFile() and get e:curInfoAddr; 5: sort Te by curInfo(e).score; 6: e.addr LD :getFilePointer(); 7: OTe  init Node (e.key, e.addr, e.curInfoAddr); 8: TD :insert.OTe /; 9: for each t 2 Te do  10: OL WD ? t; LD :getNextTupleAddr(t )  ? ;  11: LD :insert.OL/; 12: end for 13: LD :writeToDisk; 14: end for 15: return TD and LD ;  the tuple is inserted into the tail of the ES-DLL of ei , and the e.address of ei in OTe is updated if necessary.

Algorithm 6 presents the update procedure for the EQB- Tree and ES-DLL.

First, we determine whether e represents a new entity to the initial dataset and if it does, we construct its OLe and insert it into the OL of the dataset D (Lines 3 and 4). Then, the new entity e is inserted into the EQB- Tree with its head address in the ES-DLL (Lines 5 and 6). If e can be matched with a corresponding entity in E , we update the new tuples of the entity into the tuple set Te which is recorded in LD with the loop from Line 8 to Line 20. First, we set the tuple ID number (tID) and entity ID number (eID) for the new tuple tnew and set its head file address into LD in Lines 8 and 9. Thus, we have modified the address in the nodes in the ES-DLL to maintain the currency order. Next, we insert tnew into the correct position in TD . preTID represents the current address of t , and if preTIDt?new? is 0, t is inserted into the first line of Te , and the tuple immediately following t is the first tuple of the previous D, the address of which is recorded in TD (Lines 10? 12). If tnew is not the first tuple of e, the address of the next tuple immediately following t will be taken placed by t (Line 14), and the attribute tID of all the tuples  Algorithm 6 Updating ES-DLL and EQB-Tree Input: e, tnew, LD , TD Output: LD , TD  1: if e:isNewEntity == True then 2: e:addr = LD :getFilePointer(); 3: OL:=  ? (1,jE j+1, tnew), ?1  ? ;  4: LD :insert(OL) and LD :writeToDisk(); 5: OTe .setAddress(e:addr); 6: TD :insert(OTe ); 7: else 8: t WD (preTIDt?new?+1, eID, tnew); 9: addr(t / LD :getFilePointer();  10: if preTIDt?new?== 0 then 11: addr(t:next) e:addr; 12: OTe .setAddress  ? addr(t )  ? ;  13: else 14: addr(t:next) OLe :setNexTupleAddr  ? addr(t )  ? ;  15: end if 16: for each OL  e;i ; i 2  ? preTIDt?new? C 1; jE j  ? do  17: OL e;i :t:eID +=1;  18: end for 19: OLe :=  ? t , addr(t:next)  ? ;  20: LD :insert(OL) and LD :writeToDisk(); 21: end if 22: return LD , TD    Xiaoou Ding et al.: Efficient Currency Determination Algorithms for Dynamic Data 237  following t will increase by 1 (Lines 16 and 17). Then, we update the OL of e with t in LD (Lines 19 and 20).

Example 6 Consider Table 1 in the motivating example, we create a dynamic linked list of the two entities Tom and Alice, as presented in Fig. 5 according to Algorithm 6, and we efficiently update a new tuple tnew of Tom to the ES-DLL without moving any previous tuples. In addition, the data volume does not influence this update operation.

4.2.2 Updating currency graphs Next, we discuss the process of updating the currency information when inserting a new tuple tnew into Te .

First, we search the same entity in tnew using the keyword in the EQB-Tree index. After identifying the corresponding entity e from tnew, we update curInfoe with the new information from tnew. When there is no identical entity recognized by tnew in the original dataset, we know that tnew describes a new entity. It is then inserted into the dataset, the EQB-Tree is updated, and the currInfo of e is initialized, accordingly.

After the entity e represented by tnew is recognized, the currency information currInfo is updated with tnew.

Algorithm 7 presents the procedure for updating the currency graph for all the involved attributes of the entity e .

When the tnew describing e appears, it is added to G.e; Ak/ as a new node. In the loop (Lines 1?9), the currency graph of e on Ak is determined based on the currency information curInfoe (Line 2). Then, the tnew values of Ak are inserted into the vertex set of G.e; Ak/, and both the in-degree and out-degree are initialized (Lines 3 and 4). In the nested-loop (Lines 5?8), based on each 'Ak in ?CR, we can determine t ?Ak tnew or tnew ?Ak t , and then the edges will be added into the graph correspondingly. Finally, it returns a new currency graph G.e; A/.

We expect the loop between Lines 1 and 9 to execute jQ? j times in total. The currency graphs are stored in  Fig. 5 The ES-DLL updated with the new tuple in the motivating example.

Algorithm 7 Updating currency graph G.e; A/ Input: tnew;G.e/ D .VAk ; E/; ?CR Output: the new G.e; A/ after updating  1: for each Ak 2 Q? do 2: get G.e; Ak/ from curInfo.Ge 3: add Te :tnew?Ak ? into G.e; Ak/:V 4: Outdegree.tnew?Ak ?/ 0 and Indegree.tnew?Ak ?/ 0 5: for each t 2 Te , t ?Ak tnew or tnew ?Ak t can be inferred  from 'Ak 2 ?CR do 6: add (t; tnew) or (tnew; t) into G.e; Ak/:E 7: Outdegree.t or tnew) += 1 and Indegree.tnew or t ) += 1 8: end for 9: end for  10: return G.e; A/  Hash access, with a cost of O.1/ in Line 2. We also expect that examining the satisfiability of one currency rule costs r time at most, so then the nested-loop (Lines 5?8) costs r ? j? j. In total, the time complexity of Algorithm 7 is O  ? r ? j? j ? jQ? j  ? .

4.2.3 Updating currency scores After updating the currency graphs, we can update the currency score of entity e recognized by tnew, as shown in Algorithm 8. We then calculate the new currency score based on the functions of score  ? tl ?Ak?  ? , where  tl ?Ak? represents the tuple that has an edge (currency relationship order) with tnew on Ak in the currency graph. We note that in the directed graph G.e; Ak/,? tl ?Ak?; tnew?Ak?  ? is an edge starting from tl ?Ak?, and  vice versa.

If both the in-degree and out-degree values of  tnew?Ak? are 0, this means that the currency of tnew?Ak? cannot be determined according to the rules in ?CR, so we initialize the score score  ? tnew?Ak?  ? to 1 (Lines 2 and  3). When tnew?Ak? has only out-neighbors, it becomes the most current, so the score of tnew?Ak? is equal to the max score of tl ?Ak? plus 1 (Lines 4 and 5). If tnew?Ak? only has in-neighbors, we determine tnew?Ak? to be the least current, whereupon we examine the minimum score in score  ? tl ?Ak?  ? . If the minimum scores  in .tl ?Ak?/ is greater than 1, the new tnew?Ak? score equals the minimum score minus 1 (Lines 7 and 8), and if not, score  ? tnew?Ak?  ? becomes 1, and the score of  all tl ?Ak? are increased by 1, accordingly (Lines 9?12).

In other cases, the current value of tnew?Ak? is neither the highest nor the lowest current. Obviously, the score is expected to be one point higher than the maximum score of tl ?Ak? with an edge  ? tl ?Ak?; tnew?Ak?  ? (Line  16). Also, the score of the tuples tm?Ak? with an edge? tnew?Ak?; tm?Ak?  ? (more current than tnew?Ak?) must be    238 Tsinghua Science and Technology, June 2017, 22(3): 227?242  Algorithm 8 Updating the currency score of entity ewith tnew Input: tnew;G.e; Ak/ D .VAk ; E/; scoree Output: the new scoree after updating  1: for each Ak 2 Q? do 2: if Indegree.tnew?Ak?/ D 0^ Outdegree.tnew?Ak?/ D 0  then 3: score.tnew?Ak?/ 1 4: else if Indegree.tnew?Ak?/ ? 0^ Outdegree .tnew?Ak?/ D 0  then 5: score.tnew?Ak?/  ? .max16l6N score.tl ?Ak ? j  .tl ; tnew/ 2 E//C 1  6: else if Indegree.tnew?Ak?/ D 0^ Outdegree .tnew?Ak?/ ? 0 then  7: if min16l6N score.tl ?Ak ? j .tnew; tl / 2 E/ > 1 then 8: score.tnew?Ak?/  ?  ? min16l6N score.tl ?Ak ? j  .tnew; tl / 2 E/ ? ? 1  9: else 10: score.tnew?Ak?/ D 1 11: for each l from 1 to N do 12: score  ? tl ?Ak ? j .tnew; tl / 2 E  ? C D 1  13: end for 14: end if 15: else 16: score.tnew?Ak ?/  ? max16l6Nin score.tl ?Ak ? j .tnew;  tl / 2 E/C 1  17: for each m from 1 to Nout do 18: score.tm?Ak ?/C D 1 19: end for 20: end if 21: end for 22: scoree  .

P A2Q?  score.tnew//C jAj ? jQ? j 23: add score.te/ into curInfoe :score 24: return scoree  one point higher than before (Lines 17 and 18). Then, we calculate the new score of e in Line 22 and update curInfo with the new score (Line 23). Lastly, we return the new scoree after updating (Line 25).

In the algorithm, the whole loop (Lines 1?21) is executed jQ? j times. In this loop, it costs O.1/ time to obtain the number of both the in-degree and out- degree of tnew?Ak?, and the calculation of the maximum or minimum scores is executed inO.N/  ? O.jTej/  ? . The  time costs of the loop in Lines 11 and 12 and Lines 17 and 18 are O.N/ and O.Nout/, respectively. As such, the whole loop costsO  ? jQ? j?jTej  ? . In Lines 22 and 23,  it takes O ? jQ? j  ? time to determine the total currency  score of e andO.1/ time to update the score of the entity in curInfo. In total, the time complexity of Algorithm 8 is O  ? jQ? j ? jTej  ? .

Example 7 Suppose that there are five tuples for the entity Mary in Info. We take into consideration the attribute Degree regarding the educational background  of the person via the following currency rule: ' W 8t1; t2; t3; t4; .t1?Status? D Bachelor,  t2?Status? D Master, t3?Status? D PhD, t1?Status? D PostDoc! t1 ?Degree t2 ?Degree t3 ?Degree t4/:  Figure 6 shows the new currency graph of Mary for Degree when a new tuple appears regarding Mary with t [Degree] = Master comes. To clarify here, we show only the edges connected with tnew. According to ', we establish the currency graph GMary, Degree, and the in-degree and out-degree of the node tnew are 3 and 2, respectively. As shown in Algorithm 8, score.tnew?Degree?/ D score.t2?Degree?/ C 1 D 3. And the scores of tuples more current than tnew, namely t4, t5 are as follows: score.t4?Degree?/ = score.t5?Degree?/ = score.tnew?Degree?/0 C 1 D 4.

Example 8 Returning to the motivating example, when inserting the new tuple tnew into the correct location in Info, according to the currency rules (r1 to r4), we compute the currency scores of tnew for each relevant attributes as follows: score (Master) = 2, score (Programmer) = 2, score (Shanghai) = 4, score (Married) = 2, score (12 000) = 3.

So score(tnew) = 2+2+4+3+2 = 13. Therefore, we obtain t1; Alice ? t2; Alice ? t3; Alice ? tnew. The tuple tnew is then inserted right after t3, Alice in the order in which the tuples describing the same entity Alice maintain the correct data currency.

5 Experiments  In this section, we present our experiments, which we conducted on both real and synthetic datasets. In Section 5.1, we introduce our experimental settings.

In Sections 5.2 through 5.5, we analyze the influence  Fig. 6 The currency graph and score of Mary on the attribute Degree.

Xiaoou Ding et al.: Efficient Currency Determination Algorithms for Dynamic Data 239  of four main parameters to determine the efficiency of the offline preprocessing and the online dynamic determination for each dataset.

5.1 Experimental settings  We ran the experiment on a computer with an Inter(R) 3.40 GHz Core i5 CPU and 8 GB of RAM, using Java in Eclipse.

5.1.1 Experimental data We based the experiments on a real-life dataset, Student data, which contains the personal information of 10 000 students both during their time in college and after graduation. The data schema in this dataset is as follows: ftID, eID, Name, Sex, Degree, Position, College, Address, Salary, Ageg. To evaluate the efficiency of the algorithms on large-scale data, the synthetic data adhered to the same schema as that in Student data. To effectively evaluate the impact of various parameters (listed below), we generated entities and the tuple number of each entity under different conditions.

5.1.2 Currency determining implementation To identify the currency rules adopted in the experiments for both the real and synthetic data, we used the methods proposed in Ref. [23]. In addition, the semantic constraints of these currency rules also satisfy the definitions in Refs. [2, 23].

5.1.3 Algorithms We implemented the following algorithms in both the preprocessing and dynamic determination steps of the model. As such, preprocessing generates the processing order of the attributes (Algorithm 1), creates the EQB- Tree (Algorithm 2) and the ES-DLL (Algorithm 3), and obtains currency information (Algorithm 4). Dynamic determination involves updating the currency graph and scores (Algorithms 7 and 8) and updating the EQB-Tree and ES-DLL (Algorithm 6).

Here, we discuss the efficiency of four main parameters with respect to the algorithms, including the total number of entities, attributes, tuples referring to the same entity, and currency rules. The preprocessing running time includes the time spent creating and initializing the EQB-Tree and ES-DLL for all entities of the dataset and obtaining currency information regarding the entities. The dynamic determination running time includes the running times of Algorithms 7 and 8, which update the EQB-Tree and ES-DLL (Algorithm 6), respectively. We discuss situations  during the determination process in which new tuples are inserted into different locations of the ES-DLL.

5.2 Impact of the total number of entities  First, we evaluated the parameter entityNum with respect to the efficiency of the algorithms during both preprocessing and currency dynamic determination, with the conditions attrNum D 10, tupleNum D 10, ruleNum D 40.

In total, we processed 50 000 entities in the experiment. As the number of entities increased linearly, the preprocessing running time also increased linearly, as shown in Fig. 7a. During dynamic determination, we take into account four possible positions for updating a new tuple: insertion at the top, middle, and tail of the ES-DLL, and the insertion of a new entity.

As shown in Fig. 7b, the response time for updating a new tuple during the dynamic determination step is not affected by a change in the number of entities. The reason for this is that only a single scan is made over the whole dataset during preprocessing. This also validates Algorithm 7 (updating currency graph G.e; Ak/  ? and  Algorithm 8 (updating currency score scoree). The determination process runs no more than 12 ms. In addition, inserting the new tuple at the top of the linked list takes only a little more time than inserting it into either the middle or tail. Also, in cases such as these, it takes a minimum amount of time to insert the tuple into E if the tuple to be updated is a new entity.

(a) Time cost of preprocessing  (b) Time cost of currency determining  Fig. 7 entityNum effects on efficiency.

240 Tsinghua Science and Technology, June 2017, 22(3): 227?242  5.3 Impact of the number of attributes  When experimentally evaluating the number of attributes, we generated at most eight attributes for the same tuple in Student Data. Figure 8 shows the efficiency of the algorithms with different numbers of attributes and the following condition: entityNum D 10 000, tupleNum D 10, ruleNum D 40.

As shown in Fig. 8a, the preprocessing running time increases linearly. With the small-scale increase in the number of attributes, the preprocessing running time increases gradually, and the response time during the dynamic determination of currency is also not affected by an increasing number of attributes in the tuples.

With respect to updating the ES-DLL, inserting the new tuple at the top of the ES-DLL takes the most time, but is no more than 13 ms, as shown in Fig. 8b.

5.4 Impact of the number of tuples  Taking into account the number of tuples, we generated a maximum of 40 tuples for the same number of attributes in one entity. Figure 9 shows the effect of the number of tuples on the efficiency of the preprocessing and dynamic determination steps for the conditions entityNum D 10 000, attrNum D 10, ruleNum D 40.

As shown in Fig. 9a, with a linear increase in the number of tuples in a given entity, the preprocessing time increases polynomially. It takes about 70 s to preprocess a dataset containing 500 000 tuples in a total of about 10 000 people. On the other hand, the dynamic  (a) Time cost of preprocessing  (b) Time cost of currency determining  Fig. 8 attrNum effects on efficiency.

(a) Time cost of preprocessing  (b) Time cost of currency determining  Fig. 9 tupleNum effects on efficiency.

updating time is independent of the total number of tuples, and takes no more than 14 ms. As shown in Fig. 9b, it takes less time to insert a tuple describing a new entity than it does to insert one into the other three positions in the linked list.

5.5 Impact of the number of currency rules  The number of currency rules used in the determination process also has an effect on the efficiency. With the other parameters set as follows: entityNum D 10 000, attrNum D 10, tupleNum D 10, we computed the running time for the total number of currency rules varying from 60 to 140, as shown in Fig. 10. From Fig. 10a, we can see that as the number of currency rules increases linearly, the preprocessing time also increases linearly at first, and then becomes stable once the total number of currency rules exceeds 90. The reason for this is that the number of attributes affects only the preprocessing time. In this experiment, when we held attrNum D 10 constant, the increase in the total number of currency rules either added to the semantic duplications in the tuples of a given entity or between different entities. Similarly, this setting tends to lead to a stable ES-DLL creation process time after the number of currency rules reaches a certain threshold.

In dynamic determination, the change in the total number of currency rules has almost no influence on the updating of a new entity. For the other three cases, the running time increases slightly as the number of    Xiaoou Ding et al.: Efficient Currency Determination Algorithms for Dynamic Data 241  (a) Time cost of preprocessing  (b) Time cost of currency determining  Fig. 10 ruleNum effects on efficiency.

rules increases up to 100, and thereafter tends to take the same amount of time as when ruleNum D 100, as shown in Fig. 10b. That stable time cost tendency is consistent with the preprocessing result shown in Fig. 10a.

6 Conclusion  In this paper, we studied the dynamic determination of the currency of large-scale data and proposed a dynamic data currency model consisting of offline preprocessing and online dynamic determination. We designed and implemented several algorithms to optimize the attribute currency order of tuples referring to the same entity and to create and query currency information of entities. Using just a single scanning of the initial dataset, we can achieve the efficient determination and updating of data currency. In addition, we found the response time to be uninfluenced by the data scale within an appropriate range. In a set of reasonable experiments, we verified that our methods and algorithms are effective in determining the currency of dynamic data.

