Finding (Recently) Frequent Items in Distributed Data Streams

Abstract We consider the problem of maintaining frequency  counts for items occurring frequently in the union of multiple distributed data streams. Na??ve methods of combining approximate frequency counts from multi- ple nodes tend to result in excessively large data struc- tures that are costly to transfer among nodes. To mini- mize communication requirements, the degree of preci- sion maintained by each node while counting item fre- quencies must be managed carefully. We introduce the concept of a precision gradient for managing precision when nodes are arranged in a hierarchical communica- tion structure. We then study the optimization problem of how to set the precision gradient so as to minimize communication, and provide optimal solutions that min- imize worst-case communication load over all possible inputs. We then introduce a variant designed to perform well in practice, with input data that does not conform to worst-case characteristics. We verify the effective- ness of our approach empirically using real-world data, and show that our methods incur substantially less com- munication than na??ve approaches while providing the same error guarantees on answers.

1. Introduction  The problem of identifying frequently occurring items in continuous data streams has attracted sig- nificant attention recently [4, 9, 12, 14, 19, 22]. Po- tential applications include identifying large network flows [12], answering iceberg queries [13], computing iceberg cubes [17] and finding frequent itemsets and as- sociation rules [1]. However, nearly all prior work on identifying frequent items in data streams and estimat- ing their occurrence frequencies falls short of meeting the needs of the many real-world applications that ex- hibit one or both of the following two properties:  1. Distributed streams. Streams originate from multi- ple distributed sources. Data from all sources needs to be aggregated to arrive at the final result, as in the dis- tributed streams model of [15].

?Supported by an ITR grant from the NSF.

?Supported by NSF ITR grants CCR-0085982 and CCR-0122581.

2. Time sensitivity. Recent data is more important than older data.

We briefly describe two real-world applications ex- hibiting the properties just mentioned: 1. Monitoring usage in large-scale distributed sys- tems. Web content providers using the services of a Content Delivery Network (CDN) like Akamai [2] may wish to monitor recent access frequencies of content served (e.g., HTML pages/images), to keep tabs on cur- rent ?hot spots.? The CDN may serve requests from any of a number of cache nodes (Akamai currently has over 10,000 such nodes); typically requests are served by the cache node closest to the end-user making the request in order to minimize latency. Hence, keeping tabs on overall access frequencies requires distributed monitor- ing across many CDN cache nodes.

2. Detecting malicious activities in networked sys- tems:  (a) Detecting worms. Previously unknown Inter- net worms can be detected by discovering that a large number of recent traffic flows contain the same bit string [20]. Distributed monitoring can reduce detection time.

(b) Detecting DDoS attacks. Early detection of Dis-  tributed Denial of Service (DDoS) attacks is an impor- tant topic in network security. While a DDoS attack typically targets a single ?victim? node or organization, there is generally no common path that all packets take.

In fact, even packets sent to the same destination and originating from within the same organization may fol- low different routes, due to so-called ?hot potato? rout- ing [3]. This property makes it very difficult to detect distributed denial of service attacks effectively by only considering the traffic passing through any single moni- toring point, and motivates a distributed monitoring ap- proach. Furthermore, techniques that weigh recent data more than past data may help in early detection of at- tacks.

1.1 Problem Variants Both applications outlined above require algorithms  for identifying recently frequent items in the union of many distributed streams, and estimating the corre- sponding occurrence frequencies. In general, we can      classify applications of frequent item identification into four categories, in terms of whether they require (a) time-sensitivity and (b) distributed monitoring capabil- ity. We briefly describe each problem variant:  (1) Finding frequent items in a single stream: A sin- gle node sees an ordered stream of possibly repeating items. The goal is to maintain frequency counts of items whose frequency currently exceeds a user-supplied frac- tion of the size of the overall stream seen so far.

(2) Finding recently frequent items in a single stream: In this variant recent occurrences of items in the stream are considered more important than older occurrences of items. At any given time, a numeric weight is associated with each item occurrence in the stream that is a function of the amount of time that has elapsed since the appearance of the item in the stream.

A commonly-used weighting scheme is exponential de- cay [7], in which weights are assigned according to a negative-exponential function of elapsed time. The goal is to identify items whose cumulative weighted fre- quency currently exceeds a user-supplied fraction of the total across all items, and provide an estimate of the cu- mulative weighted frequencies of any such items.

(3) Finding frequent items in the union of distributed streams: In this variant there are m ordered streams S1, S2, . . . , Sm, each produced at a different node in a distributed environment and consisting of a sequence of item occurrences. The goal is the same as in Variant (1), except that item frequencies are computed over the union of streams S1, S2, . . . , Sm, instead of over a sin- gle stream.

(4) Finding recently frequent items in the union of distributed streams: This variant represents the natural combination of Variants (2) and (3).

Of these four variants, only Variant (1) has been stud- ied in prior work. (Some work conducted concurrently with our own [4, 16] also addresses problems quite sim- ilar to Variants (2) and (3), but there are significant dif- ferences with our work; see Section 4 for further dis- cussion.) Algorithms for time-insensitive frequent item identification over a single stream include those pre- sented in [9,19,22]. It is straightforward to extend these algorithms to handle Variant (2), although the effect on the space bounds and error guarantees of the resulting algorithms in some cases is nonobvious.

Variants (3) and (4) present a larger challenge. As we will show, simple adaptations of existing frequent item identification algorithms to work in a distributed setting incur excessive communication. In this paper we present a new framework for distributed frequent item iden- tification that minimizes communication requirements.

Before outlining our approach we first provide a formal  problem statement that unifies the four variants listed above.

1.2 Unified Problem Statement Our problem statement extends that of [22]. There  are m ? 1 ordered data streams S1, S2, . . . , Sm. Each stream Si consists of a sequence of item occurrences with time-stamps: ?oi1, ti1?, ?oi2, ti2?, etc. Each item occurrence oij is drawn from a fixed universe U of items, i.e., ?i, j, oij ? U . Arbitrary repetition of item occurrences in streams is allowed. Each stream Si is monitored by a corresponding monitor node Mi, of which there are m. Monitored frequency counts for high frequency items are to be supplied to a central root node R, which may or may not be the same as one of the monitor nodes.

Let S be the sequence-preserving union of streams S1, S2, . . . , Sm. Further, let c(u) be the frequency of oc- currence of item u in S up to the current time, weighted by recency of occurrence in an exponentially decaying fashion. Mathematically,  c(u) = ?  ?oi,ti??S,oi=u ??  tnow?ti T ?  where tnow denotes the current time, and ? and T are user-supplied parameters. The parameter ? ? (0, 1] controls the aggressiveness of exponential weighting.

As a special case, setting ? = 1 causes all item oc- currences to be weighted equally, regardless of age (as in Variants (1) and (3) of Section 1.1). The parameter T > 0 controls the frequency with which answers are reported, and also the granularity of time-sensitivity. A time period of T time units is referred to as an epoch.

The objective is to supply, at the end of every epoch (i.e., every T time units), an estimate c?(u) of c(u) for items occurring in S whose true time-weighted fre- quency c(u) exceeds a support threshold T . T is de- fined as the product of a user-supplied support parame- ter s ? [0, 1], and the sum of the weighted item occur- rences seen so far on all input streams, N = ?u?Uc(u), i.e., T = s ?N . The amount of allowable inaccuracy in the frequency estimates c?(u) is governed by a user- supplied parameter ?. It is required that 0 ? ? ? s (usually, ? ? s). Each time an answer is produced, it must adhere to the following guarantees:  1. All items whose true time-weighted frequency ex- ceeds s?N are output.

2. No item whose true time-weighted frequency is less than (s ? ?)?N is output.

3. Each estimate c?(u) supplied in the answer satisfies: max {0, c(u) ? ??N} ? c?(u) ? c(u).

R (?1, 1)-synopses  level 0 (Root)  Output: (?, ?)-synopsis  level 1  M1 level  (l-1) (Leaves) M2 Md  Mm  Input streams: S1 S2 Sd Sm  (?2, 1)- synopses  (?l-1, 1)-synopses  Figure 1: Hierarchical communication structure.

A useful data structure for storing intermediate an- swers is an (?, ?)-synopsis of item frequencies over a stream or union of several streams. An (?, ?)-synopsis S consists of a (possibly empty) set of time-weighted frequency estimates each denoted S : c?(u), where each S : c?(u) estimate satisfies max {0, c(u) ? ??S :n} ? S : c?(u) ? c(u). S :n denotes the total time-weighted fre- quency of all items in the synopsis (S :n = ?u?U c(u)).

The salient property of an (?, ?)-synopsis is that items with weighted frequency below ??S:n need not be stored, resulting in a reduced-size representation.

In the extended technical report version of this pa- per [21] we show how to extend two frequency count- ing algorithms that produce (?, 1)-synopses to produce (?, ?)-synopses, for any ? ? (0, 1], to achieve Variant 2 of Section 1.1. In particular, we show how to do so for lossy counting [22] and the algorithm presented in both [9] and [19], which we refer to as majority+ count- ing. We analyze the correctness and space requirements of the resulting algorithms. We show that the worst-case size of time-sensitive synopses is bounded by a time- independent constant.

1.3 Overview of Approach  There are two obvious, simple strategies for adapting single-stream frequency counting algorithms to a dis- tributed setting to achieve Variants 3 and 4 of Sec- tion 1.1, and both have serious drawbacks:  SS1 (Simple Strategy 1): Periodically, at the end of every epoch, each monitor node Mi sends to the root node R the exact frequency counts of all items occurring in Si over the last T time units. Node R then combines the counts received from the monitor nodes with (possi- bly time-decayed) counts maintained over prior epochs, and outputs items whose overall weighted counts exceed the support threshold T .

SS2: Each monitor node Mi maintains an (?, 1)- synopsis Si over the recent portion of its local stream Si. Intuitively, the (?, 1)-synopsis is a reduced sum- mary of item frequencies that does not include items  whose frequency in Si is small. Periodically, at the end of every epoch, each Mi sends its local synopsis Si to node R. Upon receiving all local synopses, node R combines them into a single unified (?, 1)-synopsis containing estimated item frequencies for the union of the contents of all input streams in the most recent epoch. This synopsis is then combined additively with an (?, ?)-synopsis containing estimated weighted counts from previous epochs, after multiplying those synopsis counts by ?, to generate a new (?, ?)-synopsis valid for the current epoch. Lastly, items whose estimated time- decayed counts exceed the support threshold T (after taking into account the error tolerance) in this synopsis are output. 1  Clearly, strategy SS1 is likely to incur excessive com- munication because frequency counts for all items, in- cluding rare ones, must be transmitted over the network.

Furthermore, the root node R must process a large num- ber of incoming counts. While strategy SS2 alleviates load on the root node to some extent, in the presence of a large number of monitor nodes and rapid incom- ing streams, the root node may still represent a signifi- cant bottleneck. To further reduce the load on the root node, nodes can be arranged in a hierarchical commu- nication structure (see Figure 1), in which synopses are combined additively at intermediate nodes as they make their way to the root. In this setting SS2 compresses data (by dropping small counts) as much as possible at each leaf node without violating the ? error bound. Con- sequently no further compression can be performed as synopses are combined on their way to the root or at the root node itself, making it impossible to eliminate counts for items whose frequency exceeds ? fraction of one or more individual streams but does not exceed ? fraction in the union of the streams whose synopses are combined at a non-leaf node. Hence, if input streams have different distributions of item occurrences, counts for items of small frequency may reach the root node unnecessarily under strategy SS2. There are thus two main disadvantages of using SS2:  1. High communication load on root node R.

2. High space requirement on R.

Suppose that, instead of applying maximal synopsis compression at the leaf nodes, some compression capa- bility is reserved until synopses of multiple incoming streams are combined at non-leaf nodes. If that is done, more aggressive compression can be performed by non- leaf nodes by taking into account the distributions of item frequencies over a larger set of input streams. As a  1Note that in both strategies time-sensitivity is only introduced at node R. It is not possible to introduce time-sensitivity in data before it is sent to R, since all item frequencies in the most recent epoch have weight 1 in our formulation.

result, the synopses reaching the root (and the synopsis maintained over previous epochs at the root) will likely be significantly smaller than in SS2. On the other hand, the synopses passed from the leaf nodes to their parents may be larger than in SS2, which is an undesirable side- effect.

Indeed, to avoid excessive communication load on any particular node or link, the amount of compression performed by each node while creating or combining synopses must be managed carefully. In hierarchically- structured monitoring environments we can configure the amount of compression performed, and conse- quently, the amount of error introduced at each level so that synopses follow a precision gradient as they flow from leaves to the root. It turns out that worst-case com- munication load on any link is minimized by using a gradual precision gradient, rather than either deferring the introduction of error entirely until data reaches the root (as in SS1), or introducing the maximum allowable error at the leaf nodes (as in SS2). Still, the best gradual precision gradient to use is not obvious.

In Section 2 of this paper we study the problem of how best to set the precision gradient formally. We first show how use of a gradual precision gradient alleviates storage requirements at the root node R. Then, we de- rive optimal settings of the precision gradient under two objectives: (a) minimize load on the root node R, and (b) minimize maximum load on any single communi- cation link under worst-case input behavior. We then introduce a variant that aims to achieve low load on all links in practice, when input data may not exhibit worst- case characteristics, by exploiting a small sample of the expected input data obtained in advance.

In Section 3 we confirm our analytical findings of Section 2 through extensive experimental evaluation on three real-world data sets. Our experiments demon- strate that na??ve methods of finding frequent items in distributed streams (SS1 and SS2) can incur high com- munication and storage costs compared with our meth- ods. Related work is discussed in Section 4, and we summarize the paper in Section 5.

2. Finding Frequent Items in Distributed Streams  In this section we show how to maintain approximate time-sensitive frequency counts for frequent items in a distributed setting, and study how to set the precision gradient so as to minimize communication. Recall that in our scenario, m monitor nodes M1, M2, . . . , Mm re- lay data periodically, once every T time units, to a cen- tral root node R. Data may be relayed through a hier- archy of nodes interposed between the monitor nodes and the central root node, as illustrated in Figure 1. Let  l ? 2 denote the number of levels in the hierarchy. We number the levels from root to leaf, with the root node R of the communication hierarchy representing level 0, its children representing level 1, etc., and the monitor nodes M1, . . . , Mm representing level (l ? 1). Let d ? 2 de- note the fanout of all non-leaf nodes in the hierarchy, i.e., the number of child nodes relaying data to each in- ternal node. 2  In this hierarchical communication structure, we as- sociate with each non-root level 1 ? i ? (l ? 1) of the communication hierarchy an error tolerance ?i. For correctness it must be ensured that ? ? ?1 ? . . . ? ?l?1 ? 0, which gives rise to a precision gradient along the communication hierarchy. (For now we assume that all nodes at the same level in the hierarchy use the same error tolerance.) Any values of ?1, . . . , ?l?1 satisfying the above constraints can be used, and the guarantees of Section 1.2 will hold. The manner in which the preci- sion gradient (i.e., ?1, . . . , ?l?1 values) is set determines the size of the synopsis that must be stored persistently at R, as well as the amount of communication that must be performed during frequency counting. For now, let us assume that some precision gradient has been decided upon. We return to the issue of how best to set the pre- cision gradient in Section 2.1.

Given a precision gradient, our procedure for com- puting time-sensitive frequency counts for items occur- ring frequently in S = S1 ? S2 ? . . . ? Sm is as fol- lows. Recall that time is divided into equal epochs of length T . During each epoch, each monitor node Mi in- vokes a single-stream approximate frequency counting algorithm, e.g., [9,19,22], using error parameter ?l?1 to generate an (?l?1, 1)-synopsis for the portion of stream Si seen so far during the current epoch. Each moni- tor node then sends its (?l?1, 1)-synopsis to its parent in the communication hierarchy, which combines the d (?l?1, 1)-synopses it receives from its d children into a single (?l?2, 1)-synopsis using either Algorithm 1a (shown below; based on lossy counting [22]) or Al- gorithm 1b (shown below; based on majority+ count- ing [9, 19]). The same process is repeated until each of R?s children combines the d (?2, 1)-synopses they re- ceive into an (?1, 1)-synopsis which is then sent to R.

The root node R maintains at all times a single (?, ?)- synopsis SA, from which the answer is derived. When, at the end of each epoch, R receives d (?1, 1)-synopses from its children, R updates SA using either Algo- rithm 2a (based on lossy counting) or Algorithm 2b (based on majority+ counting). Then, R generates the new answer to be output for the current epoch by find- ing items in SA whose approximate count in SA exceeds (s ? ?)?SA :n.

2For simplicity we assume all internal nodes of the communication hierarchy have the same fanout.

Algorithm 1: Combine synopses from children (executed by nodes other than leaves and root)  Inputs: d (?i+1, 1)-synopses S1, S2, ? ? ? , Sd Output: single (?i, 1)-synopsis S  Algorithm 1a:  1. Set S :n := d?  j=1 Sj :n  2. For each u ? d? j=1  Sj , set S :c?(u) := d?  j=1 Sj :c?(u)  3. For each u ? S, set S :c?(u) := S :c?(u) ? (?i ? ?i+1)?S :n  Algorithm 1b: 1. For each Sj ? {S1,S2, . . . ,Sd} and for each u ? Sj :  (a) If S : c?(u) exists, set S : c?(u) := S : c?(u) + Sj : c?(u). Else, create S :c?(u); set S :c?(u) := Sj :c?(u)  (b) If |S| ? 1 ?i??i+1 : let u  ? := argmin u?S  {S :c?(u)}. For each u ? S, set S : c?(u) := S : c?(u) ? S : c?(u?); if S : c?(u) ? 0, eliminate count S :c?(u)  2. Set S :n := d?  j=1 Sj :n  2.1 Setting the Precision Gradient Our approach is first to set ?1 based on space consid-  erations at node R (using worst-case analysis), and then set the remaining error tolerance values ?2, . . . , ?l?1 so as to minimize communication.

The value of ?1 determines the maximum size of the synopsis SA that must be stored by node R at all times.

If Algorithm 2b is used by the root node, the size of SA is at most 1???1 counts at all times. Otherwise, if Algorithm 2a is used, analysis of the maximum size of SA is similar to the analysis of [22] and our own analysis in [21] of time-sensitive lossy counting over a single-stream, yielding the following results. If no time- sensitivity is employed (? = 1), the size of SA is at most ln ((???1)?SA:n)  ???1 counts (formula adapted from [22]); for  ? < 1, the size is at most (1+???1)?(3+ln (2?k??+k))???1 counts, where ? = 	log 1  ? (1 + 2???1 ) + 1 and k de-  notes the maximum number of item occurrences on any input stream during any single epoch. As long as stream rates remain steady, using ?1 < ?, the synopsis SA does not grow with time after reaching a steady-state size. In contrast, when ?1 = ? (as in strategy SS2), the space requirement increases with time as we demonstrate em- pirically in Section 3.3. Our approach is to set ?1 such that the worst-case size of SA (under the maximum pos- sible stream rate k) is below any space constraint at R.

Given a value for ?1 (such that ?1 < ?), the remaining error tolerance values ?2, . . . , ?l?1 making up the pre- cision gradient determine the communication load in- curred. We illustrate the effect of the precision gradient  Algorithm 2: Update the answer synopsis (executed at the root node R)  Input: d (?1, 1)-synopses S1, . . . ,Sd, SA Output: new answer (?, ?)-synopsis SA  Algorithm 2a: 1. Set SA:n := ??SA:n + ?dj=1Sj :n 2. For each u ? SA, set SA:c?(u) := ??SA:c?(u) 3. For each u ? d?  j=1 Sj , set SA:c?(u) := SA:c?(u) + ?dj=1Sj :c?(u)  4. For each u ? SA, set SA:c?(u) := SA:c?(u) ? (? ? ?1)??dj=1Sj :n  Algorithm 2b: 1. Set SA:n := ??SA:n + ?dj=1Sj :n 2. For each u ? SA, set SA:c?(u) := ??SA:c?(u) 3. For each Sj ? {S1,S2, . . . ,Sd} and for each u ? Sj :  (a) If SA : c?(u) exists, set SA : c?(u) := SA : c?(u) + Sj : c?(u). Else, create SA:c?(u); set SA:c?(u) := Sj :c?(u)  (b) If |SA| ? 1???1 , let u ? := argmin  u?SA {SA : c?(u)}. For each u ?  SA, set SA : c?(u) := SA : c?(u) ? SA : c?(u?); if SA : c?(u) ? 0, eliminate count SA:c?(u)  R  I2I1  M4M3M2M1  S  S  S  S  (?2, 1)-synopses  (?1, 1)-synopses  Input streams:  Monitor nodes:  Root node:  Output: (?, ?)-synopsis  Figure 2: Example topology.

on communication using the following rather contrived but simple example that highlights the effect clearly; our experimental results presented later in Section 3 are con- ducted over real-world data.

2.1.1 Motivating Example  Figure 2 shows the communication topology we use for our example. We assume Algorithm 1a is used at the intermediate nodes. Suppose the overall user-specified error tolerance ? = 0.05, and for simplicity assume ?1 ? ? = 0.05. Suppose that during one epoch 100 items occur on each of S1, S2, S3 and S4, drawn from a universe of 27 distinct items. For ease of comprehen- sion, we partition the 27 distinct items into three cate- gories: A, B, and C. Category A contains one item and categories B and C each contain 13. The frequency of occurrence in each input stream of items in each cat- egory is given in the shaded region of Table 2. The      Table 1: Communication loads in example scenario.

Load on Maximum load on any Maximum  ?2 root node R link excluding load on links to R any link  0 2 27 27 0.03 2 14 14 0.05 54 14 27  Table 2: Link loads in example scenario.

M1 ? I1 and M2 ? I1 & I1 ? R & M3 ? I2 M4 ? I2 I2 ? R  ?2 category frequency cat. freq. cat. freq.

estimate est. est.

0 A 9 A 9 A 8 B 6 B 1 C 1 C 6  0.03 A 6 A 6 A 8 B 3 C 3  0.05 A 4 A 4 A 8 B 1 C 1 B 1  C 1  single item in category A occurs nine times in each of S1, S2, S3 and S4. Each item in category B occurs six times each in S1 and S3 but only once each in S2 and S4. The opposite is true for items in category C: each occurs once in each of S1 and S3 but six times in each of S2 and S4.

Table 1 summarizes the effects of varying ?2, which determines the amount of error introduced at level 2 (nodes M1 - - M4), assuming lossy counting with per- epoch batch processing is used to produce the initial synopses at the leaf nodes. Three measures of com- munication load are reported: (1) load on the root node R, (2) maximum load on any link excluding links to R, and (3) maximum load on any link. In all cases, com- munication load is measured in terms of the number of frequency counts transmitted during the epoch. Setting ?2 = 0.05 corresponds to simple strategy SS2 outlined in Section 1.3. (We do not report measurements for SS1, in which ?1 = 0 and ?2 = 0, since communication load is higher than under any of our three example strategies under all three metrics.)  To understand how these numbers come about, con- sider Table 2, which shows, for each setting of ?2, the frequency estimate for items of each category sent along each link. In the case in which ?2 = 0, the esti- mated counts sent from leaf nodes M1 - - M4 to nodes I1 and I2 (shown with shaded background) are exact.

All other values in Table 2 are underestimates. We fo- cus on the case in which ?2 = 0.03 to illustrate how these underestimates are computed. At each leaf node, when ?2 = 0.03 application of the lossy counting algo- rithm leads to undercounting of each item?s frequency  by ?2 ?100 = 0.03 ?100 = 3. Hence, estimated counts transmitted in synopses from the leaf nodes M1 - - M4 to nodes I1 and I2 are less than their actual counts by 3; some counts fall below zero and are eliminated. Once these synopses are received at nodes I1 and I2, Algo- rithm 1a is invoked, in which synopsis counts received from leaf nodes are first combined additively, and then decremented by (?1 ? ?2)?200 = 0.02?200 = 4. For the single item in Category A, leaf nodes M1 and M2 each supply a count of 6 to node I1, for a combined count of 12, which is then decremented by 4 for a final estimated count of 8 to be sent to node R. Items in Categories B and C each have combined counts of 3 at I1, which fall below zero when decremented by 4 and thus are not transmitted to R.

From Table 1 we observe a tradeoff between commu- nication load on the root node R and load on links not connected to R. Furthermore, in this particular case (al- though not always true in general), of our three example strategies, the strategy of using a gradual precision gra- dient (?2 = 0.03) is best with respect to all three metrics.

To see why, consider that if error tolerances are made large for levels of the communication hierarchy close to the leaves (in the most extreme case, by setting ?l?1 = ?, as in SS2), some locally-infrequent items are eliminated early, thereby reducing communication near the leaves.

However, an undesirable side-effect arises in the pres- ence of items just frequent enough at one or more leaf nodes to survive elimination locally, but not frequent enough overall to exceed the error threshold (as with items in categories B and C in our example). Counts for such items may avoid being eliminated until very late (or, worse, may never be eliminated), thus resulting in increased communication near the root. Hence, there is a tradeoff between high communication among non-root nodes and heavy load on the root node R.

The best way to set the precision gradient depends on the application scenario. For some applications the most important criterion may be to minimize load on the root node R where the answers are generated, which may need to devote the majority of its resources to other critical tasks for the application, even if that means in- creased load on the nodes responsible for monitoring streams and merging synopses. For other applications, it is most important to minimize the maximum load on any link to ensure that large volumes of input data can be handled without overloading network resources.

Next, we study the optimization problem of how best to select the precision gradient and synopsis-merging al- gorithm to use at each node, in order to achieve one of two objectives: (1) minimize communication load on the root node R, or (2) minimize worst-case commu- nication load on the most heavily-loaded link in the hi- erarchy. Communication load is measured in terms of      the number of frequency counts transmitted during one epoch. We study each optimization objective in turn in Sections 2.1.2 and 2.1.3, and provide optimal algorithm choices and settings for the error tolerances ?2, . . . , ?l?1 making up the precision gradient. Then, since real- world data is unlikely to exhibit worst-case behavior, in Section 2.1.4 we propose a variant that seeks to achieve low load on the most heavily-loaded link, under non- worst-case inputs for which estimated data distributions are available.

2.1.2 Minimizing Total Load on the Root Node Using Algorithm 1a at all applicable nodes and set-  ting ?i = 0 for all 2 ? i ? l?1, whereby all decrement- ing and elimination of synopsis counts is performed by children of root node R, minimizes communication load on the root node R under any input streams. We term this strategy MinRootLoad.

Lemma 1 Given a value for ?1, for any input streams no values of ?2, . . . , ?l?1 satisfying ?1 ? ?2 ? . . . ? ?l?1 and no choice of synopsis-merging algorithm re- sults in lower total communication load on node R than the values ?2 = ?3 = . . . = ?l?1 = 0 and Algorithm 1a, assuming buffer space at each node is sufficient to store all inputs arriving during one epoch.

Proof: Consider node X , an arbitrary child of the root node R. Let SX denote the union of all streams arriving at the monitor nodes belonging to the subtree rooted at X during one epoch. Since an (?1, 1)-synopsis is sent from X to R, for any setting of ?2, . . . , ?l?1, counts for all items v with frequency c(v) ? ?1 ? |SX | are sent over the link from X to R (here, |SX | de- notes the number of item occurrences in SX ). Using ?2 = ?3 = . . . = ?l?1 = 0 and Algorithm 1a at X, it is easy to see that an item u will be sent over the link from X to R only if c(u) ? ?1 ? |SX |. Therefore, this setting of ?2, . . . , ?l?1 along with the use of Algorithm 1a results in the smallest possible number of counts sent over the link from X to R. Since this property holds for any child X of R, strategy MinRootLoad minimizes the total communication load on R, for any input streams.

?  2.1.3 Minimizing Worst-Case Maximum Load on Any Link  In this section we show how to set ?2, . . . , ?l?1 and how to select a synopsis-merging algorithm to use at each node so as to minimize the maximum load on any communication link, in the worst case over all possible input streams. We provide a two step solution. First, we show that for any precision gradient ?2, . . . , ?l?1, use of Algorithm 1a at each node minimizes the load on every  link, provided buffer space at each node is sufficient to store all inputs arriving during one epoch. Then, we de- rive the optimal precision gradient when Algorithm 1a is used at each node.

We begin with the issue of selecting a synopsis- merging algorithm.

Observation 1 If, presented with identical inputs, Al- gorithm 1b produces output S and Algorithm 1a pro- duces output S ?, then S : n = S ? : n and for all items u ? S, S :c?(u) ? S ? :c?(u).

Observation 2 Consider two sets of inputs to one of Algorithm 1a or Algorithm 1b. Let input1 = {S1,S2, . . . ,Sd}, and input2 = {S ?1,S ?2, . . . ,S ?d} where for all j (1 ? j ? d), Sj : n = S ?j : n and for all items u ? S ?j , Sj : c?(u) ? S ?j : c?(u). Let input1 lead to output S, whereas input2 lead to output S ?. Then S :n = S ? :n and for all items u ? S, S :c?(u) ? S ? :c?(u).

Lemma 2 At any node X use of Algorithm 1a results in no higher communication on any link than use of Algo- rithm 1b.

Proof: Follows from Observation 1 and multiple invocations of Observation 2. ?  Lemma 3 Given a choice between Algorithms 1a and 1b under any precision gradient, use of Algorithm 1a at each node minimizes the maximum load on any link.

Proof: Follows from Lemma 2. ? It is trivial to extend this result to include leaf nodes, replacing Algorithm 1a with the original lossy counting algorithm.

Next, we show how to set ?2, . . . , ?l?1 assuming Al- gorithm 1a is used at each node, and the lossy counting algorithm is used to generate the local synopsis at each monitor node. We also assume the buffer each monitor node uses for lossy counting is large enough to store fre- quency counts of all items arriving on the input stream during any one epoch. As we later confirm in Section 3, this assumption poses no problem in practice, particu- larly if the epoch duration is small. For our worst-case analysis, we extend the set of possible inputs in two mi- nor ways:  1. The occurrence frequency of an item arriving on an input stream can be a positive real number.

2. Associated with each item u is a weight wu ? [0, 1].

In an epoch, at most one item occurrence per input stream can be an occurrence of an item of weight less than 1. The cost of transmitting the count of item u with weight wu is wu. In a synopsis, S :n =  ? wu ?c(u).

As will become clear later, both of these enhancements allow load on a link to be expressed as a continuous function, which in turn simplifies our worst-case analy- sis. Neither enhancement alters the worst-case input sig- nificantly. First, during an epoch, at most one item oc- currence per input stream can have non-integral weight.

Second, any input with real-valued item frequencies can be transformed into an input with nearly integral fre- quencies that yields identical results by multiplying each frequency by a large number, and dividing all answers produced by the same number.

For notational ease, we transform the problem of set- ting ?2, . . . , ?l?1 to that of setting ?2, . . . ,?l?1, where for all 2 ? i ? l ? 2, ?i = ?i ? ?i+1 and ?l?1 = ?l?1.

It is required that ?i ? 0 for all 2 ? i ? l ? 1, and that ?l?1i=2?i ? ?1. ?i denotes the precision margin at level i, i.e., the difference between the error tolerances at level i and level i + 1.

Let the vector ? = (?2, ?3, . . . ,?l?1). Let I de- note the contents of all input streams S1, . . . , Sm during a single epoch. Let I denote the set of all possible in- stances of I .

Given an input I , a communication hierarchy T (de- fined by degree d and number of levels l), and a setting of the precision gradient ?, let w represent the maxi- mum load on any link in the communication hierarchy:  w(I, T , ?) = max k?links(?)  {load(k)}  Worst-case load W is defined as:  W (T , ?) = max I?I  {w(I, T , ?)}  Given a communication hierarchy T , the objective is to set ? such that the worst-case load W (T , ?) is mini- mized.

We first show that it is sufficient to consider a specific subset of all instances of the general problem for worst- case analysis. Then we find precision gradient values ? values that cause the worst-case load under any of these instances to be minimal.

There exists a subset Iwc of the set of all input in- stances I such that for all instances I ? I ? Iwc, there exists an instance I ? ? Iwc such that for any T , ?, w(I ?, T , ?) ? w(I, T , ?). Hence, Iwc denotes the set of worst-case inputs. Instance I is a member of Iwc if and only if it satisfies each of the following three prop- erties:  P1:For any two input streams Si and Sj , there is no item occurrence common to both Si and Sj .

P2: For any input stream Si, all items occurring in Si occur with equal frequency.

P3: For any two input streams Si and Sj , both the number of item occurrences, and the number of distinct items, in Si and Sj are equal.

Lemma 4 For fixed T and ?, given any input instance I , it is possible to find an input instance I ? ? Iwc such that w(I ?, T , ?) ? w(I, T , ?).

Proof: Our proof of Lemma 4 is rather involved, and is provided in [21]. ?  From Lemma 4 we know it is sufficient to consider the set Iwc for worst-case communication load. Hence, we can rewrite our expression for W (T , ?) as:  W (T , ?) = max I?Iwc  {w(I, T , ?)}  Property P3 of Iwc implies that the total number of item occurrences at any leaf node is the same. Let n de- note this number (|Si| = n for all 1 ? i ? m). Let tc(j) denote the total number of item occurrences ar- riving on streams monitored by at the leaf nodes of a subtree rooted at a node at level j. It is easy to see that tc(j) = d(l?1?j) ?n, where l is the number of levels in the communication hierarchy and d is the fanout of all non-leaf nodes. The next lemma shows that worst-case inputs induce a high degree of symmetry on the resulting synopses.

Lemma 5 For any input instance I ? Iwc, the follow- ing two properties hold for the dj (?j , 1)-synopses re- layed by the dj level-j nodes to their parents:  1. No item is present in more than one synopsis.

2. The estimated frequency counts corresponding to any two items, even if present in two different synopses, have the same value.

Proof: See [21]. ?  Due to the high degree of symmetry formalized in Lemma 5, the count for each item is eliminated (due to being decremented and falling below zero) at the same level of the communication hierarchy. Let us call this level x. If all counts are dropped at the leaf level, then x = l ? 1. If all counts are retained through the entire process and are sent to the root node R (level 0), then x = 0. Otherwise, all counts are dropped at some inter- mediate level 1 ? x ? l ? 2.

The most heavily loaded link(s) are the ones leading to level x. To see why, consider that no data is transmit- ted on subsequent links and previous links have lower load since data is spread more thinly (in any communi- cation hierarchy T , the number of links between levels decreases monotonically as data moves from leaves to the root).

When synopses are combined at nodes of level i using Algorithm 1, the frequency count estimate of each item is decremented by the quantity tc(i) ??i (let      ?1 = ?1 ? ?l?1i=2?i). Hence, the true frequency count of any item occurring on some input stream must be C = ?l?1j=x+1(tc(j) ??j) + ?, where ? is a small quan- tity3. The number of items present in each input stream is thus nC  4. Since synopses for dl?1?x input streams are transmitted through a node at level x, the load on the most heavily loaded link(s) is L(x) = dl?2?x ? nC .

Clearly, the maximum value of L(x) is achieved when ? ? 0. The expression for L(x) can be simplified to:  L(x) =  ?l?1j=x+1(?j ?dx?j+1)  Now, our expression for the worst-case load on any link can be reduced to:  W (T , ?) = max x=0,1,...,l?2  {L(x)}  We desire to minimize W (T , ?) subject to the con- straints ?2, . . . ,?l?1 ? 0 and ?l?1j=2?j ? ?1. It is easy to show that this minimum is achieved when L(0) = L(1) = ? ? ? = L(l ? 2).

Solving for ?2, . . . ,?l?1, we obtain: ?i = ?1 ? d?1  (l?2)?(d?1)+d , 2 ? i ? l ? 2 and ?l?1 = ?1 ? d  (l?2)?(d?1)+d . Translating to error tolerances, we set  ?i = ?1 ? (l?1?i)?(d?1)+d(l?2)?(d?1)+d for all 2 ? i ? l ? 1. This setting of ?2, . . . , ?l?1 minimizes worst-case communi- cation load on any link. We term this strategy Min- MaxLoad WC. Under this strategy, the maximum pos- sible load on any link is Lwc =  (l?2)?(d?1)+d d??1 counts  per epoch. Lastly, we note that MinMaxLoad WC re- mains the optimal precision gradient even if nodes of the same level can have different ? values. Informally, since with worst-case inputs all incoming streams have identical characteristics, maximum link load cannot be improved by using non-uniform ? values for nodes at a given level; we omit a formal proof for brevity.

2.1.4 Good Precision Gradients for Non-Worst-Case Inputs  Real data is unlikely to exhibit worst-case character- istics. Consequently, strategies that are optimal in the worst case may not always perform well in practice. In terms of minimizing the maximum communication load on any link, the worst-case inputs are ones in which the set of items occurring on each input stream are disjoint.

When this situation arises, a gradual precision gradient is best to use (as shown in Section 2.1.3). Using a grad- ual precision gradient, some of the pruning of frequency  3Recall that we allow the frequency of an item to be a real number.

4More precisely, each stream contains ? n  C ? items of weight 1 each,  and one item of weight = n C  ? ? n C ?. Note that each input stream  contains at most one item with weight less than 1, as stipulated earlier.

counts is delayed until a better estimate of the overall distribution is available closer to the root, thereby en- abling more effective pruning. In the opposite extreme, when all input streams contain identical distributions of item occurrences, there is no benefit to delaying prun- ing, and performing maximal pruning at the leaf nodes (as in strategy SS2) is most effective at minimizing com- munication. In fact, it is easy to show that SS2 is the op- timal strategy for minimizing the maximum load on any link when all input streams are comprised of identical distributions; we omit a formal proof. (Note, however, that SS2 still incurs a high space requirement on the root node R since it sets ?1 = ?.)  We posit that most real-world data falls somewhere between these two extremes. To determine where ex- actly a data set lies with regard to the two extremes, we estimate the commonality between input streams S1, . . . , Sm by inspecting an epoch worth of data from each stream. We compute a commonality parameter ? ? [0, 1] as ? = 1m ?  ?m i=1  Gi Li  , where Gi and Li are defined over stream Si as follows. The quantity Gi is defined as the number of distinct items occurring in Si that occur at least ??|Si| times in Si and also at least ??|S| times in S = S1 ?S2 ? ? ? ? ?Sm, where |S| denotes the number of item occurrences in S during the epoch of measurement. The quantity Li is defined as the number of distinct items occurring in Si that occur at least ??|Si| times in Si. Hence, commonality parameter ? measures the fraction of items frequent enough in one input stream to be included in a leaf-level synopsis by strategy SS2 that are also at least as frequent globally (in the union of all input streams).

A natural hybrid strategy is to use a linear com- bination of MinMaxLoad WC and SS2, weighted by ?. The strategy is as follows: set ?i = (1 ? ?) ?( ?1 ? (l?1?i)?(d?1)+d(l?2)?(d?1)+d  ) + ? ?(?) for 2 ? i ? (l ? 2), and  ?l?1 = (1 ? ?) ? ( ?1 ? d(l?2)?(d?1)+d  ) + ? ?(?). We term  this hybrid strategy MinMaxLoad NWC (for non-worst- case). Commonality parameter ? = 1 implies that lo- cally frequent items are also globally frequent, and SS2 (modified to use ?1 < ?) is a good choice. Conversely, ? = 0 indicates that MinMaxLoad WC is a good choice.

For 0 < ? < 1, a weighted mixture of the two strategies is best.

2.1.5 Summary The precision gradient strategies we have introduced  are summarized in Table 3. Sample precision gradients are illustrated in Figure 3.

3. Experimental Evaluation In this section we evaluate the performance of our  newly-proposed strategies for setting the precision gra-      Table 3: Summary of precision gradient settings studied.

Strategy Description (Section Introduced)  Simple Strategy 1 (SS1) Transmits raw data to root node R (1.3)  Simple Strategy 2 (SS2) Reduces data maximally at leaves (1.3)  MinRootLoad Minimizes total load on root in all  cases (2.1.2)  MinMaxLoad WC Minimizes worst-case maximum load  on any link (2.1.3)  MinMaxLoad NWC Achieves low load on heaviest-loaded  link, under non-worst-case inputs (2.1.4)   0.0002  0.0004  0.0006  0.0008  0.001  4 3 2 1 0  Tree level (i)  SS1 SS2 MinRootLoad MinMaxLoad_WC MinMaxLoad_NWC  E rr  or to  le ra  nc e  ? i  input            leaf root  Figure 3: Precision gradients for ? = 0.001, ? = 0.5.

dient, using the two na??ve strategies suggested in Sec- tion 1 as baselines. We begin in Section 3.1 by describ- ing the real-world data and simulated distributed mon- itoring environment we used. Then, in Section 3.2, we analyze the data using our model of Section 2.1.4 to de- rive appropriate parameters for our MinMaxLoad NWC strategy that is geared toward performing in the presence of non-worst-case data. We report our measurements of space utilization on node R in Section 3.3, and provide measurements of communication load in Section 3.4.

3.1 Data Sets  As described in Section 1, our motivating applica- tions include detecting DDoS attacks and monitoring ?hot spots? in large-scale distributed systems. For the first type of application, we used traffic logs from Inter- net2 [18], and sought to identify hosts receiving large numbers of packets recently. For the second type, we sought to identify frequently-issued SQL queries in two dynamic Web application benchmarks configured to ex- ecute in a distributed fashion.

The INTERNET2 [18] traffic traces were obtained by collecting anonymized netflow data from nine core routers of the Abilene network. Data were collected for one full day of router operation and were broken into 288 five-minute epochs. To simulate a larger number of nodes, we divided the data from each router in a ran- dom fashion. We simulated an environment with 216 network nodes, which also serve as monitor nodes.

For the web applications, we used Java Servlet ver- sions of two publicly available dynamic Web applica- tion benchmarks: RUBiS [10] and RUBBoS [10]. RU- BiS is modeled after eBay [11], an online auction site, and RUBBoS is modeled after slashdot [23], an on- line bulletin-board, so we refer them as AUCTION and BBOARD, respectively. We used the suggested config- uration parameters for each application, and ran each benchmark for 40 hours on a single node.We then parti- tioned the database requests into 216 groups in a round- robin fashion, honoring user session boundaries. We simulated a distributed execution of each benchmark with 216 nodes each executing one group of database requests and also serving as a monitor node.

For all data sets, we simulated an environment with 216 monitoring nodes (m = 216) and a communication hierarchy of fanout six (d = 6). Consequently, our sim- ulated communication hierarchy consisted of four lev- els including the root node (l = 4). We set s = 0.01, ? = 0.1?s, and ?1 = 0.9??. Our simulated monitor nodes used lossy counting [22] in batch mode, whereby fre- quency estimates were reduced only at the end of each epoch (in all cases, less than 64KB of buffer space was used), to create synopses over local streams. The epoch duration T was set to 5 minutes for the INTERNET2 data set and 15 minutes for the other two data sets.

3.2 Data Characteristics Using samples of each of our three data sets, we  estimated the commonality parameter ? for each data set. Recall that we use ? to parameterize our strategy MinMaxLoad NWC presented in Section 2.1.4. We ob- tained ? values of 0.675, 0.839 and 0.571 for the INTER- NET2, AUCTION and BBOARD data sets respectively.

Hence, the AUCTION data set exhibited the most com- monality among all three data sets. Results presented in Section 3.4 show that AUCTION indeed has the most commonality.

3.3 Space Requirement on Root Node Figure 4 plots space utilization at the root node R  as a function of time (in units of epochs), using Algo- rithm 2a to generate the synopsis, for different values of the decay parameter ?, using two different strategies for the precision gradient. The plots shown are for the IN- TERNET2 data set. The y-axis of each graph plots the current number of counts stored in the (?, ?)-synopsis SA maintained by the root node R. Figure 4a plots syn- opsis size under our MinMaxLoad WC strategy under three different values of ?: 0.6, 0.9 and 1. As pre- dicted by our analysis in [21], when ? < 1 the size of SA remains roughly constant after reaching steady-state, whereas when ? = 1 synopsis size increases logarith- mically with time (similar results were obtained for the             1 21 41 61 81  Time (epoch #)  # co  un ts  ? = 0.6 ? = 0.9 ? = 1.0  (a) MinMaxLoad WC           1 21 41 61 81  Time (epoch #)  # co  un ts  ? = 0.6  (b) SS2  Figure 4: Space needed at node R to store answer synop- sis SA.

non-distributed single-stream case). In contrast, when SS2 is used to set the precision gradient (Figure 4b), the space requirement is almost an order of magnitude greater. This difference in synopsis size occurs because in SS2 frequency counts are only pruned from synopses at leaf nodes, so counts for all items that are locally fre- quent in one or more local streams reach the root node.

No pruning power is reserved for the root node, and therefore no count in SA is ever discarded, irrespec- tive of the ? value. (The same situation occurs if Al- gorithm 2b is used instead of Algorithm 2a.) This result underscores the importance of setting ?1 < ? in order to limit the size of SA, as discussed in Section 2.1.

3.4 Communication Load  Figure 5 shows our communication measurements under each of our two metrics, for each of our three data sets, under each of the five strategies for setting the pre- cision gradient listed in Table 3. First of all, as expected, the overhead of SS1 is excessive under both metrics.

Second, by inspecting Figure 5a we see that strategy MinRootLoad does indeed incur the least load on the root node R in all cases, as predicted by our analysis of Section 2.1.2. Under this metric, MinRootLoad outper- forms both simple strategies SS1 and SS2 by a factor of           INTERNET2 AUCTION BBOARD  SS1 SS2 MinRootLoad MinMaxLoad_WC MinMaxLoad_NWC  247k 10k 296k       132k 20k  # co  un ts  tr an  sm itt  ed (  pe r  ep oc  h)  (a) Load on root node R           INTERNET2 AUCTION BBOARD  SS1 SS2 MinRootLoad MinMaxLoad_WC MinMaxLoad_NWC  43k    21k  52k   19k   23k   7k  # co  un ts  tr an  sm itt  ed (  pe r  ep oc  h) (b) Maximum load on any link  Figure 5: Communication measurements (?k? denotes thousands).

five or more in all cases measured. However, MinRoot- Load performs poorly in terms of maximum load on any link, as shown in Figure 5b because no early elimination of counts for infrequent items is performed and, con- sequently, synopses sent from the grand-children of the root node to the children of the root node tend to be quite large. As expected, MinMaxLoad NWC performs best under that metric on all data sets. For the AUCTION data set, even though SS2 outperforms MinMaxLoad WC (to be expected because of the high ? value), our hy- brid strategy MinMaxLoad NWC is superior to SS2 by a factor of over two. For the INTERNET2 and BBOARD data sets, the improvement over SS2 is more than a fac- tor of three. On the negative side, total communica- tion (not shown in graphs) is somewhat higher under MinMaxLoad WC than under SS2 (increase of between 7.5% and 49.5%, depending on the data set).

4. Related Work  Most prior work on identifying frequent items in data streams [6, 8, 9, 19, 22] only considers the single-stream case. While we are not aware of any work on maintain- ing frequency counts for frequent items in a distributed stream setting, work by Babcock and Olston [5] does ad-      dress a related problem. In [5] the problem is to monitor continuously changing numerical values, which could represent frequency counts, in a distributed setting. The objective is to maintain a list of the top k aggregated val- ues, where each aggregated value represents the sum of a set of individual values, each of which is stored on a different node. The work of [5] assumes a single-level communication topology and does not consider how to manage synopsis precision in hierarchical communica- tion structures using in-network aggregation, which is the main focus of this paper.

The work most closely related to ours is the recent work of Greenwald and Khanna [16], which addresses the problem of computing approximate quantiles in a general communication topology. Their technique can be used to find frequencies of frequent items to within a configurable error tolerance. The work in [16] focuses on providing an asymptotic bound on the maximum load on any link (our result adheres to the same asymptotic bound). It does not, however, address how best to con- figure a precision gradient in order to minimize load, which is the particular focus of our work.

5. Summary  In this paper we studied the problem of finding fre- quent items in the union of multiple distributed streams.

The central issue is how best to manage the degree of approximation performed as partial synopses from mul- tiple nodes are combined. We characterized this process for hierarchical communication topologies in terms of a precision gradient followed by synopses as they are passed from leaves to the root and combined incremen- tally. We studied the problem of finding the optimal precision gradient under two alternative and incompati- ble optimization objectives: (1) minimizing load on the central node to which answers are delivered, and (2) minimizing worst-case load on any communication link.

We then introduced a heuristic designed to perform well for the second objective in practice, when data does not conform to worst-case input characteristics. Our experi- mental results on three real-world data sets showed that our methods of setting the precision gradient are greatly superior to na??ve strategies under both metrics, on all data sets studied.

