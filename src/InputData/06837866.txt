

Abstract - Mining frequent patterns is to discover the groups of items appearing always together excess of a user specified threshold from a large transaction database.

However, the transactions will grow rapidly, such that the frequent itemsets may be changed due to the addition of the new transactions. The users may eager for getting the latest frequent itemsets from the updated database as soon as possible in order to make the best decision. Therefore, it has become an important issue to propose an efficient method for finding the latest frequent itemsets when the transactions keep being added into the database. For the previous tree- based approaches, they have to re-scan the original database and generate a large tree structure. In this paper, we propose an efficient algorithm which only keeps frequent items in a condensed tree structure. When a set of new transactions is added into the database, our algorithm can efficiently update the tree structure without scanning the original database.

Keywords - Data mining, Frequent itemset, Transaction database, Tree structure

I.  INTRODUCTION  The definitions about mining frequent patterns are described as follows [1]. A transaction database consists of a set of transactions, in which each transaction includes a transaction-id (TID) and the items purchased in this transaction. Table I is an example of a transaction database. Let I = {i1, i2, ?, in} be the set of all items. An itemset is a subset of I, which is denoted as {a1, a2, ?, am} (?ai ? I, 1 ? i ?m, 1 ? m ? n). A transaction in the database supports an itemset if the itemset is a subset of the items in the transaction. The support for an itemset is the fraction of total transactions which support the itemset.

Given a user-specified minimum support threshold, the frequent itemsets are the itemsets whose supports are no less than the minimum support threshold. If the support of an itemset is less than the minimum support, then this itemset is an infrequent itemset.

In order to find out the frequent itemsets from a transaction database, there are many algorithms proposed by the previous studies [1, 2, 4, 6, 7]. However, in the real-world, the transactions will increase with time. The users may want to catch this real-time information to make advantageous decisions. Therefore, how to find the most recent frequent itemsets when a set of new transactions arrives with time becomes an important issue.

The Tree-based algorithms [3, 5] merge the new incoming transactions into a tree structure which was constructed from the original database, and then apply the FP-Growth algorithm [4] to find all the frequent itemsets, since the tree construction takes much more time than frequent itemset generation for FP-Growth algorithm. FP- Growth constructs a frequent pattern tree structure which is called FP-tree. FP-tree consists of a null root, a set of nodes and a header table. Each node, except the root node, in the FP-tree consists of three fields: item-name, count, and node-link. The item-name registers which item this node represents, count registers the number of transactions represented by the portion of the path reaching this node, and node-link links to the next node in the FP-tree carrying the same item or null if there is none.

There is an item-link structure for each frequent item.

Each entry in the header table consists of two fields: item- name and head of node-link which points to the first node in the FP-tree carrying the same item-name. The header table is built in which each item points to its occurrence in the tree via the head of node-link. The nodes with the same item-name are linked in sequence via such node-link.

After scanning all the transactions in the database, the FP- tree can be constructed.

Leung et al. proposed CAN Tree [5] (Canonical-order Tree) in 2005. CAN Tree contains all the transactions in a transaction database, and therefore it needs to scan the database only once to construct a CAN Tree. Because all the items including infrequent items are stored in a CAN Tree and the items are not ordered in their frequency order, it needs to spend a large amount of memory space to store the large CAN Tree, and take a lot of time for mining frequent itemsets from the large CAN Tree. In 2008, Hong et al. proposed FUFP (Fast Updated FP-tree) algorithm [3], which is the most efficient algorithm for incrementally mining frequent patterns. However, when an originally infrequent item becomes frequent, FUFP needs to re-scan the original database to obtain the  An Efficient Approach for Updating the Structure for Mining Frequent Patterns    Show-Jane Yen, Yue-Shi Lee, Jia-Yuan Gu Department of Computer Science & Information Engineering,  Ming Chuan University, 5 De Ming Rd., Gui Shan District, Taoyuan County 333, Taiwan  sjyen@mail.mcu.edu.tw   TABLE I THE ORIGINAL TRANSACTION DATABASE    TID Items  1 A ,B, D 2 B, C 3 B, C, D, E 4 C       support for the item in the updated database, which degrades the performance for updating the tree structure.

In order to avoid storing all the information of the transaction database in the tree structure and re-scanning the original database, we propose an efficient algorithm to update the original tree structure when the transactions are added into the database. Our storage structure is based on FP-tree structure [4] and there is a TidSet or its Complement Set recorded on each node of the tree structure, which records the TIDs of the transactions containing the items in the path from the node to the child of the root. Our algorithm just considers the added transactions to determine which frequent items turn out to be infrequent and which infrequent items turn out to be frequent. After removing the nodes which contain the infrequent items, the tree structure can be updated by simply performing set difference or intersection operations without scanning the original database.



II.  METHODOLOGY  In this section, we present the storage structure of our algorithm, and then describe how to update the storage structure for our algorithm when the transactions are added into the original database. After updating the storage structure, all the frequent itemsets can be obtained by applying FP-Growth algorithm [4].

A.  The storage structure for the original database  Our tree structure is constructed as follows: For each item, the original database DB is scanned to record the TIDs of the transactions which contain the item, that is, the TidSet for the item, which are shown in the TidList (Table II). The support count for each item can also be obtained for this database scan. The frequent items are ordered by their support count in descending order, and each item and its TidSet are added into the tree structure according to the order. For example, assume that the minimum support threshold is 50%, that is, the minimum support count is 2 for Table I. Then the ordered frequent items are B, C, and D. In the following, we illustrate how to construct the tree structure from Table I.

First, there is only an empty root node created on the tree and a header table whose structure is the same as the header table in the FP-tree [4]. According to the item order, item B and its TidSet are added into the tree.

Because there is no other node but the root on the tree, a node with item B is created as the child node of the root and the TidSet is recorded on the node. In order to reduce the memory usage, the TidSet for a node will be transformed into its Complement Set if the count for the node is greater than half of the total number of the transactions in the database. We call a node with a TidSet as a T-node, and a node with a Complement Set as a C- Node. Besides, for a node which contains item X, we call it node X. Since the count of node B whose TidSet is {1, 2, 3} which is greater than 4/2=2, the TidSet of node B is transformed to its complement set {4}, which is denoted as {4}C. Therefore, node B is a C-node. The corresponding item-link of item B in the header table is also linked to the node B. After adding item B and its TidSet, the tree structure is shown in Fig. 1.

Fig. 1.  The tree structure after adding item B   When the next item Y is added into the tree, the tree structure is traversed in depth-first order, and there are two steps to perform when a node X is visited:  (1) To check whether X?s child node need to be visited, that is to do the ?Downward Operation? on item Y and node X to get the common occurrences of items X and Y in the same transactions. The operation can be divided into the following cases: If X is a T-Node, we perform the intersection on the two TidSets of item Y and node X, that is T(Y) ? T(X); if X is a C-Node, we perform the set difference on the TidSet of item Y and the Complement Set of node X, that is T(Y) ? C(X). If the result is not empty, then our algorithm check if there is a child node of node X. If node X has a child node Z, then the downward and upward operations continue to perform on item Y with the result set and the node Z. Otherwise, a node with item Y and the result set is created as a child node of X.

For the above example, the next item which needs to be processed is item C. The downward operation on item C and the visited node B is performed, that is {2, 3, 4} - {4}C = {2, 3}, which represents item B and C have common occurrences in the transactions with TIDs 2 and 3. Therefore, a node C with TidSet {2, 3} is created as node B?s child node. Since the count of the child node C is no greater than 2, the TidSet does not need to be transformed. (2) To check whether X?s sibling node needs to be visited, that is to do the ?Rightward Operation? on item Y and node X to get the set of the TIDs of the transactions which contain item Y but no item X. The operation also can be divided into the following cases: If X is a T-Node, we perform the set difference on the two TidSets of item Y and node X, that is T(Y) ? T(X). If X is  TABLE II TIDLIST FOR EACH ITEM    Item TidSet  A 1 B 1, 2, 3 C 2, 3, 4 D 1, 3 E 3  Proceedings of the 2012 IEEE IEEM       a C-Node, we perform the intersection on the Complement Set of node X and the TidSet of item Y, that is C(X) ? T(Y). If the result is not empty, then our algorithm check if there is a sibling node of X. If node X has a sibling node Z, then the downward and upward operations continue to perform on item Y with the result set and the node Z. Otherwise, a node with item Y is created as a sibling node of X.

Fig. 2.  The tree structure after adding C as a child of node B     Fig. 3.  The tree structure after adding C as a sibling of node B    Fig. 4.  The tree structure after adding D as a child of node C  Fig. 5.  The tree structure after adding D as a sibling of node C  For the above example, the rightward operation on item C and node B is performed, that is {2, 3, 4} ? {4}C = {4}, which means that the transaction TID 4 contains item C but no item B. Therefore, a node C with TidSet {4} is created as the sibling node of node B, which is shown in Fig. 3. After that, whenever a new incoming item visits a node on the tree, the two operations need to be performed  to determine if a new node need to be created. Fig. 4 and Fig. 5 show the tree structure after performing the downward and rightward operations on item D and the visited nodes, respectively. After processing all the frequent items, the tree structure corresponding to the original database (Table I) is constructed.

B. The tree updating after adding the transactions  When a set of the new transactions are added, our algorithm first scans the new transaction database once to obtain the TidSets of each item and its support count in the new transaction database. In the following, the original database is denoted as DB, and the new transaction database is denoted as db. When a set of the transactions are added, each item in the new transaction database will meet one of the following three cases: (1) The item is frequent in DB, but becomes infrequent in the updated database DB+db. (2) The item is frequent both in DB and DB+db. (3) The item is infrequent in DB, but becomes frequent in DB+db. Our algorithm sequentially processes the items from the 1st case to the 3rd case.

In the following, we use a running example to explain our algorithm. In this example, Table I is the original database and Table III is the new transaction database. Because items B, C and D are frequent in DB, and items B and C remain frequent in DB+db, items B and C meet the 2nd case, and item D meets the 1st case.

For the items in the 1st case, since there are some nodes which contain the items on the original tree structure, these nodes should be removed after adding the transactions. If the removed node X is a leaf node, it can be removed directly. Otherwise, if there are a child node and a sibling node of X which contain the same item, then the two nodes need to be merged, that is, to combine their TidSets and sum their counts. If there is no any sibling node of X with the same item as a child node Y of X, then the parent node of X becomes the parent of Y. For the above example, because D is in the 1st case and the nodes with item D are both leaf nodes, we only remove the nodes without merging, which is shown in Fig. 6.

TABLE III A NEW TRANSACTION DATABASE db    TID Items  5 B, A 6 A, E, C  TABLE IV TIDLISTS OF THE ITEMS IN db    Item TidSet  A 5, 6 B 5 C 6 E 6    Proceedings of the 2012 IEEE IEEM          Fig. 6.  The tree structure after removing the nodes with D   After removing the items in the first case from the tree, our algorithm processes the items in the 2nd case.

Since the items have existed in the tree before adding the transactions and they are remained in the tree after adding the transactions, we only need to update the counts and TidSets on the nodes with the items. If the count for a node is greater than half of the number of the transactions in DB+db, the TidSet will be transformed to its complement set. For the above example, the nodes with item B or item C should be updated. According to Table IV, the item B with TID 5 is first added into the tree structure. The first visited node in Fig. 6 is node B which contains the same item B. Therefore, the TID 5 is added into the TidSet of node B. Since the count of the node B is 4 which is greater than 6/2=3 after adding the transactions, it remains to record the complement set of the TidSet, that is {4, 6}C, which is shown in Fig. 7. To avoid unnecessary computation on the original TidSets, the new TIDs are stored individually and combined with the original TidSets after processing all the items in the 2nd case.

Therefore, the operations only need to be performed on the new TIDs.

Fig. 7.  The tree structure after processing item B    Fig. 8.  The tree structure after combining the original and new TidSets   Another item in the 2nd case is item C which appears in the transaction TID 6 in db. The node B in Fig. 7 is first visited. Our algorithm perform the downward operation  on the node B and item C with TidSet {6}, which is {6} ? {6} = . Therefore, the child node of node B does not need to be visited. Since the rightward operation on the item C and the visited node B is {6}  {6} = {6}, the sibling node of node B need to be visited and the visited node is node C. Therefore, the TID 6 is directly added into the TidSet of node C, which becomes {4, 6}. After processing all the items in the 2nd case, the new TidSets can be really combined with the original TidSets, which is shown in Fig. 8.

Fig. 9.  The tree structure after adding item A   For the items in the 3rd case, since the items are not frequent in the original database, but becomes frequent after adding the new transactions, these items need to be added into the tree after adding the new transactions, which is the same as the method to add an item into the tree structure in the tree construction phase.

For the example, item A is in the 3rd case. Because there are no nodes with item A on the tree, the new transactions TID 6 which contains item A needs to be combined with the TidSet of item A in the original database, that is, the new TidSet of item A is {1, 5, 6}. Therefore, item A with TidSet {1, 5, 6} is added into the tree. The node B is first visited. The downward and rightward operations are performed on item A with TidSet {1, 5, 6} and node B, which are {1, 5, 6} ? {4, 6} = {1, 5} and {1, 5, 6} ? {4, 6} = {6}, respectively. Therefore, the child node of node B needs to be visited and the visited node is node C. After performing the downward and rightward operations on item A with TidSet {1, 5} and the node C, that is {1, 5} ? {2, 3} = ? and {1, 5} - {2, 3} = {1, 5}, respectively, the child node of node C does not need to be visited, but the sibling node of node C needs to be visited. Therefore, a new node A with TidSet {1, 5} is created as the sibling node of node C. Our algorithm goes back to node B and visits the sibling node C of the node B. After performing the downward and rightward operations on item A with TidSet {6} and the node C, that is {6} ? {4, 6} = {6} and {6} ? {4, 6} =?, respectively, a new node A with TidSet {6} is created as a child node of the node C, since node C has no any child node, which is shown in Fig. 9.



III.  EXPERIMENTAL RESULTS  In this section, we evaluate the performance of our  algorithm and compare it with the most efficient algorithm FUFP [3] in the same execution environment.

The experiments are performed in Java on a computer  Proceedings of the 2012 IEEE IEEM       equipped with Intel? Core? i5 Quad CPU 760 @ 2.80GHz and 2GB main memory and running on the Microsoft Windows 7 operating system. We generate four synthetic datasets T10I2D20K, T10I4D20K, T10I2D100K and T10I4D100K by using IBM Synthetic Data Generator, in which T is the average length of the transactions, I is the average size of maximal potential frequent itemsets and D is the total number of transactions.

The number of distinct items is set to 100K.

Because the tree structures of our algorithm and FUFP algorithm are the same, and both of them use FP- Growth algorithm for mining frequent itemsets, the mining times for the two algorithms are the same, too.

Therefore, we only evaluate the performance of tree updating for the two algorithms.

Fig. 10.   Execution time for FUFP and our algorithm   We take 10K transactions from the two datasets T10I2D20K and T10I4D20K as the original databases, and accumulate the execution times for adding 2K transactions every time to the two original databases, respectively. Fig. 10 shows the execution times for FUFP algorithm and our algorithm when the minimum support is set to be 0.15%. From Fig. 10, we can see that our algorithm outperforms FUFP both on the two datasets and the performance gap increases as the number of the transactions in the updated databases increase, since FUFP needs to re-scan the original database to compute the supports for the itemsets which turn out to be frequent after adding the transactions, but our algorithm can obtain the supports for these itemsets from the TidSets without scanning the original database. However, in the beginning, our algorithm takes more time to construct the original tree structure, since our algorithm needs to take time to transform the original dataset into the TidList, but FUFP uses the same way as the FP-Growth algorithm [4] to construct a FP-tree.

Fig. 11 shows the execution times for FUFP and our algorithm on the larger dataset T10I4D100K. In this experiment, We take 50K transactions from the dataset as the original database and accumulate the execution times for adding 10K transactions every time to the original database. From Fig. 11, we can see that the execution times only slightly increase as the number of the transactions in the updated database increases for our algorithm. Our algorithm also significantly outperforms  FUFP algorithm when the transactions are continuously added into the original database.

Fig. 11.   Execution time for FUFP and our algorithm on T10I4D100K

IV.  CONCLUSION   In this paper, we propose an efficient approach for incrementally mining frequent patterns. In order to reduce the memory usages, we store the complement set instead of TidSet on a node if the number of the elements in the TidSet is more than that of its complement set. When a set of the transactions is added, our algorithm only needs to apply the set difference or intersection operations on the TidSet or Complement Set, and adjust few tree nodes without re-scanning the original database. Therefore, our algorithm outperforms the previous approaches.

