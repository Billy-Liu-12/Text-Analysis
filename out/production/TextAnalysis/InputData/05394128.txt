Performance of Distributed Apriori Algorithms on a

Abstract? When large data repositories are coupled with  geographic distribution of data, users and systems, it is necessary  to combine different technologies for implementing high-  performance distributed knowledge discovery systems. On the  other hand, computational grid is emerging as a very promising  infrastructure for high-performance distributed computing. Grid  applications such as astronomy, chemistry, engineering, climate  studies, geology, oceanography, ecology, physics, biology, health  sciences and computer science often involve large amounts of  computing and/or data. For these reasons, we think grids can  offer an effective support to the implementation and use of  parallel and distributed data mining systems.

This paper describes development of parallel and distributed  prior algorithm on grid environment. Apriori algorithm along  with FP-growth (Frequent Pattern Growth) is implemented on  grid network in each grid node, which finds the local support  counts and prunes all infrequent item sets. After completing local  pruning, each grid node broadcasts messages containing all the  remaining frequent patterns to the coordinator. We have  compared the output of conventional method of apriori algorithm  with FP-tree in both homogenous and heterogeneous  environments. Practical datasets are large in nature and taken  from the UCI machine repository and are related to adult,  mushroom, and letter recognition, are used to measure the  system performance. The detailed experiment procedure and  result analysis are also discussed in this paper. In future the  security issue among different local datasets and the huge  communication cost in data migration can be considered.

Keywords- Association rules, Data mining, Grid computing, High  performance

I.  INTRODUCTION  Mitica Craus and Cristian Aflori describe that a  computational grid is a hardware and software infrastructure  that provides dependable, consistent, pervasive, and  inexpensive access to high-end computational capabilities. A  Grid is built from multipurpose protocols and interfaces that  address such fundamental issues as authentication,  authorization, resource discovery, and resource access. It is  important that these protocols and interfaces be standard and  open. Otherwise, they say we will be dealing with an  application specific system. A Grid allows its constituent  resources to be used in a coordinated fashion to deliver  various qualities of service, relating for example to response  time, throughput, availability, and security, and/or co-  allocation of multiple resource types to meet complex user  demands, so that the utility of the combined system is  significantly greater than that of the sum of its parts [1].

Among the Areas of data mining, the problem of deriving  associations from the data has received a great deal of  attention. The problem was formulated by Agrawal and  Srikanth in 1993 and is often referred to as the market-basket  problem. In this problem we are given a set of items and a  large collection of transactions, which are subsets (baskets) of  these items. The task is to find relationships between the  presences of various items within these baskets. There are  numerous applications of data mining, which fit into this  framework. The classic example from which the problem gets  its name is the super market. In this context, the problem is to  analyze customer?s buying habits by finding associations  between different items that customer place in their shopping  baskets. The discovery of such association rules can help the  retailer develop marketing strategies, by gaining insight into  matters like ?which items are most frequently purchased by  customers?. It also helps in inventory management, sale  promotion strategies, etc. It is widely accepted (except for  some recent developments) that the discovery of association  rules is solely dependent on the discovery of frequent sets.

Thus, a majority of algorithms are concerned with efficiently  determining the set of frequent itemsets in a given set of  transactions database [6], [8], [9]. The problem is essentially  to compute the frequencies of occurrences of each itemset in  the database. Since the total number of itemsets is exponential  in terms of the number of items, it is not possible to count the  frequencies of these sets by reading the database in just in one  pass. The numbers of counters are too many to be maintained  in a single pass. As a result, having multiple passes for  generating all frequent itemsets is unavoidable. Thus, different  algorithms for the discovery of association rules aim at  reducing the number of passes by generating candidate sets,  which are likely to be frequent sets. In other words, these  algorithms attempt to eliminate, as early as possible, all those  sets, which can be estimated to be infrequent sets. The  algorithms differ from one another in the method of handling  the candidate sets and the method of reducing the number of  database passes. However, one of the very recent algorithms  attempts to discover frequent sets without having to generate  candidate sets. There are other related problems in this  context. One can ask whether it is possible to find association  This work is partially supported by the Research Committee of the Guru Nanak Institute of Technology (GNIT), Hyderabad, India.

rules incrementally. The algorithms for discovering frequent  sets are not directly suitable when the underlying database is  incremented intermittently. The idea is to avoid computing the  frequent sets afresh for the incremented set of data. The  concept of border sets becomes very important in this context.

The sets of border sets can be determined without any extra  efforts. And if no border set is affected by a database update,  then it is shown that the set of frequent sets can be found  without having search through the whole database. In real-life  applications, the numbers of frequent sets are very large in  number and, as a result, the numbers of association rules are  also too large to be useful. It then becomes meaningful to  generate only the association rules in which the user is  interested. The user can specify the constraint to indicate  which combinations of items are subjected to his interest. The  discovery of frequent itemsets with item constraints is one  such important related problem [2], [5], [7], [10].

In the paper of Marek Wojciechowski et al. [3], discuss about the problems that are with the usage of apriori algorithm such as the problems identified Apriori are: (a) multiple database scans, and (b) huge number of candidates generated for dense datasets and/or low frequency threshold (minimum support). To address the limitations of Apriori-like methods, a novel mining paradigm has been proposed, called pattern- growth, which consists in a depth-first search of the pattern space. Pattern-growth methods also build larger frequent sets from smaller ones but instead of candidate generation and testing, they exploit the idea of database projections. Typically, pattern-growth methods start with transforming the original database into some complex data structure, preferably fitting into main memory. A classic example of the pattern-growth family of algorithms is FP-growth, which transforms a database into FP-tree stored in main memory using just 2 database scans, and then performs mining on that optimized FP-tree structure [3], [4].

The rest of the paper is organized as follows. Section II formulates the parallel mining of frequent itemsets. Section III explains the experiments and results in details and presents numerical simulations that demonstrate the value of the distributed association rule algorithms and give some intuition                          about the observed results. We conclude in section IV.



II. PARALLEL MINING OF FREQUENT ITEMSET  A program in Java has been developed which employed  grid-gain methods to split the functions/methods in grid  environments. The grid-gain operates upon a distributed  association rule-mining algorithms, which can be later  performed in separate node.

A. Execution in Sequence  1. Manager node starts processing by splitting the data.

2. Manager sends the data and the control to each grid  node.

3. Each node generates patterns i.e., frequent item-sets  as per their data set and support given.

4. Returns the control to the manager node for AR  generation.

5. Manager node generates association Rules for each  dataset according to the frequent item-sets sent by  each node and their confidence respectively.

B. Parallel Execution  1. Manager node starts processing by splitting the data.

2. Manager sends the data and the control to each grid  node.

3. Each grid node generates patterns i.e., frequent item-  sets as per their data sets and support given.

4. Each grid also generates association rules from the  frequent item-sets as per the confidence given.

5. The grid nodes return the control to the manager  node.

C.  Grid Model  The grid considered in this study is composed of a  number of nodes; each node is composed of several  computational resources, which may be homogeneous and/or  heterogeneous.

Grid  Manager  adult mushroom letter  recognition    adult  Grid Machine    mushroom  Grid Machine    letter recognition  Grid Machine  Home  Machine     2 5 2 5 2 5   2 4  3 3  3 4 3 4 3 4  1 5  Parallel execution using apriori and FP-growth  Serial execution using apriori and FP- growth  Figure 1. Logical architecture for implementation of distributed apriori algorithms in grid environments  164 2009 IEEE Asia-Pacific Services Computing Conference (IEEE APSCC)    In our experimental testing we use 5 homogeneous  machines, 3 heterogeneous machines and 3 tasks initially.

After that this algorithm is executed in a grid environment  and the execution time using the grid environment is  calculated. See the Fig. 1 for logical architecture for  implementing of distributed association mining algorithm in  grid environments.

TABLE I. MACHINE CONFIGURATION LIST   After calculating both execution times, these execution times  are compared, along with other evaluation criteria and hence  we show that the execution time is reduced when algorithm is  executed on Grid node. See the Table I for machine  configuration list. The Grid task we are implementing  distributed association rule mining algorithms, which is apriori  and FP growth algorithm. This algorithm is first executed on  simple java editor and the execution time of this algorithm is  calculated using the function System.currentTimeMillis();.For calculating execution time we have used the function as shown  in Fig. 2.

Figure 2. A Pseudo Code for the calculation of execution time at specific node

III. EXPERIMENTS AND RESULTS  We have developed simulated grid examples to evaluate the  distributed association rule-mining algorithm for grid  environment. In our experimental testing we use 5  homogeneous machines, 3 heterogeneous machines and 3  tasks. The initial parameters are taken randomly. We observe  that by using the grid environment, we are reducing the  execution time of the task and finally user can select the best  association rule-mining algorithm for the given data set. The  output of a sample run is shown below in Fig. 3 and Fig. 4.

A. Without Grid environment  The dataset under consideration is mushroom, letRecog, and  adult. The support is constant with varying confidence factors  and vice-versa, finally output are observed for both apriori and  FP growth algorithms (in both Linux and windows  environment). Clearly, FP growth algorithm works faster  when compared with apriori algorithm for mushroom dataset  (in both linux and windows environment). With letRecog  dataset FP growth performance in linux environment is slower  than windows environment. With adult dataset, FP growth  algorithm works slower when compared with apriori algorithm  to only some extent of variation in confidence factors,  thereafter FP growth works faster than apriori in both linux  and windows environments. Interesting observation with  mushroom and letRecog dataset is performance of the both  algorithms in linux environment is considerably slower when  compared with windows environment. Another interesting  observation with adult dataset is performance of the both  algorithms in linux environment is considerably faster when  compared with windows environment.

(a)     (b)     (c)  Machine type index  CPU Main memory  Vendor Operating System  1 INTEL  P4,3.06GHZ    512 MB  DESKTOP  HEWLETT  PACKARD   XP 32 bit  OS    2 AMD Athlon  64 X2 Dual Core Processor  TK-55, 1.80  GHZ  2 GB    Laptop  Toshiba   Vista 32 Bit  OS   3 INTEL P4,3.06GHZ    512 MB HCL XP 32 bit OS and  Linux  long start = System.currentTimeMillis();  {  -----------------------------------------  -----------------------------------------  -----------------------------------------  }  long stop = System.currentTimeMillis ();  System.out.println (? Total Execution time is " + (stop-start)  + "ms");  2009 IEEE Asia-Pacific Services Computing Conference (IEEE APSCC) 165     (d)     (e)     (f)   Figure 3. Observed serial execution time for Apriori and FP-growth algorithms without grid environment in windows and linux system for  mushroom, letRecog and adult dataset with various support and confidence  majors [a to f].

B.  With Grid environment  The datasets under consideration are mushroom, adult, and  letRecog. The confidence is constant with varying support  factors and vice-versa, finally outputs are observed for both  apriori and FP-growth algorithm execution time of serial and  parallel execution in grid environment. Here, parallel  execution time is less when compared with simultaneous  processing. Simultaneous execution time graph and parallel  execution time graph isn?t monotonous and the probable  reason for this is different classes in different datasets.

(p)     (q)     (r)     (s)  Figure 4. Observed parallel execution time for Apriori and FP-growth algorithms with grid environment in windows and linux system for  mushroom, letRecog and adult dataset with various support and confidence  majors [p to s]  C. Other Observations:  ? FP-growth algorithm performance is better than  apriori algorithm in general. However there are  certain rare cases where there is a contradiction,  that too in some non-specific variations of either  support or confidence factors.

? The number of classes present in a dataset may  affect the performance as the number of rules that  are generated increases considerably. Also FP-  growth performance degrades as per the number of  classes present in a dataset.

? When a dataset is split and sent to different remote  nodes, we cannot expect better results as due to  presence of same combinations of items or  itemsets in all the splitted parts of the dataset,  same rules may be generated in two or more nodes  thereby creating redundancy. This may also put  down the performance of the algorithm(s).

? We cannot compare the performance of two  different datasets based on their size because they  may differ in several factors like number of fields,  number of classes, frequency of items etc.

166 2009 IEEE Asia-Pacific Services Computing Conference (IEEE APSCC)

IV. CONCLUSION AND FUTURE SCOPE  In order to test our experiment grid, we chose an association rule data-mining task. In particular, the extraction, in a reasonable execution time, of all the frequent itemset from a huge database like mushroom, letRecog, and adult, with  varying minimum support. A Grid allows its constituent resources to be used in a coordinated fashion to deliver various qualities of service, relating for example throughput, and co- allocation of multiple resource types to meet complex user demands, so that the utility of the combined system is significantly greater than that of the sum of its parts. Due to the features of grid computing, which require to effectively distributing the datasets to the grid nodes, we tested extraction of association rules with both apriori and FP-growth algorithms. The simulated tests of our grid machine, for which we have used parameters obtained from real runs of our data mining application, are very promising.

Many directions for future enhancements are open. Among them, we can mention:  1) the adoption of more advanced techniques/tools such as globus toolkit and condor to distribute and split the data across the grid nodes so that rules of different datasets are generated in main coordinator node, when we execute the datasets in parallel.

2) the testing of the proposed work on a real distributed platform.

3) the use of the grid computing paradigm to solve even more challenging data mining problems and  4) this work primarily used the execution time as the resource capability but future research will be done using many factors like space, memory and so on.

5) the security issue among different local datasets and the huge communication cost in data migration can be considered and  6) to achieve the more promising potentials of computational grids, an effective and efficient scheduling framework within grids can be used.

