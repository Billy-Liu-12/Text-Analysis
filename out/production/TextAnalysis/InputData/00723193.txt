A Visual Representation Model for Software Subsystem Decomposition

Abstract  Decomposing a software system into subsystems is an important activity in the reverse engineering and maintenance domains. One approach to subsystem decomposi t ion is  based on data mining techniques.  The ISA (Identtjkation  of Subsystems based on Associations) methodology decomposes a software system i n t o subsystems by mining association rules from a database representation of the target system. This paper defines a visual representation model (RM)  to graphically present the information produced by ISA. RM provides a graphical view of the recovered subsystem decomposition, the subsystems components, and the relationships among the subsystems. RM includes notation to represent hierarchies of file  implications and hierarchies of subsystems.  Resul ts  o f  applying RA4  to represent  the subsystem decomposition of a COBOL system are discussed.

1. Introduction  A key component of reverse engineering is design recovery. Design recovery techniques aim to produce significant high level abstractions Tom  the subject system [ 11. To accomplish this objective, design recovery makes use of any materials at hand such as source code, domain knowledge, and documentation. Likewise, the outcome of a design recovery process might take different forms such as formal specifications, module breakdown, data abstractions, and dataflows [2].

One objective for design recovery is subsystem identification which is decomposing a software system into relatively independent subsystems. Subsystem identification facilitates the analysis of the software system in several ways. It can be used to understand the general architecture of the system, to identify application  domain concepts, to split the analysis effort in teams, to evaluate maintenance activities, and to perform side- effect analysis.

We are using data mining techniques to identify subsystems from systems written in imperative languages such as COBOL. This research is part of a broader project that explores the use of data mining techniques to recover the design of software  systems [3].

We are particularly interested in data mining because it can discover unsuspected non-trivial relationships among elements in a database. Moreover, data mining can unveil relevant information regardless of the lack of a priori knowledge of the object of study. Finally, data mining is designed to work with a large amount of information.

These data mining features suggest that it can be used to elicit new knowledge about an undocumented software system. The larger the system the better the possibility that data mining can produce interesting patterns.

Therefore, data mining is an appealing approach to analyze large undocumented legacy systems.

Specifically, we have developed the ISA methodology [4] to identity  data cohesive subsystems based on mined association rules. ISA produces a grouping table that contains groups of programs (i.e. subsystems). The grouping table contains diverse information about the subsystems and their interrelationships. However, this information cannot be identified easily from the grouping table because it lacks the expressiveness of other types of models such as graphical models.

In this paper we present a model, called me Representation Model (I~), that depicts graphically the information produced by ISA. RM facilitates the visualization of the identified subsystems, the subsystem components, the interrelationships among subsystem components, and the relationships among subsystems.

Moreover, RM uses layers of diagrams to represent the system at different abstract levels.

We have experimented with this approach to subsystem identification. We have been able to  O-8186-8967-6/98 $10.00 0 1998 IEEE    decompose COBOL systems into hierarchies of subsystems and to represent these results using RM. RM offers an easy-to-follow representation of the identified subsystems and their components. In addition, RM diagrams facilitate the detection of highly used files, subsystem interrelationships, and file relationships.

This paper is organized as follows. Section 2 gives a general description of the ISA methodology. Section 3 describes the RM. Section 4 describes the use of RM to graphically represent the identified subsystems of an actual system. Section 5 contains a review of related work. Finally, section 6 contains the conclusions.

2. The ISA methodology  In this section, we provide an overview of the ISA methodology to show the nature of the information it produces. A more detailed description of ISA can be found in [4].

Let s be a software system composed of a set of programs P and a set of data tiles 7. A typical example of such a system is a human resources system written in COBOL. This system would likely be composed of several subsystems such as payroll, training, recruiting, and benefits. Each subsystem would include several programs and several files. For instance, the payroll subsystem may include programs to print the payroll, to print checks, to perform the calculations, and to report tax withheld. In addition, it would contain the roster file, the salaries file, and the scheduling file. The system may also include files that are used by several subsystems such as the master employee tile and the organizational units file.

For simplicity, this definition of a system does not include script files and JCL (Job Control Language) scripts.

The ISA methodology takes a system S and identifies data cohesive subsystems based on mined association rules. We define a subsystem as a set Z={G,  H> such that G c P and c $7. ISA decomposes S into k subsystems Zi={Gi,  Hi} for i= 1,2,  . . . . k,  where Gi  n Gj = 0, and Hi  n Hj=RIfori,j=1,2  ,..., k,  and i fj.  However, G, u G2 . . . v Gk  may not be equal to P, and HI  v  Hz . . . u Hk may not be equal to 7 because there are some programs that cannot be classified into any subsystem and some files that are used by several subsystem (i.e. the master employee rile in the example above). It is important to notice that this subsystem decomposition does not imply that a program in subsystem Zi cannot use a tile in subsystem Zj.

ISA identifies subsystems in three general steps: 1. Build a database view of the system. A database  view of the system is a representation of the system or a subset of it using a database.

2 . Perform data mining. Use a data mining algorithm to mine association rules over the data base view of the system.

3. Consolidate and interpret results. Combine the outcome of the mining process to produce a subsystem decomposition of the target system.

Sections 2.1 to 2.3 explain the basic ideas behind each of these steps.

2.1. Build a database view of the system  The ISA methodology requires a data cleaning process before constructing the database view of the system. The objective is to generate a ?clean? data set for the mining process by removing noise and outliers. The resulting data set is known as the alpha set. The alpha set is the set A={P,F} suchthatPcP,Fc?,P=  { p  ]U(p,F)>y}, andF={f]QV;P)>l3}wherey,l3areintegersandy> 1, l3  > 1. U(p,  8?)  denotes the number of files f E F that the program p uses and QV; Z?) represents the number of programsp E P that use file$  Thus, the alpha set contains programs that use more than y  files and files that are used by more than p  programs. We say that a programp uses a filefor thatfis used byp ifp reads or writes information 0nJ:  Once the alpha set is built, the database view of the system is defined as the set of tuples  T= tl, t2,  . . . , tpl.  That is, there is a tuple t for each filef E F.  A tuple contains all the programs that use a particular file. Therefore, ti={  p E P 1 p uses A}.

2.2. Perform data mining  Data mining is a part of the process of knowledge discovery in databases. The basic idea behind data mining is to apply appropriate data mining algorithms to discover useful patterns i?-om large volumes of information.

Patterns are expressions that represent facts about the data contained in the database. They take different forms such as classifications, clusters, associations, and sequences 151.

In particular, ISA uses algorithms that search for association rules on the alpha set. Agrawal, Imielinski, and Swami [6] introduced the problem of mining association rules from large databases of transactions. The original idea is to find  associations among the items a customer buys. For example, for a large database of transactions where each transaction contains all the products purchased by a customer in a particular visit, the goal is to produce rules of the form ?90% of the times a customer buys eggs, she also buys bananas and crackers.? Formally, this problem is defined as follows [6]:  Let I={&,  i2, is, . . . , i,} be a set of items. D is a set of     transactions R such that R E I. An association rule is an implication X 3 Y, where Xc 1, Y c 1, and X n Y = 0.

The rule X 3 Y holds in D with confidence c if c%  of transactions in D that contain X also contain Y. It is said that R contains X if X E R. Moreover, if s%  of the transactions in D contain X u Y then the rule X 3 Y has support s.  The problem of finding association rules in a set of transactions consists on finding all the association rules that have s > minsup and c > minconj  Minsup and minconf are user-supplied parameters representing the minimum required support and confidence respectively.

In the ISA notation, P represents the set of items 1, T is the set of transactions D,  and a tuple t  is a transaction R,  Mining the alpha set for association rules produces associations of the form s[pi,  p2, . . . , p,], where pi  E P and s is the support of the association. In other words, s is the number of tuples that contain pl, p2, . . . , p,,.  In this setting, an association means that programs pl, p2, . . . , p,,  use the same s files. The association does not mean that all the programs in the association use just the s tiles; rather, it means that the s files are common among the programs in the association.

2.3. Consolidate and interpret results  The mined associations are the underlying information to identify groups of programs. Therefore, the subsystem identification is based on the use of similar sets of persistent data repositories. In other words, ISA identifies data cohesive subsystems. To this end, a grouping table is built. This grouping table organizes programs and files in rows and columns, respectively. For each program in the alpha set there is a row in the grouping table. Similarly, for each file in the alpha set there is a column in the grouping table. The intersection of a row with a column is marked if the program represented by the row uses the tile represented by the column.

The construction of the grouping table is a bottom-up iterative process. It uses the mined associations among programs to incrementally build groups of programs that use a similar set of files. Then, it merges similar groups until a similarity threshold is reached. Therefore, each group in the grouping table can be broken down into subgroups, the subgroups into sub-subgroups and so on.

The final grouping table contains a grouping of programs and tiles. The programs that use a similar set of files are in adjacent rows and the files that are likely to be used together are in adjacent columns, thereby identifying groups of programs that use a similar set of tiles. This grouping is used to define a hierarchical decomposition of the system into subsystems. Each group of programs along with the tiles used primarily by the programs in each group form a subsystem. In the same way, each  subgroup and its corresponding files form a sub- subsystem.

An example of an actual grouping table is shown in Table 1. It shows seven groups. The ftrst  six groups represent subsystems and the last one contains the programs that were not compatible with any group. The nested nature of the subsystems can be seen in the second subsystem. It can be decomposed in four sub-subsystems, (~3,  ~30,  ~2,  ~161,  Cp5?L  ~11,  (~54,  ~5% ~151,  and Cp6 28, 57).

Additional information can be derived from  this approach to subsystem identification. First, there are programs that cannot be assigned to any major subsystem (e.g., last 3 programs in ?Table 1). We call these programs singular programs. Similarly, there may be singular programs in any lower-level subsystem. That is, programs can belong to an inner-level subsystem but cannot be assigned to any of its child subsystems. This behavior suggests that singular programs may process special conditions such as exceptions or one-time reports.

Second, some of the tiles assigned to a subsystem may be used by programs in other subsystems. We call these files Zink$les.  A link file is assigned to a particular subsystem 2 because most of the programs that use it are in Z.

Nevertheless, this link file is used by programs outside Z.

Link files can be seen as the communication interface among subsystems. Third, there are files that cannot be assigned to any particular subsystem because they are used by programs from different subsystems. We call these files commonfiles.  File 75 in Table 1 is an example of a common file.

Another interesting result of mining associations is the derivation of hierarchies of $le implications. For example, assume that A, B, and C are files and that the mining process produced the following two association rules: B+A  (100%) and C!+B  (100%). The former means that 100% of the programs that use file B also use file A and the latter means that 100% of the programs using tile C also use file B. Clearly, B implies A and C implies B. Thus, C implies A. In other words, if a program uses file C it means that it also uses files B and A.

3. A model for visual representation  The grouping table lacks the required expressiveness to highlight all the information described in section 2.3. In addition, if the target system is large, the resulting grouping table will be large, making it even harder to identify and use the recovered design information.

Other options to represent the information contained in the grouping table include textual listing, tree hierarchies, acyclic graphs, (k, 2)-partite graphs [7],  dendrograms, and          Table 1. Grouping table  higraphs  [8]. However, these representation models have similar problems as the grouping table when they are used to represent large systems. Also, none of them provides ways to represent all the information generated by ISA.

Therefore, we define the graphical model RM that is capable of representing the design information produced by ISA. Our design choices were driven by the objective of producing a model that uses few building blocks and simple semantics to produce simple, yet expressive, diagrams. In addition, RM should represent the hierarchical subsystem decomposition. Finally, abstraction and the capability to represent large systems were also part of our design objectives.

We first define  the basic building blocks of Rh4. A square represents a program and a circle represents a file.

Inside the square and the circle are the program id and the file id, respectively. Then, we define a representation for the basic recovered design information (i.e., subsystems, link files, common files, and singular programs). A rectangle represents a subsystem. The programs and files that belong to a subsystem are drawn inside the rectangle representing it. Each subsystem is labeled Sx, where x is a consecutive integer starting at x = 1. The subsystem label is in a small square attached to any outer side of the rectangle representing the subsystem. Attached to the inner side of the rectangle is a dotted rectangle which contains the link files. Common tiles are drawn outside     the subsystems and singular programs are drawn inside a double-lined rectangle.

Finally, we required a way to express that a program (or a subsystem) uses a file. We call this a file usage relationship. A directed arc from a file to a subsystem or to a program represents a file usage relationship. A solid arc from filef to subsystem 2 means that every program and every sub-subsystem in 2 use f while a dotted arc means that some programs or sub-subsystems in 2 use j The file usage relationships of singular programs are not represented graphically in RM because they introduce a great deal of unnecessary arcs to the diagram. To summarize, this notation is shown in the example in Figure 1.

In addition, we defined the following notation to represent the relationships among the basic building blocks. An hexagon represents a connector. A connector is used to identity  the target of a file usage relationship.

The label inside the connector provides the information of the destination of a file usage relationship. The label has the form <destination subsystem label>/<cardinality> where the cardinality is the number of programs in the destination subsystem that use the file or set of files in the source part of the file usage relationship arc. If no cardinality is given, then all the programs use the file(s).

Figure 3 provides some examples of these connectors. For instance, file 48 in S5 has a connector to S2 indicating  Hierarchy of file -.

implications  File -  Singular .-.

programs  File usage -- relationship  (complete)  W,W,A C,B,D,F,A  4 A  Figure 2. Semantics of the hierarchy of file implications  that 6 programs in S2 use file 48. We defined the connector block to decrease the number of arcs in a diagram and to facilitate the diagram layout.

We use a combination of implicit and explicit relationships to represent a hierarchy of tile implications.

The former uses location to express a relationship while the latter uses an arc. The hierarchy is represented implicitly using nested rounded squares as shown in Figure 1. Files in deeper rounded squares correspond to files in the lower levels of the hierarchy. File usage relationships are represented explicitly using arcs. The starting point of a file usage relationship arc, noted by the  System Level Diagram  ,*-e Subsystem  III1 5 --- File usage .*  I q  relationship 3 (partial)  q6 i  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . r;;lm__- ._.-.*.  I.-~---&;.--;;i,;-mID  --- Link Files  Figure 1. RM notation  2 3 5    dot, determines the files associated to it. For example, in Figure 1 the line that goes fkom the rounded square containing file C to subsystem S2 means that all the programs in S2 use files C, B, and A. Two elements complete the notation: a small square attached to the outer side of the top-level rounded square represents all the tiles in the hierarchy and a small circle connects two or more file usage relationships. Figure 2 shows an example containing all the elements of this notation. The letters at the end of the arcs state the meaning of the corresponding file usage relationship. As Figure 2 shows, all possible file usage relationships from a hierarchy of file implications can be represented by combining implicit and explicit relationships.

We used layered diagrams along with a labeling mechanism to show the hierarchical subsystem structure.

Layered diagrams facilitate the representation of large systems because layering permits representing the system at different abstraction levels. In the first layer, only major elements of the system are portrayed. More details are included in subsequent layers.

RM uses layered diagrams as follows. The tirst  layer contains the main subsystems, the common files among main subsystems, the hierarchies of file implications, and a cluster of singular programs. In the second layer, each main subsystem has a diagram that represents it in detail.

Similarly, each sub-subsystem drawn in a second layer diagram has a third-layer diagram that represent the sub-  6S216  Figure 3. First-layer diagram of the PS system     subsystem in greater detail. This layering continues until a primitive level is reached. The labeling mechanism follows similar rules to the labeling of processes in data flow diagrams. The main subsystems, which are the subsystems in the top layer, are labeled with consecutive numbers starting at 1 and prefixing an S (i.e., Sl,  S2, . . . ).

A low level subsystem 2 is labeled with its parent?s label followed by a period and a consecutive number x = 1, 2, . . . n, where n is the number of sub-subsystems belonging to the parent of 2 (e.g., S1.2. identities the sub-subsystem 2 in subsystem Sl).  Figures 3 and 4 show this layering and labeling in two Rh4 diagrams derived from the grouping table on Table 1. Figure 3 is the top layer diagram representing the entire system, and Figure 4 represents the S2 subsystem.

A diagram in an inner layer representing a subsystem Z includes the ?external? files used by the programs in Z, and the connections to the external programs or  and programs are located outside the subsystem boundaries. External files are drawn over a box that contains the label of the subsystem they belong to. This notation is used to represent external files 65, 66, 4, and 48 in the S2 diagram (Figure 4). The external programs or subsystems are represented with connector blocks and related to the appropriate file with a file usage relationship arc. For example, file 62 in S2.1  is used by 2 programs in subsystem S4. This relationship is represented by a file usage relationship that goes from  file 62 to a connector outside the boundaries of S2 (Figure 4).

In addition, the diagram in Figure 4 exemplifies the incorporation of grater dletail  in lower-level layers. For instance, some of the file usage relationships have been expanded: in the parent diagram (Figure 3) there is just one arc between one of the file implication hierarchies and S2, while in Figure 4 that arc has been replaced by 5 arcs. Some of these arcs go to the edge of S2 and others  subsystems that access files inside Z.  These external files go to S2?s  subsystems.

( 1 5 )  Is)  (S2.4) b . . . . . . . . . . 2..

Is) (28)  Figure 4. RM diagram for the S2 subsystem  2 3 7    When a solid-line arc ends in the edge of a rectangle, all programs inside the rectangle use the file(s) associated to the arc. However, some programs inside the rectangle may not use that particular file(s). To denote this restriction, the label of the program or subsystem not using the file(s) is drawn between parenthesis over the arc, and a triangle is drawn in the edge of the program or subsystem restricting the file usage relationship. For example, the arc that goes from external file 73 to the edge of S2 means that all programs inside S2 use files 73 and 75, except for program 15 (Figure 4). Program 15 in S2.3 includes a triangle to show that it is restricting a file usage relationship. Similarly, a file usage relationship to a subsystem can be restricted. For example, the annotation ?(S2.4)?  over the arc that goes from external file 76 to S2 indicates that the programs in subsystem S2.4 do not use file 76.

Another semantic element shown in Figure 4 is the cardinality of a partial file usage relationship. The cardinality is drawn over the arc that represents the partial file usage relationship. For example, the arc that goes from  external file 82 to S2.1  means that just one program in S2.1 uses files 82 and 39. Another way to represent cardinality is with connectors. For example, the connector that goes from file 6 1 to external subsystem Sl indicates that all the programs in sub-subsystem S 1.1 use file 6 1.

Finally, when RM is used to represent very large systems, we draw sub-subsystems inside the main subsystem rectangles instead of programs. Similarly, we draw clusters of files instead of single files. The tile clusters are represented with circles. The file cluster labeling follows the same rules as the labeling of subsystems, but the prefix letter is an F. For example, F1.2 is tile cluster two in subsystem one. This procedure can be applied to inner layers until the subsystems and file clusters are simple enough to be represented in a single diagram.

4. Case study  We used F&l  to represent graphically the subsystems identified from a Point of Sale (PS) system. PS is a COBOL system that consists of 93 programs and 60 files.

We applied ISA to produce a subsystem decomposition of the PS system. First, we detected 73 programs that use at least one file. We assigned a unique consecutive number to each program and to each file. Thus, we had programs 1 to 73, and files 1 to 60. Then we created the alpha set, which contained 60 programs and 36 files, Next, we applied the Apriori algorithm [9] to mine association rules. Finally, we built the grouping table shown in Table 1. The first column in the grouping table contains the program ids and the second column contains the amount  of files a particular program uses (U(p)). Similarly, row one contains the file ids and the second row the number of programs that use a particular tile (Q(f)). The table contains the 46 programs in the alpha set that use more than three files. They are grouped in 6 groups. The last group in the table contains three programs that were not assigned to any group. Programs that use three or less files did not match any group either. Thus, there are 17 singular programs. Last, we constructed the RM diagrams for the PS system.

Figure 3 is the first layer of the RM diagram for the PS system. It shows the six subsystems labeled Sl to S6, the two hierarchies of file implications, and the cluster of singular programs. File 78 is not included in any hierarchy but it is considered a common file thereby drawn outside the subsystems. Figure 4 shows one of the second-layer diagrams representing subsystem S2. It includes 4 sub-subsystems, 3 common files, and several examples of tile usage relationships, file usage restrictions, and relationships with external tiles and programs.

These examples provide evidence that RM meets the original design objectives. First, FM  is capable of representing the recovered design information that ISA produces. Second, RM uses few building blocks and can represent large systems at different abstraction levels.

Third, F&I facilitates the visualization of the hierarchical subsystem decomposition.

In the top layer, RM diagrams provide a general map of the organization of the system by highlighting major subsystems, common files across main subsystems, and the set of singular files. At the subsystem level, FM diagrams facilitate the visualization of the main subsystem components, the critical files within the subsystem, and the relationships with other subsystems.

Finally, the cardinality of the tile usage relationships can be helpful to determine the importance of the relationships among subsystems.

As with other diagramming models, layout is an issue for RM. From a positive perspective, inside the rectangles (sub-subsystems) there is only a list of programs and files.

In other words, the internal structure of the rectangles in a diagram is irrelevant. The structure is defined in the next layer; thus, the only concern when drawing rectangles is to make them large enough to enclose the corresponding files and programs. Consequently, the layout problem is centered on the distribution of the rectangles and the hierarchies of file implications. This task is simplified by using connectors for file usage relationships between distant entities. From a negative perspective, there is the problem of deciding which file usage relationships are worth representing with an arc instead of with a connector. The driving decision factors are the     representation of important relationships, the aesthetics of the diagram and the elimination of overlapping arcs.

Another situation is that the external riles and programs may cause layout problems if many of them go to a single entity. Too many external entities require many tile usage relationship arcs which leads to overcrowded diagrams.

In addition to the layout problem, we identified the following limitations of RhJ.  For clarity reasons, we do not include tile usage relationships that have low cardinality in the top layers of the diagram. This type of file usage relationships introduces several arcs and connectors that are not relevant for the level of abstraction presented in the top layers. Nevertheless, these file usage relationships are included in lower-level layers. The problem is determining the cardinality and the file usage relationships that are ?irrelevant? in each layer.

There is also an ambiguity problem when using file usage relationships restrictions. For example, sub- subsystem S2.4 in Figure 4 has a file usage relationship restriction. That is, programs in S2.4 do not use file 76.

Since file 76 implies file 75, this file usage restriction indicates that programs in S2.4 do not use file 75 either.

However, there is a tile usage relationship that goes from file 63 to S2 indicating that all subsystems inside S2 use files 63 and 75. In short, the file usage restriction indicates that file 75 is not used in S2.4 but the file usage relationship indicates otherwise. According to the grouping table in Table 1 the programs in S2.4 do use file 75. This problem can be solved by adopting the convention that the file restrictions are applied first and then the file usage relationships. However, the current notation still may produce some ambiguity.

A low level diagram representing subsystem Z may contain many external tiles and many external programs using files in Z.  Some of these external entities may be part of subsystems belonging to the same main subsystem as Z (a main subsystem is a subsystem in the top layer).

This differentiation between external entities that belong to the same or to a different main subsystem is important because the former represent interfaces within the same main subsystem while the latter represent interfaces with other main subsystems. Although external files and programs belonging to the same main subsystem can be identified in a RM diagram using the entities? labels, FCM does not provide a way to highlight this information.

5. Related work  Lakbotia [lo] considers that the problem of subsystem classification is essentially a graph partitioning problem.

Thus, we can infer that graphs are a natural way to represent the components of a software system and their interrelationships. For instance, graphs are used to  represent several aspects of recovered software architectures [l 11, and to represent references to global variables [ 121.

Tree-based graphs are widely used to represent software subsystem decompositions because these decompositions can lead to hierarchical relationships among subsystems. For example, a tree is used in [13]  to represent a hierarchy of subsystems and modules. In addition, some variations of trees used to represent hierarchies include dendrograms [14]  to represent layers of partitioned subsystelm  classifications [IO], treemaps [ 151  to visualize hierarchical information structures, and (k,2)-partite  graphs [7] to model multiple hierarchies.

An object model [16]  is another representation of recovered subsystem decomposition. Examples of research in this direction are [ 171,  [ 181,  and [ 191.  Another approach for representing recovered software artifacts uses browsers that combine text and graphs [20].

FM  benefited from  several of these representation models. In addition, RIM uses the underlying ideas of Venn Diagrams to represent subsystem membership. The use of layered diagrams to represent large systems, the notation for labeling each layer, and the use of abstraction levels are similar to the notation used for data flow diagrams. The representation of hierarchies of file implications resembles higraphs [8]. Higraphs  use rounded squares, called blobs, as the basic building block and FCM  uses rounded squares to represent subsets.

Nested rounded squares represent set membership in both notations. In RM terms, set membership is used to represents levels in the hierarchy of file implications. In addition, higraphs  use arcs to denote relationships among blobs and RM uses arcs to represent file usage relationships.

6. Conclusions  We have presented a representation model (FCM)  to display graphically the results of the ISA methodology.

ISA identifies data cohesive subsystems by mining association rules from a database view of the target system. The mined associations rules among the programs and files of the system allow the construction of hierarchies of file implications and groups of programs or subsystems. A bottom-up approach constructs larger subsystems of programs and files. RM exploits this characteristic by representing the identified subsystems as layered diagrams, The first layer gives the overall organization of the system, including the main system components and their relationships. Subsequent layers introduce more detail. Therefore, RM can be used at several levels of a reverse engineering analysis or a maintenance effort. For example, the top-layer diagram     provides a general view of the system that can be used by a project leader to form teams and to assign subsystems to each team. Similarly, each team leader can use lower layers of the diagrams to plan the analysis strategy, to detect important relationships with other teams, and to assign resources to the  analysis of each program. Finally, programmers can use the Rh4 diagrams to get the overall view of the system, to detect possible side effects, and to identify similar programs.

One advantage of RM is its simplicity. It uses few building blocks and simple semantics. Despite this simplicity, RM is capable of representing file implication hierarchies, which increases the expressiveness of the diagrams. Therefore, RM can also be used to analyze and document transactional software  systems that use large quantities of flat files or a relational database.

RM  diagrams can be drawn with CASE tools that support diagramming. Nevertheless, future work includes developing an automated RM tool. Most of the limitations mentioned in section 4 need to be addressed in the construction of the tool. We consider that the layout and the representation of file usage relationships in each layer are the main problems associated with developing an automated RM  tool. One intermediate option is to develop a semi-automated tool. This tool would suggest an initial layout for the subsystems and the file hierarchies, then automatically add file usage relationships, one at the time.

The user would monitor the process and take corrective actions to ensure simplicity of the diagrams. For example, the user could either move rectangles along with their file usage relationships to avoid overlapping arcs or decide to defer the representation of certain file usage relationships to lower-level diagrams.

