Analyzing Malware by Abstracting the Frequent Itemsets in API call Sequences

Abstract?Analyzing the usage of Windows Application Program Interface (API) is a common way to understand behaviors of Malicious Software (malware) in either static analysis or dynamic analysis methods. In this work, we focus on the usage of frequent messages in API call sequences, and we hypothesize that frequent itemsets composed of API names and/or API arguments could be valuable in the identification of the behavior of malware. For verification, we introduced clustering processes of malware binaries based on their frequent itemsets of API call sequences, and we evaluated the performance of malware clustering. Specific implementation processes for malware clustering, including API calls abstraction, frequent itemsets mining and similarity calculation, are illustrated. The experiment upon a big malware dataset demonstrated that merely using the frequent messages of API call sequences can achieve a high precision for malware clustering while significantly reducing the computation time. This also proves the importance of frequent itemsets in API call sequences for identifying the behavior of malware.

Keywords-malware; frequent-itemsets; API call sequences; clustering; Sandbox

I.  INTRODUCTION Malicious software, or malware for short, ranging from  classic computer viruses to Internet worms, bots and Trojan horses, have brought countless hazards to nowadays Internet, especially to the most prevalent desktop operating system ? Microsoft Windows. Various methods have been proposed for malware analysis. One of the most common methods is to analyze the behavior of malware by abstracting the API calls. This is because most applications running in user mode need to call Windows API functions for requesting services from the kernel in Windows.

Therefore, the sequence of API calls is capable to represent the main behavior of a run-time application in such period.

Moreover, we can further analyze the function parameters and track the information flows from the API call sequences [1].

As early as 1998, Hofmeyr et al.[2] studied the intrusion detection in UNIX systems using sequences of system calls.

Similarly, Shankarapani et al.[3] proposed two frameworks, called SAVE (Static Analyzer for Vicious Executables) and MEDic (Malware Examiner using Disassembled Code), to detect malicious codes using the API call sequences or static API call set. However, the methods mentioned above  those abstract API calls of malware by static codes disassemblers, like Win32Dasm, OllyDbg, et al., are challenged by the continuously updated obfuscation and packing techniques, which makes it difficult for the static methods to get correct API calls. Therefore, novel methods to dynamically abstract API calls have been proposed recently [4-9]. In contrast to static techniques, dynamic analysis methods monitor the behavior of malware during run-time, which is often indicative for malicious activity and hard to conceal.

Although abstracting the API calls during run-time provides means for studying the behavior of malware, it is not sufficient to detect malware. The ability to analyze the API calls automatically and deeply is also required. To the best of our knowledge, two teams have made good progress in terms of analysis for the sequences of API calls. The first framework is proposed by Rieck et al. [5], which embeds the API call sequences to high-dimensional vector spaces, and allows for malware clustering and classification with high precision. The second one is introduced by Ahmed et al. [8], which is able to detect malware using statistical features that are extracted from both spatial (arguments) and temporal (sequences) information from API calls. Both frameworks use full sequences of API calls as input parameters for similarity calculation (the similarity between one binary to another binary or one binary to a model).

However, not all information from API calls is valuable for calculating the similarity between different malicious binaries. On the contrary, in many cases, redundant messages can reduce the similarity even two binaries originally belonging to the same category. Moreover, calculating upon whole sequences is time-consuming, especially when dealing with a large number of malware binaries.

We consider that the frequent messages of API call sequences, like frequent arguments or frequent itemsets composed of API names and API arguments, play an important role in reflecting the behavior of malware. In this paper, we ran clustering processes of malware binaries based on their frequent itemsets of API call sequences, and we evaluated the performance of malware clustering. We then explained the specific processes of this work with a formal description of the frequent API itemsets mining method. At last, we utilized a big malware dataset including 3131 malware binaries for executing clustering based on the frequent messages of API call sequences, the results of   DOI 10.1109/TrustCom.2013.36     Dynamic analysis (Sandbox)  API call sequences  Clustering  Malware binaries  Sequences of frequent itemsets  Frequent pattern mining algorithms  Comparing signature sequences  Frequent Itemsets Mining AnalysisAPI calls Abstaction   Figure 1. Framework of our malware analysis method  experiments demonstrated that an appropriately selected value of frequency can retain a satisfying clustering performance while significantly reducing the computation time. This proves our hypothesis that the frequent messages of API calls are valuable in representing the important behaviors of malware.

The remaining of the paper is organized as follows. In section II, the motivation of our idea is introduced. In section III, the framework of our analysis method and detailed description are illustrated. In section IV, we compare the result of our framework to the current state-of-art methods using public datasets. We conclude our study in section V.



II.  MOTIVATION Frequent pattern mining has been a hot theme in data  mining research for a long time [10]. Frequent patterns are itemsets or subsequences that appear in a data set or a time series with frequency no less than a user-defined threshold.

It was first proposed to find the associate items in supermarkets [11]. For example, a set of items, such as apple and banana that appear frequently together in a transaction data set, is a frequent itemset. Finding frequent patterns is very useful for mining associations, correlations and features among data.

In our research of analyzing the behavior of malware, the sequences of API calls can be considered as a transaction data set, in which each API call and its parameters (input and output) form a set of items. So a frequent itemset in an API call sequence can represent a pattern of behavior, thus an API call sequence will be featured by multiple frequent itemsets. Since malware binaries with similar behavior can be considered as belonging to the same class, so we expect that the similarity between whole API call sequences can be replaced by the similarity between sequences consisting of ordered frequent itemsets. This will be verified by our following analysis and experiments.



III. ANALSYIS FRAMEWORK Our malware analysis framework consists of three  modules: API calls Abstraction, Frequent Itemsets Mining, and Analysis. The relationship among these modules is demonstrated in Figure 1. The workflow is summarized as below.

? In the first step, we use dynamic analysis tools, like sandbox, to monitor and capture the behavior reports of malware binaries, and then abstract the information of API calls from the behavior reports including the sequences of API calls and each API call?s input parameters, and return value.

? In the second step, we use frequent pattern mining algorithms to find the frequent API calls or frequent itemsets including API call?s name and parameters, and then use the frequent itemsets to build the sequence of features for next analysis.

? In the last step, we give a distance function to calculate the similarity between different malware binaries. Based on the Distance Metrics, malware clustering is executing.

A. Abstracting API calls We use dynamic analysis method to abstract API calls  from malware binaries. The tools we used include a commercial sandbox, called CWSandbox 1  and an open-source sandbox, called Cuckoo Sandbox 2 . Both sandboxes execute malware samples in a simulated environment, monitor system calls and automatically generate detailed behavior reports. What we need here is to abstract the information related to API calls (or system calls). Note that the two sandboxes produce different output formats for behavior reports.

However, we can use a unified representation to  0202 | 00006b2c 047c8042 00011000 0202 | 00006b2c 047c8042 00108000 0202 | 00006b2c 047c8042 00091000 0c01 | 00000064 0c01 | 00001770 0a06 | 0ffb568e 00000000 0000066a 0a05 | 0fd6c4b4 0d01 | 0307 | 000004 004000 01 00000000 0da3b4d3 0307 | 000004 004000 01 00006b2c 047c8042 0306 | 000004 004000 01 00006b2c 047c8042  Figure 2. A snippet of the API call sequence in MIST format   1 https://mwanalysis.org/ 2 http://www.cuckoosandbox.org/     represent the sequences of API calls. One method is to use the MIST representation [12] which was proposed by Trinius et al., or to use the BBIS representation which was proposed by our team [9]. Figure 2 gives an example about the MIST representation of a snippet of API call sequence.

In MIST, each instruction in one line encodes one monitored system call and its arguments using short numeric identifiers, such as ?0202? for the API call ?LoadLibraryA?. The API call arguments are arranged in different levels of blocks, reflecting behavior with different degree of granularity. In our malware analysis framework, we can choose the level of API calls based on actual demand.

Moreover, in the process of extraction of API calls, there are two points to note. First, there are three principles to follow when abstracting the API calls from the output reports from sandboxes: (1) API calls within the same process need to be ordered by timestamp, with the earlier one coming first; (2) API call lists from different processes will be connected from head to tail in the whole sequences; (3) Different lists of multi-processes will be ordered by the first timestamp of each API call list, with the earlier one coming first. Second, we cannot change the monitored objects in CWSandbox; however, we can add or delete the monitored API functions for improved performance in Cuckoo Sandbox. We have described the specific implementation in our former contribution in detail [9].

B. Frequent itemsets mining Once we get a sequence of API calls for a malware  sample, we need to find out the frequent itemsets in the sequence to build the features list. In this subsection, we first present formal definitions of API calls and the problem about frequent itemsets mining, and then we introduce the common algorithms for frequent itemsets mining.

1) Formal definitions Based on common concepts about mining frequent  pattern in transaction database, here we define the thi  API call with its parameters in the sequence as a transaction  iT :  ( ,1) ( ,2) , ( )( , , , , , )i i i i i i iT A P P P R?? ?   (1)  where iA  is the string name of current API function, iR is the return value, ( , ) ( [1, ( )])i kP k i?? is the thk  number of arguments and ( )i? is the number of arguments. Then the sequence will correspond to a transaction database  1 2{ , , , }nD T T T? , where n  is the length of a sequence of API calls. Define 1 2{ , , , }nI I I I?  is the set of all possible items including API functions names, arguments, return values, thus iT I? . Moreover, for any X I? , we call X  an itemset. Specifically, X  is a k-itemset when the number of items in X  is k .

Based on above conceptions, we give the definition of frequent itemsets of a sequence of API calls.

Definition: For any itemset X I? and X ?? ,   ,Sup X D is the support of X , ,Conf X D is the confidence of X  as defined in Equation (2) and Equation (3):      , , n  i i  Sup X D Match X T ?  ??   (2)  In Equation 2, 1,  ( , ) 0,  i i  i  X T Match X T  X T ??  ?  ??      ,  , Sup X D  Conf X D n  ?   (3)  where , iMatch X T is a Boolean function representing whether X  is included in iT  or not. Suppose the minimum support as min_support and the minimum confidence as min_conf, if , _Sup X D min support? and simultaneously , _Conf X D min conf? , we consider X  as a frequent itemset of database D.

For example, suppose we have an API call sequence as listed in Figure 2 and we suppose an itemset X  that  ? ?"0202","00006b2c", "047c80 42"X ? , then we get:   , 3Sup X D ? , 3, 27.2%  Conf X D ? ? .

If we define _   2min support ? , _ 20%min conf ? , then based on our above definition, X  will be a frequent itemset of the current API call sequence.

Note that above definition of frequent itemsets in transaction database is not exactly the same as the original definition in [11], our definition is set based on actual needs for malware analysis.

2) Frequent mining algorithms Since there are usually a large number of distinct single  items in an API call sequence, and their combinations may form a very huge number of itemsets, it is challenging to develop scalable methods for mining frequent itemsets in a sequence with larger size. Three efficient methods for mining frequent itemsets methodologies have been proposed : Apriori, FP-growth and Eclat [10]. In which Apriori algorithm proposed by Agrawal et al. [13] is the most prevalent one, which states that: A k-itemset is frequent only if all of its sub-itemsets are frequent. This implies that the frequent itemsets can be mined by first scanning the database to find the frequent 1-itemsets, then using the frequent 1-itemsets to generate candidate frequent 2-itemsets, and check against the database to obtain the frequent 2-itemsets. This process iterates until no more frequent k-itemsets can be generated for some k. By pruning useless combinations with the minimum support and confidence, the frequent itemsets can be efficiently extracted.

In this paper, we use an open-source implementation of     Apriori Program3 to accomplish our goals for frequent itemsets mining.

3) Post processing about frequent itemsets mining We extract frequent itemsets in the API call sequences  instead of the whole sequences for next step about malware analysis. Therefore, after the mining process, we need to connect the frequent itemsets to a new sequence. In this paper, we simply sort the frequent itemsets by their confidence. Moreover, we can control the scale of frequent itemsets by adjusting the value of _min support  and min_conf. In the following analysis process, we consider this sequence with ordered frequent itemsets as the signature sequence for every malware sample.

C. Malware analysis 1) Comparing signature sequences  For malware analysis techniques like clustering and classification, the most basic thing is to quantify the distance or similarity between malware binaries. Rieck et al.

[14] have proposed a method for measure similarity for sequential data in linear-time. In this method, the signature sequence needs to be embedded in a high-dimensional vector space, where each dimension is associated with a behavioral pattern. A methodology named n-grams is adopted. For example, if a sequence     S a b c d e?? ? , and if we consider 2-gram as a feature, we get the feature sequence as ,  ,  ,  ab bc cd de? ? . This up-scaling also increases the dimensionality of the distribution from k  to  nk . The method in [14] does not limit the distance calculation mode. Here in our framework, we measure the relation between embedded signature sequences based on geometric distance, which was deeply described in [14] as shown below.

If two vectors ( )x? and ( )y?  that correspond to malware feature sequences x, y with definitions:  1 2 3( ) ( , , , , )nx x x x x? ?   (4)  1 2 3( ) ( , , , , )ny y y y y? ?   (5)  The distance dg between x and y should be:       2, ( )s s s S  dg x y x y x y? ? ? ? ?  ? ? ? ??   (6)  Due to the normalization method, the value of  ,dg x y ranges from 0 for same behavior to 2  for the  maximum deviation. The usage of normalization can help us to evaluate the similarity of malware binaries in a unified mode.

2) Clustering analysis Clustering is considered as a basic technique of machine  learning which aims at dividing a given data set into meaningful groups, named clusters. In malware analysis  3 http://www.borgelt.net/  area, clustering enables discovery of novel malware classes.

Since we can sort the pairs of malware binaries by distance, we can use the standard single-linkage hierarchical clustering method mentioned in [15]. However, the hierarchical clustering has a complexity of 2O( )n  which is large when n is big number. For reducing the computation cost, Rieck et al. have proposed a new clustering method, which use a new conception, so called prototype that can accelerate clustering procedure. In this paper, since our focus is to evaluate the importance of frequent messages in API call sequences by clustering, we just need to maintain the consistency of clustering processes for different experiments. Here we directly utilize the algorithms that have been proposed by Rieck et al. in [5].



IV. EVALUATION  A. Datasets In order to evaluate our proposed malware analysis  framework, we consider a total number of 3131 malware binaries4. The malware binaries have been collected over a period of three years via various sources, including honeynets, spamtraps, anti-malware vendors and security researchers. Those binaries have also been assigned a known class of malware by the majority of six independent anti-virus products. The data set contains 24 malware classes, as listed in Table 1. The labeled classes of malware binaries can be utilized to examine our clustering results later.

In our experiments, we use two sandboxes CWSandbox and Cuckoo Sandbox to analyze the above malware binaries respectively.

B. Experiment results  To assess the performance of clustering, we employ the evaluation metrics of precision and recall [5, 6]. Precision P reflects how well individual clusters agree with malware classes and the recall R measures to what extent classes are  TABLE I  THE CLASSES OF MALWARE BINARIES  Malware Class # Malware Class #  a ADULTBROWSER 262 m PORNDIALER 97  b ALLAPLE 300 n RBOT 101  c BANCOS 48 o ROTATOR 300  d CASINO 140 p SALITY 84  e DORFDO 65 q SPYGAMES 139  f EJIK 168 r SWIZZOR 78  g FLYSTUDIO 33 s VAPSUP 45  h LDPINCH 43 t VIKINGDLL 158  i LOOPER 209 u VIKINGDZ 68  j MAGICCASINO 174 v VIRUT 202  k PODNUHA 300 w WOIKOINER 50  l POSION 26 x ZHELATIN 41   4 http://pi1.informatick.unimannheim.de/Malheur/.

0 0.2 0.4 0.6 0.8 1 1.2 1.4  0.1  0.2  0.3  0.4  0.5  0.6  0.7  0.8  0.9   Minimun distance between clusters  F- m  ea su  re  (a) Clustering Results      F:94.7%  F:95.0%  F:90.9%  F:94.7%  F:95.0%  F:90.9%  0 0.2 0.4 0.6 0.8 1 1.2 1.4        Minimun distance between clusters  Ti m  e( s)  (b) Computation Time elapsed      Our Framework  Malheur  CBM  Our Framework  Malheur CBM   Figure 3. Comparison of three frameworks  scattered across clusters. Formally, we define precision and recall for a set of clusters C and a set of malware classes Y as:  1 1# # c C y Y  P c R y n n? ?  ? ?? ?   (7)  where #c is the largest number of sequences in cluster c sharing the same class and #y is the largest number of sequences labeled y within one cluster. Consequently, the goal is to seek an analysis setup which maximizes precision and recall. An aggregated performance score is adopted for our evaluation, denoted as F-measure, which combines precision and recall as seen in Eq (8). A perfect discovery of classes yields 1F ? , while either a low precision or recall results a lower value of F-measure.

2P RF P R ?  ? ?  (8)  As seen in Figure 3, we compare the F-measure and computation time of three frameworks: our framework (which uses the analysis results from CWSandbox), Malheur [5] (which uses the analysis results from CWSandbox) and CBM [9] (which uses the analysis results from Cuckoo Sandbox). From Figure 3(a) we can see our method has achieved the best performance in most of tests with different values of minimum distance between clusters.

We also notice that the peak value of F-measure of our framework (94.7%) is better than CBM (90.9%) but a little lower then Malheur (95.0%), However, the gap is very small (0.5%) and acceptable.

Moreover, from Figure 3(b) we can see that, compared with Malheur and CBM, the average computation time of our framework is greatly reduced to be lower than 2s per clustering process.

Based on the clustering performance of our malware analysis framework, such as F-value and computation time, we see that using only the frequent messages of API call sequences, such as the frequent itemsets of API calls and  API arguments, is sufficient for malware clustering analysis with satisfying performance, compared it to the usage of whole messages of API call sequences in [5] and [9]. As a result, the experiments above have verified our idea about the importance of frequent itemsets of API call sequences.



V.   CONCLUSIONS AND FUTURE DIRECTIONS In this paper, we proposed a new malware analysis  method by abstracting the frequent itemsets of API call sequences. To evaluate the practicability of our proposed method, we execute clustering processes upon a big malware dataset. The clustering experiment shows that this method can significantly reduce the computation time while keeping a high performance for malware clustering.

In the future, we are planning to further study the frequent messages of API call sequences from a different perspective, both in single malware behavior report for representing the important behavior, as demonstrated in this paper, and also to abstract the frequent messages existing in multi-malware which are classified into a same class. By this way, we expect to use the frequent messages between multi-malware in the same class to automatically generate detection features for malware detection.

