1520-9210 (c) 2016 IEEE. Personal use is permitted, but republication/redistribution requires IEEE permission. See http://www.ieee.org/publications_standards/publications/rights/index.html for more information.

Abstract?This paper proposes a new hashing framework to conduct similarity search via the following steps: 1) employing linear clustering methods to obtain a set of representative data points and a set of landmarks, of the big data set; 2) using the landmarks to generate a probability representation for each data point. The proposed probability representation method is further proved to preserve the neighborhood of each data point; and 3) integrating PCA with manifold learning to lean the hash functions using the probability representations of all representative data points. As a consequence, the proposed hashing method achieves efficient similarity search (with linear time complexity), and effective hashing performance and high generalization ability (simul- taneously preserving two kinds of complementary similarity structures, i.e., local structures via manifold learning and global structures via PCA). Experimental results on four public data sets clearly demonstrate the advantages of our proposed method in terms of similarity search, compared to the state-of-the-art hashing methods.

Index Terms?Hashing, image retrieval, spectral clustering, manifold learning, similarity search.



I. INTRODUCTION  S IMILARITY search is defined as quickly finding out the mostsimilar data points from the big data set for a given query [1], [2], [3], [4], [5]. Recent similarity search techniques include index techniques (such as kd-tree, B-tree, R-tree, M-tree, cover tree, metric tree, and QUC-tree) and hashing methods (such as data-dependent hashing and data-independent hashing) [6], [7], [8], [9], [10]. Index techniques conduct exact similarity search, but only effective for dealing with the low-dimensional data sets [11], [12], [13]. By contrast, hashing techniques conduct Approximate Nearest Neighbor (ANN) search and have been becoming increasingly popular in real applications, such as multimedia search [14], [15], [16], database management [17], [18], and medical image analysis [19].

Different from exact similarity search, hashing needs less retrieval cost via scanning a subset of the entire data set to effectively conduct ANN search on high-dimensional data sets. The key step of hashing is hash function learning, which converts the high-dimensional con- tinuous data into low-dimensional binary codes while preserving the  This work was supported in part by the China Key Research Program (Grant No: 2016YFB1000905), the China 973 Program (Grant No: 2013CB329404), the China 1000-Plan National Distinguished Professorship, the Nation Nat- ural Science Foundation of China (Grants No: 61573270, 61761130079, 61363009 and 61672177), the Guangxi Natural Science Foundation (Grant No: 2015GXNSFCB139011), the Guangxi High Institutions Program of Introducing 100 High-Level Overseas Talents, the Guangxi Collaborative Innovation Center of Multi-Source Information Integration and Intelligent Processing, the Research Fund of Guangxi Key Lab of MIMS (16-A-01-01 and 16-A-01-02), and the Guangxi Bagui Teams for Innovation and Research.



X. Zhu and S. Zhang are with the Guangxi Key Lab of MIMS and the College of Computer Science and Information Technology at Guangxi Normal University, Guilin, Guangxi, 541004, PR China. E-mail: xfzhu0011@hotmail.com and zhangsc@mailbox.gxnu.edu.cn.



X. Li is with the Center for OPTical IMagery Analysis and Learning (OPTIMAL), State Key Laboratory of Transient Optics and Photonics, Xi?an Institute of Optics and Precision Mechanics, Chinese Academy of Sciences, Xi?an 710119, Shaanxi, P. R. China. Email: xuelong li@opt.ac.cn  Zongben Xu is with the School of Mathematics and Statistics, Xian Jiaotong University, Xian 710049, China. Email: zbxu@mail.xjtu.edu.cn.

Litao Yu is with Queensland Brain Institute (QBI), University of Queens- land, Queensland, QLD 4072, Australia. Email: l.yu4@uq.edu.au.

Can Wang is with School of Information and Communication Technology, Griffith University. Email: canwang613@gmail.com.

*Corresponding author.

similarity information (i.e., similarity structures of the data) among data points [20], [21], [22].

Previous methods of hash function learning include Locality Sen- sitive Hashing (LSH) based hashing methods [23], [24], [25], [26], Principal Components Analysis (PCA) based hashing methods [27], [28], [29], [30], and manifold based hashing methods [31], [30], [32], [33], [34], [35]. LSH based hashing methods randomly select a linear function as the hash function. The process of hash function learning is independent from the data, so LSH based hashing methods are usually called data-independent hashing methods. PCA based hashing methods and manifold based hashing methods, respectively, utilize PCA and manifold techniques, to learn the hash functions. Moreover, PCA based methods and manifold based methods explore the data distribution to separately preserve the global and the local similarity structures of the data, and thus are called data-dependent hashing methods. In brief, LSH based hashing methods achieve fast retrieval speed, but need long bits to represent each data point for achieving reasonable hashing performance. Both PCA and manifold based hashing methods achieve significant hashing performance, but are with inefficient retrieval speed, i.e., at least quadratic time complexity for the training stage.

In this paper, we propose a linear hashing method to overcome the drawbacks of previous hashing methods. Specifically, we first employ linear spectral clustering methods to obtain the representative set and the landmark set of the big data set. We then use the landmark set to obtain the probability representation of the big data set, and also prove that the resulting probability presentation preserves the neighborhood of the data. We further combine PCA with manifold learning in a unified framework to learn hash functions using the representation set. As a result, the use of the representative set and the landmark set achieves a linear hashing, while both the probability representation and the process of hash function learning enable to achieve high generalization ability and effective retrieval results.

Different from previous hashing methods, the proposed method has the following contributions:  ? The proposed method is a data-dependent method, which has been shown to outperform the data-independent hashing methods (such as LSH based hashing methods). Moreover, our method only needs representing the high-dimensional data by short binary codes (such as less than 64 bits in our experiments), while LSH based hashing methods need to represent each data point by long binary codes, such as more than 100-bit binary codes [21].

? Even though the hashing methods (including PCA based meth- ods, manifold based methods, and our proposed method) are data-dependent, our method achieves less computation cost, shorter binary codes and more effective hashing performance, than other data-dependent hashing methods. On one hand, the proposed method learns the hash functions using the landmark set, whose size is much small than the size of the big data set, so our hash function learning process needs less storage and computation costs. On the other hand, our proposed method learns the hash functions via preserving both the local and global similarity structures of the data, and thus enables to output significant hashing performance. By contrast, previous hashing methods only consider each of these two types of    1520-9210 (c) 2016 IEEE. Personal use is permitted, but republication/redistribution requires IEEE permission. See http://www.ieee.org/publications_standards/publications/rights/index.html for more information.

This article has been accepted for publication in a future issue of this journal, but has not been fully edited. Content may change prior to final publication. Citation information: DOI 10.1109/TMM.2017.2703636, IEEE Transactions on Multimedia   similarity structures, even though they have been shown to provide complimentary information to each other.

? Experimental results in public data sets show that our proposed method achieves the best performance in terms of similarity search in large-scale data sets, compared to the state-of-the-art hashing methods. This verifies the theoretical advantages of our proposed method, i.e., concurrently preserving the global (via PCA) and the local(via manifold learning) similarity structures of the data.



II. RELATED WORK  Hashing methods for ANN search usually include two steps, i.e., hash function learning and binarization. Hash function learning usually involves finding a continuous embedding of original data.

Binarization converts the embedding of original data to binary codes by threshold methods. For example, the literatures in [36], [37], [38] simply quantize the low-dimensional embedded data into binary codes by a threshold, such as mean and median. Hierarchical hashing (HH) [39] first divides the real values of each dimension into four regions via three thresholds, and then encodes each dimension with double bits. Double-Bit Quantization (DBQ) [40] learns adaptive thresholds to quantize each projected dimension into double bits.

However, above methods separately learn the hashing functions and the threshold, so that it is difficult for such sequential two-step methods to receive the optimal hashing performance even though each of two steps achieves their individual optimizations [33]. To address this issue, the method in [33] simultaneously learns the hash functions and the threshold to output the optimal results of both hash functions and the threshold.

In the literature, most hashing methods focus on the step of learning hash function. Therefore, in this section, we categorize previous hashing methods into three categories, such as uni-modal hashing, multi-modal hashing, and cross-modal hashing, according to the number of the data sets to learn hash functions [8], [41].

Uni-modal hashing conducts ANN search on a data set and can be categorized into three sub-categories, such as unsupervised hash- ing, supervised hashing and semi-supervised hashing. Unsupervised hashing learns the hash functions without taking prior knowledge (i.e., label information) into account [32], [42], [43], [44]. Supervised hashing learns the hash functions via considering prior knowledge, such as ?similar? and ?dissimilar? pairs of the data [45], [46], [36].

Semi-supervised hashing employs a supervised term to minimize the empirical error on the labeled data and an unsupervised term to maximize desirable properties, such as variance and independence of individual bit in the binary codes [30], [34].

This paper focuses on unsupervised hashing since it is expen- sive to obtain prior knowledge for the construction of hashing in real applications. We further partition current unsupervised hashing methods into two sub-groups, such as data-independent hashing methods (such as LSH based hashing) and data-dependent hashing methods (such as PCA based hashing methods and manifold based hashing methods). Data-independent hashing methods generate hash functions without considering the properties of the data. For example, LSH and its variants [23], [47], [24], [17] learn the hash functions based on random projections. The Kernelized LSH (KLSH) [25] captures the intrinsic relationships among training samples using kernel functions instead of linear inner products. Shift-invariant Kernel LSH (SKLSH) [26] learns the hash functions by mapping the random features into shift-invariant kernels. Data-dependent hashing methods have been becoming increasingly popular in the applications of ANN search since it can generate effective hash functions by exploring the properties of training data. For example, PCA based hashing methods [48], [28] learn the hash functions via preserving  the maximal covariance of original data and have been shown to outperform LSH based hashing methods in [29]. However, PCA based hashing methods assign the same weight to each bit, even though different bits contain different variance. To address this issue, Isotropic hashing (IsoHash) learns the hash functions for producing projected dimensions with isotropic variances (equal variances) [39], while ITerative Quantization (ITQ) [29] designs a non-orthogonal relaxation or sequential projection to alleviate such an unbalanced variance issue. Manifold based hashing methods [44], [35], [49], [31] employ manifold learning techniques to learn hash functions, for preserving the local similarity structures of the data, i.e., similar data points have similar binary codes. The key issues of most manifold based hashing methods are the high time complexity [32] and the out-of-sample problem (i.e., not generating explicit hash functions), such as the methods [44], [50], [32].

Multi-modal hashing is designed to conduct hash function learning for encoding multi-modal data [16], [51]. For example, the method [16] first uses an iterative method to preserve the semantic similarities among training examples, and then keeps the consistency between the hash codes and the corresponding hashing functions designed for multiple modals. Multiple Feature Hashing (MFH) [20] preserves the local structure information of each modal and also globally considers the alignments for all the modals to learn a group of hash functions for real-time large scale near-duplicate web video retrieval. However, multi-modal hashing is constraint to the real applications because it is difficult and impractical to obtain multi-modal queries.

Cross-modal hashing is much more popular because only one view is needed for a query. For example, in real applications, we can use search engines (such as Google, Bing, and Baidu) to conduct cross- modal search, such as searching images via a text query. Besides, the retrieval tasks (such as image-to-image, text-to-image, and image-to- text) can also be conducted by cross-modal hashing. In the literatures, Multi-modal Latent Binary Embedding (MLBE) [52] devises a gen- erative model to conduct hash function learning using only hundreds of data points out of millions data points as training samples, i.e., a small subset of training data. Both Cross-Modal Similarity Sensitive Hashing (CMSSH) [16] and Inter-Media Hashing (IMH) [2] are not used to learn the hash functions from large-scale training data sets yet since they need high time complexity, such as O(n3) where n is the sample size. To reduce the time complexity, Linear Cross-Modal Hashing (LCMH) [13] takes both the intra-similarity in each modal and the inter-similarity across the modals to conduct cross-modal hashing within linear time complexity. Recently, Latent Semantic Sparse Hashing (LSSH) [53] conducts cross-modal similarity search by employing sparse coding and matrix factorization, while Deep Cross-Modal Hashing (DCMH) [54] integrates feature learning with hash function learning in a framework.



III. PRELIMINARY  In this section, we first show the notions used in this paper, and then separately introduce the background of PCA based hashing and manifold based hashing, followed by the motivation of our proposed method.

A. Notations  In this paper, we denote matrices, vectors, and scalars, respectively, as boldface uppercase letters, boldface lowercase letters, and normal italic letters. We summarize other notations used in this paper in Table I.

Given a set of n data points Z = {z1, z2, ..., zn} ? Rn?d  where d is the number of features, we assume that the matrix Z is zero-centered, i.e.,  ?n  j=1 zj,i = 0 (i = 1, ..., d). The goal    1520-9210 (c) 2016 IEEE. Personal use is permitted, but republication/redistribution requires IEEE permission. See http://www.ieee.org/publications_standards/publications/rights/index.html for more information.

This article has been accepted for publication in a future issue of this journal, but has not been fully edited. Content may change prior to final publication. Citation information: DOI 10.1109/TMM.2017.2703636, IEEE Transactions on Multimedia   TABLE I THE DETAILS OF USED NOTATIONS IN THIS PAPER.

Z The feature matrix of a data set X The feature matrix of the representative set x a vector of X xi the i-th row of X xj the j-th column of X xi,j the element in the i-th row and the j-th column of X  ||X||F the Frobenius norm of X, i.e., ||X||F = ?  ?  i,j x i,j  ||X||2,1 the ?2,1-norm of X , i.e., ||X||2,1 = ?  i  ?  ?  j x i,j  rank(X) the rank of X X  T the transpose of X tr(X) the trace of X X  ?1 the inverse of X  of this paper is to learn a binary code matrix B ? {?1, 1}n?c  for Z without label information to conduct uni-modal unsupervised hashing, where c denotes the number of the codes. Specifically, for the k-th bit (k = 1, ..., c), we denote its binary encoding function as hk(z) = sgn(zwk), and  sgn(v) = { 1, if v ? 0,  ?1, otherwise.

(1)  where sgn(?) denotes the result of element-wise application and W = [w1, ...,wd] ? R  d?c is the transformation matrix. Therefore, we have the following formulation:  B = sgn(ZW) (2)  B. PCA hashing  According to the point of view of the information-theory, a hashing should maximize the information provided by each bit [30], i.e., a binary bit giving balanced partitioning of Z may produce maximum information. However, it is difficult to find such hash functions to meet the balancing requirement. To do this, PCA based hashing first assumes that the maximum entropy partitioning implies to maximize the variance of each bit. That is, the variance of each bit is maximized and the bits are pairwise uncorrelated as well [30], [29]. As a consequence, this assumption results in the following formulation:  ?(W ) = ?  k  var(hk(z))  = ?  k  var(sgn(zwk))  s.t., 1 n BTB = Ic  (3)  where var(?) is the variance of a vector (or a matrix), and Ic ? Rc?c  is an identity matrix.

The maximized variance in Eq. (3) indicates that the encoding  functions produce exactly balanced bits, i.e., BTB = Ic. However, the discrete issue makes Eq. (3) intractable. To address this issue, Eq. (3) is usually transferred to the following continuous version:  ??(W) = 1 n  ?  k  wTk Z TZwk  = 1 n tr(WTZTZW),  s.t., WTW = Ic  (4)  where the orthogonal constraint WTW = Ic requires that the vectors of W (the hyperplanes of the hash functions) are uncorrelated (or orthogonal to each other).

Eq. (4) is exactly the PCA, so we call the resulting hashing based on Eq. (4) and its variants as PCA based hashing methods, and can obtain the optimal W as the top c eigenvectors of the data covariance matrix ZTZ, which corresponds to the top c non-zero eigenvalues of ZTZ. The PCA hashing in Eq. (4) has been demonstrated to preserve the global similarity structures of the data [33]. It is noteworthy that  similarity preserving is the key assumption of hash function learning, i.e., converting original data to the low-dimensional binary codes [55].

The PCA based hashing methods need high time complexity of the training stage, i.e., quadratic to the sample size, to conduct hash function learning. Moreover, the variance of the data in different PCA directions is usually different. In particular, the directions with high variance carry more information than the directions with low variance. To deal with this issue, Spectral Hashing (SH) [27] employs a separable Laplacian eigenfunction to forbid assigning more bits to the directions with less variance. However, SH is a heuristic method by assuming the data to follow uniform distribution. Different from SH, Semi-Supervised Hashing (SSH) [30] sequentially projects the directions via relaxing the orthogonality constraints of PCA.

ITerative Quantization (ITQ) searches a rotation of zero-centered data to minimize the quantization error to keep the variance of the data.

C. Manifold hashing  Different from the PCA based hashing methods [29], [30], [27], [28] to preserve the global similarity structures of all the data, man- ifold based hashing methods [21][33] focus on the local similarity structures, i.e., k Nearest Neighborhood (kNN) preservation for each data point. Their motivation is that 1) the requirement of some real applications. For example, conducting information retrieval via search engines such as Google and Bing, usually expects finding the most similar results (i.e., a subset of the big data set) for a given query; 2) the requirement of manifold learning. A lot of literatures have shown that the global similarity structure preservation possibly results in bad performance due to the adverse impact of noise and outliers, which will be avoided by the local similarity preservation [56].

By following the literatures such as [56] to preserve the local similarity for each data point, we first build a similarity matrix S ? Rn?n using the following steps:  1) Constructing the adjacency graph We calculate the similarity (or the distance) between any two data points.

2) Constructing the sparse adjacency graph We keep the similarity of two data points if a data point is one of the k nearest neighbors (where k is a tuning parameter) of another data point, otherwise 0. This enables to keep noise or outliers out of the local similarity preservation.

Above steps output a sparse similarity matrix for the data set. After this, we also expect to minimize the weighted average Hamming distance of each data pair, and thus devise the following objective function:  n ?  i,j=1  si,j?bi ? bj? 2, s.t., BTB = Ic, B  T1 = 0 (5)  where each row of S indicates that each data point is represented by a subset of all data points. Different from the global similarity structures in Eq. (4), the local similarity structures in Eq. (5) are preserved by a sparse kNN graph, which results in a significant reduction of the storage and computation costs.

We define a diagonal matrix D ? Rn?n whose entries are defined as Di,i =  ?n  j=1 sij , and let L = D ? S, Eq. (5) is thus converted  to the following objective function:  min B  Tr(BTLB) s.t., BTB = Ic, B T1 = 0 (6)  where 1 and 0, respectively, are the matrices with all entries as 1 and 0.

The manifold based hashing methods (such as Self-Taught Hashing (STH) [57] and Anchor Graph Hashing (AGH) [31]) were designed to automatically preserve the local neighborhood structures inherent in the data to learn compact binary codes. Hence, manifold based    1520-9210 (c) 2016 IEEE. Personal use is permitted, but republication/redistribution requires IEEE permission. See http://www.ieee.org/publications_standards/publications/rights/index.html for more information.

This article has been accepted for publication in a future issue of this journal, but has not been fully edited. Content may change prior to final publication. Citation information: DOI 10.1109/TMM.2017.2703636, IEEE Transactions on Multimedia   hashing methods have been shown to achieve more effective hashing performance than LSH based hashing methods and PCA based hashing methods, but need more expensive time cost than these two kinds of hashing methods.

D. Motivation  By comparing two eigenvalue problems in Eq. (4) and Eq. (6), they separately preserve the global similarity structures and the local similarity structures of the data, to result in the time complexity at least min{O(n2d, d3)} and O(n3), respectively.

On one hand, either PCA based hashing methods or manifold based hashing methods only preserves one type of similarity structures.

However, in the literatures, both of these two kinds of similarity structures have been demonstrated to strengthen the performance of unsupervised spectral feature selection due to providing complimen- tary information to each other [55], [58]. Specifically, the global similarity structure preservation contains generalization ability, while the local similarity structure preserves the manifolds of the data. It is noteworthy that the process of hash function learning is actually a process of dimensionality reduction. Thus, it is reasonable to combine these two types of similarity structures into a framework.

On the other hand, if the feature dimensions d is large, the high time complexity of these two hashing techniques are forbidden in the applications of big data. Moreover, big data are usually stored in the disk rather than the memory of the PC. The retrieval in the disk is time-consuming. This motivates us to select a subset of big data (called the representative set in this paper), which can be put into the memory of the PC, to learn the hash functions.

Therefore, in this paper, we integrate PCA with manifold learning to simultaneously preserve the local and global similarity structures of the data to learn the hash functions on the representative set with linear time complexity. First, we conduct linear spectral clustering to hierarchically conduct clustering on the big data set because the big data may not be fed into the memory of modern PC for similarity search. Specifically, we employ the spectral clustering method in [59] to output a set of cluster centers, which can be fed into the memory of PC and approximately represent the distribution of the big data set. We regard the resulting cluster centers as the representative set of the big data set. We then employ the same linear clustering method on the representative set to further output their cluster centers, which are called the landmarks of the representative set (and also the big data set) in this paper. Second, we use the landmark set (containing all the landmarks) to generate a probability representation for each data point of the big data set, and further prove that the probability representations preserve the neighborhood of the big data set. Third, we use the probability representations of the representative set to learn the hash functions by integrating the local similarity structure preservation (via PCA) with the global similarity structure preservation (via manifold learning) in a framework. As a consequence, the training stage outputs the landmark set, the hashing functions, and the binary codes of the big data set.

In testing stage, we first yield the probability representation of each query via the landmark set, and then transfer the resulting probability representation to its binary codes via the hash functions. Finally, we conduct similarity search between binary codes of the query and the big data set via calculating their Hamming distance in the memory of PC.



IV. APPROACH  A. Graph PCA  We first transfer Eq. (4) via ignoring the factor 1 n  to yield the following objective function:  max tr(WTZTZW), s.t., WTW = Ic (7)  We then assume that the binary matrix B can be transferred as a combination between the feature matrix X and a linear transformation matrix W, i.e., B = XW. We further transfer Eq. (6) to obtain the following formulation:  min W  tr(WTZTLZW), s.t., WTW = Ic (8)  By integrating Eq. (7) with Eq. (8), we have the objective function as follows:  min tr(WTZTLZW)? ?tr(WTZTZW), s.t., WTW = Ic  (9)  where ? is a tuning parameter. Finally, we have our final objective function to learn the hash functions as follows:  min tr(WT (ZT (L? ?In)Z)W), s.t., WTW = Ic  (10)  where In ? Rn?n is an identity matrix. Eq. (10) integrates the minimum of the local similarity structure preservation in Eq. (9) with the maximum of the global similarity structure preservation in Eq.

(8) to achieve two kinds of similarity structure preservation at the same time, where the tuning parameter ? is used to balance their weights.

Although Eq. (10) can simultaneously learn the local and global structures of the data, its time complexity is still high, i.e., min{O(n2d), O(d3)}, whose complexity is same as that of PCA hashing in Eq. (4). In the next subsection, we design to learn the representative set and the landmark set to represent the distribution of the big data set.

B. Probability representation  Manifold based hashing methods [20], [34], [60], [57] generate semantic representations of original data, instead of using original d feature spaces, to represent each data point for preserving the local similarity structures of the data. More specifically, manifold based hashing methods assume that each data point form a feature space, so that there are n feature spaces. In this way, each data point represented by all the data points obtains a probability or a coordinate in each feature space. Moreover, each data point is sparsely represented by a subset of all data points to avoid the adverse impact of noise or outliers. As a result, the resulting representation naturally preserves the local similarity structures among data points.

However, such a method has the following limitations to be addressed. First, the time complexity to construct the representation is at least O(n3), which is overwhelming for big data. Second, given the resulting similarity matrix S in Eq. (5), we assume that all the data points lie in an n dimensional feature space. Actually, in big data, the value of n is very large, and thus resulting in a very high-dimensional data matrix, which needs expensive storage and computation costs.

Third, the high-dimensional data have been demonstrated to have a low-dimensional feature space where noise and redundancy are removed [55]. Finally, the sample size of the data set is usually too big to fit them in the memory of PC. In this case, it will be very time consuming to learn the hash functions.

In this paper, we propose a novel strategy to address the above issues, by which an efficient scheme of hash function learning is developed without using the whole data set for local similarity    1520-9210 (c) 2016 IEEE. Personal use is permitted, but republication/redistribution requires IEEE permission. See http://www.ieee.org/publications_standards/publications/rights/index.html for more information.

This article has been accepted for publication in a future issue of this journal, but has not been fully edited. Content may change prior to final publication. Citation information: DOI 10.1109/TMM.2017.2703636, IEEE Transactions on Multimedia   structure preservation. First, we use linear clustering methods to group the data set into subgroups whose cluster centers consist of the representative set of the data set. The number of the cluster centers can be large so that the representative set can be fed into the memory of the PC. Second, we usually generate a representative set as large as possible to capture the characteristics of the data set, but it is still time consuming to conduct hash function learning with the similarity matrix constructed by the representative set. Hence, we further conduct clustering on the representative set to obtain the cluster centers, i.e., the landmarks, each of which is the cluster center of the representative set. Moreover, the number of cluster centers is regarded as the dimensions of the low-dimensional feature space of original data. Third, given the dimensions of the intrinsic space, we use the landmark set to probabilistically represent each data point of the big data set and the representative set as well. Finally, we prove that the resulting representation preserves the local similarity structures.

We have at least two methods to search the dimensions of the intrinsic space via conducting clustering on the high-dimensional data, such as the method of affinity propagation clustering [61] and the cross-validation method. However, the algorithmic complexity of affinity propagation is quadratic in the number of data points and thus cannot be used to deal with big data. In this paper, we predefine a set of dimensions and then use the cross-validation methods to find the best number of clusters for the data sets. Specifically, given the dimensions of the intrinsic space of the original high-dimensional similarity matrix, i.e., m, the further step is to partition the feature space of the similarity matrix into clusters, which is actually a group partition issue.

In this paper, we first employ the clustering method in [59] with linear complexity to generate r cluster centers, which consist of the representative set X ? Rr?d. Given the representative set X, we then employ the same clustering method to generate m clusters and regard the resulting cluster centers as the landmarks, i.e., lk (k = 1, 2, ..., m). We further devise a probability representation method to represent each data point by the landmarks. Specifically, for a given representative set X, each data point xi lies in the m-dimensional space spanned by the landmark set. Moreover, each data point has a probability belonging to each space. Given a query y, we want to find the data points which have similar locations to y in the space of X.

That is, we also give the probability of y to each space spanned by the landmarks. In this way, finding the similar data points is transferred to find the minimal distance of probability between the query and each data point in the data set. Actually, we cannot obtain exact probability of the data set without infinity data points, but we can approximately estimate it via the following steps.

First, we calculate the Euclidean distance between each data point xi and each cluster center lk, i.e.,  ui,k = ?xi ? lk? 2 (11)  According to the literature [62], the probability of a data point belonging to a space can be defined as the Euclidean distance gi,k:  gi,k = exp(?ui,k/?)  ?m  j=1 exp(?ui,j/?)  (12)  where ? is a tuning parameter to control the decay rate of gi,k with respect to ui,k.

Let gi = [gi,1; ...; gi,k; ...; gi,m], gi forms a probability represen- tation of xi, which characterizes the probability distribution of the location of xi in the space spanned by X. Actually, the rationale of the probability definition of gi is similar to that of kernel density estimation with a heat kernel. That is, if xi is near the k-th cluster center, gi,k will have large value. Otherwise, the value of gi,k  will small. Moreover, the reduce rate will be decided by the tune parameter ?, which is set as ? = 1 in this paper.

Second, in the traditional similarity matrix S, each data point is represented by a subset of all data points to avoid the effect of noise. Hence, we also use a subset of landmarks (i.e., s) to represent each data point. That is, in the local similarity preservation, we only preserve first s largest probabilities in gi, and set the left probabilities to 0. Specifically, we denote gs as the s-th most largest probability of gi to have:  g?i,k =  {  gi,k if gi,k ? gs 0 if gi,k < gs  (13)  After this, we normalize g?i,k to have the following equation:  g?i,k = g?i,k  ?m  j=1 g?i,k (14)  Finally, we set the probability representation of xi as g?i = [g?i,1; ...; g?i,k; ...; g?i,m].

The probability representation g?i is a sparse vector, which char- acterizes the spatial structure of xi in the space spanned by the representative set X or the big data set Z. In this case, similar data points have similar probability representations, so g?i is a reasonable representation of xi. In the left of this section, we use Theorem 1 to show that the proposed m-dimensional representation model preserves the local similarity structures of training data.

Theorem 1. Following the process from Eq. (11) to Eq. (14), the neighborhood of each data point in either the representative set X or the data set Z is preserved.

Proof: Here we focus on the proof of the neighborhood preser- vation of the representative set, and the neighborhood preservation of the big data set can be proved with the similar principle. We first add these m cluster centers into X to form a new dataset X  ?  , i.e.,  X ?  = {x ?  1,x ?  2, . . . ,x ?  r,x ?  r+1, . . . ,x ?  r+m} = {x1,x2, . . . ,xr, l1, . . . , lm}  (15)  We then denote each data point in X as  x ?  = r+m ?  j=1  g?i,jx ?  j (16)  where j = 1, . . . , r +m, and g?i,j = 0 if x ?  j is not one of the m- nearest cluster centers of x  ?  i.

According to the literature [63], each data point in X  ?  can be represented by m cluster centers as in Eq. (16). Obviously, this is also applied to X since X is a subset of X  ?  . Actually, Eq. (16) leads to the following reconstruction (or representation) error measured by the following cost function:  E(X) = ?  i  ?  ?  ? x?  ?  j g?i,jx  ?  j  ?  ?  ? (17)  Moreover, Eq. (16) shows two characteristics, i.e., sparseness and invariance. The sparseness means that each representative data point xi is represented by a subset of m cluster centers (i.e., s nearest neighbors) via enforcing g?i,j = 0 if x  ?  j does not belong to this set. According to the literature [63], the defined g?i,j in Eq. (14) minimizes the reconstruction errors in Eq. (16) as well as obeys several important symmetries. That is, the new representation of x  ?  i  in X ?  i is invariant to rotations, rescalings, and translations. More specifically, Eq. (15) shows the invariance to rotations and rescalings, and the constraint  ?  j g?i,j = 1 ensures the invariance to translations.

Moreover, these symmetries ensure that the reconstruction weights (i.e., the new representations) make geometric properties independent on a particular distribution of the data. Therefore, the similarity structures of the data points in X can be well preserved in the derived m-dimensional representation.

1520-9210 (c) 2016 IEEE. Personal use is permitted, but republication/redistribution requires IEEE permission. See http://www.ieee.org/publications_standards/publications/rights/index.html for more information.

This article has been accepted for publication in a future issue of this journal, but has not been fully edited. Content may change prior to final publication. Citation information: DOI 10.1109/TMM.2017.2703636, IEEE Transactions on Multimedia   C. Hash function learning  In the proposed hashing method, namely graph PCA (gPCA), we first conduct Section IV-B to yield the probability representation of each data point via Algorithm 1, and then optimize the objective function in Eq. (10) to obtain W. Finally, the binary codes of the data points can be obtained by sgn(G?W). We list the pseudo of training stage and testing stage, respectively, of our proposed method, in Algorithm 2 and Algorithm 3.

Algorithm 1: The Pseudo of Calculating the Probability Repre- sentation of All Data Points.

Input: y ? Rd; Z ? Rn?d; ?: tuning parameter; s: the value of kNN; m: the number of clusters.

Output: g?y ? Rm and G? ? Rn?m.

1 Conduct clustering to generate X via [59]; 2 Conduct clustering to generate the landmarks via [59]; 3 Calculate Euclidean distance of any data pair in Z via Eq. (11); 4 Calculate the probability of each data point in Z via Eq. (12); 5 Calculate the sparse probability representation of each data  point in Z via Eq. (13); 6 Normalize the sparse probability representation of each data  point in Z via Eq. (14);  Algorithm 2: Training Stage of the Proposed Method gPCA.

Input: Z ? Rn?d; ?: tuning parameter; c: the number of bits.

Output: B ? Rn?c; W ? Rm?c.

1 Yield the probability representation G? of X via Algorithm 1; 2 Conduct eigenvalue decomposition on (G?T (L? ?In)G?); 3 Yield the probability representation G? of X via Algorithm 1; 4 Calculate B via sgn(G?W) for all the data points of Z;  Algorithm 3: Testing Stage of the Proposed Method gPCA.

Input: y ? Rd; W ? Rm?c.

Output: by ? Rc.

1 Yield the probability representation g?g of y via Algorithm 1; 2 Calculate by via sgn(g?yW); 3 Calculate the Hamming distance between by and B;  The time cost of our method focuses on the clustering and the eigenvalue decomposition. The clustering method is linear (i.e., O(dmn)) and the eigenvalue decomposition is quadratic to the number of landmarks, i.e., min{O(m2d), O(d3)}. Hence, the time complexity of our method is O(dmn) (d ? n). We list the time complexity of training stage and testing stage of some popular hashing methods in Table II.

The space complexity of our gPCA method is O(d(m + n)) in training stage and O(dl + ck) plus O(cn) (binary bits) in testing stage.

D. Connection to previous hashing methods  Comparing with data-independent hashing methods, i.e., LSH based hashing methods in [23], [47], [24], [17], [25], [26], our proposed gPCA learns the hash functions according to the data distri- bution, so that outputting reasonable hashing performance. Moreover, our gPCA can use shorter binary codes (i.e., less than 64 bits) to represent each data point, than LSH based hashing. Although our  TABLE II TIME COMPLEXITY COMPARISON OF THE HASHING METHODS.

Training stage Testing stage LSH[65] O(1) O(1) SH[27] O(d2n) O(dc) ITQ[29] O(d2n+ c3) O(dc) AGH[31] O(dmn+m2n) O(dm)  MDSH[28] O(d2n) O(dc) LLH[35] O(dn) O(sc) IMH[32] O(dmn) O(dm)  gPCA O(dmn) O(dm)  Note that c, d, m, n, and s, respectively, are the length of binary codes, the dimensions of the data, the number of centers, the training size, and the number of nearest neighbors.

gPCA has higher time complexity than LSH based hashing methods, in terms of training stage and testing stage, our gPCA achieves linear time complexity for training stage and constant time complexity for testing stage, and thus can be easily run in the modern PC for conducting similarity research on big data.

Comparing with PCA based hashing methods in [48], [28], [29], [30] which only consider to preserve the maximum variance of the data (i.e., the global similarity structures), our proposed gPCA also considers the local similarity preservation. Moreover, these current PCA based hashing methods have higher time complexity than our methods. Comparing with manifold based hashing methods in [57], [60], [20], [2] which only consider to preserve the local similarity structures, our proposed gPCA also considers the global similarity preservation by preserving the maximum variance of the data. Moreover, these previous manifold based hashing methods need at least quadratic time complexity for training stage, while our method only needs linear time complexity. It is noteworthy that both PCA based hashing methods and manifold based hashing methods are a special issue of our proposed gPCA methods. For example, our method shrinks to a manifold based hashing methods by setting ? = 0 in Eq. (10), while our method becomes a PCA based hashing method by setting the value of ? as infinity.

Actually, the literatures [58], [64] have shown that both the local and global similarity structures of the data provide complimentary information to each other so that achieving optimal performance. This indicates that it is reasonable for our method to combine these two kinds of geometries together. Locally Linear Hashing (LLH) [35] is the only hashing method which considers both of these geometries to conduct hash function learning. However, LLH usually achieves suboptimal hashing results because it sequentially conducts two steps to preserve these two similarity structures. By contrast, our proposed gPCA method considers preserving them simultaneously and thus yielding optimal hashing results. Furthermore, our method only needs to conduct eigenvalue decomposition once while LLH needs to do that twice.



V. EXPERIMENTAL RESULTS  In this section, we evaluate the proposed gPCA method on four widely used benchmark data sets, i.e., CIFAR (60K) [66], MNIST (70K) [59], NUS-WIDE (193K) [67], and GIST (500K) [14]. We compare our gPCA with the data-independent hashing method LSH [47], two PCA based hashing methods (i.e., MDSH [28] and ITQ [29]), two manifold based hashing methods (such as AGH [31] and IMH [32]), and the method LLH [35] which sequentially preserves the local and the global similarity structures of the data.

A. Comparison methods  We list the details of the comparison methods as follows:    1520-9210 (c) 2016 IEEE. Personal use is permitted, but republication/redistribution requires IEEE permission. See http://www.ieee.org/publications_standards/publications/rights/index.html for more information.

This article has been accepted for publication in a future issue of this journal, but has not been fully edited. Content may change prior to final publication. Citation information: DOI 10.1109/TMM.2017.2703636, IEEE Transactions on Multimedia   ? LSH randomly selects linear functions as hash functions. In our experiments, we follow the literature [33] to generate a Gaussian random matrix as the hash functions.

? MDSH first learns the similarity matrix of original data to preserve the global similarity structures of the data, and then optimizes a matrix factorization problem on the resulting simi- larity matrix to output the top eigenvectors as the hash functions.

? ITQ first employs PCA to preserve the global similarity struc- tures of original data, and then learns an orthogonal transfor- mation matrix as the hash functions via solving the issue of unbalanced variances on different directions.

? AGH generates the graph representation of each data point, and then uses the resulting new representations to encode the testing data points with binary codes.

? IMH first employs any non-parametric dimensionality reduction methods to convert original high-dimensional data into their low- dimensional feature spaces via preserving the local similarity structures of the data, and then proposes a heuristic method to learn the hash functions.

? LLH first captures the manifold structures of original data using locality-sensitive sparse coding, and then designs a joint minimization problem of the embedding error and the quan- tization loss to recover the resulting manifold structures in a low-dimensional Hamming space.

B. Data sets  The CIFAR data set consists of 60,000 color images from 10 classes, where each class contains 6,000 images and each image is represented by a 512-dimensional GIST feature vector. In our experiments, we select 50,000 images (i.e., 5,000 images per class) to be the representative set for hash function learning in training stage, while the left 10,000 images are testing set.

The MNIST data set consists of 70,000 images which are as- sociated with a digit from ?0? to ?9?. We represented each image with a 784-dimensional feature vector. Following the setting in [31], [33], we split MNIST into two parts, i.e., training set and testing set, respectively, contains 69,000 images and 1,000 images.

The NUS-WIDE data set in our experiments consists of 195,969 images, in which each image is annotated by at least one of the 21 most frequent labels out of original 81 concept tags. Each image is represented by a 500-dimensional SIFT feature vector. We uniformly sample 100 images from each of these 21 tags to form testing set of 2,100 images. The left 193,869 images serve as the big data set.

The GIST data set includes 500,000 images and 1,000 testing images, where each image is represented by a 960-dimensional global GIST feature vector.

C. Evaluation metric  We conduct two similarity search by following previous literatures [31], [21], i.e., hash lookup and Hamming ranking, respectively. Hash lookup needs constant time complexity with a single hash table, while Hamming ranking measures the search quality via ranking the retrieved data points in terms of the Hamming distances to a specific query.

In our experiments, we first use the mean precision of HAMming radius 2 (HAM2) and the Mean Average Precision (MAP), respec- tively, to evaluate the results of hash lookup and Hamming ranking under different hash bits. We also evaluate all the hashing methods in terms of precision-recall curves and time cost.

By regarding the evaluation metric HAM2, we set the threshold of Hamming radius as 2 to output the retrieved training data, whose  Hamming distance is less than 2 to the query. We then report the mean precision of all the queries.

Given a query and r retrieved data points by the hashing methods, we define MAP as follows:  AP (q) = 1 l  R ?  r=1  P (r)?(r)  MAP = 1 q  Q ?  q=1  AP (q) (18)  where l and P (r), respectively, are the number of true neighbors of the ground truth and the precision of the top r retrieved training data, and ?(r) = 0 means the r-th retrieved data point is a false neighbor of the query, otherwise ?(r) = 1. MAP is thus defined as the mean of all queries? average precision. Clearly, the larger the HAM2 or MAP, the better the hashing performance is.

The data sets (such as CIFAR and MNIST) have class labels for each image, so we regard their true nearest neighbors as the semantic nearest neighbors, i.e., the images will be regarded as neighbors if they share the same digital labels. For the data sets (such as NUS- WIDE and GIST), we follow the literatures [31], [29] to replace MAP with Mean Precision (MP) of top-5000 returned neighbors since the calculation of MAP is time consuming on the big data set.

D. Parameters settings  For fair comparison, we set all the training data as the represen- tative set on the data sets CIFAR and MINST, while we uniformly select 63,000 (i.e., 300 images per class) and 60, 000, respectively, for the data sets NUS-WIDE and GIST, as the representative set, to learn the hash functions. We set the number of landmarks as {100, 300, 500, 700, 900} for the methods (such as AGH, IMH, and our gPCA) using k-means to generate the landmarks, and also set the range of all the parameters of all the hashing methods as [0.01, 0.1, 1, 10, 100], where all the methods output their best hashing performance.

E. Result analysis  We report the parameters? sensitivity on different numbers of the landmarks and the variation of ? in Eq. (10) in Fig. 1, and list the results of three evaluation metrics of all hashing methods in Figs.

2- 4. We also report the running time of all the hashing methods in Table III.

From Fig. 1, we know that our method achieves better hashing results while increasing the number of landmarks. The reason is that our proposed gPCA method may easier estimate the distribution of the data set with more landmarks. On the other hand, our proposed method selects different values of ? at different data sets to achieve the best hashing performance. Specially, the data sets (such as CIFAR and MNIST) select large value (e.g., ? ? [10, 100]) and the other two select small value (e.g., ? ? [0.1, 1]). It is noteworthy that the parameter ? in Eq. (10) is used to balance the weight between the PCA part and the manifold part, i.e., the large value of ? enables to add the weight of the PCA part. According to our experimental results, we know that small data sets (such as CIFAR and MNIST) need more weight of local structures of the data than large data sets (such as NUS-WIDE and GIST).

By regarding Figs. 2 to 4, our proposed gPCA method achieves the best hashing performance and has comparable running time to state- of-the-arts hashing methods. For example, our method on average improves by 42.2%, 20.2%, 8.6%, and 5.7%, respectively, than the data-independent hashing method (i.e., LSH), the best PCA hashing method (i.e., MDSH), the best Manifold based hashing method    1520-9210 (c) 2016 IEEE. Personal use is permitted, but republication/redistribution requires IEEE permission. See http://www.ieee.org/publications_standards/publications/rights/index.html for more information.

This article has been accepted for publication in a future issue of this journal, but has not been fully edited. Content may change prior to final publication. Citation information: DOI 10.1109/TMM.2017.2703636, IEEE Transactions on Multimedia      0.01 0.1     0.2  0.4  H A  M  (a) CIFAR   0.01  0.1    0.5   H A  M  (b) MNIST   0.01  0.1    0.5  H A  M  (c) NUS-WIDE     0.01 0.1     0.5  H A  M  (d) GIST Fig. 1. The HAM2 results of our proposed gPCA with different numbers of landmarks and different values of ? in Eq. (10) while setting the code length as 32, on four data sets.

20 30 40 50 60  0.05  0.1  0.15  0.2  0.25  0.3  Code length  H A  M      LSH  ITQ  MDSH  AGH  IMH  LLH  gPCA  (a) CIFAR  20 30 40 50 60  0.2  0.4  0.6  0.8  Code length  H A  M      LSH ITQ MDSH AGH IMH LLH gPCA  (b) MNIST  20 30 40 50 60  0.1  0.2  0.3  0.4  Code length  H A  M      LSH ITQ MDSH AGH IMH LLH gPCA  (c) NUS-WIDE  20 30 40 50 60  0.1  0.2  0.3  0.4  0.5  Code length  H A  M      LSH  ITQ  MDSH  AGH  IMH  LLH  gPCA  (d) GIST Fig. 2. The HAM2 results of all hashing methods on four data sets at different number of hash bits, i.e., c ? [12, 16, 24, 28, 32, 48, 64].

20 30 40 50 60  0.05  0.1  0.15  0.2  Code length  M A  P      LSH  ITQ  MDSH  AGH  IMH  LLH  gPCA  (a) CIFAR  20 30 40 50 60  0.2  0.4  0.6  Code length  M A  P      LSH ITQ MDSH AGH IMH LLH gPCA  (b) MNIST  20 30 40 50 60  0.2  0.4  0.6  Code length  M P      LSH ITQ MDSH AGH IMH LLH gPCA  (c) NUS-WIDE  20 30 40 50 60  0.1  0.2  0.3  0.4  0.5  Code length  M P      LSH  ITQ  MDSH  AGH  IMH  LLH  gPCA  (d) GIST Fig. 3. The results of MAP and MP, respectively, of all hashing methods, on the data sets (i.e., CIFAR and MNIST) and the data sets (i.e., NUS-WIDE and GIST), at different number of hash bits, i.e., c ? [12, 16, 24, 28, 32, 48, 64].

0 0.2 0.4 0.6 0.8 1  0.2  0.4  0.6  0.8   Recall  P re  ci si  o n      LSH  ITQ  MDSH  AGH  IMH  LLH  gPCA  (a) CIFAR  0 0.2 0.4 0.6 0.8 1  0.2  0.4  0.6  0.8   Recall  Pr ec  is io  n      LSH ITQ MDSH AGH IMH LLH gPCA  (b) MNIST  0 0.2 0.4 0.6 0.8 1  0.2  0.4  0.6  0.8   Recall  Pr ec  is io  n      LSH ITQ MDSH AGH IMH LLH gPCA  (c) NUS-WIDE  0 0.2 0.4 0.6 0.8 1  0.2  0.4  0.6  0.8   Recall  P re  ci si  o n      LSH  ITQ  MDSH  AGH  IMH  LLH  gPCA  (d) GIST Fig. 4. The precision-recall curves of all hashing methods, on four data sets at different number of hash bits, i.e., c ? [12, 16, 24, 28, 32, 48, 64].

(i.e., IMH), and the best comparison method (i.e., LLH), in terms of the HAM2 results in Fig. 2. We list more observations as follows:  ? Data-dependent hashing methods (i.e., PCA based methods, Manifold based methods, LLH, and our gPCA) outperform data- independent method, i.e., LSH. For example, data-dependent hashing methods on average improve by more than 32%, com- pared to the LSH method. This indicates that it is reasonable for taking the data distribution into account for conducting similarity search. Actually, we can regard the learnt data distribution as prior knowledge. That is, data-dependent hashing methods consider constructing hashing with prior knowledge, while data- independent hashing method LSH does not take it into account.

? We find that the methods (such as LLH and our gPCA) on average improve by about 8.26% and 22.85%, respectively, compared to manifold based hashing methods and PCA based hashingn methods, since both LLH and our gPCA simultaneous- ly consider preserving the local and global similarity structures of the data. This implies that preserving two kinds of similar- ity structures enables to achieve better hashing performance, compared to the methods which only preserve each of these similarity structures in our experiments. Our experimental results further demonstrate that these two kinds of similarity structures provide complimentary information to each other, as shown in previous literatures [58], [64].

1520-9210 (c) 2016 IEEE. Personal use is permitted, but republication/redistribution requires IEEE permission. See http://www.ieee.org/publications_standards/publications/rights/index.html for more information.

This article has been accepted for publication in a future issue of this journal, but has not been fully edited. Content may change prior to final publication. Citation information: DOI 10.1109/TMM.2017.2703636, IEEE Transactions on Multimedia   TABLE III RUNNING TIME (RECORDED IN SECOND) FOR ALL THE HASHING METHODS.

Methods CIFAR MNIST NUSWIDE GIST  training testing training testing training testing training testing LSH 1.1 1.5? 10?5 1.3 2.3? 10?5 3.5 1.8? 10?5 20.1 3.7? 10?4  ITQ 14.5 4.7? 10?5 15.0 2.5? 10?5 30.4 2.1? 10?5 135.0 4.5? 10?4  MDSH 10.5 4.5? 10?5 8.3 5.1? 10?5 26.1 1.9? 10?5 100.1 6.9? 10?4  AGH 19.6 8.4? 10?5 19.0 3.6? 10?5 26.3 5.6? 10?5 163.3 4.5? 10?4  IMH 17.2 5.2? 10?5 20.1 4.8? 10?5 20.2 4.7? 10?5 166.4 5.2? 10?4  LLH 22.2 9.7? 10?5 32.6 5.5? 10?5 56.2 9.9? 10?5 186.5 6.5? 10?4  gPCA 15.9 5.1? 10?5 16.0 4.3? 10?5 29.2 5.0? 10?5 150.2 5.8? 10?4  ? Our gPCA method outperforms LLH in terms of all three evaluation metrics since the sequential steps in LLH easily leads to suboptimal.

? In terms of training time, data-dependent hashing methods (such as ITQ, MDSH, AGH, IMH, LLH, and gPCA) are more time consuming than data-independent hashing methods (i.e., LSH) since the former methods need to conduct a learning process using training data. More specifically, LSH is the fastest one, ITQ, MDSH, AGH, IMH, LLH and gPCA have similar training time. In terms of testing time, all the hashing methods are in the same magnitude.



VI. CONCLUSION  In this paper, we proposed a novel and effective unsupervised uni- modal hashing method via preserving the local and global similarity structures of the data. To do this, we first partitioned the whole data set into groups (or clusters) and generated the probability representations of all the data points via sparsely representing them by the landmarks. We then devised a new objective function to conduct an eigenvalue problem on the representative set, and further proved that such a method preserves the neighborhood of the data. Our experimental results on public benchmark data sets showed that our proposed gPCA hashing method leaded to very competitive hashing performance, compared to the comparison hashing methods, and achieved real-time similarity retrieval in big data. In this paper, we only considered the linear relationship among the data set and thus cannot model the complex relationship among the big data set. In our future work, we will extend our proposed framework to consider the nonlinear relationship among the data via kernel trick.

