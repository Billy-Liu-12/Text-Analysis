2332-7790 (c) 2016 IEEE. Personal use is permitted, but republication/redistribution requires IEEE permission. See http://www.ieee.org/publications_standards/publications/rights/index.html for more information.

Abstract?To be able to leverage big data to achieve enhanced strategic insight, process optimization and make informed de- cision, we need to be an efficient access control mechanism for ensuring end-to-end security of such information asset. Signcryp- tion is one of several promising techniques to simultaneously achieve big data confidentiality and authenticity. However, sign- cryption suffers from the limitation of not being able to revoke users from a large-scale system efficiently. We put forward, in this paper, the first identity-based (ID-based) signcryption scheme with efficient revocation as well as the feature to outsource unsigncryption to enable secure big data communications be- tween data collectors and data analytical system(s). Our scheme is designed to achieve end-to-end confidentiality, authentication, non-repudiation, and integrity simultaneously, while providing scalable revocation functionality such that the overhead demand- ed by the private key generator (PKG) in the key-update phase only increases logarithmically based on the cardiality of users.

Although in our scheme the majority of the unsigncryption tasks are outsourced to an untrusted cloud server, this approach does not affect the security of the proposed scheme. We then prove the security of our scheme, as well as demonstrating its utility using simulations.

Index Terms?Access control, big data, identity-based sign- cryption, revocation, verifiable outsourced computing.



I. INTRODUCTION  Big data and big data analytics have a wide range of applications, such as biology [1], social sciences [2], smart grid [3], digital forensics [4], [5], and Internet of Things (IoT) [6]. For example, in a smart grid, 22 gigabytes of data could be generated by the smart grid each day from its two million customers at one utility according to the estimation reported in [7]. The knowledge mined from this big dataset can not only enhance the efficiency and reliability of the legacy grid, but also inform the strategies undertaken by the utility company to enhance consumer interaction [3].

As data becomes ?bigger?, so does users? concerns about data security and user privacy [9], [10], [8]. Leakage of sensitive user data can be extremely damaging to the individual concerned as well as the organization; thus, eroding the confidence of the users. On one hand, ensuring the data can only be accessible by the authorized user or system is crucial in  H. Xiong is with the School of Information and Software Engineering, University of Electronic Science and Technology of China, Chengdu 610054, China (e-mail: xionghu.uestc@gmail.com) K.-K. R. Choo is with the Department of Information Systems and Cyber Security, The University of Texas at San Antonio, San Antonio, TX 78249 USA (e-mail: raymond.choo@fulbrightmail.org) A. V. Vasilakos is with the Department of Computer Science, Electrical and Space Engineering, Lulea University of Technology, 97187, Lulea, Sweden (e-mail: vasilako@ath.forthnet.gr).

Manuscript received April 19, 2005; revised January 11, 2007.

Is my data  secure?  Is the data  real?  Data Generation/Acquisition Big Data Data Analysis/Mining  Is the process efficient?  Fig. 1: An example security challenge in big data.

guaranteeing confidentiality of these data. On the other hand, without the capability to ensure the integrity, non-repudiation and authentication of big data, decisions may be made on wrong and misleading information (e.g. data that have been altered by an attacker). Big data security solutions also need to be scalable, and be capable of handling an ever increasing volume, veracity, velocity and variety nature of big data. An example security challenge is illustrated in Fig. 1, which is the focus of this paper.

In general, data authenticity and confidentiality can be achieved using secure signature and encryption schemes, re- spectively. To collectively provide confidentiality, integrity, non-repudiation and authentication, one can use the conven- tional ?signature-then-encryption? strategy, which allows the sender to sign a message prior to encrypting the signed message. However, this approach is not fit-for-purpose in a big data environment which requires real-time and large-scale data processing.

Signcryption, a promising security solution for big data, can capture the functions of both public key signature and encryption simultaneously, and has been shown to outperform the traditional signature-then-encryption strategy [11]. Unsur- prisingly, a number of signcryption schemes designed for vehicle ad hoc networks [12], smart grid [13], wireless mobile networks [14], secure e-mail [15], wireless body area networks [16], [17], etc, have been proposed in the literature. We observe that signcryption [18], [19], [20], [21], [22] schemes for traditional public key infrastructure (PKI) are well-studied.

However, due to the expensive certificate management inher- ent in a PKI implementation, PKI-based signcryption is not suitable for big data (analytical) deployment. Therefore, to eliminate the limitations of PKI, security researchers have suggested a number of signcryption schemes designed for identity-based public key cryptography (ID-PKC) system (see    2332-7790 (c) 2016 IEEE. Personal use is permitted, but republication/redistribution requires IEEE permission. See http://www.ieee.org/publications_standards/publications/rights/index.html for more information.

This article has been accepted for publication in a future issue of this journal, but has not been fully edited. Content may change prior to final publication. Citation information: DOI 10.1109/TBDATA.2017.2697448, IEEE Transactions on Big Data  2 JOURNAL OF LATEX CLASS FILES, VOL. 6, NO. 1, JANUARY 2007  [24], [25], [26], [27]).

While ID-based signcryption (shorten as IB-BC) scheme  appears to be a potential solution for secure communication in a big data environment [28], [29], there are a number of challenges that need to be addressed before such schemes can be deployed in practice. Firstly, once the subscription of a user has expired or the private key of the user is exposed, the scheme must be able to support user revocation.

In the conventional PKI setting, the revocation function can be achieved by broadcasting a certificate revocation list. However, this approach does not work in a ID-PKC system, due to the absence of public key certificate. To provide such a revocation function in ID-PKC, Boneh and Franklin [30] proposed a different approach such that the public key of a user consists of an identity and a pre-determined time period. The revocation function is carried out by the PKG, which periodically refresh- es key update information associated with each time interval.

In this way, only non-revoked users are able to obtain short- term secret keys in the current time interval by incorporating their own long-term private keys and key update information distributed by the PKG. Due to the need to support large scale data processing, it is important that the revocation function is also scalable without incurring significant computational overheads. While there are various constructions of revocable ID-based or certificateless primitives [31], [32], [33], [34], [35], [36], [37], [38], [39], [40], [42], [43], adding revocation function to ID-based signcryption schemes does not appear to be trivial. This is not a new challenge, but the only known revocable ID-based signcryption scheme scheme that is not scalable is that of [41]. In this scheme, the size of key-updates increases with the cardinality of users in a linear manner.

What makes things worse, this scheme has been shown to be vulnerable to short-term key exposure attacks [42], [43].

In other words, this scheme cannot guarantee the security of non-revoked users so long as the short-term private keys of these users have been compromised.

Cloud computing is also another relatively recent trend, which enables on-demand and ubiquitous provision of con- figurable computing and storage resources in real-time and on an ad-hoc basis. Cloud computing allows one to out- source expensive computation tasks from the users to the cloud server in a pay-per-use fashion. In the context of IB- SC schemes, users can benefit by leveraging the cloud to undertake expensive unsigncryption operations without the need for significant investment in hardware and software purchasing and maintenance. We also note that a receiver (e.g., the analytical system) may receive a large number of messages from their large user-base (i.e., the users are also known as data generators); therefore, it is necessary to design IB-SC schemes with unsigncryption outsourcing function. Although several attribute-based encryption paradigm featured with the outsourced decryption has been proposed in the literature (see [45], [46], [47], [48], [49], [50], [51], [52]), designing secure signcryption scheme with the capability to support outsourced unsigncryption remains a research challenge, due to the need to preserve both confidentiality and unforgeability during outsourcing.

Therefore, in this paper, we seek to design an IB-SC  scheme with efficient revocation and unsigncryption outsourc- ing. Specifically, we introduce a new primitive, which ensures the efficiency and privacy for both sender and receivers and offers the scalable revocation function. We regard the main contribution of this paper as two-fold: ? We propose a novel ID-based signcryption scheme with  efficient revocation functionality (R-IBSC), based on the binary tree structure. In particular, our construction offers a shorter ciphertext size and faster signcryption compared with the sign-then-encrypt approach. Furthermore, the key-update overhead at the PKG increases logarithmically with the number of users, which is particularly attrac- tive in a large-scale big data environment. Our scheme also achieves short-term key exposure resistance, and is proven to achieve indistinguishability and existential unforgeability against the chosen ciphertext attacks adap- tively (shorten as IND-CCA2) and the chosen message attacks adaptively (shorten as EUF-CMA) assuming the intractability of the Decision Bilinear Diffie-Hellman (DBDH) problem and the computational Diffie-Hellman (CDH) problem respectively in the well-known random oracle model [53]; and  ? We also describe the formal definition and security mod- el of the R-IBSC scheme with verifiable unsigncryp- tion outsourcing, such that the prohibitively expensive computation operations at the receiver can be offloaded to the untrusted cloud server. We then present a con- crete construction by incorporating the idea of key re- randomization and ciphertext blinding. Fuelled by the random oracle model, the proposed outsourceable R- IBSC scheme is proven that the malicious cloud server is unable to learn any information about the underlying encrypted plaintext and the receiver can validate the correctness of the outsourcing computation carried out by the cloud server.

We also demonstrate the utility of our schemes using exper- iments on a Intel-core personal computer and a sensor node with ATmega128L processor respectively.

In the next section, the related work on secure outsourcing of attribute-based encryption (see Section II-A) and revocable ID-based cryptosystems (see Section II-B) are briefly reviwed.



II. RELATED WORK  A. Secure Outsourcing of Attribute-based Encryption  Extending the concept of IBE, attribute-based encryption (also known as ABE) [54] provides flexible and versatile access control over encrypted data by enabling one-to-many encryption based on user attributes. To eliminate the decryp- tion overhead on the user side, Green et al. [45] proposed an ABE paradigm equipped with outsourced decryption based on a key blinding technique. By applying the transformation key provided by the user, a semi-trusted cloud server is able to convert any ABE ciphertext into a ElGamal-style ciphertext without accessing the data or secret keys. With the transformed ciphertext from the cloud server, the user can perform the complete decryption with a small computational overhead at the client?s end. To ensure correctness of the conversion    2332-7790 (c) 2016 IEEE. Personal use is permitted, but republication/redistribution requires IEEE permission. See http://www.ieee.org/publications_standards/publications/rights/index.html for more information.

This article has been accepted for publication in a future issue of this journal, but has not been fully edited. Content may change prior to final publication. Citation information: DOI 10.1109/TBDATA.2017.2697448, IEEE Transactions on Big Data  SHELL et al.: BARE DEMO OF IEEETRAN.CLS FOR COMPUTER SOCIETY JOURNALS 3  carried out by the semi-trusted cloud server, Lai et al. [46] introduced verifiability of the cloud?s decryption service and proposed a concrete construction using a parallel encryption technique. Particularly, a redundancy ciphertext is appended to the original ciphertext for correctness checking. Observing the cumbersome bandwidth and computation cost in [46], Lin et al. [47] and Mao et al. [48] put forward alternative approaches to construct ABE equipped with verifiable outsourced decryp- tion by incorporating the idea of commitment independently.

Ma et al. [51] proposed an ABE paradigm that supports both outsourced decryption and encryption, and defined a new security notion of exculpability for the outsourced decryption to guarantee the user cannot ?accuse? the cloud server of incorrect translation, while the cloud server performs the transformation honestly. To realize the strongest form of access policy, Xu et al. [52] put forward a circuit ABE scheme with verifiable decryption outsourcing based on the multilinear map. Although decryption outsourcing has been extensively studied in the ABE environment already, there is no IBSC with unsigncryption outsourcing in the literature so far.

B. Revocable ID-based Cryptosystems  Since the seminal work of Boneh and Franklin [30], Boldyreva et al. [31] put forward the first IBE supporting an efficient revocation, named as scalable RIBE, based on fuzzy identity-based encryption [54] and the binary tree structure [56], such that the overhead on the PKG side only increases with the cardinality of users in logarithmic manner. This is a significant improvement to the solution in [30] since the overhead of PKG in [31] grows linearly with the cardinality of users. Inspired by the idea in [31], Libert et al. [32] and Chen et al. [33] proposed an adaptive-identity secure and a lattice-based revocable IBE scheme, respectively. By revisiting the security model for RIBE, Seo and Emura [42], [43] identified the short-term private key exposure attack to demonstrate that the RIBE schemes in [31], [32], [33] are vulnerable to this attack and presented the RIBE scheme with short-term private key exposure resistance. Following [42], [43], the RIBE schemes featured with key generation delegation [34], [35] and key-escrow elimination [39] have also been investigated. Revocable ID-based signature with short-term key exposure resilience was proposed in [43]. As far as we know, the only known revocable IB-SC scheme is reported in [41]. Unfortunately, this scheme is far from being scalable and is vulnerable to a short-term key exposure attack. Thus, constructing IBSC supporting efficient revocation and temporary key exposure resilience remains a research challenge.



III. PRELIMINARIES  A. Computational Assumptions  Given two abelian groups G and GT where both groups are 1) multiplicative cyclic groups and 2) associated with the same order (say prime p). Based on G and GT , a non-degenerate and efficiently computable function e? : G ? G ? GT can be defined with bilinearity such that e?(ga, gb) = e?(g, g)ab, where  g and e?(g, g), respectively, are generators of the cyclic group G and GT . Then, a, b are selected from Z?p at random.

Definition 1: (Decision Bilinear Diffie-Hellman (DBDH) Problem). Taking four random elements {g, ga, gb, gc} and and one random element Z chosen from G and GT respectively as input, the DBDH problem refers to determining whether Z  ?

= e?(g, g)abc or not. Here, a, b, c ?R Z?p.

Definition 2: (Computational Diffie-Hellman (CDH) Prob-  lem). Taking three elements {g, ga, gb} ? G randomly chosen from G as input, the CDH problem in G refers to calculating gab. Here, a, b ?R Z?p.

B. Modeling Revocable ID-based Signcryption  In the R-IBSC scheme, three entities are typically involved to interact with each other: PKG, sender and receiver. By incorporating the idea of IBSC schemes [25], [26], [27], R- IBE schemes [31], [42] and R-IBS schemes [36], [37], [43], the formal definition of R-IBSC scheme has been presented as follows.

1) Setup: With the number of users, say n, in the system, this algorithm outputs the system parameters params, the master secret key msk and a revocation list RL, which is initially set as empty.

2) IniKeyGen: By taking the user identity ID, params as well as msk as input, this algorithm generates the initial private key skID.

3) KeyUpdate: By taking params, the current time period T , the current RL, as well as msk, this algorithm outputs the update key ukT .

4) KeyDer: By taking as input skID, ukT as well as params, this algorithm outputs the full private key skID,T for ID in T .

5) Signcrypt: Given params, a message m, an identity IDR of the receiver, a full private key skIDS ,T of the sender as well as T , this algorithm generates a ciphertext ?.

6) Unsigncrypt: Given ?, the full private key skIDR,T of the receiver, as well as the identity IDS of the sender, this algorithm recovers the plaintext m.

7) Revoke: By taking as input a set of identities to be excluded, current T and RL, this algorithm returns an updated RL.

C. Security definitions of Revocable ID-based Signcryption  Taking the confidentiality and unforgeability into considera- tion simultaneously, the standard security aspects of ID-based signcryption include indistinguishability and existential un- forgeability against adaptively chosen ciphertext attack (short- en as IND-IBSC-CCA2) and chosen message and identity attack (shorten as EUF-IBSC-CMA) respectively. We define the security model of R-IBSC by adapting the notions in [25], [26], [27].

As for the IND-R-IBSC-CCA2 security, the security game betwixt a simulator/challenger C and an adversary A is de- picted as follows.

2332-7790 (c) 2016 IEEE. Personal use is permitted, but republication/redistribution requires IEEE permission. See http://www.ieee.org/publications_standards/publications/rights/index.html for more information.

This article has been accepted for publication in a future issue of this journal, but has not been fully edited. Content may change prior to final publication. Citation information: DOI 10.1109/TBDATA.2017.2697448, IEEE Transactions on Big Data  4 JOURNAL OF LATEX CLASS FILES, VOL. 6, NO. 1, JANUARY 2007  ? Initial. The simulator C first executes Setup algorithm to generate msk and initial RL, and then publishes params and keeps msk and RL secret.

? Phase 1. In this phase, A can query the following oracles in adaptive manner:  1) Initial-Private-Key-Extract Oracle: Taking ID ? ID as input, this oracle outputs the initial private key skID by carrying out the IniKeyGen algorithm.

2) Update-Key-Extract Oracle: Taking T ? T as input, this oracle outputs the update key ukT by carrying out KeyUpdate algorithm.

3) Full-Private-Key-Derive Oracle: Taking T ? T and ID ? ID as input, this oracle outputs the full private key skID,T by carrying out the IniKeyGen and KeyUpdate algorithms.

4) Unsigncryption Oracle: Taking T ? T , IDR ? ID and ? as input, this oracle outputs the cor- responding plaintext by carrying out the Unsign- crypt(?, IDS , skIDR,T ) algorithm, where skIDR,T can be extracted by running the IniKeyGen and KeyUpdate algorithms.

? Challenge. After Phase 1 is terminated by A, two mes- sages m?0 and m  ? 1 along with the tuple (ID  ? R, T  ?) will be submitted to C with the restrictions: 1) (ID?R, T ?) should not be queried in the Full-Private-Key-Derive oracle; and 2) the algorithm Revoke should be carried out with the input (ID?R, T ) if the initial private key of the ID?R has already been extracted in T (? T ?). C extracts the sender?s full private key skID?S ,T? and outputs ?  ?  by carrying out the Signcrypt algorithm with the input (params,m??, skID?S ,T? , ID  ? R, T  ?), where ? is a random bit chosen by C. Finally, C gives ?? to A.

? Phase 2. Similar to the phase 1, the Initial-Private-Key- Extract, Update-Key-Extract, Full-Private-Key-Derive and Unsigncryption oracles can be accessed by A in adaptive manner with the restrictions: 1) the tuples (ID?R, T  ?) and (ID?R, T ?, ??) cannot be queried in the  Full-Private-Key-Derive and Unsigncryption oracles respectively; and 2) the algorithm Revoke should be carried out with the input (ID?R, T ) if the initial private key of the ID?R has already been extracted in T (? T ?).

? Guess. If the bit ?? output by A is equal to ?, A is regarded to win this game.

The advantage Adv(A) of adversary A for the above game is defined as |2Pr[?? = ?]? 1|, where Pr[?? = ?] refers to the probability that ?? = ?.

Definition 3: A R-IBSC scheme is regarded to be secure against adaptive chosen ciphertext attack (shorten as IND-R- IBSC-CCA2), if no PPT algorithm A can win IND-R-IBSC- CCA2 game with non-negligible advantage.

The security game betwixt a simulator/challenger C and an adversary F is depicted to define the EUF-R-IBSC-CMA security as follows.

? Initial. The simulator C first executes Setup algorithm to  generate msk and initial RL, and then publishes params and keeps msk and RL secret.

? Attack. In this phase, F queries the following oracles in  adaptive manner: 1) Initial-Private-Key-Extract, Update-Key-Extract  and Full-Private-Key-Derive: These oracles are i- dentical to those in IND-R-IBSC-CCA2 game.

2) Signcrypt Oracle: By taking T ? T , a sender?s identity IDS ? ID and message m as input, this oracle executes the Signcrypt algorithm with the input (m, IDR, skIDS ,T ) to output the ciphertext, where skIDS ,T can be extracted by running the IniKeyGen and KeyUpdate algorithms.

? Forgery. Finally, a ciphertext ?? is generated by F on message m? associated with (ID?S , T  ?). F wins this game if Unsigncrypt(??, ID?S , sk?IDR , T  ?) = m? with the restrictions: 1) the tuple (ID?S , T  ?) has not been submitted to the Full-Private-Key-Derive oracle; and 2) the algorithm Revoke should be carried out with the input (ID?S , T ) if the initial private key of the ID  ? S has already  been extracted in T (? T ?).

The probability of F to win the EUF-R-IBSC-CMA game  is defined as the advantage of F .

Definition 4: A R-IBSC scheme is regarded to be secure  against existential unforgeability against adaptive chosen mes- sage and identity attack (shorten as EUF-R-IBSC-CMA), if no PPT adversary F can win the EUF-R-IBSC-CMA game with non-negligible advantage.

D. KeyUpdateNode algorithm The KeyUpdateNode algorithm [31], [42], [43], which can  output a covering set based on the complete subtree approach, is employed in our scheme to realize efficient revocation func- tion. Concretely, each member in the system is bind with a leaf node ?i randomly selected from a complete binary tree BT and is correspondingly assigned a group of nodes, which includes all of the nodes in the path ranging from its own terminal node ?i to the root node and is thus denoted as Path(?i). Besides, a revocation list RL is created and maintained to record the leaf nodes associated with the revoked users. By taking BT and RL in time period Tk as input, a covering set of leaf nodes, say CS, is output by the KeyUpdateNode algorithm to ensure that Path(?i)  ? CS 6= ? iff the user (associated with the terminal  node ?i) is still legitimate (non-revoked). The specification of KeyUpdateNode algorithm is depicted formally in Algorithm 1, where xleft and xright respectively represents the left and right child of non-terminal node x.

In Fig. 2, an illustration example of KeyUpdateNode al- gorithm with input of BT, RL, and Tk is given in detail. For the case that nobody has been excluded, the node R (root of BT) is output by the KeyUpdateNode algorithm. As for the case that one user u5 equipped with the terminal node K is removed, the set R will be updated by adding the set Path(K)= {R,B,E,K}, and the set CS = {A,L, F} will be returned as the output of algorithm KeyUpdateNode. For the revoked user u5, Path(K)  ? CS = ?. On the contrary, at  least one node y ? CS can be obtained by every non-revoked user associated with ?i such that y ? Path(?i). In particular, u1, u2, u3 and u4 have the node A ? Y , u6 have the node L ? Y , u7 and u8 has the node F ? Y .

2332-7790 (c) 2016 IEEE. Personal use is permitted, but republication/redistribution requires IEEE permission. See http://www.ieee.org/publications_standards/publications/rights/index.html for more information.

This article has been accepted for publication in a future issue of this journal, but has not been fully edited. Content may change prior to final publication. Citation information: DOI 10.1109/TBDATA.2017.2697448, IEEE Transactions on Big Data  SHELL et al.: BARE DEMO OF IEEETRAN.CLS FOR COMPUTER SOCIETY JOURNALS 5  Algorithm 1 KeyUpdateNode(BT, RL, Tk) for ?(?i, Tj) ? RL do  if Ti ? Tk then insert Path(?i) into R  end if end for for ?x ? R do  if xleft /? R then insert xleft into CS  end if if xright /? R then  insert xright into CS end if  end for if |RL| = 0 then  insert the root node into CS end if return CS  R  G H I J K L M N  C D E F  A B  Nodes output by KUNodes for key update  R  G H I J K L M N  C D E F  A B  Nodes output by KUNodes for key update  Revoked nodes marked by KUNodes  No user is revoked  Fig. 2: An example of KeyUpdateNodes algorithm.



IV. PROBLEM STATEMENT  A. System Model  Compared with the model for typical R-IBSC, a cloud server is involved in the outsourced R-IBSC scheme. To ensure authenticity and confidentiality in big data, the data generator collecting extremely large scale data from distributed data sources is considered a sender, whereas the analytical system extracting useful knowledge from these big data acts as a receiver. To relieve the heavy computational load off the analytical system (recall that the number of data generators in the system could be up to millions), a cloud server is maintained by a semi-trusted third party to deliver redundant computing resources to the analytical system. During the outsourcing, the analytical system sends a transformation key once to the cloud server, who in turn performs the outsourcing  Analytical system  Private Key Generator  Data generators Cloud  Secure Computation  Outsourcing End-User  End-User End-User  Fig. 3: System Model for outsourced R-IBSC in Big Data paradigm.

unsigncryption on the ciphertexts that the analytical system is interested and returns to her partially unsigncrypted ciphertext.

It is desirable that the computational task carried out by the analytical system in the outsourcing unsigncryption should be strictly less than those performed in normal unsigncryption.

The system model for outsourced R-IBSC scheme in Big Data paradigm can be found in Fig 3. Based on the proposed system model, the outsourced R-IBSC scheme is formally defined as follows.

A R-IBSC with Verifiable Outsourced Unsigncryption scheme (Setup, IniKeyGen, KeyUpdate, KeyDer, Signcrypt, Unsigncrypt, Revoke, Setup.out, Ciphertext.ran, Transfor- m.out and Unsigncrypt.out) is specified by the following eleven polynomial time algorithms:  1) Setup, IniKeyGen, KeyUpdate, KeyDer, Signcrypt, Unsigncrypt, Revoke. The algorithms are identical to those in the above R-IBSC scheme.

2) Setup.out: On input params and the private key skIDR,T of receiver, this algorithm is carried out by the receiver to output a transformation key tkIDR,T , a cor- responding retrieving key rkIDR,T and a string String containing the information needed in the outsourcing.

3) Ciphertext.ran: On input a normal ciphertext ?, this algorithm is carried out by the receiver to generate a re-randomized ciphertext ??.

4) Transform.out: On input params, a randomized ci- phertext ??, a transformation key tkIDR,T , the sender?s identity IDS and time period T , this algorithm is carried out by the cloud server to compute the transformed ciphertext ???.

5) Unsigncrypt.out: This algorithm takes in input params, the retrieving key rkIDR,T , a normal ciphertext ? and a transformed ciphertext ???, the outsourcing unsigncryp- tion algorithm is performed by the receiver to output m or ? in case ? is not valid.

B. Security Definition  A R-IBSC scheme with outsourced unsigncryption scheme should not introduce new vulnerabilities to the normal R-IBSC scheme. The receiver can directly outsource the computation to the cloud server in case this server is fully trusted. Unfor- tunately, this security assumption is not reasonable since the cloud server is usually assumed to be malicious. Bearing this assumption in our mind, the privacy and verifiability require- ments of a R-IBSC scheme equipped with outsourced unsign- cryption scheme is formally described. Informally speaking,    2332-7790 (c) 2016 IEEE. Personal use is permitted, but republication/redistribution requires IEEE permission. See http://www.ieee.org/publications_standards/publications/rights/index.html for more information.

This article has been accepted for publication in a future issue of this journal, but has not been fully edited. Content may change prior to final publication. Citation information: DOI 10.1109/TBDATA.2017.2697448, IEEE Transactions on Big Data  6 JOURNAL OF LATEX CLASS FILES, VOL. 6, NO. 1, JANUARY 2007  privacy implies that an adversary (even the malicious cloud server) cannot learn any information about the underlying encrypted plaintext. On the other hand, verifiability enables a user to validate the correctness of the translation carried out by the cloud server. As for the privacy, the security game between a simulator/challenger C and an adversary A is depicted as follows.

? Initial. The simulator C first executes Setup algorithm to generate msk and initial RL, and then publishes params and keeps msk and RL secret.

? Phase 1. In this phase, A queries the following oracles in adaptive manner:  1) Initial-Private-Key-Extract, Update-Key-Extract, Full-Private-Key-Derive and Unsigncryption ora- cles. These oracles are identical to those in IND-R- IBSC-CCA2 game.

2) Transform-Key-Extract Oracle: Taking T ? T and an identity IDR ? ID of the receiver as the input, this oracle outputs the transformation key tkIDR,T by running Setup.out algorithm. It is unneces- sary for A, who has submitted (T, IDR) to Full- Private-Key-Derive oracle, to query Transform- Key-Extract Oracle on the same (T, IDR). Be- cause anyone can generate a transformation key tkIDR,T using skID,T by himself/herself.

3) Unsigncryption.out Oracle: Taking as input T ? T , an identity IDR ? ID of the receiver, a normal ciphertext ? and a transformed ciphertext ???, this oracle runs the Unsigncrypt.out algorithm to output the plaintext, where the retrieving key rkIDR,T can be extracted by running the Setup.out algorithm.

? Challenge. After Phase 1 is terminated by A, two mes- sages m?0 and m  ? 1 along with the tuple (ID  ? R, T  ?) will be submitted to C with the restrictions: 1) (ID?R, T ?) should not be queried in the Full-Private-Key-Derive oracle; and 2) the algorithm Revoke should be carried out with the input (ID?R, T ) if the initial private key of the ID?R has already been extracted in T (? T ?). C extracts the sender?s full private key skID?S ,T? and outputs ?  ?  by carrying out the Signcrypt algorithm with the input (params,m??, skID?S ,T? , ID  ? R, T  ?), where ? is a random bit chosen by C.

? Phase 2. Similar to the phase 1, the Initial-Private-Key- Extract, Update-Key-Extract, Full-Private-Key-Derive and Unsigncryption oracles can be accessed by A in adaptive manner with the restrictions: 1) the tuples (ID?R, T  ?) and (ID?R, T ?, ??) cannot be queried in the  Full-Private-Key-Derive and Unsigncryption oracles respectively; and 2) the algorithm Revoke should be carried out with the input (ID?R, T ) if the initial private key of the ID?R has already been extracted in T (? T ?).

? Guess. If the bit ?? output by A is equal to ?, A is regarded to win this game.

The advantage Adv(A) of adversary A for the above game is defined as |2Pr[?? = ?]? 1|, where Pr[?? = ?] refers to the probability that ?? = ?.

Definition 5: A R-IBSC scheme equipped with outsourced  unsigncryption is regarded to be privacy preserving against adaptive chosen ciphertext attack, if no PPT algorithm A can win the above game with non-negligible advantage.

As for the verifiability, the security game betwixt a chal- lenger/simulator C and an adversary F is depicted as follows.

? Initial. The simulator C first executes Setup algorithm to  generate msk and initial RL, and then publishes params and keeps msk and RL secret.

? Attack. In this phase, F queries the following oracles in adaptive manner:  1) Initial-Private-Key-Extract, Unsigncryption, Update-Key-Extract, Full-Private-Key-Derive, Transform-Key-Extract, and Unsigncryption.out oracles.

? Forgery. With the input of a re-randomized ci- phertext ?? associated with the original ciphertex- t ? and (m?, ID?S , T  ?), F outputs a transformed ciphertext ??? and wins this game if Unsigncryp- t.out(?, ???, ID?S , sk?IDR , T  ?) = m? with the restrictions: 1) the tuple (ID?S , T  ?) has not been submitted to the Full- Private-Key-Derive oracle; and 2) the algorithm Revoke should be carried out with the input (ID?R, T ) if the initial private key of the ID?R has already been extracted in T (? T ?).

The advantage of F is defined as the probability it wins in the above game.

Definition 6: A R-IBSC scheme with outsourced unsign- cryption scheme is regarded to be verifiable against adaptive chosen message and identity attack, if no polynomial time F has non-negligible advantage in the above game.



V. OUR PROPOSED R-IBSC WITH VERIFIABLE OUTSOURCED UNSIGNCRYPTION  A. Intuition  To achieve revocation function, the private key of user (data generator or analytical system) comprises a fixed component associated with the identity (also called initial private key) and an updatable component corresponding with the time period (also named as updated key). The Signcrypt and Unsigncrypt algorithms can be performed exclusively by the user featured with both the initial private key and updated key. In case a user is revoked, PKG simply stops publishing updated key for that user. Inspired by the KeyUpdateNode algorithm, the binary tree structure can be employed to achieve efficient revocation by reducing the workload of the PKG. Concretely, PKG issues the initial private key for a registered user by associating each user to a leaf node randomly selected from a binary tree and generating a group of private keys (associated with the identity of this user) according to the data stored in each node in the path ranging from the root node to the corresponding terminal node. According to the revocation list generated in each time period, the PKG executes the KeyUpdateNode algorithm to output a group of nodes and broadcasts the data stored in this set as the updated key to each user in the system. In this way, only the legitimate (non-revoked) users can generate the short-term private key in current time period by invoking the KeyDer algorithm. When the data generator intends to deliver    2332-7790 (c) 2016 IEEE. Personal use is permitted, but republication/redistribution requires IEEE permission. See http://www.ieee.org/publications_standards/publications/rights/index.html for more information.

This article has been accepted for publication in a future issue of this journal, but has not been fully edited. Content may change prior to final publication. Citation information: DOI 10.1109/TBDATA.2017.2697448, IEEE Transactions on Big Data  SHELL et al.: BARE DEMO OF IEEETRAN.CLS FOR COMPUTER SOCIETY JOURNALS 7  a message m to the analytical system, the data generator runs Signcrypt algorithm using its short-term private key and delivers the ciphertext to the analytical system. Once receiving the ciphertext from the data generator, the analytical system runs Unsigncrypt algorithm to recover the message m. With this R-IBSC scheme, confidentiality, integrity, authentication, non-repudiation and revocation can be offered simultaneously.

As for the secure outsourcing, the main trick behind our construction is to incorporate a key blinding technique and a ciphertext re-randomization technique to outsource the un- signcryption such that the adversary (including the malicious cloud server) cannot learn any information about the encrypted message. Meanwhile, the correctness of the outsourced com- putation done by the cloud server can be validated. More precisely, the receiver supplies the cloud server with a transfor- mation key which enables the latter to perform the partially unsigncryption. It is remarkable that the transformation key only needs to be uploaded to the cloud once in a time period and unlimited number of ciphertexts can be transformed by the cloud server in this time period. During this time period, the receiver can re-randomize the receiving ciphertext and forward it to the cloud server, which transforms the ciphertext and returns the partially-unsigncrypted result to the receiver.

Once obtaining the partial ciphertext from the cloud server, the receiver can retrieve the plaintext with the secret retrieving key and validate the correctness of outsourced computation with the random factor used in the ciphertext re-randomization.

B. Our Scalable R-IBSC Scheme  ? Setup: Choose x and two generators g, g2 at random from Zp and G respectively, and compute g1 = gx. Pick three hash functions Hi for i ? {1, ? ? ? , 4} such that H1 : ID ? G, H2 : T ? G, H3 :M?GT ?M?G5 ? G, where ID,M and T refer to the identity space, message space and time space respectively. The PKG publishes {g, {gi}i?{1,2}, {Hj}j?{1,??? ,4},SE} as the public system parameters and keeps {x,RL,BT} secret, where SE = (Enc, Dec), RL, BT represents secure symmetric-key encryption scheme [57], initially-empty revocation list as well as binary tree with n leaves.

? IniKeyGen: In case receiving ID, PKG searches RL to check whether ID ? RL or not and aborts if so.

Otherwise, PKG randomly chooses a terminal node ?ID from BT and binds ID with ?ID. With respect to each node ? ? Path(?ID), PKG selects xID?1 at random from Zp and stores (xID?1 , xID?2 ) in the node ? satisfying xID?1 + xID?2 = x mod p to initialize the node ?. PKG then selects rID? at random from Zp and computes (dID?1 , dID?2 ) = (g xID?1 2 ? (H1(ID))r  ID ? , gr  ID ? ). Finally, PKG returns the  initial private key skID = {(dID?1 , dID?2 )}??Path(?ID) to ID.

? KeyUpdate: Regarding to each node ? output by the algorithm KeyUpdateNode with the input (BT, RL, T ), PKG extracts xID?2 from ?, selects s  ID ? randomly from Zp,  and calculates (d?ID?1 , d? ID ?2 ) = (g  xID?2 2 ? (H2(T ))s  ID ? , gs  ID ? ).

After that, the PKG returns {(d?ID?1 , d?ID?2 )} as the update key, where ? ? KeyUpdateNode(BT,RL, T ).

? KeyDer: If the intersection of KeyUpdateNode(BT, RL, T ) and Path(?ID) are empty, returns ?. Oth- erwise, choose ? from KeyUpdateNode(BT, RL, T ) ?  Path(?ID) and selects rID, sID at random from Zp, and calculates the full private key skID,T = (sk1ID,T , sk  ID,T , sk  ID,T ) such that sk  ID,T = d  ID ?1 ? d?ID?1 ?  (H1(ID)) rID ? (H2(T ))sID , sk2ID,T = dID?2 ? grID and  sk3ID,T = d? ID ?2 ? gsID .

? Signcrypt: On receiving (T,m, IDR, skIDS ,T ), the sender executes the following steps.

1) Choose at random k ?R Zp.

2) Compute t = e?(g1, g2)k, ?1 = H4(t)?m, ?2 = gk,  ?3 = H1(IDR) k, ?4 = H2(T )k, ?5 = sk2IDS ,T and  ?6 = sk IDS ,T  .

3) Compute ?7 = sk1IDS ,T ?H3(m, t, ?1, ?2, ?3, ?4,  ?5, ?6) k.

Returns ? = (?1, ?2, ?3, ?4, ?5, ?6, ?7) as the ciphertext.

? Unsigncrypt: On receiving (?, IDS , skIDR,T , T ), the  intended receiver executes the following steps.

1) Calculate t = e?(?2,sk  IDR,T  )  e?(?3,sk2IDR,T )e?(?4,sk3IDR,T  ) and m =  H4(t)? ?1.

2) If e?(?7, g) = e?(g1, g2)e?(H1(IDS), ?5)e?(H2(T ), ?6)  e?(H3(m, t, ?1, ?2, ?3, ?4, ?5, ?6), ?2), returns m as the plaintext and aborts otherwise.

? Revoke: In each time period T , PKG updates the revo- cation list by performing RL = RL  ? {(?ID, T )}, where  ?ID denotes the leaf node associated with the user ID revoked in T .

It is obvious to observe the correctness of the above R- IBSC scheme. Then the security proof of the proposed R- IBSC scheme in terms of confidentiality and unforgeability are respectively given in the Theorems 1 and 2.

Theorem 1: [Confidentiality] If there exists an adversary, say A, who is able to break the IND-R-IBSC-CCA2 of the proposed R-IBSC scheme, then an algorithm, named as C, can be built to deal with the DBDH problem efficiently.

Proof. Given a binary coin ? randomly chosen from {0, 1}, a DBDH instance can be generated independent of C?s view.

Concretely, the tuple (X,Y, Z, e?(g, g)xyz) is returned if ? = 0, otherwise the tuple (X,Y, Z, e?(g, g)v) is output such that (X = gx, Y = gy, Z = gz) and x, y, z, v are selected from Z?p at random. The task of C is to guess the binary coin ? involved in the given DBDH instance.

Initial: C delivers the public key (g, {gi}i=1,2) to A such that (g1 = X, g2 = Y ). The target ID?R and T  ? is sent to H1 and H2 at some point respectively and that H1(ID) and H2(T ) are assumed to be asked before ID and T are used in any other queries respectively.

Phase 1: Besides two tables S,L, C should also maintain a binary tree BT to simulate the following oracles: ? H1 Queries. C randomly selects an index ? from {1, 2, ? ? ? , qH1} and maintains a table H1 to simulate the random oracle H1. After receiving an identity IDi (1 ? i ? qH1 ), C checks whether the item associated with IDi appears in H1 or not. If so, the corresponding item will be forwarded to A. Otherwise, C selects ui at    2332-7790 (c) 2016 IEEE. Personal use is permitted, but republication/redistribution requires IEEE permission. See http://www.ieee.org/publications_standards/publications/rights/index.html for more information.

This article has been accepted for publication in a future issue of this journal, but has not been fully edited. Content may change prior to final publication. Citation information: DOI 10.1109/TBDATA.2017.2697448, IEEE Transactions on Big Data  8 JOURNAL OF LATEX CLASS FILES, VOL. 6, NO. 1, JANUARY 2007  random from Z?p and calculates  H1(IDi) =  { gui1 , i 6= ?; gu? , i = ?.

After inserting the item (IDi, ui) into the table H1, C returns H1(IDi) as the answer to A.

? H2 Queries. C randomly selects an index ? from {1, 2, ? ? ? , qH2} and maintains a table H2 to simulate the random oracle H2. After receiving a time period Tj (1 ? j ? qH2 ), C checks whether the item associated with Tj appears in the tableH2 or not. If so, the corresponding item will be forwarded to A. Otherwise, C randomly selects vj from Z?p and calculates  H2(Tj) =  { g vj 1 , j 6= ?; gv? , j = ? .

After inserting the entry (Tj , vj) in the list H2, C returns H2(Tj) as the answer to A.

? H3 Queries. C maintains a table H3 to simu- late the random oracle H3. Once receiving a query (m, t, ?1, ?2, ?3, ?4, ?5, ?6), C first searches the table H3 to check whether the item associated with this query has already been inserted into the table H3 or not. If not, C selects ? from Z?p randomly, calculates h3 = g?1 as the answer and inserts (m, t, ?1, ?2, ?3, ?4, ?5, ?6, ?, h3) into the table H3. Otherwise, C responds A with the existing h3.

? H4 Queries. C maintains a table H4 to simulate the ran- dom oracle H4. Once receiving a query t, C first searches the table H4 to check whether the item associated with this query has already been inserted into the table H4 or not. If not, C randomly chooses h4 ?R {0, 1}? randomly, computes H4(t) = h4 as the answer and inserts (t, h4) into the table H4. Otherwise, C responds A with the existing h4.

? Initial-Private-Key-Extract Queries: On receiving IDi, C selects a leaf node ?IDi from BT at random and binds IDi with ?IDi . With respect to each ? ? Path(?IDi), C responds as follows:  ? In case i 6= ?, C selects xIDi?2 at random from Z?p and simulates the initial private key (dIDi?1 , d  IDi ?2 ) by  assigning rIDi = ? y ui  + r?i where r ? i ?R Z?p. Thus,  (dIDi?1 , d IDi ?2 ) is calculated such that d  IDi ?1 = g  ?xIDi?2 2 ?  g uir ? i  1 and d IDi ?2 = g  ? 1ui 2 ? gr  ? i . Furthermore, C stores  xIDi?2 in the node ?.

? Otherwise, C selects xIDi?1 randomly from Z?p and cal-  culates (dIDi?1 , d IDi ?2 ) such that d  IDi ?1 = g  x IDi ?1  2 ?gu?rID? and dIDi?2 = g  rID? , where rID? ?R Z?p. C then stores xIDi?1 in the node ?.

After setting L = L ? {IDi}, C returns (dIDi?1 , d  IDi ?2 )  ??Path(?IDi ) as the answer.

? Update-Key-Extract Queries: Whenever receiving a  query (IDi, Tj), C responds for each node ? ? KeyUpdateNode(BT,RL, Ti) as follows:  ? In case i 6= ?, C extracts xIDi?2 associated with ? and selects sIDi? from Z?p at random. After that, the challenger computes (d?IDi?1 , d?  IDi ?2 ) such that d?  IDi ?1 =  g x IDi ?2  2 ? (H2(Ti))s IDi ? and d?IDi?2 = g  s IDi ? .

? Otherwise, C aborts if j = ? . Otherwise, C recalls xIDi?1 from the node ? and sets sIDj = ?  y vj  + r?Tj where r?Tj ?R Z  ? p. C then calculates (d?  IDi ?1 , d?  IDi ?2 )  such that d?IDi?1 = g ?xIDi?1 2 ? g  vjr ? Tj  1 and d? IDi ?2 = g  ? 1vj 2 ?  g r?Tj . Furthermore, C stores xIDi?1 in the node ?.

C sets S = S ? {Tj} and returns (d?IDi?1 , d?  IDi ?2 ) as the  answer for ? ? KeyUpdateNode(BT,RL, Ti).

? Full-Private-Key-Derive Queries: On receiving (ID, T ), C obtains the full private key by querying the Initial- Private-Key-Extract and Update-Key-Extract oracles in case IDR 6= ID? or T 6= T? . Otherwise, C aborts.

? Unsigncryption Queries: When A queries the ciphertext ? = (?1, ?2, ?3, ?4, ?5, ?6, ?7) associated with identity IDR and IDS within time period T , C can answer the query by carrying out the Unsigncryption algorithm in case IDR 6= ID? or T 6= T? . If IDR = ID? and T = T? , C can obtain skIDS ,T and step through the table H4 with items (t, h4) as follows. C computes m = ?1 ? h4 and sets h3 = H3(m, t, ?1, ?2, ?3, ?4, ?5, ?6) in case (m, t, ?1, ?2, ?3, ?4, ?5, ?6, ?, h3) ? H3. C then checks whether t ?= e?(g2, ( ?7sk1IDS,T  )1/?) or not. If this equation does not hold, C moves to the next item in H4 and scan the table H4 again. Otherwise, C checks whether e?(?7, g)  ?

=  e?(g1, g2)e?(H1(IDS), ?5)e?(H2(T ), ?6)e?(H3(m, t, ?1, ?2, ?3, ?4, ?5, ?6), ?2) holds or not. If not so, C moves to the next item in H4 and scans the table H4 again.

Otherwise, C returns m as the answer.

Challenge: In this phase, A will submit (m?0,m?1) as well as (ID?R, T  ?) to be challenged, where ID?R /? L and T ? /? S . C checks whether ID?R 6= ID? or T ? 6= T? , if so C aborts. Otherwise, C first makes the Full-Private- Key-Derive query on (ID?S , T  ?) to obtain skID?S ,T? = (sk1ID?S ,T?  , sk2ID?S ,T? , sk3ID?S ,T?  ) and tosses a coin by selecting ? from {0, 1} randomly. The simulated ciphertext is generated as ??1 = m  ? ??P ?, ??2 = gk, ??3 = H1(ID?)k, ??4 = H2(T ?)k,  ??5 = sk ID?S ,T  ? , ??6 = sk ID?S ,T  ? and ??7 = sk ID?S ,T  ? ? H3(?  ? 1 , ? ? 2 , ? ? 3 , ? ? 4 , ? ? 5 , ? ? 6 , ID  ? S , ID  ? R, T  ?)k. We note that if P ? = e?(g, g)xyz , if we let k = z, then ??1 = m  ? ??e?(g, g)xyz =  m?? ? e?(g1, g2)z , ??2 = gz , ??3 = H1(ID?)z = gu?z , ??4 = H2(T  ?)z = gv?z , ??5 = sk ID?S ,T  ? , ??6 = sk ID?S ,T  ? and ??7 = sk  ID?S ,T  ? ?H3(??1 , ??2 , ??3 , ??4 , ??5 , ??6 , ID?S , ID?R, T ?)z .

Phase 2: This phase is similar to the phase 1 and satisfies  (ID?, T ?) /? S.

Guess: Once receiving ?? from A, C returns 0 as the answer  for ? if ?? = ?, otherwise returns 1 as the answer.

Theorem 2: [Unforgeability] If there exists an adversary F  breaking the EUF-R-IBSC-CMA of the proposed R-IBSC scheme, then an algorithm C can be built to deal with the CDH problem efficiently.

Proof. Given {g, gx, gy} as a random CDH instance, the purpose of C is to output gxy such that x, y are selected from Z?p at random.

2332-7790 (c) 2016 IEEE. Personal use is permitted, but republication/redistribution requires IEEE permission. See http://www.ieee.org/publications_standards/publications/rights/index.html for more information.

This article has been accepted for publication in a future issue of this journal, but has not been fully edited. Content may change prior to final publication. Citation information: DOI 10.1109/TBDATA.2017.2697448, IEEE Transactions on Big Data  SHELL et al.: BARE DEMO OF IEEETRAN.CLS FOR COMPUTER SOCIETY JOURNALS 9  Initial: The simulator C sets (g1 = gx, g2 = gy) and delivers (g, g1, g2) to F as the public key.

Attack: Besides a table S, C maintains a binary tree BT to simulate the following oracles: ? H1, H2, H3, H4, Initial-Private-Key-Extract, Update-  Key-Extract and Full-Private-Key-Derive Queries.

These oracles are identical to those in the IND-R-IBSC- CCA2 game.

? Signcryption Queries: When F queries the plaintext m associated with identity IDR and IDS within time period T , C can respond this query by carrying out the Signcryption algorithm in case IDS 6= ID? or T 6= T? .

If IDS = ID? and T = T? , C simply aborts.

Forgery: During this stage, F outputs a forged ciphertext ?? = (??1 , ?  ? 2 , ? ? 3 , ? ? 4 , ? ? 5 , ? ? 6 , ? ? 7) on (m  ?, T ?) under the identity ID?S and ID  ? R, where ID  ? S /? L and T ? /? S. If  ID?S 6= ID? or T ? 6= T? , C aborts. Otherwise, the submitted ?? is valid since  e?(??7 , g) = e?(g1, g2)e?(H1(ID ? S), ?  ? 5)e?(H2(T  ?), ??6)  ?e?(H3(??1 , ??2 , ??3 , ??4 , ??5 , ??6 , ID?S , ID?R, T ?), ??2)  It is obvious that  e?(gx, gy) = e?(??7 , g)e?(H1(ID ? S), ?  ? 5) ?1e?(H2(T  ?), ??6) ?1  ?e?(H3(??1 , ??2 , ??3 , ??4 , ??5 , ??6 , ID?S , ID?R, T ?), ??2)?1  According to our setting, gxy = ??7 ? (??5)?u ? ? (??6)?v  ? ? (??2)  ??? can be calculated as the solution of the given CDH instance.

C. Our R-IBSC Scheme with Verifiable Outsourced Unsign- cryption  Based on the above scalable R-IBSC scheme, we present a R-IBSC scheme with verifiable outsourced unsigncryp- tion (shorten as R-IBSC-VOU). The Setup, IniKeyGen, KeyUpdate, KeyDer, Signcrypt, Unsigncrypt, and Revoke algorithms are identical to those in the R-IBSC scheme exactly.

The remaining algorithms are depicted as follows.

? Setup.out: On input the receiver?s private key skIDR,T ,  this algorithm first selects z ?R Z?p at random and computes sk?IDR,T = (sk  IDR,T  , sk21IDR,T , sk IDR,T  ) =  ((sk1IDR,T ) 1/z, (sk2IDR,T )  1/z, (sk3IDR,T ) 1/z). It then  sets the transformation key tkIDR,T as sk ? IDR,T  and the corresponding retrieving key rkIDR,T as z. Lastly, it computes String=(K1,K2,K3,K4) = (e?(g, g), e?(g1, g2), e?(H1(IDS), g), e?(H2(T ), g)).

? Ciphertext.ran: On input a ciphertext ?, this algorithm randomly chooses u, v, w from Z?p and calculates the randomized ciphertext ?? = (??2, ?  ? 3, ? ? 4, ? ? 5, ? ? 6, ? ? 7) =  (?2, ?3, ?4, ?5 ? gu, ?6 ? gv, ?7 ? gw).

? Transform.out: On input the public system parame-  ters, a randomized ciphertext ??, a transformation key sk?IDR,T , the sender?s identity IDS and time peri- od T , this algorithm is performed to compute the transformed ciphertext ??? = (K0,K5,K6,K7) =  ( e?(??2,sk  IDR,T  )  e?(??3,sk IDR,T  )e?(??4,sk IDR,T  ) , e?(??7, g), e?(?  ? 5, H1(IDS)),  e?(??6, H2(T ))).

? Unsigncrypt.out: Taking as input the public system parameters, the retrieving key z, a normal ciphertex- t ? and a transformed ciphertext ???, the outsourcing unsigncryption algorithm computes t = Kz0 , m = H4(t) ? ?1. If K5 = Kw1 ? K2 ? K6 ? K?u3 ? K7 ? K?v4 ? e?(H3(m, t, ?1, ?2, ?3, ?4, ?5, ?6), ?2) holds, it out- puts m. It returns ? otherwise.

Theorem 3: [Privacy] Suppose that the basic R-IBSC scheme is adaptively CCA privacy preserving, then the above R-IBSC-VOU scheme is also adaptively CCA secure.

Proof. If there exists an adversary A who attacks the above R-IBSC-VOU scheme successfully in the adaptively CCA secure model, then an algorithm B can be built to attack the basic R-IBSC scheme in the adaptively CCA secure model.

Suppose that C is the challenger associated with B in the adaptively CCA-secure game of the basic R-IBSC scheme. A is invoked by B as follows.

Initial: The simulator B sets (g1 = X, g2 = Y ) and delivers (g, g1, g2) to A as the public key.

Phase 1: B maintains three initially empty tables S, L and T as well as a binary tree BT to simulate the following oracles: ? H1, H2, H3, H4, Initial-Private-Key-Extract, Update-  Key-Extract, and Full-Private-Key-Derive Queries.

These oracles are identical to those in the IND-R-IBSC- CCA2 game.

? Transform-Key-Extract Queries: On receiving (IDR, T ), B responds as follows.

? If IDR 6= ID? or T 6= T? , B knows the receiver?s private key skIDR,T in this time period. Then C can randomly select z from Z?p as the retrieving key and calculate sk?IDR,T = (sk  IDR,T  , sk21IDR,T , sk IDR,T  ) =  ((sk1IDR,T ) 1/z, (sk2IDR,T )  1/z, (sk3IDR,T ) 1/z) as the  transformation key.

? If IDR = ID? and T = T? , B chooses ran-  dom exponent rIDR , sIDR , z ?R Z?p and sets sk?IDR,T = (sk  IDR,T  , sk21IDR,T , sk IDR,T  ) = (gz2 ? H1(IDR)  rIDR ?H2(T )sIDR , grIDR , gsIDR ). Finally, B inserts the entry (IDR, T, sk?IDR,T , z) in a table T and returns the transformation key sk?IDR,T to A.

It is notable that B does not have the knowledge of the actual retrieving key x/z.

? Unsigncrypt.out Queries: WhenA queries a transformed ciphertext (K0,K5,K6,K7) and a normal ciphertext ? = (?1, ?2, ?3, ?4, ?5, ?6, ?7) associated with identity IDR and IDS within time period T , B responds as follows.

? If IDR 6= ID? or T 6= T? , B knows the receiver?s transformation key and retrieving key in this time period and can carry out the Unsigncryption.out algorithm directly.

? If IDR = ID? and T = T? , B can derive the secret key skIDS ,T of the sender and step through the table H4 with items (t, h4) as follows. B computes m = ?1 ? h4 and sets h3 = H3(m, t, ?1, ?2, ?3, ?4, ?5, ?6) in case (m, t, ?1, ?2, ?3, ?4, ?5, ?6, ?, h3) ? H3.

B then checks whether e?(g2, ?2)  ?

= K  1/z 2 or    2332-7790 (c) 2016 IEEE. Personal use is permitted, but republication/redistribution requires IEEE permission. See http://www.ieee.org/publications_standards/publications/rights/index.html for more information.

This article has been accepted for publication in a future issue of this journal, but has not been fully edited. Content may change prior to final publication. Citation information: DOI 10.1109/TBDATA.2017.2697448, IEEE Transactions on Big Data  10 JOURNAL OF LATEX CLASS FILES, VOL. 6, NO. 1, JANUARY 2007  not. If this equation does not hold, B moves to the next item in H4 and scan the table H4 again. Otherwise, B checks whether e?(?7, g)  ?

=  e?(g1, g2)e?(H1(IDS), ?5)e?(H2(T ), ?6)e?(H3(m, t, ?1, ?2, ?3, ?4, ?5, ?6), ?2) holds or not. If so, B returns m as the answer. Otherwise, B moves to the next item in H4 and scans the table H4 again.

Challenge: In this phase, A will submit (m?0,m?1) as well as (ID?R, T  ?) to be challenged such that ID?R /? L and T ? /? S.

B checks whether ID?R 6= ID? or T ? 6= T? , if so B aborts.

Otherwise, B forwards (m?0,m?1, ID?R, T ?) to C, who in turn returns a challenge ciphertext ?? associated with m??. Then B returns ?? to A as its challenge ciphertext.

Phase 2: This phase is similar to the phase 1 and satisfies (ID?, T ?) /? S.

Guess: B will return ??, which submitted by A, as the answer.

Theorem 4: [Verifiability] The R-IBSC scheme with ver- ifiable outsourced unsigncryption depicted above achieves verifiability against collusion and adaptive chosen message attack.

Proof. To prove that the R-IBSC scheme with verifiable out- sourced unsigncryption achieves verifiability against collusion and adaptive chosen message attack, we will demonstrate that the adversary can only convince an invalid ciphertext as valid with at most advantage 1p?1 . The following game is performed by the challenger C and the adversary F .

Initial: The simulator C sets (g1 = gx, g2 = gy) and sends the public key (g, g1, g2,K1,K2,K3,K4) to the adversary F .

Attack: C maintains an initially empty tables S as well as a binary tree BT to simulate the following oracles: ? H1, H2, H3, H4, Initial-Private-Key-Extract, Update-  Key-Extract, Transform-Key-Extract, Full-Private- Key-Derive, Signcrypt, and Unsigncrypt.out Queries.

These oracles are identical to those in the IND-R-IBSC- CCA2 game.

Forgery: The adversary F gives (m?, ID?S , T ?) to be chal- lenged, where ID?S /? L and T ? /? S. C randomly chooses k? ?R Zp and four elements ??3 , ??4 , ??5 , ??6 ?R G, and computes t = e?(g1, g2)k  ? , ??1 = m  ? ? H4(t), ??2 = gk ? ,  ??7 = (H ? 3) k? , where H3(m?, t, ??1 , ?  ? 2 , ? ? 3 , ? ? 4 , ? ? 5 , ? ? 6) = H  ? 3.

After that, C randomly chooses u?, v?, w? ?R Z?p and com- putes the blinded ciphertext ?? = (??2, ?  ? 3, ? ? 4, ? ? 5, ? ? 6, ? ? 7) =  (??2 , ? ? 3 , ? ? 4 , ? ? 5 ?gu  ? , ??6 ?gv  ? , ??7 ?gw  ? ) and K1 = e?(g, g), K2 =  e?(g1, g2), K3 = e?(H1(ID?S), g), K4 = e?(H2(T ?), g), and  delivers ?? to the adversary. Then F returns K?0 ,K?5 ,K?6 ,K?7 to the challenger.

We will demonstrate that K?5 = K w?  1 ?K2 ?K?6 ?K?u ?  3 ?K?7 ? K?v  ?  4 ? e?(H ?3, ??2) happens with advantage 1p?1 . Obviously, we can rewrite the equations ??5 = ?  ? 5 ? gu  ? , ??6 = ?  ? 6 ? gv  ? and  ??7 = ? ? 7 ? gw  ? as follows.

DLg? ? 5 = DLg?  ? 5 + u  ?  DLg? ? 6 = DLg?  ? 6 + v  ?  DLg? ? 7 = DLg?  ? 7 + w  ?  Number of revoked users 0 100 200 300 400 500 600 700 800 900 1000  O ve  rh ea  d of  u pd  at ed  in fo  rm at  io n             Wei et al's scheme Ye et al's scheme Sign-then-Encrypt approach Our scheme  Fig. 4: Overhead of PKG with regard to the number of revoked users.

It is obvious to see that the adversary can only recov- er (??5, ?  ? 6, ? ? 7) with probability  p?1 due to the fact that  (u?, v?, w?) are chosen randomly from Z?p. Moreover, we can rewrite K?5 = K  w?  1 ?K2 ?K?6 ?K?u ?  3 ?K?7 ?K ?v? 4 ? e?(H ?3, ??2)  as follows:  DLe?(g,g)( K?5  K?6K ?  ) = w? ?DLe?(g,g)K1 +K2  ?u? ?DLe?(g,g)K3 ? v? ?DLe?(g,g)K4 +DLe?(g,g)e?(H  ? 3, ? ? 2)  Thus, the adversary can only generate a triple (K?5 ,K ? 6 ,K  ? 7 )  satisfying the above equation with probability 1p?1 since w ? ?  DLe?(g,g)K1 + K2 ? u? ? DLe?(g,g)K3 ? v? ? DLe?(g,g)K4 + DLe?(g,g)e?(H  ? 3, ? ? 2) is a random element in Z?p.



VI. COMPARISON  The comparison between our normal R-IBSC scheme, the outsourceable R-IBSC scheme, the only known ID-based sign- cryption schemes for big data [28], [29]1, and the signature- then-encryption approach with respect to security and efficien- cy is shown in this section. The up-to-date revocable ID-based encryption scheme and revocable ID-based signature scheme due to Seo and Emura [43] have been used to instantiate the signature-then-encryption approach. We summarize the security properties and key update complexity of different schemes in Table I, where the entry X, ? and ? indicates ?satisfy?, ?not satisfy? and ?not provided? respectively. The comparison demonstrates that only our scheme meets all of the desirable security properties, while the other schemes only own partial properties. We let SM, E, and P stand for the time  1To achieve compatibility, the Schnorr-based one-time signature in [58] is adopted to instantiate the one-time signature in [28].

2332-7790 (c) 2016 IEEE. Personal use is permitted, but republication/redistribution requires IEEE permission. See http://www.ieee.org/publications_standards/publications/rights/index.html for more information.

This article has been accepted for publication in a future issue of this journal, but has not been fully edited. Content may change prior to final publication. Citation information: DOI 10.1109/TBDATA.2017.2697448, IEEE Transactions on Big Data  SHELL et al.: BARE DEMO OF IEEETRAN.CLS FOR COMPUTER SOCIETY JOURNALS 11  TABLE I: Comparison of different schemes  Schemes Computational cost Security Ciphertext size Out Ciphertext size Signcrypt Unsigncrypt IND-CCA2 EUF-CMA Revocable (bits) (bits)  Wei et al.?s scheme [28] 6SM+E+P 2E+10P X X ? 5056 0 Ye et al.?s scheme [29] 6SM+P 4P ? ? ? 640 0 Seo et al.?s scheme [43] 9SM+E 7P ? X X 2144 0  Our normal R-IBSC 3SM+E 7P X X X 1120 0 Our outsourceable R-IBSC 4SM+E 6SM+E+P X X X 1120 960  TABLE II: Time cost of cryptographic operation (in milliseconds)  Operations Data generator Analytical system Exponential in Fp2 950 2.84  Scalar multiplication in G 950 11.88 Pairing 1900 25.10  to compute the scalar multiplication in G, the exponentiation in GT and the pairing computation respectively. We assume that |G| = 160 bits, |GT | = 1024 bits, and |m| = 160 bits. It is fair to ignore the non-dominant operations and the auxiliary message, i.e., time period or entity identifier.

It is noted that our outsourceable scheme needs an extra outsourcing ciphertext with 960 bits.

As for the overhead of PKG in computing and issuing key updates, our scheme and signature-then-encryption approach [43] achieve a significant improvement over the solutions in [28], [29] supposing r ? n/2 and is particularly appropriate in the big data era. Here, n and r denotes the number of users and the number of revoked users, respectively. For the case r > n/2, the key update complexity of our scheme is identical to the schemes in [28], [29], whereas our scheme can be reloaded to ensure efficient key update. The observations from Fig. 4 demonstrate that our proposed scheme is the first IBSC scheme featured with efficient revocation functionality.

To assess the computational efficiency, a 2.4-GHz Intel i5 central processing unit installed with Windows XP OS is modeled as the hardware platform for the analytical system.

In this platform, the Tate pairing e? : G?G? GT established on the supersingular elliptic curve E/Fp : y2 = x3 + x is implemented based on the Standford PBC (Pairing-Based Cryptography) library [59]. To achieve the security level of 1024-bits RSA, the embedding degree of E/Fp is set to 2 and p is set to be some prime congruent with 3 mod 4. Here, G and GT denotes a group of points over the curve E/Fp and a subgroup of Fp2 respectively. The running time of the cryptographic operations, which are obtained by repeating the experiments 1000 times on Intel-core personal computer, are listed in Table II. As for the data generator, the simulation is conducted on a ATmega128L processor running at 7.3728 MHz equipped with 4 KB of EEPROM and 128 KB flash memory. Different from the analytical system, the ?T pairing is implemented with TinyPBC [60] in the environment for the data generator such that ?T : E/F2271 ? E/F2271 ? F24?271 .

According to [61], [62], the running time of the cryptographic operations on the sensor node is also listed in Table II.

Based on the methods introduced in [63], [64], [66], [65], the computation cost of different schemes can be evaluated as follows. For example, in the unsigncrypting algorithm of Seo  Number of message to be signcrypted 0 10 20 30 40 50 60 70 80 90 100T  im e  co ns  um pt  io n  of d  at a  co lle  ct or  o n  co m  pu ta  tio n  (m s) ?105             Wei et al.'s s scheme Ye et al.'s s scheme Seo et al.'s scheme Our normal scheme Our outsourceable scheme  Fig. 5: Computation cost of data collector.

and Emura?s approach [43], seven pairings are required by the analytical system, and thus the computation time of analytical system is 7 ? 25.10 = 175.7 ms. Fig. 5 shows the time consumption on computation of data collector to signcrypt a message in Wei et al.?s scheme, Ye et al.?s scheme, Seo et al.?s scheme and our schemes. It is obvious that our scheme achieves a much lower time consumption comparing with Seo et al.?s scheme. Fig. 6 illustrates the time consumption on computation of analytical system to unsigncrypt a ciphertext in Wei et al.?s scheme, Ye et al.?s scheme, Seo et al.?s scheme our normal R-IBSC scheme and our outsourceable R-IBSC scheme. From Fig. 6, we can observe that our outsourceable R-IBSC scheme dramatically reduces the time needed to un- signcrypt the transformed ciphertext comparing to our normal R-IBSC scheme and existing schemes [28], [29], [43].



VII. CONCLUSION Motivated by the practical and operational needs to provide  secure communication for big data in a cloud computing de- ployment, we proposed a novel ID-based signcryption scheme with efficient revocation and unsigncryption outsourcing. This is, as far as we know, the first ID-based signcryption scheme to provide both efficient revocation and unsigncryption out- sourcing. We then proved the security of the proposed scheme in the random oracle model. Extensive experimental results also demonstrated the utility of the proposed scheme.

There are many direct and interesting open problems. By considering the defects of random oracle model, one interest- ing open problem is to design revocable ID-based signcryption    2332-7790 (c) 2016 IEEE. Personal use is permitted, but republication/redistribution requires IEEE permission. See http://www.ieee.org/publications_standards/publications/rights/index.html for more information.

This article has been accepted for publication in a future issue of this journal, but has not been fully edited. Content may change prior to final publication. Citation information: DOI 10.1109/TBDATA.2017.2697448, IEEE Transactions on Big Data  12 JOURNAL OF LATEX CLASS FILES, VOL. 6, NO. 1, JANUARY 2007  Number of ciphertexts to be unsigncrypted 0 10 20 30 40 50 60 70 80 90 100  T im  e co  ns um  pt io  n of  a na  ly tic  al s  ys te  m o  n co  m pu  ta tio  n (m  ss )  ?104   0.5   1.5   2.5   Wei et al.'s scheme Ye et al.'s scheme Seo et al.'s scheme Our normal scheme Our outsourceable scheme  Fig. 6: Computation cost of analytical system.

scheme secure in the standard model. It is also interesting to eliminate the expensive bilinear pairing operation in the revocable ID-based signcryption scheme. Finally, future work also includes prototyping the proposed scheme for evaluation in a real-world environment.

