A Fast Algorithm for Mining association Rules Based  on Boolean Matrix

Abstract?The discovery of association rules in data mining is an important issue, the core of which is the frequent pattern mining, Apriori algorithm is classical for the association rule mining, but it should repeatedly scan the database and can produce plenty of candidates. By examples, it is proved that Boolean Matrix Association Rules algorithm can improve the algorithmic efficiency by reducing the times of accessing database and without producing candidates.

Keywords-data mining; association rule; boolean matrix; frequent itemset

I. INTRODUCTION Association rule mining could discovery interesting  associations or dependency relations between item sets among mass data. Generating frequent item sets is the first step of association rule mining.  In most practices of association rule mining, people usually adopt Apriori algorithmic that was put forward by R.Agrawal in 1994 [1]. The algorithmic has a great disadvantage---it generating frequent item sets by repeatedly scanning the database, producing plenty of candidates and then testing the candidates, the cost of generating candidates is large[2]. This paper put forward a completely new algorithmic based on Boolean matrix, its advantage is save time, it only need scan the database once and need not generate vast candidates and frequent item sets. This algorithmic could find the maximum frequent item sets which meet the minimum support in short time through the operation of vector and matrix.



II. ESSENTIAL CONCEPT Association rule [3]: Suppose I = {I1,I2, ,Im}, and I is a  aggregate of items. Suppose date D with which task related is an aggregate of database transactions, and each of the transaction T is an aggregate of items and IT . Every transaction has an id, called TID. Association rule is a implication as BA , and IA , IB , BA .

Support s: the support which rule BA  in the transaction sets D is the percent that transaction D contain  BA , it is probability )( BAP , express it as )()(sup BAPBAport .

Confidence c: the confidence which rule BA  in the transaction sets D is the percent of transaction that contain B as well as A, it is conditioned probability )|( ABP , express it as  )(sup )(sup  )( )()|()(  Aport BAport  AP BAP  ABPBAconfidence .

Strong association rule: suppose there is a transaction sets D, association rule mining is generating association rule whose support is bigger than minimum support and confidence is bigger than minimum confidence. The rule is called strong association rule.

The task of association rule mining is mining all of the strong association rules in the transaction database D. The item set BA  which strong association rule BA corresponding sure is frequent sets. The confidence of association rule BA , which could be enduced by frequent sets, could be computed by the support of frequent sets A and the support of BA . Therefore, we can compartmentalize association rule mining into two sub-questions:  1) Find all frequent sets in the data sets D : according to the definition , the frequent of each item must at least as big as scheduled minimum support .

2) Generate strong association rule according to the frequent itemsets: according to the definition , the rules must at least as big as the minimum support and minimum confidence.

The task of the first sub-question is find all frequent item sets in D effectively, it?s the core question of association rule mining and the criterion of weighing association rule mining; It?s easier to solve the second sub-question using the definition of minimum confidence. At present, all association rule mine algorithms presented aim at the first sub-question which decide the capability of the algorithms.

Inner product: according to the definition of inner product of vectors in algebra , for any two m dimensional vectors  and =(y ,y ,?,y ), the inner product of  and  can be denoted as m  i ii yx  ,  .



III. BOOLEAN MATRIX OF THE TRANSACTION DATABASE For any supposed transaction database D [5], suppose:     RDf :                                                            (1)  nmijrDfR )()(  and j  j ij TIi  TIi r   i=1,2, ,m;  j=1,2, ,n.

Database D can be mapped on the Boolean matrix R with the effect of f by scanning the database only once. For example, table 1 is a transaction database D; it can be mapped on the Boolean matrix R as (2).

TABLE I. TRANSACTION DATABASE  TID Item sets T1 I1,I3,I6 T2 I3,I4,I7 T3 I1,I2,I5 T4 I3,I5,I7 T5 I1,I3, I5,I6 T6 I4,I5 T7 I3,I5,I6,I7 T8 I1,I6 T9 I2,I3 ,I4     R  (2)

IV. THE DESCRIPTION OF THE ALGORITHM OF ASSOCIATION RULE MINING BASED ON BOOLEAN MATRIX  If transaction database D correspond to Boolean matrix R, and TnR ),,,( 21 , where T mean transposition and  is m dimensional row vectors in real field and I = 1,2, ,n.

Suppose I={I1,I2, ,Im}is a sets composed by m different items that in D. If a subsets of I, ITp , is a k-frequent item sets in database D, and Tp is mapped as m dimensional row vectors according (1), and then [4]:  ki ,, , i=1,2,?,n                  (3)  Though the analysis, the corresponding Boolean matrix of any transaction database by scanning the database can be obtained only once. Therefore the mining for databases can be translates into the analysis of its Boolean matrix. For some group of the database D must include item sets that included in every frequent item sets, according to (3), m dimensional row vector to which frequent item sets in database D correspond make inner product with each row vector of Boolean matrix R, and the sum of the inner product could not exceed the size of the frequent item sets. So we can multiply Boolean matrix R by its transpose RT, and the result can be denote as T. Apparently, T is a n factorial symmetric matrix, denote its upper triangular matrix as T (show as (4)), and then tij(i = 1,2, ,n; j = 1,2, ,n  and i j) in T are the values of ji , ,and there are not computed repeatedly.

nn  n  n  t  tt ttt  T 222  (4)  Find the maximal number in T and denote it as k, k must on the leading diagonal, for according to (3) we know that if  kji ,  and k get the maximal value, then ji ,  must equal to k. If the number of elements which  are bigger than or as big as k in i row of T: >=Minsup, then the row vector is the possible row to which k-frequent sets that meet the minimum support corresponding, and vectors  ),,,,( 21 jjji  show that the elements in the jjj ,,, 21 columns of i row which is in T are bigger than  or as big as k, where  is the number of elements which meet the condition; If numbers of elements which is bigger than or equal to k in every row vectors are smaller than the minimum support Minsup, then there are not k-frequent sets that meet the minimum support; then find the sub-maximum denote as (k- 1).As the same reason (k-1) must be on the leading diagonal. If numbers of elements which is bigger than or equal to (k-1) in every row vectors are smaller than the minimum support Minsup, then there are not (k-1)-frequent sets that meet the minimum support; then find the next sub-maximum denote as (k-2) in T. Repeat it until all (k-x)-frequent sets are found that meet the minimum support. Through the record of the vector  ),,,,( 21 jjji , operation of logical and using any Minsup vectors can be made that are not repeat in  jjj ,,, 21 , and reserve the results in which the number of elements of nonzero equal to the maximum (k-x), the items to which the elements of nonzero correspond are the requested (k- x)-frequent sets.

According to above, we can obtain a upper triangular matrix T through the product of Boolean matrix R and its transport matrix RT, then we get the times that the maximum of T emerged in each row, if there is a row meet the minimum support, then find the k-frequent sets immediately. It?s not necessary to find 1-frequentsets, and then 2-candidatesets, and then link and cut it until find k-frequent sets. If there is a request of getting 1-frequentsets, 2-frequentsets, (k-x-1)- frequent sets, we could get them using the same algorithm. The steps are described as follow:  1) Scanning the transaction database D, building corresponding Boolean matrix TnR ),,,( 21 , providing the expected minimum support Minsup.

2) Computing and obtaining the matrix T, finding the maximum k on the leading diagonal (t11,t22,?,tnn) ,scanning each row of T,computing the number  of elements whose value is bigger than or equal to k in every row, then judging whether Minsup is tenable or not.

3) If it is tenable,then the row is the possible row to which k-frequentsets correspond and record the vector  ),,,,( 21 jjji ,and then continually scanning, computing the number  of elements whose value is bigger than or equal to k in every row, then judging whether Minsup is tenable or not.

4) If the scanning is end and  of each row is smaller than Minsup,then find the sub-maximum k-1 on the leading diagonal (t11,t22,?,tnn) from T , then repeat step(2) until finding the right row.

5) At last , analyze the vector ),,,,( 21 jjji in which the frequent item sets meet the condition in turn , making operation of logical AND using any Minsup vectors that are not repeat in jjj ,,, 21 ,and then obtaining the frequent itemsets that meet the minimum support by judge.



V. EXPERIMENT EVOLUTION In order to explain the algorithm directly, let us take the  table 1 for example, its Boolean matrix is R, denoting as T  nR ),,,( 21 . Suppose the minimum support Minsup = 2. At first we obtain the computed matrix T that is:   T  The second step is sort the elements )2,2,4,2,4,3,3,3,3(  on the leading diagonal of T , getting the maximum 4 , scanning every row of T in turn , computing the number  of elements whose value is bigger than or equal to 4 in every row, then judging whether  Minsup is tenable or not. Apparently, in the fifth row of T, 55t  = 4, denoting it as 5 (5,1) , there  =1<Minsup and in the seventh row, 77t =4 denoting it as  7 (7,1) , there =1<Minsup as well, so the fifth row and the seventh row are not the possible row existing 4- frequentsets, that is there doesn?t exist 4-frequentsets whose frequencies are bigger than or equal to 2. The third step is begin with the second step, Finding the sub-maximum 3 on the leading diagonal of T, then scanning each row in turn, computing the number  of elements whose value is bigger than or equal to 3 in every row, then judging whether Minsup is tenable or not. Apparently, in the first row of T,  1511 tt =3, denoting it as 1 (1,5,2)  , there =2=Minsup , in the fourth row , 4744 tt = 3 denoting it as  4 (4,7,2) ,there =2=Minsup and in the fifth row , 3,4 5755 tt , denoting is as 5 (5,7,2) ,there =2=Minsup  . The three row are all meet the condition that the frequencies are bigger than or equal to 2 .The fourth step is finding the 3-  frequentsets through logical AND. The detailed method is show as follow: For 1 (1,5,2) , it is need to calculate logical AND for any two vectors in { , As there are only two vectors in { ,  it is only need to calculate logical AND directly: 51 = (1 0 1 0 0 1 0). In the result, there are 3 nonzero elements. It is meet the condition of 3-frequentsets.

631 III  is the right 3-frequentsets for the positions to which the nonzero elements correspond are 1,3,6 ; As the same reason , 753 III  can be get from the result of 74  and  653 III  can  be get from the result of 75 .At last the 3- frequentsets are get : 631 III 753 III 653 III . The 2-frequentsets could be getting in the same way. Scanning each row of T in turn, computing the number of elements whose value is bigger than or equal to 2 in each row. If  Minsup is true, then the row is the possible row that exist 2- frequentsets, recording it as 1 2( , . , )i j j j , making operation of logical AND using any 2 vectors that are not repeat in jjj ,,, 21 , and then obtaining the requested 2- frequentitemsets. The result is the same as the result computing by Aprior algorithm, and using this algorithm it only need scanning database once without generating plenty of candidate item sets, improving the efficiency of the algorithm.



VI. CONCLUSION Association rule mining is a very important problem in the  field of data mining. This paper put forward a algorithm of association rule mining that can reduce the times of accessing database and need not to generate candidate item sets based on Boolean matrix for Apriori algorithm need to generate plenty of candidate item sets. The new algorithm need to scan the database only once and as the structure of the Boolean matrix is simple, it can be understood easily, and it is easy to compute without generating plenty of candidate item sets; For the databases are translate into files of matrix and the files are very small, it reduce plenty of time spending on scanning the database .So the algorithm is efficient ordinarily, but when  supMin , the efficiency of the algorithm will reduce.

REFERENCE [1] Agrawal R ,Srikant R. Fast Algorithm for Mining Associa2 tion rules[A]  . In :Proceedings of the 20th International Con2 ference on VLDB[C] .

Santiago ,Chile :1994 :487 499.

[2] Liu Saxing , Tan Liqiu , Xiong Yongjun. A Study on Association Rules Mining Algorithm and Its Application[J]. Engineering and Computer Science , 2007  [3] Jaiwei Han, Micheline Kamber.Data Mining Concepts and Techniques[M].Translating by Fan Ming,Meng Xiaofeng. Beijing :China Machine Press, 2007, 146-183  [4] Zhang Herui,Hao Bingxin.Advanced Algebra[M] Third Edition.Beijing:Higher Education Press,1993.

