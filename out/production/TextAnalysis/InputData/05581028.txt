AN ALGORITHM OF LOCATING ORDER MINING BASED ON SEQUENCE  NUMBER

Abstract: At present, existing association rules mining algorithms  have redundant candidate frequent itemsets and repeated computing. This paper proposes an algorithm of locating order mining based on sequence number, which is suitable for mining long frequent itemsets. In order to fast search long frequent itemsets, the algorithm adopts not only traditional down search, but also the method of locating order of subset to generate candidate frequent itemsets. It has two aspects, which are different from traditional down search mining algorithm. One is that the algorithm need locate order of subsets of non frequent itemsets via down search. The other is that the algorithm uses character of attribute sequence number to compute support for only scanning database once. The algorithm may efficiently delete repeated L-candidate frequent itemsets generated by (L+1)-non frequent itemsets via locating subsets? order, whose efficiency is improved. The result of experiment indicates that the algorithm is suitable for mining long frequent itemsets, and it is faster and more efficient than present algorithms of mining long frequent itemsets.

Keywords: Long frequent itemsets; Down search; Locating order;  Sequence number; Association rules  1. Introduction  In order to reduce redundant candidate frequent itemsets and the times of scanning database, people propose some mining algorithms, such as, IDMFIA as in [1]. In order to easily generate candidate frequent itemsets and fast compute support, some binary mining algorithms were presented, such as in [2, 3, 4, and 5]. B-Apriori as in [2] is faster than Apriori for binary logic operation, and B-ARDSM [3] is also faster than IDMFIA when double mining, and although ARNBSN as in [4] is faster than B-Apriori, it is only suitable for mining short frequent itemsets. ITDASN as in [5] is suitable for mining long frequent itemsets, but there are still redundant candidate frequent itemsets and repeated computing when mining algorithm generates L-candidate frequent itemsets of (L+1)-non frequent itemsets. And so, this paper proposes an  algorithm of locating order mining based on sequence number, denoted by ALOMSN, which is suitable for mining long frequent itemsets, and is faster and more efficient than ITDASN as in [5].

2. Base Notions and Properties  Definition 1 Binary Transaction (BT), there is a transaction T is expressed as character string (b1 b2?bm), bk ? [0, 1], k=1?m, if ik? T, and then bk =1, otherwise bk =0.

Example let I= {1, 2, 3, 4, 5, 6} be an itemsets, if a transaction is expressed as Ti= {2, 5, 6}, and then BTi= (010011).

Definition 2 Digital Transaction (DT), it is an integer, and its value is decimal integer of binary transaction.

Example if BT= (010010), and then DT=18.

Definition 3 Digital Item (DI), it is an integer, and it is  the simplest digital transaction which only expresses an item attribute.

Example let I= {i1, i2?im}, and then DI1=1? DIm = 2m-1.

Definition 4 Digital Transaction Length (DTL), it is an integer, it is equal to the sum of ?1? in Binary Transaction.

Definition 5 Suppose digital transaction of T1 is denoted by DT1, digital transaction of T2 is denoted by DT2. If T1 ? T2, and then DT1 ? DT2, DT1 is regarded as subset of DT2, which is regarded as superset of DT1.

Definition 6 Sequence Number (SN), it is a group of ordered number, here, these numbers may be repeated, and each number is called a sub-Item of sequence number.

Example let SN= {46, 124, 65, 125, 79, 62, and 112} be a sequence number, thereinto, 124 is called a sub-Item of Sequence Number.

Definition 7 Sub Item Dimension (SID), it is an integer, it is equal to the sum of ?1? in binary code of sub-Item.

Example, let 58 be a sub-Item, and then SID (58) = SID (111010)2=4.

Definition 8 Sequence Number Dimension (SND), it is an integer, it is equal to the sum of items? SID contained by          SN.

Example, let SN = {58, 30, 63, 121, 79, 63, and 109} be  a sequence number, and SND = SID (58) + SID (30) + SID (63) + SID (121) + SID (79) + SID (63) + SID (109) = 4 + 4 + 6 + 5 + 5 + 6 + 5 = 35.

Property 1 Let I= {i1, i2?ik}, if DTLm= DTLn =L-1, and then if and only if DTL (DTm | DTn) =L, the number of same items is (L-1) between DTm and DTn.

3. The mining algorithm based on sequence number  3.1. Data Structure and the Rule of Locating Order  Data Structure Candidate {  Int value; // saving DT Int length; //saving DTL Int LNo; // saving the value of locating order Int [] location=new int[m]; //saving the site of item  } CSet, NFSet According to Property 1, we may let the rule of location  order be expressed as follows: Rule Each (L-1)-subset of L-non frequent itemsets is  located only once when it is firstly generated from L-non frequent itemsets to (L-1)-subset, i.e. locating order of subset is only one when it is saved in CSet.LNo.

Example, here are two transactions 5-{61, 55}, DT=53 is not only 4-subset of 61, but also 4-subset of 55, obviously, it is the third time that 61 generates 53 when 61 generates its all 4-subsets, it is the second time that 55 generates 53 when 55 generates its all 4-subsets, and so, locating order of 53 is not 2 but 3 because 55 won?t generate 53 and needn?t judge according to these rules of generating subset in chapter 3.2.

3.2. The Key Technique of Generating Candidate Frequent Itemsets  The key technique is that the method of generating (l-1)-candidate frequent itemsets by locating subset?s order is used to down search frequent itemsets.

There are three problems to solve by the algorithm, which are expressed as follows:  (1)The algorithm need delete a specified item of l-non frequent itemsets.

(2)The algorithm need delete repeated (l-1)-candidate frequent itemsets of l-non frequent itemsets.

(3)The algorithm need delete redundant (l-1)-candidate frequent itemsets, which are subset of frequent itemsets or superset of non-frequent itemsets.

As we all known, presented algorithm is easy to solve the third problem. The algorithm uses the feature of locating  order to solve the rest problems, i.e. it can automatically delete an item of l-non frequent itemsets to generate (l-1)-candidate frequent itemsets, and then uses the relation between length and order of subset to delete repeated (l-1)-candidate itemsets.

Let I = {i1, i2?im} be an itemsets, and let ISet save digital item (DI), namely ISet[t] =2t (t=0?m-1). Suppose there are N l-non frequent itemsets, let NFSet save them, and let CSet save (l-1)-subset. Aiming to each NFSet[i] which saves i the first l-non frequent itemsets, these rules of generating subset are expressed as follows:  Rule 1 Aiming to each l-non frequent itemsets, namely NFSet[i], the sum of (l-1)-subset generated by NSet[i] is denoted by Sum =NFSet[i].length- NFSet[i].LNo.

Rule 2 when NFSet[i] generates j the first (l-1)-subset, if location identifier deleted by NFSet[i] is denoted by ID, and ID= NFSet[i].LNo + (j-1).

Rule 3 when NFSet[i] generates j the first (l-1)-subset, which is saved by CSet[j], and then value of its domain are expressed as follows:  CSet[j].value=NFSet[i].value&(~ISet[NFSet[i].location [ID]]); CSet[j].length=NFSet[i].length-1; CSet[j].LNo=NFSet[i].LNo + (j-1), namely ID; CSet[j].location [0... (CSet[j].length-1)]  =NFSet[i].location [0?ID-1, ID+1? (NFSet[i].length-1)].

Let {i1, i2?im} be a transaction, whose digital  transaction is denoted by CT, its information of data structure is expressed as follows:  CT.value=2m-1, CT.length=m, CT.LNo=0; CT.location [0] = 0?CT.location [m-1] = m-1.

The algorithm of generating (l-1)-candidate itemsets is  expressed as follows: Input: there are N l-non frequent itemsets, and these  itemsets are saved NFSet.

Output: there are C (l-1)-subsets, and these itemsets are  saved CSet.

Generate-Candidate(NFSet,CSet) (1) FOR(i=1; i?N; i++){ (2)   FOR(j=1;j?NFSet[i].length-NFSet[i].LNo);j++){ (3)        ID = NFSet[i].LNo + (j-1); (4)        CSet[++Count].value=NFSet[i].value&  (~ISet [NFSet[i].location [ID]]); (5)    CSet[Count].length = NFSet[i].length - 1; (6)    CSet[Count].LNo = NFSet[i].LNo +(j-1); (7)        FOR(k=0;k<ID;k++){  //Delteing ID the first item (8)        CSet[Count].location[M++] =  NFSet[i].location[k]; } (9)   FOR(k=ID+1; k<NFSet[i].length; k++){ (10)      CSet[Count].location[M++] = NFSet[i].location[k]; } (11)   M = 0;          (12)   } (13) }  3.3. The Key Technique of Computing Support  The method of computing support adopted by the algorithm is expressed as follows:  Step1: According to definition 1, the algorithm extracts Binary Transaction from original database.

Step2: Aiming to each item, its corresponding Binary code is turned into Sequence Number in subsection according to definition 6.

Step3: Aiming each candidate frequent itemsets, we knew that every item in candidate has own Sequence Number, and then we will use Boolean calculation compute these Sequence Number in turn, and finally the result is new Sequence Number.

Step4: Computing Sequence Number Dimension of the new Sequence Number according to definition 8. Its value is equal to support of candidate frequent itemsets.

For example, there are ten transactions in database. The course of computing support is expressed as follows:  Step1: Extracting Binary Transaction from database.

T1: {a, b, c, e, f},     BT1 = (111011)2; T2: {a, c, d, e, f},     BT2 = (101111)2; T3: {a, b, e, f},       BT3 = (110011)2; T4: {a, b, c},         BT4 = (111000)2; T5: {b, c, d, e, f},     BT5 = (011111)2; T6: {c, d, e, f},       BT6 = (001111)2; T7: {a, c, d, f},       BT7 = (101101)2; T8: {c, d, e},         BT8 = (001110)2; T9: {a, b, c, e, f},     BT9 = (111011)2; T10: {b, d, e, f},      BT10 = (010111)2; Setp2: Computing Sequence Number of each sub-Item  in database is expressed as table 1.

TABLE 1. COMPUTING SEQUENCE NUMBER  No. a b c d e f BT1 1 1 1 0 1 1 BT2 1 0 1 1 1 1 BT3 1 1 0 0 1 1 BT4 1 1 1 0 0 0 BT5 0 1 1 1 1 1 Item1 30 23 27 9 29 29 BT6 0 0 1 1 1 1 BT7 1 0 1 1 0 1 BT8 0 0 1 1 1 0 BT9 1 1 1 0 1 1 BT10 0 1 0 1 1 1 Item2 10 3 30 29 23 27  SN {30, 10} {23, 3}  {27, 30}  {9, 29}  {29, 23}  {29, 27}  Step3: Let C = {c, d and e} be a candidate frequent itemsets, and then Computing its support, denoted by Support  (C): SN ({c}) = {27, 30}; SN ({d}) = {9, 29}; SN ({e}) = {29, 23}; SN ({c, d, e}) = {27&9&29, 30&29&23}  = {9, 20}; Support (C) = SND ({9, 20})  = SND (9) + SND (20) = 2 + 2 = 4.

3.4. The Process of Search Frequent Itemsets  FSet: saving frequent itemsets (FI).

NFSet: saving NFI of searching down same length.

CSet: saving candidate frequent itemsets of searching  down same length.

Step1: The algorithm changes original transaction into  mining transaction, namely, original database is turned into D on descending by digital transaction according to definition 1 and 2.

Step2: The algorithm computes support of first candidate frequent itemsets which contain all item attributes, if it is frequent itemsets, and then it will be written to FSet, then algorithm goes to Step5. Otherwise, it will be written to NFSet.

Step3: The algorithm generates frequent itemsets. There are two parties as follows:  Firstly, the algorithm uses the function of Generate? Candidate(NFSet, CSet) to generate (l-1)-subsets of l-non frequent itemsets.

And then, aiming to each (l-1)-subsets of CSet, if it is not subset of FSet, then computing its support by chapter 3.3.

If it is a frequent itemset, then it is written to FSet, otherwise it is a non frequent itemsets which is written to NFSet.

Step4: The algorithm needs repeat doing Step3 until frequent itemsets isn?t generated by algorithm.

Step5: The algorithm output FSet.

4. Comparing the capability of algorithms  According to the content of reference [4] and [5], we knew that ARNBSN is more efficient than B-Apriori when mining short frequent itemsets, ITDASN is only suitable for mining long frequent itemsets. Hence, here we only compare ALOMSN with ARNBSN and ITDASN.

4.1. Analyzing the Capability of Algorithms  ARNBSN: The algorithm is similar to B-Apriori when generating candidate frequent itemsets, but the method of          computing support is computing Sequence Number Degree.

The algorithm only need scan once all these transactions and use Boolean calculation to compute this Sequence Numbers Degree, and so the efficiency of algorithm is improved efficiently. It is more efficient than B-Apriori, but it is only suitable for mining short frequent itemsets.

ITDASN: The algorithm is only suitable for mining long frequent itemsets since this down search strategy is adopted.

It uses the way of binary Boolean calculation to generate binary candidate frequent itemsets, and uses the method of computing Sequence Number Degree to obtain support of candidate frequent itemsets. But the algorithm have redundant candidate frequent itemsets and repeated computing when it generates L-candidate frequent itemsets of (L+1)-non frequent itemsets.

ALOMSN: The algorithm is also suitable for mining long frequent itemsets through down search. It also uses the method of computing Sequence Number dimension to obtain support of candidate frequent itemsets. The algorithm uses the way of binary Boolean calculation to generate binary candidate frequent itemsets, but the algorithm need locate order of subsets when it generates L-candidate frequent itemsets of (L+1)-non frequent itemsets, and so the algorithm is able to delete redundant candidate frequent itemsets and repeated computing to improve efficiency.

4.2. Comparing the Experiment of Algorithms  Now we use these results of experiment to testify above analyses. We use three mining algorithms to generate frequent itemsets from these transactions, their Binary Transactions are expressed as digital from 1 to 4095, there are 12 items attribute in database, i.e. m=12, N=4095.

Our experimental circumstances are expressed as follow: Intel(R) Celeron(R) M CPU 420  1.60 GHz, 1.24G, language of the procedure is Visual C# 2005.NET, OS is Windows XP Professional.

The result of generating frequent itemsets about algorithms ARNBSN and ALOMSN is expressed as Fig. 1, and the result of generating frequent itemsets about algorithms ITDASN and ALOMSN is expressed as Fig. 2, here is absolute support. As the support and length of frequent itemsets change, the runtime of ARNBSN and ALOMSN is expressed as Fig 3. As the support and length of frequent itemsets change, the runtime of ITDASN and ALOMSN is expressed as Fig 4.

Figure 1. The experimental result of ARNBSN and ALOMSN    Figure 2. The experimental result of ITDASN and ALOMSN    24(2) 12(3) 4.9(4) 2.4(5) 1.2(6) 0.9(7) 0.48(8) 0.24(9)  Support%(Length)  R un  tim e(  M ill  ise co  nd ARNBSN ALOMSN    Figure 3. Comparing runtime of ARNBSN and ALOMSN    Figure 4. Comparing runtime of ITDASN and ALOMSN  5. Conclusions  This paper proposes an algorithm of locating order mining based on sequence number, which is suitable for          mining long frequent itemsets. The result of experiment indicates that the algorithm is faster and more efficient than present algorithms of mining long frequent itemsets.

