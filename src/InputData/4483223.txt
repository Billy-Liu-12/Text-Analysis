On code generation for derived associations

Abstract  While the generation of executable code for explicit asso- ciations in UML models is well understood, it is less clear how executable code can be generated if the associations are derived. We discuss how this can be achieved for an important class of derived associations that are defined by means of derivation rules. The result is optimized and exe- cutable (as opposed to template) code. The generated code supports semantic reflection, that is, runtime access to the rules used to define the association. We relate these fea- tures to use cases from the area of business rules. We also present the Take rule compiler, a Java implementation of the principles discussed.

1 Introduction  Visual modeling is widely seen as a useful approach to tackling the complexity of large scale object-oriented de- sign. However, more and more features have been added to programming languages that have turned them gradually into modeling languages. Examples for this trend are in- terfaces (for syntax specification), assertions and unit tests (semantic specification), and annotations. These features directly compete with modeling language features like con- straint languages and stereotypes. A fundamental advan-  tage of modeling in a programming language is that the transition from model and design into executable code is straight forward, and that the correctness of this transi- tion can be easily verified. It is against this background that more and more research is done into making models executable, that is, facilitating the transition from models into executable applications. Research in this area includes the Model Driven Architecture (MDA) initiative of the Ob- ject Management Group (OMG), and the Eclipse Modeling Framework (EMF) of the Eclipse foundation1.

As far as the static modeling of classes and their relation- ships is concerned, the gap between UML modeling and modern programming languages like Java2 is particularly narrow. However, the representation of associations is still significantly different in UML and Java. While associations are first class citizens in UML, they are not directly sup- ported in Java. Depending on the navigability requirements, an association between a domain class and a range class is represented as a Java attribute in the domain class or range class. However, in some circumstances other representa- tions are more appropriate, including the representation of an association as a Java class [9, 6].

The situation is less clear for derived associations. The semantics of derived associations is very vaguely defined  1The EMF includes template-based code generation facilities 2While we focus here on Java as a target platform, most of the state-  ments made also apply to languages such as C++, C#, and Smalltalk  19th Australian Conference on Software Engineering  DOI 10.1109/ASWEC.2008.36   19th Australian Conference on Software Engineering  DOI 10.1109/ASWEC.2008.36   19th Australian Conference on Software Engineering  DOI 10.1109/ASWEC.2008.36   19th Australian Conference on Software Engineering  DOI 10.1109/ASWEC.2008.36     in UML - the isDerived property in Association is a boolean that ?specifies whether the association is derived from other model elements such as other associations or constraints? [10]. There are however some patterns that can often be observed whenever derived associations are used.

Often, derived associations represent deep access to indi- rectly referenced objects by navigating along a path built by object references.

The rest of this paper is organized as follows: in chapter 2, we describe URML, a UML extension that can be used to define derived associations visually in a class diagram.

We then discuss the interfaces of the code generated from rules, in chapter 3, and introduce TAKE, a rule compiler for Java, in chapter 4. Take can import the derivation rules from URML models, and generate runtime code from these models. In chapter 5 we discuss a particular property of the generated code called semantic reflection. We conclude this paper with a discussion of related approaches and future work.

2 Defining Derived Associations in URML  The UML-Based Rule Modeling Language (URML) [13], which was developed in the REWERSE project ([11]), allows to represent rules within UML class diagrams.

URML supports the UML-based modeling of three kinds of rules: derivation rules, production rules and ECA/reaction rules. In this paper, we are only concerned with derivation rules.

Although the UML supports the representation of deriva- tion rules in the form of OCL derive expressions, it does not provide any visual constructs for modeling rules graph- ically within a UML diagram. Since various components of a rule expression refer to certain visual model elements, it is clearly desirable to visualize these references when rep- resenting a rule in a UML diagram, instead of expressing it purely textual as in OCL.

In particular, any condition and the conclusion of a derivation rule may refer to a classifier (such as a class or an association). The referenced classifier represents a pred- icate with classes representing unary predicates, and n-ary associations representing n-ary predicates where n ? 2.

The conclusion represents an atomic predicate logic for- mula (in short: atom). Any condition represents a possibly negated, and possibly existentially quantified atom.

In URML, a derivation rule is visually represented as a circle, with incoming arrows attached to it representing con- ditions, and an outgoing arrow attached to it representing the conclusion. The URML diagram shown in Fig. 1 con- tains one derivation rule (with rule ID 4) having three con- ditions (the incoming arrows) and one conclusion (the out- going arrow). Each of these three visually expressed condi- tions has implicit variables.

Figure 1. A derived association defined in URML  The positive condition represented by the arrow originat- ing at the RentalCar-isStoredAt-Branch associa- tion stands for the atom isStoredAt(car, branch) where car and branch represent object variables ranging over the two associated classes, RentalCar and Branch, respec- tively.

The two other conditions are negated atoms where the negation is expressed by the crossed arrows. The condition represented by the crossed arrow originat- ing at the RentalCarScheduledForService class stands for the negated atom ? rentalCarScheduledForService(car) where the implicit variable car is shared with the positive condition described above.

The condition represented by the crossed arrow originat- ing at the RentalCar-isAssignedTo-Rental asso- ciation stands for the negated and existentially quantified atom ?? rentalisAssignedTo(car, rental) where the im- plicit variable car is again shared with the positive condi- tion described above.

Thus, the diagram represents the following rule:  IF isStoredAt(car, branch) AND ? rentalCarScheduledForService(car) AND ?? rentalisAssignedTo(car, rental)  THEN isAvailableAt(car, branch)  where the object variables car and branch are implicitly universally quantified.

The rules expressed in URML diagrams can be serial- ized with the help of the general rule markup language R2ML[12] developed in the REWERSE project.

3 The Structure of Generated Code  The structure of the generated code depends on the prop- erties of the association. The following patterns are com- monly used for explicit (non-derived) associations :  1. For a functional association (having a range multiplic- ity of one or zero-to-one), an attribute is generated in the domain class, and the type of the attribute is the range class.

2. For a non-functional association (having a range multi- plicity of many), an attribute is generated in the domain class, the type of the attribute is a container type. The kind of container used may depend on further prop- erties, such as isOrdered. If the target language sup- ports generics, the range class is used as a type variable for the container type.

3. For more complex associations such as bidirectional associations that need synchronization, ternary asso- ciations or many-to-many associations, special classes are created for representing the association. Instances of these classes or collections of these instances are then referenced by attributes in the domain and/or range class depending on the multiplicity and the nav- igability of the association ends.

In addition to the attributes mentioned, public access methods are usually generated as well. The property that influences the code generation most is the multiplicity of the association ends. For associations defined by means of derivation rules, it is in principle possible to compute the multiplicity of the derived association ends from the multi- plicities of the associations and properties that are prereq- uisites of this rule. Therefore, the same artifacts could be generated for derived associations. On the other hand, we are interested to provide an application programming inter- face (API) that allows applications to retrieve information about the rules at runtime. This requires a richer and more expressive interface. The solution proposed here is to gen- erate a dedicated class that provides a query interface. That is, for a given association this class provides methods that can be used to query the objects instantiating the associa- tion. For each association, the query interface must support several methods reflecting the different modes that can be used to navigate the association. In particular, for binary associations, a subset of the following queries must be sup- ported:  1. A method with one parameter representing an instance of the domain class, returning the collection of all range class instances linked to it.

2. A method with one parameter representing an instance of the range class, returning a collection of all domain class instances linked to it.

3. A Boolean-valued method with two parameters, one representing a domain class instance and the other one representing a range class instance, for testing whether the parameter objects form a link instantiating the as- sociation or not.

4. A method without parameters returning the extension of the association, that is, all Java objects that represent the links (as instances) of the association.

While using collections as return types where many ob- jects are expected is consistent with the current practice of generating code, it can be very inefficient. In particular, the computation of derived associations can be expensive. For instance, if associations are defined by means of derivation rules, then computing association instances requires back- tracking and recursion. Often, association instances are pro- vided by looking up external sources such as relational data- bases or Web services. Again, these operations are expen- sive and collecting query results in in-memory collections is not very scalable.

On the other hand, by using the iterator pattern [5] the situation can be improved dramatically. An iterator gives client applications access to associated objects without ex- plicitly collecting them. That is, these objects can be made available (fetched from external data sources or computed) as they are needed. In Java, the iterator pattern is im- plemented by the two interfaces java.util.Iterator and java.util.Enumeration. The main purpose of these in- terfaces is to provide means to loop over in-memory collec- tions without making assumptions about their internal struc- ture. They do not provide an interface that can be used to release resources allocated by the iterator. Examples in- clude network and database connections, and in-memory structures representing the derivation tree for associations defined by rules.

For this reason, we have decided to extend the Java itera- tor interface by adding a close() method. The respective generic interface nz.org.take.rt.ResourceIterator < T > is provided as part of the TAKE project alongside the implementation class nz.org.take.rt.ResultSet < T >.

The interface ResourceIterator < T > does extend the standard iterator interface java.lang.Iterator < T >.

For the example shown in Fig. 1, the code generator should create a class representing the association instances isAvailableAt (listing 1), and a class with methods to query the respective instances (listing 2). In the TAKE implementation presented here, these methods are named by default as follows: the name of the class represent- ing the association, followed by an underscore and a sig- nature. A signature is a sequence consisting of 1 and 0     characters denoting whether the association slot at this po- sition is known (input parameter) or not (output parame- ter). For binary associations, the first slot position repre- sents the domain class and the second position represents the range class. These methods represent different modes of navigating and querying the association. For instance, the method isAvailableAt 10 can be used to navigate from the domain class to the range class of the association, while isAvailableAt 01 can be used to navigate the association in the reverse direction. Often, not all methods are needed and in this case a code generator will only need to gener- ate a subset of the methods depending on the navigability requirements defined in the model.

1 p u b l i c c l a s s i s A v a i l a b l e A t { 2 p u b l i c R e n t a l C a r s l o t 1 ; 3 p u b l i c Branch s l o t 2 ; 4 p u b l i c i s A v a i l a b l e A t ( 5 R e n t a l C a r s l o t 1 , 6 Branch s l o t 2 ) { 7 s u p e r ( ) ; 8 t h i s . s l o t 1 = s l o t 1 ; 9 t h i s . s l o t 2 = s l o t 2 ;  10 } 11 p u b l i c i s A v a i l a b l e A t ( ) { 12 s u p e r ( ) ; 13 } 14 }  Listing 1: Generated association class  1 p u b l i c c l a s s KB { 2 R e s u l t S e t <i s A v a i l a b l e A t > i s A v a i l a b l e A t 1 1 ( 3 f i n a l R e n t a l C a r s l o t 1 , f i n a l Branch s l o t 2 ) ; 4 R e s u l t S e t <i s A v a i l a b l e A t > i s A v a i l a b l e A t 1 0 ( 5 f i n a l R e n t a l C a r s l o t 1 ) ; 6 R e s u l t S e t <i s A v a i l a b l e A t > i s A v a i l a b l e A t 0 1 ( 7 f i n a l Branch s l o t 2 ) ; 8 R e s u l t S e t <i s A v a i l a b l e A t > i s A v a i l a b l e A t 0 0 ( ) ; 9 }  Listing 2: Methods signatures generated to query the de- rived association  4 The TAKE Rule Compiler  4.1 The Compiler API  The TAKE rule compiler is the proof of concept imple- mentation of the ideas outlined above. It can be used in order to generate the association classes as well as the meth- ods used to query the associations. The compiler can also be used to generate only the query interface without gener- ating the actual query method bodies. This feature is use- ful in many applications where the associations themselves  1 p u b l i c C o l l e c t i o n <Ren ta lCa r> g e t A v a i l a b l e C a r s ( 2 Branch b ) { 3 KB kb = new KB ( ) ; 4 R e s u l t S e t <i s A v a i l a b l e A t > r s = 5 kb . i s A v a i l a b l e A t 0 1 ( b ) ; 6 C o l l e c t i o n <Ren ta lCa r> c o l l = 7 new A r r a y L i s t <Ren ta lCa r > ( ) ; 8 w h i l e ( r s . hasNext ( ) ) { 9 c o l l . add ( r s . n e x t ( ) . s l o t 1 ) ;  10 } 11 r s . c l o s e ( ) ; 12 r e t u r n c o l l ; 13 }  Listing 3: Accessor to navigate the association from branches to cars  1 p u b l i c Branch g e t A v a i l a b l e C a r s ( R e n t a l C a r c ) { 2 KB kb = new KB ( ) ; 3 R e s u l t S e t <i s A v a i l a b l e A t > r s = 4 kb . i s A v a i l a b l e A t 1 0 ( c ) ; 5 Branch o = n u l l ; 6 i f ( r s . hasNext ( ) ) { 7 o = r s . n e x t ( ) . s l o t 2 ; 8 } 9 r s . c l o s e ( ) ;  10 r e t u r n o ; 11 }  Listing 4: Accessor to navigate the association from cars to branches  are relatively static parts of the object model, and applica- tions reference the respective interfaces. But the rules used to actually define the associations may change often, and it is desirable to deploy the generated implementation code into running applications. TAKE contains a solution for this problem as well, based on runtime generation and compila- tion of code using the Java compiler API [7] and special class loaders. For details, the interested reader is referred to the online TAKE documentation [2].

The compiler is essentially a code generator that gener- ates Java source code. The source code generated uses iter- ators to describe the derivation tree defined by the rules. In particular, chained iterators are used for horizontal traver- sal. That is, given an association that is defined by multiple rules, each rule will be queried separately and the query re- sults (iterators) will be concatenated to an iterator. Using iterators again has the advantage of lazy initialisation: the derivation tree is traversed as results are requested by the application. Nested iterators are used for vertical traversal.

That is, the results for a single rule are built by combining the results obtained by evaluating the prerequisites.

Listing 5 shows the code that can be used to generate code for rules defined in the R2ML. We assume that the ref- erenced classes with code representing non derived prop-     erties and associations have already been generated at this stage.

1 D e f a u l t L o c a t i o n l o c a t i o n = new D e f a u l t L o c a t i o n ( ) ; 2 NameGenerator nameGenera to r = 3 new Defau l tNameGene ra to r ( ) ; 4 Compi le r c o m p i l e r = new D e f a u l t C o m p i l e r ( ) ; 5 c o m p i l e r . s e tNameGene ra to r ( nameGenera to r ) ; 6 I n p u t S t r e a m s c r i p t = 7 new F i l e I n p u t S t r e a m ( ? e u r e n t . r2ml ? ) ; 8 KnowledgeSource k s o u r c e = 9 new R2MLKnowledgeSource ( s c r i p t ) ;  10 c o m p i l e r . s e t L o c a t i o n ( l o c a t i o n ) ; 11 c o m p i l e r . se tPackageName ( ? e u r e n t ? ) ; 12 c o m p i l e r . se tC lassName ( ?KB? ) ; 13 c o m p i l e r . compi l e ( k s o u r c e . ge tKnowledgeBase ( ) ) ;  Listing 5: Script used to generate code from R2ML sources  The compile input consists of a knowledge base that is provided by a knowledge source. The knowledge source used in listing 5 reads rules from R2ML sources. TAKE in- cludes a scripting language and a second knowledge source class that can read rules from scripts. The compiler has a number of configuration options, including:  1. A name generator used to generate valid names for the Java artefacts to be generated. For instance, the name generator removes whitespaces in names.

2. A location object is used to generate the output streams for the code to be generated. Usually these streams point to files.

3. Package and class name specify the full name of the main class to be generated.

4.2 Code generated for queries  The main method generated is shown in listing 6. Both methods are implemented as static methods in a class with a name starting with KBFragment . The main reason for this is scalability. Instead of generating one class with code to query all associations, one class is generated per associ- ation. The public methods are still proxied in a central KB class, the name of this class can be customised when code is generated.

The public method (line 1) generates a session specific DerivationController object and then delegates the query to another method (line 6). The derivation controllers main function is to keep track of the derivation depth. The de- finition of derived associations can be recursive. That is, associations used to define derived associations can be de- fined by rules as well. This is well known from systems like Prolog and called rule chaining. The responsibility of the  derivation controller is to keep track of the current deriva- tion depth and to record the rules used. In particular, the re- set method can reset the derivation depth to the given value and is therefore used to enforce backtracking.

The non public method consists of an iterator chain. The reason for this is that an association can be defined by more than one rule. That is, in the visual URML model, more than one arrow can point to the derivation. Each rule is rep- resented by another private method (such as isAvailable 0 referenced in 6), and the resulting iterators are chained to- gether. This design is inspired by the popular Apache com- mons collections [1] library that contains abstract classes that can be used to manipulate iterators and to treat them as elements of an iterator algebra. For instance, if there was another rule defining the isAvailableAt associations, another case statement would be generated. The single- ton EmptyIterator.DEFAULT represents a reusable in- stance of an empty iterator. The order in which rules are rep- resented within the iterator chain is arbitrary. This reflects the two dimensional structure of UML diagrams where there is no order between connections unless additional lan- guage elements are used3. If rules are defined using sequen- tial formats such as scripts, the rules are implicitly ordered.

However, in many business applications this order is mean- ingful and represents prioritisation.

4.3 Code generated for derived associa- tions  For each combination of a rule and a signature that de- fines which slots in the predicate head are known a private method is generated. This method directly represents the logic of this rule at runtime. In our example, the method generated for the rule is isAvailable 0. In listing 6, this method is referenced in line 11. The implementation of this method is shown in listing 7. The code itself is rather com- plex and consists of a set of nested iterators. This method must bind the variables in the query by objects. This is similar to unification in logic programming [8]. For this purpose, the methods representing the prerequisites of the rules must be invoked. An inner class bindingsInRule? is generated in order to keep track of all variable bindings in the rule (in line 6). This class is instantiated using a final variable (line 12) that is accessible from within all nested iterators. Each nested iterator represents another level of derivation tree traversal. At each level, additional variables are bound. A nested iterator is an iterator over iterators.

That is, there is an outer iterator that returns inner iterators that are then chained together. The use of generic parame- ters allows to use to Java compiler in order to enforce type safety. Note that the generic type parameter of the last it- erator (iterator4 in line 40) is IsAvailableAt. This is the  3Such as labels in communication diagrams     1 p u b l i c s t a t i c R e s u l t S e t <I s A v a i l a b l e > i s A v a i l a b l e ( f i n a l R e n t a l C a r c a r ) { 2 D e r i v a t i o n C o n t r o l l e r d = new D e f a u l t D e r i v a t i o n C o n t r o l l e r ( ) ; 3 R e s u l t S e t <I s A v a i l a b l e > r e s u l t = new R e s u l t S e t ( K B F r a g e m e n t i s A v a i l a b l e . i s A v a i l a b l e ( ca r , d ) , d ) ; 4 r e t u r n r e s u l t ; 5 } 6 R e s o u r c e I t e r a t o r <I s A v a i l a b l e > i s A v a i l a b l e ( f i n a l R e n t a l C a r ca r , f i n a l D e r i v a t i o n C o n t r o l l e r d e r i v a t i o n ) { 7 f i n a l i n t l e v e l = d e r i v a t i o n . g e t D e p t h ( ) ; 8 R e s o u r c e I t e r a t o r <I s A v a i l a b l e > r e s u l t = new I t e r a t o r C h a i n <I s A v a i l a b l e >(1) { 9 p u b l i c O b j e c t g e t I t e r a t o r O r O b j e c t ( i n t pos ) {  10 s w i t c h ( pos ) { 11 c a s e 0 : r e t u r n i s A v a i l a b l e 0 ( ca r , d e r i v a t i o n . r e s e t ( l e v e l ) ) ; 12 d e f a u l t : r e t u r n E m p t y I t e r a t o r . DEFAULT; 13 }}} ; 14 r e t u r n r e s u l t ; 15 }  Listing 6: Main method generated to query the association (simplified)  type representing the association.

4.4 Code generated for explicit associa- tions  The rules are used in order to define associations based on other (explicit or derived) associations. For each of these associations, methods are generated. In listing 7, these methods are references in lines 17 (storedAt 10), 25 (not isScheduledForService 1), and 36 (not assignedTo 10). The not prefix indicates that the respective prerequisite uses negation. If the association is derived, the method is generated as discussed in the pre- vious chapter. Otherwise, code is generated that assumes that one of the code generation patterns discussed earlier (properties or collection properties, respectively) has been used. This code is then wrapped so that it can be accessed using a consistent iterator-based API. The code generation is template-based, the template engine used is Velocity [4].

Different templates are available depending on the follow- ing three properties:  1. Whether the prerequisite is negated.

2. Whether the range multiplicity (of the prerequisite as- sociation) is one or many.

3. Whether the domain class and the range class are known.

For instance, the template shown in listing 8 is used to generate code representing an explicit, unnegated one-to- one association where the domain class is known and the range class is unknown4. In the code, a singlton iterator is used. This is an iterator that iterates over a single object.

4For a complete list of templates, the reader is referred to http://take.googlecode.com/svn/trunk/take/src/nz/org/take/comp- iler/reference/. The respective templates are the files starting with PropertyPredicate and the extension vm.

That is, the first call to next returns a reference to the object passed to the constructor as parameter. Once next has been called, hasNext always return false.

1 s t a t i c R e s o u r c e I t e r a t o r < $ r e s u l t t y p e > $method ( 2 f i n a l $ s o u r c e t y p e sou rce , 3 f i n a l D e r i v a t i o n C o n t r o l l e r d e r i v a t i o n ) { 4 d e r i v a t i o n . l o g ( 5 $ p r o p e r t y , 6 D e r i v a t i o n C o n t r o l l e r . BEAN PROPERTY, 7 sou rce , 8 D e r i v a t i o n C o n t r o l l e r . NIL ) ; 9 $ r e s u l t t y p e r e s u l t = new $ r e s u l t t y p e ( ) ;  10 r e s u l t . $ s l o t 1 = s o u r c e ; 11 r e s u l t . $ s l o t 2 = s o u r c e . $ a c c e s s o r ( ) ; 12 r e t u r n 13 new S i n g l e t o n I t e r a t o r <$ r e s u l t t y p e >( r e s u l t ) ; 14 }  Listing 8: Template used to generate code to access an ex- plicit, unnegated ONE2ONE associations  The compiler instantiates these templates when gener- ating code. In particular, the variables in the template5  are instantiated. In listing 9, the generated code to query the storedAt association is shown. In line 11, the method getStoredAt in RentalCar is invoked to query the asso- ciation. From the point of view of logic, the semantics of the getStoredAt predicate is provided by the object model.

That is, we can use standard Java method calls to find out whether pairs of objects are instances of the predicate or not. In this case it is known that the predicate is functional and this fact can be used to find the associated object.

Figure 2 depicts the control flow between the objects in- volved in responding to a query. Visual stereotypes are used as follows: the lifelines with a dark background represent instances of domain classes, while the lifelines with a light background represent instances of generated classes. The  5variable names in velocity start with a $ character      2 p r i v a t e s t a t i c R e s o u r c e I t e r a t o r <I s A v a i l a b l e > i s A v a i l a b l e 0 ( 3 f i n a l R e n t a l C a r ca r , f i n a l D e r i v a t i o n C o n t r o l l e r d e r i v a t i o n ) { 4 d e r i v a t i o n . l o g ( ? r u l e 1 ? , D e r i v a t i o n C o n t r o l l e r . RULE, car , D e r i v a t i o n C o n t r o l l e r . NIL ) ;  6 c l a s s b i n d i n g s I n R u l e 1 { 7 Branch p1 ; 8 R e n t a l C a r p2 ; 9 R e n t a l p3 ;  10 } ;  12 f i n a l b i n d i n g s I n R u l e 1 b i n d i n g s = new b i n d i n g s I n R u l e 1 ( ) ; 13 b i n d i n g s . p2 = c a r ;  15 / / code f o r s t o r e d A t (<car >,<branch >) 16 f i n a l R e s o u r c e I t e r a t o r <s t o r e d A t > i t e r a t o r 1 = 17 KBFragemen t s to r edAt 10 . s t o r e d A t 1 0 ( ca r , d e r i v a t i o n . i n c r e a s e D e p t h ( ) ) ;  19 / / code f o r i s S c h e d u l e d F o r S e r v i c e (<car >) 20 f i n a l R e s o u r c e I t e r a t o r <n o t i s S c h e d u l e d F o r S e r v i c e > i t e r a t o r 2 = 21 new N e s t e d I t e r a t o r <s t o r e d A t , n o t i s S c h e d u l e d F o r S e r v i c e >( i t e r a t o r 1 ) { 22 p u b l i c R e s o u r c e I t e r a t o r <n o t i s S c h e d u l e d F o r S e r v i c e > g e t N e x t I t e r a t o r ( s t o r e d A t o b j e c t ) { 23 b i n d i n g s . p2 = o b j e c t . s l o t 1 ; 24 b i n d i n g s . p1 = o b j e c t . s l o t 2 ; 25 r e t u r n K B F r a g e m e n t n o t i s S c h e d u l e d F o r S e r v i c e 1 . n o t i s S c h e d u l e d F o r S e r v i c e 1 ( 26 b i n d i n g s . p2 , 27 d e r i v a t i o n . i n c r e a s e D e p t h ( ) ) ; 28 }} ;  30 / / code f o r a s s i g n e d T o (<car >,< r e n t a l >) 31 f i n a l R e s o u r c e I t e r a t o r <n o t a s s i g n e d T o > i t e r a t o r 3 = 32 new N e s t e d I t e r a t o r <n o t i s S c h e d u l e d F o r S e r v i c e , n o t a s s i g n e d T o >( i t e r a t o r 2 ) { 33 p u b l i c R e s o u r c e I t e r a t o r <n o t a s s i g n e d T o > g e t N e x t I t e r a t o r ( n o t i s S c h e d u l e d F o r S e r v i c e o b j e c t ) { 34 b i n d i n g s . p2 = o b j e c t . s l o t 1 ; 35 r e t u r n 36 K B F r a g e m e n t n o t a s s i g n e d T o 1 0 . n o t a s s i g n e d T o 1 0 ( b i n d i n g s . p2 , d e r i v a t i o n . i n c r e a s e D e p t h ( ) ) ; 37 }} ;  39 / / code f o r / a v a i l a b l e A t (<car >,<branch >) 40 f i n a l R e s o u r c e I t e r a t o r <I s A v a i l a b l e > i t e r a t o r 4 = 41 new N e s t e d I t e r a t o r <n o t a s s i g n e d T o , I s A v a i l a b l e >( i t e r a t o r 3 ) { 42 p u b l i c R e s o u r c e I t e r a t o r <I s A v a i l a b l e > g e t N e x t I t e r a t o r ( n o t a s s i g n e d T o o b j e c t ) { 43 b i n d i n g s . p2 = o b j e c t . s l o t 1 ; 44 b i n d i n g s . p3 = o b j e c t . s l o t 2 ; 45 r e t u r n new S i n g l e t o n I t e r a t o r ( new I s A v a i l a b l e ( b i n d i n g s . p2 , b i n d i n g s . p1 ) ) ; 46 }} ;  48 r e t u r n i t e r a t o r 4 ; 49 }  Listing 7: Method generated for availableAt rule     1 s t a t i c R e s o u r c e I t e r a t o r <s t o r e d A t > s t o r e d A t 1 0 ( 2 f i n a l R e n t a l C a r sou rce , 3 f i n a l D e r i v a t i o n C o n t r o l l e r d e r i v a t i o n ) { 4 d e r i v a t i o n . l o g ( ? p r o p e r t y s t o r e d A t ? , 5 D e r i v a t i o n C o n t r o l l e r . BEAN PROPERTY, 6 sou rce , 7 D e r i v a t i o n C o n t r o l l e r . NIL ) ;  9 s t o r e d A t r e s u l t = new s t o r e d A t ( ) ; 10 r e s u l t . s l o t 1 = s o u r c e ; 11 r e s u l t . s l o t 2 = s o u r c e . g e t S t o r e d A t ( ) ; 12 r e t u r n new S i n g l e t o n I t e r a t o r <s t o r e d A t >( r e s u l t ) ; 13 }  Listing 9: Instantiated template for explicit, unnegated ONE2ONE associations  blank box with the stereotype ??ClientApplication?? rep-  the associations.

4.5 Negation  URML supports the definition of associations with neg- ative prerequisites. There is a large body of research on how to deal with negations in rules. In a nutshell, there are two different negations, often referred to as strong nega- tion and negation as failure. These concepts are related to whether our knowledge about the facts using a certain pred- icate symbol is complete (closed world assumption) or not (open world assumption). In the context of associations, this means that the semantics of the negation used depends on whether the association is explicit or not. TAKE treats negation as polymorphic negation. That is, if the negated condition points to an explicit association, the negation will be interpreted as explicit, strong negation. If the associa- tion is derived, the association is interpreted as negation as failure. The main reason for this is a feature called external fact stores. External fact stores are part of TAKE but cannot be represented in URML. A fact store is a factory that can be used to create iterators to access external sources provid- ing association instances. For instance, external fact stores can be used to access a database with customer details, or to look up service directories using Web services. In this case, using the open world assumption is appropriate.

The example shown in Fig. 1 contains two negations: notisScheduledForService[car] and notassignedTo[car, rental]. While the first condi- tion is a simple negated boolean property, it can be considered as unary association. A template is used to generate code for this property, the generated code is shown in listing 10. The code is simple: it queries the method isScheduledForService() and returns a value depending on whether the method invocation re- turns true or false. The explicitly negated condition  is essentially treated as if there was a separate predicate symbol notisScheduledForService that is linked to isScheduledForService through the negation operator for booleans defined in the programming language.

The second negated prerequisite is a binary association with a variable rental that is only used here (within the rule). That is, it is implicitly quantified and must be in- terpreted as ?the car is not assigned to any rental?. The code generated checks this condition by comparing the assignedTo property to the null pointer.

1 s t a t i c R e s o u r c e I t e r a t o r <n o t i s S c h e d u l e d F o r S e r v i c e > 2 n o t i s S c h e d u l e d F o r S e r v i c e 1 ( 3 f i n a l R e n t a l C a r s l o t 1 , 4 f i n a l D e r i v a t i o n C o n t r o l l e r d e r i v a t i o n ) { 5 d e r i v a t i o n . l o g ( 6 ? i s S c h e d u l e d F o r S e r v i c e ( ) ? , 7 D e r i v a t i o n C o n t r o l l e r . JAVA METHOD ) ; 8 i f ( ! s l o t 1 . i s S c h e d u l e d F o r S e r v i c e ( ) ) { 9 n o t i s S c h e d u l e d F o r S e r v i c e r e s u l t =  10 new n o t i s S c h e d u l e d F o r S e r v i c e ( ) ; 11 r e s u l t . s l o t 1 = s l o t 1 ; 12 r e t u r n new S i n g l e t o n I t e r a t o r 13 <n o t i s S c h e d u l e d F o r S e r v i c e >( r e s u l t ) ; 14 } 15 r e t u r n E m p t y I t e r a t o r . DEFAULT; 16 }  Listing 10: Code generated for a negated property  1 s t a t i c R e s o u r c e I t e r a t o r <n o t a s s i g n e d T o > 2 n o t a s s i g n e d T o 1 0 ( 3 f i n a l R e n t a l C a r sou rce , 4 f i n a l D e r i v a t i o n C o n t r o l l e r d e r i v a t i o n ) { 5 d e r i v a t i o n . l o g ( 6 ? p r o p e r t y a s s i g n e d T o ? , 7 D e r i v a t i o n C o n t r o l l e r . BEAN PROPERTY, 8 s o u r c e ) ;  10 i f ( s o u r c e . ge tAss ignedTo ( ) == n u l l ) { 11 n o t a s s i g n e d T o r e s u l t = 12 new n o t a s s i g n e d T o ( ) ; 13 r e s u l t . s l o t 1 = s o u r c e ; 14 r e s u l t . s l o t 2 = n u l l ; 15 r e t u r n new S i n g l e t o n I t e r a t o r <n o t a s s i g n e d T o > 16 ( r e s u l t ) ; 17 } 18 r e t u r n E m p t y I t e r a t o r . DEFAULT; 19 }  Listing 11: Code generated for a negated association with an unbound variable  5 Semantic Reflection  The TAKE compiler does not only generate code to query derived associations, but also provides an interface  resents an object that is part of a client application querying     Figure 2. Runtime control flow  to query the rules used to define these associations. This is a very useful feature in many business applications where system features have to be traced to the underlying business logic. The TAKE API supports attaching meta data to rules, and generates a runtime interface that can be used by ap- plications in order to query these meta data. In this API, meta data are represented as key value associations. Key and value are both strings. Keys are often taken from ded- icated meta data vocabularies such as Dublin Core. TAKE also contains a small meta data vocabulary that consists of the keys listed in table 1.

annotation meaning instantiation  take.auto.date compilation timestamp  new Date()  take.auto.creator user name System.getProperty (?user.name?)  take.auto.name textual repre- sentation of rule  e.toString()  Table 1. Built in meta data  The TAKE compiler extracts annotation at compile time from rules and serializes the collected meta data using an XML file annotations.xml. This file is stored in the same location as the generated classes, and can be accessed as a resource using the class loader used to load the generated classes. The generated main class (KB in our example) has an additional method getAnnotations(String) that re- turns the annotations for a rule identified by id. The result set itself has an API that can be used to query the rules used.

Note that this API returns only the (unique) rule ids, not the  rules themselves. The rules are not available at runtime.

However, if it is necessary to make the rule available at run- time, the TAKE core API could be used and the rules can be queried by id. Serialised rules could also be explicitly stored in the meta data. On purpose, the precise mechanism how to do this has been left open as the framework should support different techniques to serialise and store rules.

1 KB kb = new KB ( ) ; 2 R e n t a l C a r c = . . . ; 3 P r i n t S t r e a m o u t = System . o u t ; 4 R e s u l t S e t <I s A v a i l a b l e > r s = kb . i s A v a i l a b l e 1 0 ( c ) ; 5 I s A v a i l a b l e r e s u l t = r s . n e x t ( ) ; 6 System . o u t . p r i n t l n ( ? b r a n c h : ?+ r e s u l t . b r a n c h ) ; 7 / / p r i n t meta d a t a o f t h e r u l e ( s ) used 8 L i s t <D e r i v a t i o n L o g E n t r y > l o g = 9 r s . g e t D e r i v a t i o n L o g ( ) ;  10 f o r ( D e r i v a t i o n L o g E n t r y e : l o g ) { 11 Map ann = kb . g e t A n n o t a t i o n s ( e . getName ( ) ) ; 12 i f ( ann != n u l l ){ 13 o u t . p r i n t l n ( ann . g e t ( ? t a k e . a u t o . d a t e ? ) ) ; 14 o u t . p r i n t l n ( ann . g e t ( ? t a k e . a u t o . c r e a t o r ? ) ) ; 15 o u t . p r i n t l n ( ann . g e t ( ? t a k e . a u t o . t o s t r i n g ? ) ) ; 16 } 17 } 18 r s . c l o s e ( ) ;  Listing 12: Application code to query an association and the rules used to define the association  Listing 12 shows the application code used to query the application, navigating from the domain class instance (the rental car c) to the range class instance. First the branch is computed and printed on the console, and then the meta data of the rules used are extracted and printed. Finally, the result set is closed.

The availability of information about the specification of code at runtime is similar to reflection6 [3] in object oriented languages. While reflection provides runtime access to the structure (syntax) of the program, the TAKE API provides access to the semantics of code. The rules represent the ab- stract specification of the code generated from them, and the meta data can be used to make these rules and other contex- tual information available at runtime. Therefore we call this feature semantic reflection. This seems to contradict estab- lished object-oriented design principles such as information hiding and component blackboxing. On the other side, the API does not reveal technical implementation details which might differ depending on the compiler used. Instead, it re- veals a specification that describes the functionality of code in abstract terms. There are numerous business use cases for this kind of design and interesting social consequences. For instance, the availability of this feature may help to improve trust into software systems as they are better understood by end users. Access to meta information such as who the cre- ator of a rule is can shorten the time to fix problems that occurred during analysis.

6 Conclusion  We have presented an approach for defining derived as- sociations visually in a UML class diagram and for gener- ating Java code for them. We consider this as a contribution to the vision of model driven engineering - the automated generation of applications from models.

The TAKE compiler presented here is available online under the GNU Lesser General Public License (LGPL)7, the project homepage is http://code.google.com/p/take/. The existing solution is expressive and scalable enough to gen- erate code for the UServ Product Derby Case Study pub- lished by the business rule forum 8, the respective example classes are part of the TAKE distribution and the respective application can be started from the TAKE Web page using Java Webstart. The scenario contains 69 rules, this rules are compiled into 111 source code files and 354 classes9. Com- pilation takes 2567 ms on a system with a 2.0GH T5600 dual core processor, 2.0GB of RAM running on Ubuntu 7.04 with Java 1.6, with logging switched on.

