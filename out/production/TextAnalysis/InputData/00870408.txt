Data Mining Library Reuse Patterns  using Generalized Association Rules

ABSTRACT In this paper, we show how data mining can be used to dis- cover library reuse patterns in existing applications. Specifi- cally, we consider the problem of discovering library classes and member functions that are typically reused in combina- tion by application classes. This paper improves upon our earlier research using ?association rules? [SI by taking into account the inheritance hierarchy using ?generalized associ- ation rules?. This turns out to be a non-trivial but worthwhile endeavor.

By browsing generalized association rules, a developer can discover patterns in library usage in a way that takes into account inheritance relationships. For example, such a rule might tell us that application classes that inherit from a par- ticular library class often instantiate another class or one of its descendents. We illustrate the approach using our tool, CodeWeb, by demonstrating characteristic ways in which applications reuse classes in the KDE application frame- work.

Keywords Software libraries, reuse patterns, data mining.

1 INTRODUCTION Using a software library is not easy. Selecting the right com- ponents for reuse is only part of the problem. There is still the issue of reusing these components in the right way. This is particularly important with application frameworks where multiple components are reused in combination. A classic example is Smalltalk?s ModeWiew/Controller.

Indeed, Will Tracz writes:  If you have components to reuse, then you need to glue them together.. . After you glue pieces to- gether long enough, you start seeing a pattern, then you can reuse the glue too [12, p. 411.

Perniission to make digital or hard copies of all or part of this mark for personal or classroom use is granted without fee provided that copies are not made or distributed for prolit or commercial advantage and that copies bear this notice and the full citation on the first pagc. To copy othmise, to republish, to post on sewers or to redistribute to lists, requires prior specific permission andlor a fee.

ICSE 2000 Limerick Ireland Copyright ACM 2000 1-581 13-206-9/00/6 ... $5.00  In this paper, we shall discover patterns in the ways library classes are reused in practice, which we call reuse patterns.

This is done by data mining existing applications that use the library. For example, we may find that most application classes that inherit from a library class Widget tend to over- ride its member function paint(). As another example, we may notice that most application classes that instantiate a li- brary class Painter and that call its member function begin() also call its member function end().

Traditionally, such knowledge is presented by example in library tutorials and/or toy programs. However, not all li- braries come with such representative examples of reuse.

This is particularly true for libraries developed by a com- pany for internal use only and libraries developed by the open source community. Writing quality tutorials and toy programs is a time consuming and difficult process. More- over, software developers would rather write code than doc- umentation.

Our reuse pattern approach has the following benefits: (1) by leveraging existing applications and using data mining tech- nology, we do not need expert analysis to identify character- istic usage of the library; (2) by using many real-life appli- cations instead of a few toy programs, we can demonstrate reuse of many library classes in numerous and deeper ways; and (3) by using automated techniques, we can keep reuse patterns up to date with respect to the most recent version of the library and applications.

This paper improves upon our earlier research on reuse pat- terns using ?association rules? [SI by taking into account the inheritance hierarchy using ?generalized association rules?.

By browsing generalized association rules, a developer can discover patterns in library usage in a way that takes into account inheritance relationships. For example, such a rule might tell us that application classes that inherit from a par- ticular library class often instantiate another class or one of its descendents.

The paper is organized as follows. Section 2 introduces the field of data mining and describes a well-known method for addressing the ?shopping basket analysis? problem that takes into account taxonomies. Section 3 demonstrates how a sim- ilar data mining technique can be used to discover software   http://washington.edu   library reuse patterns in existing applications in a way that takes into account inheritance relationships. Section 4 shows how browsing such reuse patterns for the KDE application framework can illustrate characteristic reuse in existing ap- plications. Section 5 discusses related work. Section 6 sum- marizes the paper, concluding with future work.

2 DATAMINING Data mining may be defined as follows:  The process of nontrivial extraction of implicit, previously unknown and potentially useful infor- mation (such as knowledge rules, constraints, reg- ularities) from data [9].

Data mining is widely used in business to gain a competi- tive edge. An effective data mining application in the retail environment is shopping basket analysis. Progress in bar- code technology has made it possible to store busker dura that contains items purchased on a per-transaction basis. By using data mining technology, one can find patterns in items that are bought in combination.

Association Rules Shopping basket analysis can be done by mining associa- tion rules [l]. Let I = {il, iz, . . . , im}  be a set of literals, called items. An association rule is an implication of the form (AzEx z) + (AgEy y), which we write more com- pactly as X =+ Y, where X c I, Y c I, and X n Y = 8.

(Throughout this paper, we shall distinguish sets of items from individual items by using upper and lower case letters, respectively.)  For example, suppose that people who purchase bread and butter also tend to purchase milk. In that case, the corre- sponding association rule is ?breadAbutter*milk?. The an- tecedent of the rule X consists of bread and butter and the consequent Y consists of milk.

Such rules are useful for analyzing data. For example, to determine how one might boost the sales of milk, one could look for rules that have ?milk? in the consequent. To deter- mine the impact of discontinuing the sale of butter, one could find all rules that have ?butter? in the antecedent.

Incidently, observe that as we are using sets throughout, an item that occurs multiple times in a transaction is not treated any differently from one that occurs only once.

Confidence and Support Let D be a set of transactions, where each transaction T is a set of items (iremser) such that T 5 I. We say that a rule X + Y holds in transaction set D with confidence c% if c% of transactions in D that contain X also contain Y. We say that itemset 2 has support s% in transaction set D ifs% of transactions in D contain 2. Support is also defined for rules: X * Y has supporr s% if itemset X U Y has support  s%. For brevity, we may at times write ?supp(Q)? to indicate the support of an itelnset or rule Q in D.

Returning to our example, suppose we find that in 90% of transactions in which customers purchase bread and butter, they also purchase milk. Moreover, say that 5% of trans- actions include all three items: bread, butter, and milk. In that case, the confidence of the rule ?breadAbutter=+milk? is 90% while its support is 5%.

Support should not be confused with confidence. While con- fidence is a measure of the rule?s strength, support corre- sponds to its statistical significance.

For example, a rule a A b + c may have much higher confi- dence than a + c, which means that whenever we encounter a in a transaction, it is more likely we find c if b is also present. So, in that sense a A b + c is stronger than a s j  c and we should take it more seriously in our analysis of the data. (As a side note, this notion of rule strength is differ- ent from logical implication in which case a + c would be considered stronger because it implies a A b 3 c.)  Now, support is a measure of statistical significance in the following sense: if supp(X + Y) x supp(X) x supp(Y), then it is likely that X and Y are independent and co-occur in transactions by chance; however, if supp(X + Y) >> supp(X) x supp(Y), then this is not likely to be the case [7].

(We make this argument more precise in Section 3.) Retum- ing to our example, it may be that a =$ c is more statistically significant although a A b 9 c has higher confidence.

Association Rule Mining Problem Given a set of transactions D, the problem of mining associ- ation rules is the following:  Generate all association rules that have support s% at least as great as some user-specified mini- mum support smin% and confidence c% at least as great as some user-specified minimum confidence %in%.

Several algorithms have been presented in the literature for finding all such association rules. Many of them are vari- ations on the Apriori algorithm [l], which works in two phases: (1) it finds all itemsets that have support above the minimum support; and (2) it uses these itemsets to generate all rules whose confidence is above the minimum confidence.

In such an algorithm, larger values of smin% can reduce the running time significantly but larger values of Cmin% have little effect on the running time (although they do yield fewer rules of course).

Taxonomies In this paper, we shall be concerned with generalized asso- ciation rules which take into account the presence of tax- onomies [ll].  By taxonomies, we mean ?is-a hierarchies? where a node?s descendents represent specializations of that     node.

For example, a taxonomy may indicate that white bread is a kind of bread and that skim milk is a kind of milk. In that case, the taxonomy would have white bread as a descendent of bread and skim milk as a descendent of milk. As we shall see in Section 3, such taxonomies allow us to take into ac- count the class inheritance hierarchy when mining for library reuse patterns.

Taxonomies allow us to mine for rules at different levels of abstraction. This is important since interesting associations among data items often occur with more abstract concepts.

In particular, purchase patterns may not show any substantial regularities at the primitive data level, but may show some interesting regularities at higher levels of abstraction.

For example, the rule ?white breadAbutter+skim milk? may have insufficient support using standard association rule min- ing, but ?breadAbutter+milk? may pass the support require- ment using generalized association rules. That is because additional transactions may support other kinds of bread and milk.

Formally speaking, we model one or more taxonomies as a directed acyclic graph 7 on the items I = {il, i2, . . . , im}.

Edges in the 7 denote is-a relationships among items.

Specifically, an edge from c to p in 7 indicates that p is the parent of c and means that c is a particular kind of p (or in other words, that p is a generalization of c.)  Generalized Association Rules Generalized association rules improve upon standard asso- ciation rules by incorporating a taxonomy 7. In particular, a generalized association rule is an implication of the form (AzEx x) + AyEY y , which we write as X + Y, where X c I, Y c I, X n Y = 0, and no item in Y is an ances- tor of any item in X. The reason for this latter requirement is that any rule of the form ?x ancestor(x)? is true with 100% confidence and consequently redundant.

Before proceeding further, we first define a partial order on itemsets using the taxonomy 7. In particular, X < Y if and only if we can get from itemset Y to itemset X by replacing one or more items in Y with some ancestor(s) in 7.  Observe that X may have fewer or greater items than Y; for exam- ple {food) < {bread, butter) and {dairy product, liquid) < {milk]. If X < Y, then itemset X is an ancestor of Y or, equivalently, Y is a descendent of X.

Now, we say that a generalized association rule X + Y holds in transaction set D with conjidence c% if c% of trans- actions in D that contain X ,  or a descendent of X ,  also con- tain Y, or a descendent of Y. Moreover, itemset 2 has sup- port s% in transaction set D if s% of transactions in D con- tain 2 or a descendent of 2. Support for rules is defined as follows: X + Y has support s% if the itemset X U Y has   support s%.

Our earlier observations with respect to confidence and sup- port still apply in this more general context. Moreover, if a rule X + Y has minimum support and confidence, then the rule X + ancestor(Y) is guaranteed to have both minimum support and confidence also. However, the rules ancestor(X) + Y and ancestor(X) + ancestor(Y) have minimum support but not necessarily minimum confidence.

To support taxonomies, one can use algorithms for mining standard association rules by considering ?extended transac- tions?? that contain not only the items in transactions but also their ancestors. To make this process efficient, certain op- timizations are done to restrict the number of itemsets that need to be counted at various stages in the algorithm and the number of ancestors added to form extended transac- tions [ 113.

Finally, there is also the problem that taxonomies tend to yield more rules, many of which are redundant. Conse- quently, pruning the output to show only ?interesting rules? is essential. We shall describe our pruning technique in Sec- tion 3.

3 MINING REUSE PATTERNS Now that we have introduced generalized association rule mining in Section 2, we demonstrate how to apply this tech- nology to discover library reuse patterns in existing appli- cations. We do this in a way analogous to that for discov- ering items that are typically purchased together in basket data. Specifically, we identify library classes and member functions that are often reused in combination by application classes.

For example, we may find that application classes that inherit from the library class Widget usually override its member function Widget::paint(). In that case, we would generate the generalized association rule:  class-inheritswidget + class-overrides: Widget::paint().

Of course, one might question the utility of such a rule. It may be obvious from the library source that paint() could be overridden in application classes (perhaps because it is declared virtual in a language like C++). However, not all virtual functions are overridden with equal frequency. If a member function is overridden most of the time - or under certain circumstances - then the developer should consider overriding the function in his own application under similar circumstances.

Applying Generalized Association Rule Mining Conceptually, our application of generalized association rule mining in the manner described above is simple. However, in practice, there are many issues to consider. For exam- ple, what kinds of reuse relationships do we want to in- clude? How do we take advantage of the inheritance hier- archy? How do we prune the resulting rules?

In what follows, we present a fairly detailed account of ap- plying our approach to C++ software libraries and appli- cations. In particular, we define our notion of items I = {il, iz, . . . , z m } ,  explain how to construct the set of transac- tions D, and present a taxonomy 7 over items I based on the class inheritance hierarchy.

While existing data mining algorithms can be used [ll], there are issues to consider while pruning the resulting gen- eralized association rules. Thus, we conclude our discussion by describing the pruning process.

Items In our use of generalized association rules, items indicate reuse relationships involving classes or member functions.

For example, a typical item might be class-inherits:Widget where the reuse relationship is inheritance and the class reused is Widget, As another example, the item class-ove rrides : W id get: :paint () indicates an overriding relationship with Widget?s member function paint().

We associate with every application class A ?the set of all items I(A) that are involved in a reuse relationship with class A. Returning to our example, if a class mywidget (only) inherits from Widget and overrides paint(), then  I(myWidget)={ class-inherits:Widget, class-0verrides:Widget:: paint() 1.

Also, the reuse relationship need not involve a library class. For example, if myDialog instantiates myButton, then class-instantiates:myButtone I(myDia1og).

The complete set of items I is defined as I = U A  I ( A ) where the union is over all application classes A. The set I contains items with reuse relationships that involve both application and library classes.

In what follows, we shall expand on the various reuse rela- tionships. Before doing so, we extend our notation to in- clude library and application names as prefixes of classes and their member functions. For example, we shall write app?myDialog to indicate that myDialog is defined in appli- cation app. Similarly, we shall write lib?Widget::paint() to indicate that member function Widget::paint() is defined, or at least declared as an abstract member, in library lib. Global functions, such as main(), are represented by omitting the class name, as with app?maino.

There are five reuse relationships that we have considered in our research: class inheritance, class instantiation, function invocation, function overriding, and implicit invocation. Al- though our approach can be applied to any object-oriented programming language, we shall, for concreteness, base our presentation on C++. For the reuse relationships mentioned, we present the corresponding item types below: .

class-inherits:p?class This item expresses a standard inheritance relationship. Both single and multiple in-  heritance are allowed.

class-instantiates:p?class We say that class or mem- ber function A instantiates class B if and only if (1) A allocates an instance of B on the stack by way of a non-pointer variable of type B or (2) A allocates an instance of B on the heap using new or malloc(). Ei- ther way, A instantiates a new instance of B. We only generate instantiation items for classes. So, if A is ac- tually a member function of some class C, then we say that C instantiates B and write this as the item class-instantiates:p?B.

class-calls:p?class::func() If a function p?A::f() calls a function q?B::g(), then we construct an item indicating a call made by class A: class-calls:q?B::g()e I(p?A).

class-overrides:p?class::func() If a class p?A inherits from q?B and overrides its member function q?B::f(), then we construct the item class-overrides:q?B::f().

class-receives-signaI:p?class::signal() If implicit invocation is used in the libraries and applications at hand, we assume there is some way to easily identify how this is done through simple lexical analysis of the source. If an object of type A broadcasts ?signal()? that is received by an object of type B, then we construct an item class-receives-signaI:p?A::signal()e I(q?B).

Moreover, we also include a class-calls item for the emission by A.

For each of the items defined above, there is also a corre- sponding version with a ?-? symbol appended to the item class. Such items are used whenever the corresponding ap- plication class may reuse a descendent of the class in the item. For example, if an application class is associated with class-instantiates:lib?PushButton, then we also associate the item class-instantiates:lib?Button^ since PushButton inherits from Button.

?hamactions We could simply define each transaction T(A) as equal to I(A) for each A. That is, simply include all items associated with each application class. We could then prune uninterest- ing rules after the data mining is complete. However, this would be very inefficient. It pays to reduce the number of items in transactions as early as possible to reduce computa- tional blowup in the mining process.

Recall that our goal is to identify how library classes are typ- ically reused in existing applications. Moreover, we do not care so much about how library classes reuse other library classes nor how application classes reuse other application classes. Rather, we are interested in how application classes reuse library classes.

One might try to construct transactions consisting of those items associated with application classes that refer to library classes and functions. For example, we could include an item like c1assjnherits:lib?Widget in a transaction for applica- tion class app?mywidget but exclude any items referring to application classes or functions.

However, there is a problem in doing this. Con- sider a class app?myDialog that inherits from Iib?Dialog and instantiates app?myPushButton that in turn inher- its from Iib?PushButton. In such a case, we would like to include class-instantiates:app?myPushButton in app?my Dialog?s transaction so that we may (indirectly) sup- port the following generalized association rule:  class-inherits:lib?Dialog + class,instantiates:lib?Pus hButton*.

Also, suppose app?myDialog makes a call to app?myPushButton::show(), where show() is defined in PushButton?s ancestor Widget. In that case, we would like to include class-calls:app?myPushButton::show() in app?myDialog?s transaction so that we may (indirectly) support the following generalized association rule:  class-inherits:lib?Dialog + class-calls:lib?PushButton^::show().

Consequently, we include additional items in transactions to make this possible. In particular, given the items I(A) for an application class A, we include in T(A) only the following items in I(A): (1) all items involving a library class Iib?A or member function lib?A::f(); (2) those items involving appli- cation classes app?A that inherit directly or indirectly from a library class Iib?B; and (3) those items involving application member functions app?A::f() where class app?A inherits di- rectly or indirectly from a library class Iib?B that defines or overrides member function f.

Taxonomy We define a taxonomy 7 in a way that mirrors the inher- itance hierarchy. Consider the set of all transaction items Itrans defined as Itrans = UA T ( A )  where the union is over all application classes A and T ( A )  denotes the items in the transaction for A. For efficiency, we construct a taxonomy that is induced by only those items in Itrans .

First, we consider items in Itrans that do not involve member functions. These denote inheritance or instan- tiation. Without loss of generality, we consider instan- tiation; inheritance is handled similarly. For an item c1assJnstantiates:p?Cc we consider all ancestors AI, . . . , Ak of C in the inheritance hierarchy.

The item class-instantiates:p?C contributes the following to the taxonomy I: (1) nodes class-instantiates:p?C, class-instantiates:p?C ,? class-instantiates:pl?Al? , . . . , class-instantiates:pk?AkA; (2) an edge from  class-inhe ts:Widget*  i c1assinherits:lib?Dialog  pp?myPushButtorP class-instantiates:lib?PushButton  class-instantiates:app?my PushButton  Figure 1: Items not involving member functions in taxon- omy.

class-instantiates:p?C to class-instantiates:p?C*; (3) edges from class-instantiates:p?C to class-instantiates:pi?Ai?  where C inherits from Ai; and (4) edges from class-instantiates:pi?A,?  to class-instantiates:pj?Aj* where A, inherits from Aj .

By distinguishing items using ?*?, a user can tell whether a rule involves only the items mentioned or possibly their descendents. For example, a rule involving item class-instantiates:p,?Ai^ makes it very clear that some application classes that support the rule may instanti- ate a descendent of Ai. However, if the rule had class-instantiates:p,?Ai, then all application classes that support this rule instantiate Ai. Finally, observe that the min- ing algorithm may generate both kinds of rules with differ- ent confidence and support. Browsing both can be helpful in learning to use the library.

Let us again consider a class app?myDialog that inher- its from Iib?Dialog and instantiates app?myPushButton that in turn inherits from Iib?PushButton. The transaction for app?myDialog contains items class-inherits:lib?Dialog and class-instantiates:app?myPushButton. Figure 1 shows the contributions made by these two items to the taxonomy 7. Observe that another transaction has contributed the node class-instantiates:lib?PushButton and the edge from class-instantiates:lib?PushButton to class-instantiates:lib?PushButton^.

Next, we consider items in Itran, that do involve member functions. These denote function invocation, function over- riding, or implicit invocation. We handle such items in much thesame way as those not involving member functions ex- cept that we only consider ancestor classes that inherit or define the member function in question.

class-calls:lib?PushButton::show() class_calls:app?myDialog::accepl()  class-callsapp?yPush1utlon::show~  Figure 2: Items involving member functions in taxonomy.

For example, suppose a class app?myDialog calls app?myDialog::accept() and app?myPushButton::show(). The trans- action for app?myDialog contains items class-cal1s:app?my Dialog ::accept () and class-calls:app?myPushButton::show(). Figure 2 shows the contributions made by these two items to the taxonomy 7. Observe that another transaction has con- tributed the node class-calls:lib?PushButton::show() and the edge from class-calls:lib?PushButton::show() to class-calls:lib?PushButton^::show().

Pruning We do not present all generalized association rules to the user but only those that we deem ?interesting?. This is par- ticularly important since, in practice, we find that there are thousands of similar andlor redundant rules that would over- whelm the user otherwise.

We shall assume that there is only one item in the consequent of each generalized association rule. This is not a serious limitation since X + y1 A y2 A. . A yn is logically equivalent to ( X  + y ~ )  A (X + yz) A .  - .  A ( X  + yn); so, instead of showing a rule with n items in the consequent to the user, we instead show n rules each having a consequent of one item.

Global Pruning Initially, we perform a global pruning that is applied to all rules discovered by data mining. Afterwards, we shall per- form local pruning on various subsets of rules that survive global pruning.

Uninteresting Rules We prune rules such as the following:  class-calls:lib?A::f() + class-instantiates:lib?A Such a rule is hardly surprising. It is quite likely that any reuse of a class member function implies that the  class is inherited from or instantiated at some point.

Consequently, we prune rules where an item in the antecedent involves a member function lib?A::f() and an item in the consequent instantiates or inherits a class B - where B may be A, an ancestor of A, or a descendent of A - that defines or inherits member function f().

In addition, we prune rules with a class in the an- tecedent that is a (strict) descendent or ancestor of the class in the consequent. For example, a rule such as c1assJnstantiates:lib?K + class-calls:lib?B::f() is pruned if and only if A is a descendent of B or B is a descendent of A. The rationale behind this heuristic is to avoid the numerous rules that would result in a deep inheritance hierarchy (e.g., if say A has many descendents B).

Misleading Rules Some generalized association rules are misleading [2]. For example, suppose the rule x A y  + z has confidence 60% while the rule y + z has confi- dence 80%. In that case, the first rule is misleading since the presence of x actually decreases the likeli- hood of finding the item z. More generally, given a rule X + y with confidence c%, we say it is mislead- ing if and only if there is another rule X? + y with confidence c?% where 8 C X? C X ,  c%/d% < y, and where y is a user-defined threshold typically set at one or over. (In this case, we allow X? = 8 in this other ?rule? in which case the confidence is simply the sup- port of item y.)  Statistically Insignificant Rules We can view the sup- port of an itemset X as the probability of finding X in a transaction. A rule X 3 Y is not very interesting to us if X and Y just happen to co- occur in transactions by chance. Specifically, if supp(X + Y) x supp(X) x supp(Y), then it is likely that X and Y are independent and X + Y would not be statistically significant. Yet, if supp(X + Y )  >> supp(X) x supp(Y), then this is not likely to be the case.

More specifically, suppose we find that X and Y have supports p ,  and p y  which we shall use as esti- mates for the true probabilities of finding the respective itemsets in any given transaction. If we assume that X and Y ,are independent, then the probability of finding both in a particular transaction is p Z p y .  Now, suppose we have n transactions and the rule X 3 Y occurs in k of them (with support k/n). Then the probability that X + Y occurs in k or more transactions assuming that X and Y are independent is [7]:     Clearly, the lower the above probability - the so-called p-value - the more statistically significant the rule X + Y since it is less likely that X and Y are inde- pendent. In our experiments, we ensure that all rules have p-values of X or less, where X is a user-specified threshold.

Local Pruning In addition to the global pruning described above, we also prune locally on various subsets of the rules discovered.

Specifically, our tool allows the user to browse: (1) rules that demonstrate reuse of a particular library class; and (2) rules that are violated in a particular application (where the tool acts like a ?reuse lint?).

In the former case, we consider only the set of rules with that library class in the antecedent or consequent. In the latter case, we consider only those rules that are violated by at least one class in the application of interest. Either way, once we have extracted the subset of rules, we follow the same local pruning procedure when presenting the results to the user.

The motivation for local pruning is the following: given the presence of a particular rule, another rule may not be surpris- ing to us. In that case, it is desirable to additionally prune the latter rule to focus the user?s attention on those rules that are interesting. The pruning process that follows builds upon several existing techniques [2, 111.

Consider rules X + y and rule X? + y, where X? is a sub- set of X. If we know the confidence c?% for rule X? + y, then we expect the confidence for rule X + y to also be c?% since there is no reason to believe - without prior knowl- edge of the library and/or applications - that the additional items X-X? in the antecedent are likely to increasefdecrease the occurrence of y. Thus, we shall consider pruning X + y if its confidence c% is not much greater than c?%. More specifically, we set an interest threshold 6 and prune any such rule X =$ y where c%/c?% < 6. If it is not pruned, we say that X + y is &interesting with respect to X? + y.

We also perform anotherform of pruning: Suppose we have two rules X =+- y and X 3 $ where X is an ancestor of itemset X contqning the same number of items (where ?an- cestor? means X < X as defined in Section 2) or Q is an ancestor of y (or both). In such a cye ,  we may keep the more specific rule X + y and prune X 3 6.

Generally speaking, we would like to show the more specific rule which tends to be more informative. However, we may also wish to show the more general rule if its confidence is much greater than expected.

If X + y has confidence c%, then X + y has expected confidence c% since there is no reason to believe, without prior knowledge, that y is more/less likely to be in a trans- action with X than one with X. However, as $ is an an- cestor of y, the rule X + $ clearly has confidence c% and  possibly much more. To get a reasonable estimate for ex- pected support, we shall assume prior knowledge of the rel- ative support of y and $. With such knowledge, we would expect X + Q to have confidence (supp(Q)/supp(y)) * c% since of those transactions that support X, we would expect supp(Q)/supp(y) of them to support Q.

By the first observation, X + y has expected confidence-c%.

Given the confidence c% for X + y, we would expect X + $ to have confidence (supp($)/supp(y)) ,* c% as explained above. Consequently, we prune the rule X + i j  if and only if ~ s u p p ~ ~ ~ ~ ~ u p p ~ y ~ ~ ~ c ~  < 6 for some interest threshold 6.

Finally, combining this analysis with our earlier results on smaller antecedents X?, we shall prune a rule X + ij given confidence c?% for X? + y if and only if  < 6. This follows because the ex- pected confidence for X =+- y is the same as the confidence c?% for X? + y.

Now, we are ready to describe the complete pruning proce- dure. Given a set of rules { X I  + y1,. . . , X ,  + yn}, we first construct a partial order with a node for each rule. The nodes in the partial order are ordered as follows: X i  + yi < Xj + yj if and only if: (1) the rules are not identical; (2) 0 E X i  C X j ;  and (3) X ,  is more specific than or equal to Xj and y, is a descendent of or equal to yj.

Pruning proceeds by considering the nodes of the partial or- der in topological sort order. That is, an ancestor is always processed before its descendents. In this process, a rule X + y is not pruned if and only if it is &interesting with respect to all ancestors in the partial order that have survived the pruning process to that point.

4 BROWSING REUSE PATTERNS In this section, we shall demonstrate how one might browse and learn from generalized association rules by considering code written for the KDE desktop environment. The KDE li- braries provide a C++ application framework for developing GUI applications. In our experiment, we have mined reuse patterns for the KDE 1.1.2 core libraries (which include the Qt toolkit) by analyzing 76 real-life applications.

Specifically, we have used our tool, CodeWeb, to mine for generalized association rules with confidence of at least 10% and support of at least 15 transactions. (There were 1365 transactions total so the support requirement as a percentage is about 1.1%.) The global pruning parameters were set at y = 1.25 and X = 0.01. The local pruning parameter 6 was set to 1.25. Only rules with one item in the antecedent and one item in the consequent were considered.

To contrast generalized association rule mining with our ear- lier work on standard association rule mining, we also in- clude the data mining results where inheritance was ignored all together. On a Sparc Ultra 1, mining generalized asso- ciation rules took about 50 minutes while mining standard  E%  ~ s u p p ~ g ~ ~ s u p p ~ y ~ ~ ~ c , ~  E%     association rules took 20 minutes. The rule statistics are as follows:  Rules Global Pruning Mined Uninteresting Misleading Insignificant  Generalized 5 1308 13299 1904 6681 Standard 21594 996 320 978  Rules Left  Observe that while the number of rules mined by generalized association rules is significantly more than that using stan- dard association rules, a greater percentage of these rules is eliminated during global pruning. Of course, the number of rules pruned locally varied depending upon the local context and is not shown here.

Typically, a developer just starting out with a library would identify important library classes and browse their reuse pat- terns. By ?important?, we mean those library classes that are reused in many existing applications and are thus likely to be relevant in new applications also. For example, a developer using our tool would notice that the KDE classes KApplica- tion and QObject are reused in 99% and loo%, respectively, of the 76 applications mined - and are thus essential in any KDE application. We consider the reuse patterns for these two classes in what follows.

KApplication Reuse Patterns Figure 3 shows all reuse patterns predicated on the instanti- ation of KApplication in an application class. The support- ers of a rule are those application classes for which all rule items apply. For example, an application class that supports reuse pattern #1 must instantiate KApplication and calls its member function exec(). We also show the detractors of a rule which are those application classes for which the an- tecedent items apply but where the consequent item does not hold. For example, an application class that detracts from reuse pattern #1 must instantiate KApplication and not call exec(). Our tool allows users to browse the source code for both supporters and detractors of reuse patterns; these ap- plication classes illustrate characteristic and uncharacteristic reuse, respectively.

In Figure 3, we find - among other things - that of those applications classes that instantiate the KApplication class, 72.3% call its member function exec(), 58.5% instantiate KT~pLevelWidget~, 53.8% call the member function set- Mainwidget() of the class KApplication, and 46.2% call the show() member of the class KTopLevelWidget^. Re- call that the symbol ?A? indicates that some application class may reuse a strict descendent of KTopLevelWidget rather than the class itself,  By browsing reuse patterns in combination with library ref- erence documentation (which is usually available) and appli- cation source code, a developer can learn to use a library by example in much the same way as studying manually con- structed tutorials and/or toy programs (both of which may  not be available).

For example, doing this for the rules in Figure 3 reveals that the class KApplication, instantiated in the main() function of most KDE applications, manages the application event queue. We also observe that applications inherit from KTo- pLevelWidget to define the main widget of the application (e.g., one that is not contained in any other); this widget is then instantiated and a call to setMainWidget0 tells the li- brary that whenever the user closes this widget that the appli- cation should terminate all together. Afterwards, the exec() member of KApplication is called to enter the main event  Finally, it turns out that all applications that instantiate KTo- pLevelWidget^ always instantiate a descendent that they de- fine. Without taking into account the inheritance hierarchy (e.g., using generalized association rules), we would miss reuse patterns involving this class all together.

QObject Reuse Patterns The class QObject is an ancestor of almost all classes in the KDE libraries. According to the reference documentation, this class provides facilities for event handling and timing operations. Figure 4 shows some of the reuse patterns re- ported by our tool for QObject; of the 53 rules found for this class, 47 involve a ?*? symbol in the antecedent and/or consequent. It turns out that application classes rarely reuse QObject directly; typically, they reuse it indirectly through one of its descendents. Although QObject is very funda- mental to the KDE libraries, only six rules would have been found without taking into account the inheritance hierarchy.

5 RELATEDWORK In this paper, we have looked for pattems in the way library classes have been reused in practice by existing applications.

In this section, we shall talk about several related techniques.

Exemplars An exemplar is an executable visual model consisting of one or more instances of at least one concrete class for each ab- stract class in a library [6]. By browsing these classes as well as their static relationships and dynamic interactions, one can get a general understanding of how the framework works in a small example.

While an exemplar may be helpful, it is a pre-selected toy example that may not be representative of ?real-life? appli- cations. Moreover, exemplars place an extra burden on the developers of the software library. In contrast, our approach allows the user to browse reuse patterns and the correspond- ing supporter and detractor classes in real-life applications.

Moreover, the tool is automated and works on any existing code.

Reengineering Libraries Recently, research has been done on reengineering libraries by analyzing their usage in several existing applications [lo].

This is done by constructing a lattice that provides insights  loop.

~ - ~ - " l l l l l l l _ l  .--  Figure 3: KApplication reuse patterns. Clicking on kasteroids', a supporter of reuse pattern #1, yields the code on the right.

Figure 4: QObject reuse patterns.

into the usage of the class hierarchy in a specific context.

Such a lattice can be used to reengineer the library class hi- erarchy to better reflect standard usage. In contrast, we are interested in helping novice users learn to use a library to write new applications - not reengineer the library itself.

This different perspective has led us to: (1) initiate a new &search direction for mining code for the purposes of illus- trating characteristic code reuse; (2) use data mining tech- niques that scale to a hundred or more applications - not just a few examples for which confidence and support mea- sures would not be meaningful; (3) look for different kinds of reuse patterns that are more helpful for demonstrating reuse of the library classes; and (4) construct a tool whose user in- terface is aimed at users of a software library rather than its developers.

Other Work involving Data Mining Researchers have used data mining and related techniques for a variety of purposes. For example, data mining has been used to: discover likely program invariants [5]; infer spec- ifications in software [3]; and decompose a software sys- tem into data cohesive subsystems to assist developers with reengineering and maintenance tasks [4]. The last of these is the only other work we are aware of that uses association rule mining in the software engineering domain.

6 CONCLUSIONS AND FUTURE WORK In this paper, we have shown how data mining can be used to discover library reuse patterns in existing applications.

Specifically, we considered the problem of discovering li- brary classes and member functions that are typically reused in combination by application classes.

This paper improves upon our earlier research using ?associ- ation rules? [$] by taking into account the inheritance hier- archy using ?generalized association rules?. This has turned out to be non-trivial due to the significantly larger number of rules that arise as a result. Consequently, pruning is impor- tant and we showed several ways in which it can be done.

By browsing generalized association rules, a developer can discover patterns in library usage in a way that takes into ac- count inheritance relationships. We have illustrated the ap- proach using our tool, CodeWeb, by demonstrating charac- teristic ways in which applications reuse classes in the KDE application framework. We have observed that some impor- tant rules would not have been found without taking into ac- count the inheritance hierarchy. I  One can view our general approach to mining reuse patterns as learning from positive experience. That is, library reuse that has worked in practice. (Presumably, one would se- lect ?stable? applications to demonstrate reuse patterns in a library.) However, one can also mine negative experi- ence. That is, misunderstandings and problems that came up when reusing components from a software library. For future work, it would be interesting to determine if one can .

mine negative experience in an automated way -perhaps by analyzing application CVS logs for reuse patterns that were problematic and later corrected.

