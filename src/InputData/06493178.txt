Parallel Frequent Set Mining Using Inverted Matrix  Approach

Abstract?Mining frequent patterns in large transactional database is considered as one of the most important data mining problems. The recent explosive growth in data collection made the current rule mining algorithms restricted and insufficient to analyze excessively large transaction sets because they suffer from many problems when mining massive transaction datasets. Some of the major problems are: (1) required multiple database scan, (2) massive computational power requirement (3) huge memory requirement , and (4) lake of parallelism (5) less of interactive nature for different support value ([1-2]). In this paper an approach of Inverted matrix, the new representation of transactional database is used and distributed it amongst parallel nodes. Frequent item from the inverted matrix is assigned to parallel nodes. In parallel implementation, a Co-Occurrence Frequent Item (COFI) tree for assigning frequent item is generated by the parallel nodes. Mining process is accomplished by all nodes which generate all frequent items in which the assigned items are participated. Here, less communication is required amongst the master node all parallel node to generate all frequent itemsets. Two techniques have been used for assignment of frequent item to the parallel nodes, viz.  (1) Alternate Loop Splitting (ALS), and (2) Block Loop Splitting (BLS).  We have Implemented sequential as well as parallel algorithms for frequent set mining and compared its performance on mushroom [9] database having approximately 10000 transactions, 120 different items and 23 average transaction sizes. It has been found that alternate loop splitting achieves better time complexity as compared to block loop splitting. Also both the parallel techniques are found to be better than sequential algorithm.

Keywords- parallel data mining; frequent itemset; inverted matrix; COFI tree

I.  INTRODUCTION In recent days various data mining techniques have been  evolved. Frequent pattern mining is one of the important techniques used in many data mining tasks, such as association rules, correlations, causality, sequential patterns, episodes, clusters, sequences, multi-dimensional patterns, max-patterns etc. Identifying a frequent pattern is considered as one of the most important tasks and it has been focused by many practitioners/researchers since last  decade. Many solutions are available that uses sequential or parallel techniques, but they are suffering from the various bottlenecks like unbalanced load distribution, high communication overheads, lacking of synchronization with parallel nodes and most important high I/O overhead for scanning the dataset multiple times. Thus, It is important and interesting research problem to mine efficient and an effective frequent pattern.

In this paper, a comparison of one sequential algorithm, and two parallel algorithms, namely, alternate loop splitting, and block loop splitting, which are based on inverted matrix and COFI-Tree, has been made.



II. PROBLEM STATEMENT Frequent pattern mining is a sub-problem of mining  association rules. Formal definition of frequent pattern mining can be stated as follows:  Let set of Items I = {it1, it2, it3?itn}. Where n is the dimensionality of the problem. Let, the task-relevant data is DB, a set of transactions database where each transaction Ts contains a set of items which is subset of I  i.e. Ts ? I. A transaction Ts is said to contain R, a set of items in I, if R ? Ts. An itemset R is said to be frequent, if its support (i.e.

ratio of transactions in D that contain R, to the total number of transactions in D) is greater than or equal to a given minimum support threshold. The frequent itemset R is called a frequent k-itemset, if it contains k items. A 1- itemset is also called a frequent item ([4],[10]).

Much of the present research work has been focused to mine the frequent patterns.



III. BACKGROUND In [1], El-Hajj and Zaiane proposed a new frequent item  set mining algorithm named COFI. In this algorithm, mining process is accomplished within three steps described as follows in three subsections.

A. Construction of Inverted Matrix Layout The transaction database is scanned twice and generates a  new transaction layout called inverted matrix layout. It is combination of horizontal and vertical transaction layout, so      Node-1  * *  *m  Master Node  Node-2 Node-m  Lable ?1? indicates assignment of items 1, m+1, and so on.

Lable ?2? indicates assignment of item 2, m+2 and so on Lable ?m? indicated assignment of item m, m+m and so on Lable ?*? indicates node send the frequent itemset after mining all item?s COFI tree, assign to that node.

???..

it gets the benefits of both the layouts. The horizontal transaction layout combines all items together in one transaction, and vertical transaction layout relates all transaction that share the same item together.

B. Constructing a COFI-Tree In this step, from the inverted matrix layout, the Co-  Occurrence Frequent Item (COFI) tree is constructed which is relatively small tree for each frequent item. Important characteristic of COFI tree is that, the items which participate in constructing COFI-tree for given item I, are more frequent or as frequent as I. In other words, the COFI- tree for item I, all frequent items which are more frequent than I and share transaction with I, participate in building a tree.

C. Mining  a COFI-Tree In this step, each COFI-tree of all items has been mined  independent of each other. Here, for each COFI-tree of item I, mine the k-itemset frequent patterns in which the item I participates.



IV. PARALLEL IMPLEMENTATION OF FREQUENT PATTERN MINING  Various parallel algorithms have been developed, but they are suffering from various problems like improper dynamic load balancing, high communication cost, multiple scan of transactional database by all the parallel nodes, improper data distribution etc. ([5-8]). In this paper, two parallel techniques based on the inverted matrix approach have been implemented and compared with each other.

These parallel techniques are also compared with the sequential technique.

In parallel implementation, the inverted matrix is replicated to all parallel nodes by the master node. So, all nodes are having the full transactional database. Then each node creates the COFI tree for the item which is assigned to them by the master node and mines it. After mining all the COFI trees by parallel node, frequent itemsets are sent to master node. At the end, master node having all the frequent itemsets mined by all the parallel nodes. Let n be number frequent item and m is the number of parallel nodes (assuming m<n). Here, the assignment of items to the parallel nodes accomplished by two parallel techniques, namely, alternate loop splitting and block loop splitting are described as follows.

A. Alternate Loop Splitting(ALS) Technique In inverted matrix, items are stored in ascending order of  their support value. So, the item which is most frequent is stored at the highest index position. In this technique, all n frequent items from the inverted matrix are evenly assigned to m nodes, one by one, i.e. least frequent item is assigned to node 1, next least frequent item is assigned to node 2 and so on up to m nodes. After that, (m+1)th item is assigned to node 1 and so on until all items are distributed amongst all m nodes. The implementation architecture of this technique is shown in Fig 1. and the algorithm for Alternate Loop Splitting technique is shown in Fig. 2.

Figure 1.  Implementation architecture of ALS Technique.

Figure 2.  Implementation architecture of ALS Technique.

B. Block Loop Splitting(BLS) Technique In this technique, from all n frequent items from the  inverted matrix, first n/m items are assigned to node 1, next n/m items are assigned to node 2 and so on. This process is continued until last n/m items are assigned to node m. In other words, after ordering the frequent items by their support in inverted matrix, starting from the least frequent item, each processor successively receives n/m block of items from master node. So in this case processor 1 builds the COFI-tree for first n/m frequent items (i.e. 0 to (n/m)-1), processor 2 build the COFI-tree for second n/m frequent items (i.e. n/m to (2n/m)-1) and so on. The   implementation architecture of this technique is shown in Fig. 3 and the algorithm for the Block Loop Splitting technique is shown in Fig.4.

Algorithm: Alternate Loop Splitting Input: Transactional Database Output: Frequent itemsets  1. Create inverted matrix layout by scanning transaction database twice at master node.

2. Replicate inverted matrix to every m nodes.

3. Distribute n frequent items amongst m nodes  (assuming m<n) and mine as following: 3.1 Assign least frequent item from Inverted  Matrix to Node 1, next least frequent item to node 2 and so on up to m nodes. Assign (m+1)th item to node 1 again until all frequent items are distributed amongst m nodes.

3.2 Create COFI trees for items at every node for items which is assigned to those nodes.

3.3 Mine the COFI-Tree which is created in nodes.

3.4 Send the mined frequent item by the nodes to  master node.

Node-1  * *  *m  Master Node  Node-2 Node-m  Lable ?1? indicates assignment of first n/m block of items.

Lable ?2? indicates assignment of second n/m block of items Lable ?m? indicated assignment of mth n/m block of items.

Lable ?*? indicates Node send the frequent itemset after mining all item?s COFI tree, assign to that node  ???..

Figure 3.  Implementation architecture of BLS Technique.

Figure 4.  Implementation architecture of BLS Technique.



V. EXPERIMENT AND RESULT In this work, we have implemented sequential as well as  parallel inverted matrix algorithm which mines the frequent item sets from the mushroom database [9] having approximately 10000 transactions, with 120 items, and an average transaction length of 23 items. The parallel implementation of the presented algorithms is carried out using JAVA RMI. The parallel implantation was tested on a cluster of six 1.66 GHz Pentium processor having 512 MB RAM on 100 mbps LAN. The result was derived by executing the particular technique for different support value, on different number of nodes varying from 1 to 6 nodes. The overall procedure was repeated multiple times and average results are presented from multiple runs. Some results are based on the maximum or minimum time taken by process amongst multiple processes executing on parallel nodes,  some results are based on the average time of the execution and some results are based on the time difference between maximum and minimum time taken by the parallel processes. Following observations can be made from the experimental results obtained.

? Parallel techniques give better performance as compared to the sequential technique (see Fig. 5).

? Generally, it is apparent from  inverted matrix that, there can be more possibility that the COFI tree for the less frequent item may have more depth than the COFI tree for the more frequent item. COFI tree is not generated for the item which is most frequent.

The COFI tree for the second most frequent item having at most depth one. Theoretically, there is high possibility that COFI tree for the less frequent item requires more time to mine compared to the COFI tree for the more frequent item. Again, in ALS, frequent items are evenly distributed, one-by-one, from least frequent to most frequent, while in BLS, frequent items are distributed in blocks, i.e. block of most frequent items are assigned to first node and block of least frequent items are assigned to the last node. So, in ALS load is evenly distributed, where-in BLS the load is not evenly distributed. It has been observed that, ALS balances the load amongst the parallel nodes better than the BLS (Fig. 5 and Fig.

6). In Fig. 5, we have shown the load balancing between ALS and BLS by comparing the minimum time take by the processes and maximum time take by the processes with different support values, and in Fig. 6, we have shown the load balancing by comparing the time difference between maximum time taken by the processes and minimum time taken by the processes with different support values.

? It has been found that the alternate loop splitting technique is efficient in terms of execution time than the block loop splitting technique(see Fig. 7).

? Fig. 7 and Fig. 8 show that, in both the techniques, as number of processing nodes increases, the processing time decreases, for a given support value.

