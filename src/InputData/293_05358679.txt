Rule-chain Incremental Mining Algorithm Based on Directed Graph

Abstract?Aiming to discover the rule-chains directly, a novel graph-based online incremental mining algorithm (RIOMining) is proposed. Firstly, an interrelated bitmap based on a directed graph (PAGraph) is designed to compress the rule-chain information for storage. The compressed storage of the directed-graph effectively avoids repetitious database scanning and makes meaningful rules found more conveniently. Secondly, four theorems about discovery and pruning of frequent path in the graph are proved, so as to the rule-chains could be iteratively generated by searching incremental paths, while the theorems narrow the search scope and promote the performance by properly pruning and extending paths. It effectively reduces the redundancy calculation. Comparing it with other two fast mining algorithms, DLG and FP-growth, experimental result shows that it can mine rule-chains of high quality, especially, it is of real-time accuracy, and thereby it can be widely applied to dynamic network environment.

Keywords-Rule-chain; Incremental Mining; Frequent Path Discovery; Association rule

I.  INTRODUCTION Generally, the design of Association Rule Mining (ARM)  is divided into two phases: (1) Seeking all association rules (ARs) in database, and (2) Discovering useful rules within ARs. Since a tremendous volume of information need to be processed, the exponential growth of rules with item sets growth becomes the key problem, which makes it difficult to discover available ARs that are always only a small part.

Previous studies focused on the first phase, to deal with the fast generation of frequent item sets (FIs). Recently, some researchers proposed some effective and efficient algorithms which used association graph to solve the problem of tremendous volume of processing information. In this paper, based on these results of successful researches, we proposed a novel rule-chain incremental online mining algorithm based on directed graph to promote the efficiency of ARs online mining in real-time. Meanwhile, the compressed storage of frequent item information in the directed-graph effectively avoids the disadvantage of repetitiously scanning transaction database and make meaningful rules found more conveniently.

Related work. Algrawal first proposed a famous two- stage algorithm based on FIs, Apriori algorithm [1]. The disadvantages of this approach are repetitiously scanning transaction database and generating large numbers of candidate item sets, which lead to low time and space efficiency. Therefore, many researchers have made great efforts to improve the algorithm [2-6], in which the graph- based mining method is a new research idea. For example, Yen[2], Muthukumar[3] and Appice[4], et al. proposed their respective graph-based mining algorithms and DLG algorithm is a typical one, that scans database to construct an association graph, and traverse the graph to generate all large item sets. Burdick?s algorithm defined a vertical bitmap to store projection of items and designed a depth-first traversal of item set lattice [5]. Yang & Sun presented a prefix general linked list, and get a new algorithm for fast mining ARs by using it [6]. These models reduce the number of scanning database effectively. However along with introducing graph into ARM, the ?new complexity? is readily brought, and accordingly it costs additional time and space.

Though graph-based ARM is imperfect, there is no doubt that it is a new idea for the mining algorithm. Using association graph, relationship between frequent items could be set out, the mining operation could be transferred to the route-searching operation, and many study results of path optimization could be adopted. Based on these researches [7-10], this paper proposed a novel graph-based rule-chain incremental online mining algorithm (RIOMining). Firstly, the potential association rule directed graph (PAGraph) is created, in which the node is corresponding to a frequent item (FI), and the arc is to a frequent 2-itemsets from greater FI to smaller FI. Then, four theorems about discovery and pruning of frequent path are proved. Thus rule-chains could be discovered by iterative search in PAGraph. Comparing to the traditional mining methods, experimental result shows RIOMining can mine rule-chains of high quality efficiently, especially, it is of real-time accuracy, and thereby it can be widely applied to network dynamic environment.

The paper is organized as follows. The definition of PAGraph and its characters are given in Section 2 as the basic work. The principle of graph-based mining is described   DOI 10.1109/FSKD.2009.587    DOI 10.1109/FSKD.2009.587     in detail in Section 3, in which several theorems about discovery and pruning of frequent path are proved, and RIOMining algorithm is given. Section 4 reports the results of the computer experiments comparing with DLG algorithm and traditional FP-growth algorithm, and Section 5 concludes the paper and points out the directions of our future work.



II. POTENTIAL ASSOCIATION DIRECTED GRAPH  A. Structure of PAGraph In order to construct the mathematical model, several  symbols will be used as follows [7].

There is a transaction database, TD::= {<TID, ITEMS >}  and TN is the number of transactions, where <TID, ITEMS > is a transaction, TID is the transaction identifier, and ITEMS is items involved in the transaction.

Supposed ISET::= {I1, I2?} is the candidate item set of a transaction database TD, N::=|ISET| is the number of candidate items. The definition of IBits is given as follows.

Definition 1. (IBits). IBits is a bit vector about an item, its length is the number of transactions, if i-th bit is ?1?, it means the item appears in the i-th transaction, otherwise ?0?, means not in i-th transaction.

? count(Item): is the frequent of the item, computed simply by taking count of ?1? in IBits of the item.

? Sup(Item): is the item support, computed by formula, Sup(Item::)=count(Item)/TN                       (1)  IBits describes the item distribution in TD, Sup(Item) is the item support.

Definition 2. (IMap). IMap is a bit matrix, composed by IBits of all candidate items, i.e.

IMap::= (IBits)N?1.                                (2) Definition 3.  (FIs). FIs is the frequent item set, i.e.

FIs::={ Item |Sup(Item) ? Mins}                  (3) where Mins is a threshold called the minimum item  support Similarly, k-FIs is the frequent k-item sets, k=2...N, and  k-FIs::={<Ii1?Iik>|Sup(Iij)?Mins,                       (4) Sup(Ii1???Iik)?Mins, j=1?k }  Then, a potential association rule directed graph, PAGraph, is defined.

Definition 4. (PAGraph). PAGraph=<V, E> is called potential association rule directed graph, where V is the set of nodes in accordance with FIs; E is the set of edges, E::={<Ii,Ij>| Sup(Ii) ? Sup(Ij) ? Mins ?Sup(Ii?Ij) ? Mins }.

The structure shows that each edge in PAGraph is corresponding to a frequent 2-itemsets, and an edge is to an arc from greater frequent item to smaller one.

B. Properties of PAGraph According to the graph theory, we easily obtained the  following three properties of PAGraph which are very useful for further proving theorems about discovery and pruning of frequent path.

1. The number of nodes in PAGraph is equal to the number of frequent items, and the number of arcs in PAGraph is equivalent to the number of frequent 2-itemsets.

2. The out-degree of a node is equal to the number of its adjacent nodes in the PAGraph, i.e. the number of frequent 2-itemsets starting from the node.

3. For each arc <Ii,Ij>?E, there are Sup(Ii?Ij)?Mins and Sup(Ii) ?Sup(Ij)?Mins, then Sup(Ii?Ij) can be computed readily by the formula[7], Sup(Ii?Ij) = count ( IBitsi ? IBitsj ) / TN.



III. RIOMINING ALGORITHM BASED ON THEOREMS ABOUT DISCOVERY AND PRUNING OF FREQUENT PATH  A. Theorem of frequent path Theorem 1. (Theorem of frequent path) Each frequent k-itemsets is corresponding to a path in  PAGraph whose length is k-1.

Proof: From PAGraph?s nature 2 we know that, for each k-  FI::=<I1?Ik>, there exists Sup(I1???Ik)? Mins.

So the support of the subset of {I1?Ik} is greater than or  equal to Mins, that is, the subset is frequent, then Sup(I1 ?I2) ? Mins, Sup(I2?I3) ? Mins,?, Sup(Ik-1?Ik) ? Mins, and <I1,I2>, <I2,I3>, ?, <Ik-1,Ik> are frequent.

Therefore, as the definition of PAGraph, these arcs compose a path whose length is k-1.

This concludes the proof.

B. Theorem of non-frequent path pruning Theorem 2. (Theorem of non-frequent path pruning) In PAGraph, ? <Ii, Ij>?E, i.e. <Ii, Ij>?2-FIs, for  another node Ik, if Ik is not connected with Ii or Ij, then <Ii, Ij, Ik>?3-FIs.

Proof: Supposed <Ij,Ik>?E, that is, it?s not 2-FI, and  count(Ij?Ik)<Mins*TN.

As count(Ii?Ij?Ik)? count(Ij ?Ik) and count(Ij?Ik) <  Mins*TN, then Sup(Ii?Ij ?Ik) <Mins.

Thus, <Ii, Ij, Ik>?3-FIs.

This concludes the proof.

The theorem is easy to understand. It is also readily  extended to k-FI situations, k=2?N. In PAGraph, there is a path <I1,I2,?,Ik>, and <I1,I2,?,Ik> belongs to k-FIs, then for another node such as Iu, if Iu is not connected with one of I1,I2,?,Ik, then <I1,I2,?,Ik, Iu> doesn?t belong to (k+1)-FIs.

This conclusion can be used to effectively prune the path from rule-chain search process of mining.

C. Theorem of Incremental frequent path Supposed LDB is the transaction database, ?LDB is  LDB?s incremental database, TN::=|LDB|, ?TN::=|?LDB|.

Let k-FIs(D) be k-FIs of database D, Sup(D,Iset) and count(D, Iset) be respectively the support and the frequent of Iset in D, where Iset is a item set and D is a database.

Theorem 3. (Theorem of Incremental frequent path) For each Iset?( k-FIs(LDB) ? k-FIs (?LDB)), there  exist Iset?k-FIs (LDB??LDB). That is, if Iset, the item set, is frequent respectively in LDB and ?LDB, then it is frequent in LDB??LDB.

Proof: As Iset?k-FIs(LDB), then count(LDB, Iset) ? Mins *  TN, and as Iset?k-FIs (?LDB), then count (?LDB, Iset) ?Mins * ?TN.

Thus, count (LDB, Iset) + count ?LDB, Iset) ?Mins * TN + Mins * ?TN, i.e. count (LDB??LDB, Iset) ?Mins * (TN +?TN ).

From the definition of the support, Sup(LDB??LDB, Iset)=count (LDB??LDB, Iset) / ( TN+?TN ) ?Mins.

Therefore, Iset is k-FI in LDB??LDB.

This concludes the proof.

D. Theorem of incremental non-frequent path pruning Theorem 4. (Theorem of incremental non-frequent path  pruning) ? Iset ? ISET, if Sup(?LDB, Iset) ? Mins and Iset is not  frequent in LDB, then Iset must be not frequent in LDB??LDB.

Proof: As Iset is not frequent in LDB, then count(LDB, Iset) ?  Mins * TN, and as Sup(?LDB, Iset)?Mins, then count (?LDB, Iset) ? Mins * ?TN.

Thus, count(LDB, Iset) + count(?LDB, Iset) ?Mins * TN + Mins * ?TN, i.e. count(LDB??LDB, Iset) ?Mins * (TN +?TN).

From the definition of the support, Sup(LDB??LDB, Iset)= count(LDB??LDB, Iset) / (TN +?TN) ?Mins.

Therefore, Iset is not frequent in LDB??LDB.

This concludes the proof.

E. RIOMining algorithm Let Minconf be the minimum confidence, PL(D)::= 2-  FIs(D)?...?k-FIs(D) be the collection of frequent item sets, ?PL(D) be the collection of non-frequent item sets.

When ?LDB is added to LDB, there are four situations to be dealt with in accordance with these four theorems above.

Situation 1.

The incremental frequent handling of PL(LDB).

That is, for each Iset in (PL(LDB)?PL (?LDB)), there  must exist Iset?PL(LDB??LDB). It can be proved by theorem 1.

Situation 2.

The incremental non-frequent handling of PL(LDB).

That is, for each Iset?PL (LDB), if Iset? ?PL(?LDB),  there may exist Iset?PL(LDB??LDB). Because Sup (LDB, Iset) is given, we can get count( ?LDB, Iset) by only scanning ?LDB simply, and then compute Sup(LDB ? ?LDB, Iset) to determine whether Iset is frequent or not in LDB??LDB.

Situation 3.

The incremental frequent handling of ?PL(LDB).

That is, for each Iset??PL (LDB), if Iset? PL(?LDB),  there may exist Iset?PL(LDB??LDB). Because count(?LDB, Iset) can be gotten through the process of ?LDB mining, so we just re-use IMap of LDB to obtain  count(LDB,Iset), and then compute Sup(LDB??LDB, Iset) to determine whether Iset is frequent or not in LDB??LDB.

Situation 4.

The incremental non-frequent handling of ?PL(LDB).

That is, for each Iset??PL (LDB)??PL(?LDB), there  must exist Iset??PL(LDB??LDB). It can be proved by theorem 4.

In light of above, the RIOMining algorithm idea is: Step 1. Supposed LDBt::=LDBt-1??LDB, LDB0::= ?.

The algorithm iteratively mines the frequent path with incremental length to obtain PL(?LDB). In accordance with the theorem 1 and 4, it narrows the search scope to promote the performance by properly pruning and extending paths.

Step 2. In the mining process, in accordance with the theorem 2 and 3, the algorithm gets rid as far as possible of the part of ISET that is frequent in ?LDB or LDB, and not frequent in LDB??LDB, so as to produce a smaller candidate collection of frequent item sets. It effectively reduces the following redundancy calculation.

Algorithm 1. RIOMining Input: PL(LDBt-1), LDBt-1.IMap, ?LDB Output: PL(LDB??LDB) Procedure RIOMinging ( ) Begin PL(?LDB) = CMining(?LDB, Mins) For( k=2; FIsk(LDB)?? and FIsk (?LDB) ?? ; k++) Begin FIsk (LDB??LDB)= ?  // FIsk is k-FIs For each x ?FIsk (LDB) Do   //situation 1.

If x?FIsk (?LDB) then FIsk (LDB??LDB)= FIsk (LDB??LDB)?{x} For each x ?(FIsk (LDB)?FIsk (LDB ??LDB)) Do  // situation 2.

If count(LDB??LDB, x) /(|LDB|+|?LDB|) ?Mins then FIsk (LDB?? LDB)= FIsk (LDB?? LDB)?{ x } For each x ?FIsk (?LDB)?FIsk (LDB ?? LDB) Do   // situation 3.

If count(LDB??LDB,x)/(|LDB|+|?LDB|) ?Mins then FIsk (LDB?? LDB)= FIsk (LDB?? LDB)?{ x } PL(LDB?? LDB) = PL(LDB?? LDB) ?FIsk (LDB?? LDB) End End  Algorithm 2. Mining ?LDB Input: ?LDB Output: PL(?LDB) Procedure CMining ( ) Begin     ?LDB.IMap = GetIMap (?LDB, Mins) FIs=CreateFIs(?LDB.IMap, Mins) ?LDB.PAGraph=CreatePAGraph(?LDB.IMap, FIs, Mins) // Generate 2-FIs k=2; PL(?LDB)= FIs?FIs2 While FIsk ?? Do      // k=2,3,? Begin FIsk+1 =? For each x?FIsk Do Begin Nodek=LastNode(x) For each u?<Nodek,u> in ?LDB.PAGraph Do If Sup(?LDB, x?u) ? Mins then FIsk+1 = FIsk+1 ?{ <x,u> } End PL(?LDB)= PL(?LDB)?FIsk+1 k++ End End

IV. RESULTS AND DISCUSSION Based on analyzing, we can see that, the time  complexity of Algorithm 1 and Algorithm 2 are as follows:  ? ?  =  +   2 ]*4)[( N  i  i N  i N CC                           (5)  O( ? ?  =   *   N  i  i NC  N )                               (6)  Since the new algorithm is not necessary to repeat scan the original database, which only dynamicly scan incremental data set once, it can make full use of the results of the original excavation, such as PL(LDB) and PL(?LDB), to generate incremental results.

To test the algorithm, RIOMining, we compared it with DLG [2] and FP-growth [11]. We programmed them in JAVA on a PC with Intel(R) Pentium(R) M processor 1300MHz and 512M memory.

Experimental datasets we used were generated by modified version of IBM synthetic data generator on Linux[12] whose parameters, D is the number of transactions, T is the average number of items in a transaction and I is the number of whole items.

Figure 1.  The comparision on D10KT10I1K     Figure 2.  The comparision on D1KT10I100  Fig. 1 is the experimental result on dataset D10KT10I1K and Fig. 2 is on dataset D1KT10I100. Algorithms are run under different supports. The result shows that RIOMining can mine rule-chains of high quality, especially, it is of real- time accuracy, and thereby it can be widely applied to dynamic network environment.



V. CONCLUSIONS AND FUTURE WORK This paper presents some of the key techniques for  directed-graph-based online mining problem on network environments. Taking the advantage of the algorithm, the research implemented a dynamic mining model for partner online selection based on a real-time collaboration incidence graph. Comparing to the traditional offline mining methods, the model have better real-time accuracy, especially, the indirect or weak associations in business cooperation also can be effectively caught.

The future work should be done on the issues of intelligent parallel mining algorithm based on RIOMining for internet open platform and we believe this will have our system work more efficiently.

