Heterogeneity-Aware Data Regeneration in Distributed Storage Systems

Abstract?Distributed storage systems provide large-scale re- liable data storage services by spreading redundancy across a large group of storage nodes. In such big systems, node failures take place on a regular basis. When a node fails or leaves the system, to maintain the same level of redundancy, it is expected to regenerate the redundant data at a replacement node as soon as possible. Previous studies aim to minimize the network traffic in the regeneration process, but in practical networks, where link capacities vary in a wide range, minimizing network traffic does not always mean minimizing regeneration time.

Considering the heterogeneous link capacities, Li et al. proposed a tree-structured regeneration scheme, called RCTREE, to bypass the low-capacitated link encountered in direct transmissions.

However, we find that RCTREE may rapidly lose data integrity after several regenerations.

In this paper, we reconsider the problem of minimizing regeneration time in networks with heterogeneous link capacities.

We derive the minimum amount of data to be transmitted through each link to preserve data integrity. We prove that building an optimal regeneration tree is NP-complete and propose a heuristic algorithm for a near-optimal solution. We further introduce a flexible regeneration scheme, which allows providers to generate different amount of coded data. Simulation results show that the flexible tree-structured regeneration scheme can reduce the regeneration time significantly.



I. INTRODUCTION  Large-scale distributed storage systems are widely used today to provide reliable data storage service, by spreading data redundancy over a large number of storage nodes. Users can access their data anytime anywhere. Such application scenarios include large data centers like Google File Systems [2], Total Recall [3], OceanStore [4] and peer-to-peer storage systems such as Wuala [5].

In such big systems, nodes fail frequently and the failures should be handled on a routine basis. After a node fails or leaves the system, the reliability degrades and the protected data becomes vulnerable. To maintain the same level of redundancy, it is important to regenerate the lost data at a replacement node, called newcomer, as soon as possible [2]. A direct way to solve this problem is to minimize the amount of data transferred during the repair process. Thus,  Yan Wang is also with School of Software, East China Jiao Tong University, Nanchang, China. This work is supported in part by the National Science Foundation of China under Grant 61171074, Program for New Century Ex- cellent Talents in University under Grant NCET-11-0113, Shanghai Municipal R&D Foundation under Grant No. 13511500400 and Projects of East China Jiaotong University(10RJ02). Xin Wang is the corresponding author.

Dimakis et al. proposed Regenerating Codes [6] to minimize the total repair bandwidth. They found that there is a trade-off between repair bandwidth and storage efficiency, with two ex- tremal cases: the minimum-storage regenerating (MSR) point where each node stores the minimum amount of data, and the minimum-bandwidth regenerating (MBR) point where the storage efficiency is sacrificed for minimum repair bandwidth.

For simplicity, they assumed each surviving node participating in the regeneration, called provider, sends the same amount of data to the newcomer.

However, minimizing repair bandwidth does not always mean minimizing regeneration time, especially in heteroge- neous networks where link capacities vary in a wide range. The heterogeneous networks are common in distributed storage systems. For example, within a data center, servers are usually placed in racks, and servers in the same rack enjoy much higher bandwidth than those located in different racks [7].

Meanwhile, the available bandwidths among servers are dif- ferent because of different background traffics, even if the link capacities are the same [8]. The difference of link bandwidths becomes even larger when using multiple geo-distributed data centers for distributed storage, which is a conventional practice for large companies, e.g. Google, to safeguard their users? data from the failure of an entire data center [9]. In these networks, the time of regeneration process is determined not only by the amount of data transmitted from providers to the newcomer, but also by the bandwidths of bottleneck links between them.

For fast regeneration in heterogeneous networks, Li et al.

[1] have proposed a tree-structured topology data regeneration with regenerating codes, called RCTREE. They achieve high utilization of network links by building a tree-structured path to transfer data, in addition to reducing the regeneration traffic by coding data on the intermediate node of the tree. However, because of transmitting insufficient amount of data, their codes may lose data integrity, i.e., the data collector may fail to reconstruct the original file. Specifically, a distributed storage system is usually described with parameters (n, k, d), where n is the number of storage nodes, k is the number of nodes accessed by data collector to reconstruct the file, and d is the number of providers participating in the regeneration. In literature, the ability to reconstruct the file from any k storage nodes is called MDS property [10].

In this paper, we study the problem of minimizing regen- eration time in heterogeneous networks while maintaining the  IEEE INFOCOM 2014 - IEEE Conference on Computer Communications      v1  v4 v3  v0  v2  (a) network model with one new- comer and four storage nodes  v1  v4 v3  v0  v2  (b) conventional star-structured re- generation scheme (STAR)  v1  v4 v3  v0  v2  (c) tree-structured regeneration scheme (TR)  v1  v4 v3  v2  v0  1 2  4 3  (d) flexible tree-structured regener- ation scheme (FTR)  Fig. 1. Examples for tree regeneration schemes: STAR, TR and FTR. The parameters are n = 5, d = 4, k = 2, M = 480Mb, ? = M/k = 240Mb, ? = ?  d?k+1 = 80Mb. The regeneration time of STAR, TR and FTR is 5.33s, 4s and 3s, respectively.

MDS property. Our contributions are composed of two parts.

First, we reconsider the tree-structured regeneration ap-  proach with regenerating codes, for which we develop the information flow graph method from [6]. Using this method, we derive the minimum amount of data to be transmitted on each link of a given regeneration tree, and formulate the problem of building an optimal regeneration tree to minimize the regeneration time. Unfortunately, we find this problem is NP-complete, mainly because the flow on each link exhibits a correlation with the number of providers using this link. We propose a heuristic algorithm, called Tree-structured Regener- ation (TR), to find a near-optimal regeneration tree.

Second, we introduce a new approach to further reduce the regeneration time by flexibly determining the amount of data generated by each provider. In previous studies such as regenerating codes and RCTREE, they both assume that each provider generates the same amount of coded data to be transmitted to the newcomer. However, we find that this assumption is not necessary. If we allow the provider with low end-to-end bandwidth to generate less data, the regeneration time will be further reduced. Note that as a compromise, the provider with high end-to-end bandwidth will have to generate more coded data to maintain the MDS property. We derive a sufficient condition for determining the amount of data generated by each provider to preserve the MDS property, and combine it with the tree-structured regeneration scheme.

The resultant regeneration scheme is called Flexible Tree- structured Regeneration (FTR).

These ideas can be intuitively illustrated with the example shown in Fig. 1. Consider the overlay network shown in Fig. 1(a), where v0 is the newcomer, and v1, v2, v3, v4 are the d = 4 providers. The bandwidths are labeled on the links, which range from 5Mbps to 60Mbps. We assume that the redundancy is coded as an (n = 5, k = 2)-MDS code, such that any 2 out of 5 storage nodes are able to reconstruct the file. Suppose the size of the original file is M = 480Mb, and each storage node stores ? = M/k = 240Mb. In order to regenerate the lost data at v0, regenerating codes require downloading ? = Mk(d?k+1) = 80Mb data from each provider.

Fig. 1(b) shows the conventional regeneration scheme (STAR) which uses the star-structured topology: v0 receives data  directly from the four providers. The regeneration time of STAR is determined by the slowest transmission which takes  ? 15Mbps = 5.33 seconds. Fig. 1(c) shows the regeneration tree used by TR and RCTREE. They coincide with the same tree in this example. In RCTREE, each provider generates ? coded data with its local storage, encodes them with its received data (if any) and finally transmit ? data to its parent node, which means v1 only transmits ? data to v0 in the example. We find that this is not sufficient for the MDS property (refer to Sec. II for more details). According to our analysis, the minimum amount of data transferred on edge (v1, v0) is 2? = 160Mb at least. Thus, it costs TR max{ 2?60Mbps , ?20Mbps} = 4 seconds to accomplish the regeneration. Fig. 1(d) shows the flexible tree-structured regeneration (FTR) scheme. Each provider is allowed to generate different amount of coded data. We find that if providers v1, v2, v3, v4 generate ?1 = 90Mb, ?2 = 90Mb, ?3 = 60Mb, ?4 = 90Mb, respectively, and v1 transmits ?1 + ?4 = 180Mb to v0, the MDS property is maintained. The regeneration time of FTR is reduced to max{ ?1+?460Mbps , ?320Mbps , ?435Mbps , ?250Mbps} = 3 seconds.

To evaluate the performances of our algorithms, we im- plement all these regeneration schemes and run simulations with practical link capacities. Experimental results show that, according to the variance of link capacities, our proposed algorithm can reduce the regeneration time by 10% ? 90%, compared with conventional regenerating codes. And the FTR scheme even outperforms RCTREE in many scenarios.

The remainder of the paper is organized as follows. In Sec. II, we formulate the process of data regeneration in dis- tributed storage systems and analyze the loss of MDS property in RCTREE by theory and practice. In Sec. III, we reconsider the tree-structured regeneration scheme by analyzing the cor- responding information flow graph. In Sec. IV, we propose a flexible scheme based on tree-structured regeneration. We evaluate the performance of our two proposed regeneration schemes in Sec. V. We introduce the related works in Sec. VI and conclude the paper in Sec. VII.



II. PROBLEM FORMULATION Assume a file consisted of M blocks is encoded into n?  blocks and stored in n storage nodes. Each node holds ? blocks. It is required that the file can be reconstructed by  IEEE INFOCOM 2014 - IEEE Conference on Computer Communications      accessing any k storage nodes. After a storage node fails, d providers are accessed to regenerate ? blocks at a newcomer.

We use a complete graph G(V,E) to represent the overlay network consisted of the d providers and the newcomer [1][11]. For any two nodes u, v ? V , let c(u, v) denote the link capacity from node u to v.

With regenerating codes, each provider generates ? coded blocks by encoding its own ? blocks and directly transmits them to the newcomer. The d provider-to-newcomer flows form a star topology centered at the newcomer. However, in real world overlay networks, end-to-end links usually have different capacities, which may vary in one or two orders of magnitude [12]. Repairing with the star topology may suffer from the low link capacity between some provider and the newcomer.

Considering the heterogeneous link capacity and the bottle- neck effect, Li et al. [1] proposed a tree-structured regenera- tion scheme which transmits the regeneration traffic along a carefully selected tree spanning all providers. In this way, they may by-pass low capacitated links and perform coding at the intermediate nodes of the tree to save bandwidth. However, their method cannot maintain the MDS property. To illustrate this, we first extend the information flow graph for the tree- structured regeneration and then use its with a specific example to show the loss of MDS property caused by RCTREE.

A. Information Flow Graph for Tree-structured Regeneration  Information flow graph is first introduced by Dimakis et al.

[6] to study the sufficient and necessary condition of the MDS property. As their method is based on the star topology, we need to generalize the construction of the information flow graph for arbitrary tree-structured regeneration topology.

(a) regeneration tree  inu outu  inu outu  inu outu  inv outv  (b) corresponding part of information flow graph  Fig. 2. The part of information flow graph corresponding to the regeneration of storage node v (newcomer). Assume d = 3 and u1, u2, u3 are the providers.

In particular, we construct the information flow graph in the following way. For each storage node u, create two nodes uin  and uout and a link of capacity ? from uin to uout. Create a source node s and for each initial storage node u, add a link from s to uin with infinite capacity. For each regenerated storage node, we add links according to its regeneration procedure, which is specified by the regeneration tree T and the amount of data f(u, v) transmitted on each link of the tree. During the regeneration, if provider u transmits f(u,w) blocks to provider w, we add a link from uout to wout with capacity f(u,w), and if provider u transmits f(u, v) blocks to  the newcomer v, we add a link from uout to vin with capacity f(u, v). For example, Fig. 2(a) shows the regeneration tree consisted of 3 providers and a newcomer, the corresponding part of information flow graph is shown in Fig. 2(b).

For a data collector (DC) which connects to k storage nodes to reconstruct the file, we add k links from the k ?out? nodes to DC with infinite capacity. As long as the min-cut separating source s from DC is no less than the file size M , DC can reconstruct the file [6].

B. Loss of MDS property in RCTREE  Assume a file of size M = 480Mb is stored on 5 storage nodes v1, v2, ? ? ? , v5. Each node holds ? = 240Mb data and the MDS property requires that the file can be reconstructed by any two storage nodes. Suppose v5 fails, v0 is the newcomer and v1, ? ? ? , v4 are the d = 4 providers. Let the example network shown in Fig. 1(a) be the overlay network.

In this example, RCTREE will use the same regeneration tree as shown in Fig. 1(c), but transmit ? = Mk(d?k+1) = 80Mb on each link. Assume the data collector connects to v0 and v3 to reconstruct the file. Fig. 3 shows the information flow graph. As noted in the figure, there is a cut of volume 2?+? = 400Mb, which is smaller than the file size. Therefore, the file cannot be reconstructed with storage nodes v3, v0.

inv outv  inv outv  inv outv  inv outv  inv outv  inv outv  in iv  out iv  Fig. 3. An example of RCTREE and the corresponding information flow graph. The parameters are n = 5, d = 4, k = 2,M = 480Mb, ? = M/k = 240Mb, ?= M  k(d?k+1) = 80Mb. A min-cut with capacity 2? + ? = 400Mb is illustrated by a red dashed line, implying that a DC can not reconstruct the original file by connecting with {v3, v0}.

To find out how frequently such failures of reconstruction occur, we have implemented RCTREE scheme based on Ran- dom Linear Regenerating Codes(RLRC) and run simulations with practical parameters. Random linear coding is performed over a sufficiently large finite field GF (216), so that the probability of reconstruction failure caused by generating linearly dependent blocks can be ignored [13]. Fig. 4 shows the probability that data collector successfully reconstructes the file. From the results, we can see that data collector can hardly reconstruct the original file after 5 rounds of regenerations.

IEEE INFOCOM 2014 - IEEE Conference on Computer Communications      0 10 20 30 40 50 60 70 80 90 100 ?0.1   0.1  0.2  0.3  0.4  0.5  0.6  0.7  0.8  Repair times  P r  [d at  a is  a va  ila bl  e]  MSR, bandwidth = [0.3,120]Mbps     [n = 10, d = 8, k = 6] [n = 10, d = 9, k = 6] [n = 10, d = 8, k = 7] [n = 11, d = 8, k = 6]  Fig. 4. The impact of repair times to the probability of successfully reconstructing the original file.

C. Summary  From the simulation results, we can see that it is necessary to reconsider the problem of optimizing regeneration time with heterogeneous link capacities and maintaining the MDS property at the same time.

Specifically, given the topology of the overlay network G(V,E) and link capacities c(u, v), (u, v) ? E, let f(u, v) denote the number of blocks transmitted along each link (u, v).

Our target is to minimize the regeneration time. Considering that the coding operation are performed parallel with the data transmission, which dominates the regeneration time, we may simply represent the regeneration time as  max{f(u, v) c(u, v)  |(u, v) ? E}  Our contributions consist of two parts. First, we reconsider the basic tree-structured regeneration scheme where each provider is assumed to generate the same amount of coded blocks. Second, we relax the assumption and further reduce the regeneration time by flexibly determining the amount of information generated by each provider.



III. TREE-STRUCTURED REGENERATION SCHEME WITH REGENERATING CODES  A tree-structured regeneration solution has two parts: the regeneration tree T ? E and the number of blocks f(u, v) transmitted on each link of the tree. In this section, we first study the minimum f(u, v) to preserve the MDS property with a given regeneration tree. Thereafter, we show that the problem of building an optimal regeneration tree is NP- complete. Finally, we conclude this section with a heuristic algorithm to construct a regeneration tree.

A. Determine f(u, v) for a given regeneration tree  We use the information flow graph as constructed in Sec. II-A to determine the minimum flow f(u, v) on each link that ensures the MDS property.

Theorem 1: For a given regeneration tree T rooted at the newcomer, in order to preserve the MDS property, the mini- mum number of blocks transmitted on each link (u, v) ? T is  min{mu?, ?} where mu is the number of nodes in the sub-tree rooted at u.

Here ? is the number of blocks transmitted in the regenerating codes, which satisfies  ?k i=1 min{(d? i+ 1)?, ?} = M .

Proof: Construct the information flow graph as described in Sec. II-A. The key is to compute the min-cut of this information flow graph. Let [U, U? ] denote a min-cut separating data collector DC from the source, where U is the set of nodes containing DC. Then U must contain at least k ?out? nodes.

Label the corresponding k storage nodes as u1, u2, ? ? ? , uk in topological order, such that ui is a provider in regenerating uj only if i < j. We divide the cut links into k sets. If uini /? U , the i-th set i contains only one link uini ? uouti . Otherwise, the i-th set contains all the cut-links introduced in the repair of node ui (Fig. 5). According to our scheme, a link u ? v has flow rate mu? only if the subtree rooted at u has mu nodes.

As there are at most i ? 1 providers in U repairing ui, there are at most d? i+ 1 providers not in U . Thus the total flow rate of the i-th set is at least min{(d? i+ 1)?, ?}.

inu  inu outu  inu outu  outu  outv  outv  outv  outv  Fig. 5. An example of min-cut in an information flow graph in tree-structured regeneration process. The parameters are d = 4, k = 3. The red dotted line shows the min-cut and the darkened links are the cut-links.

Sum up the volume of each link set, the volume of the cut [U, U? ] is at least  ?k i=1 min{(d ? i + 1)?, ?} = M . Thus,  if f(u, v) ? min{mu?, ?}, DC can construct the file by assessing any k storage nodes.

To show that we cannot reduce f(u, v) further, we need to show that the min-cut of volume M is achievable. According to the information flow graph constructed in the proof, we can see that such a min-cut is achievable if we require each provider provides ? blocks, which means the solution min{mu?, ?} is optimal for a given regeneration tree.

B. Construction of the optimal regeneration tree  With the knowledge of how much information to be trans- mitted on each link, the remaining task is to build an optimal regeneration tree T to minimize the regeneration time. How- ever, we find that the optimal regeneration tree problem, ORT  IEEE INFOCOM 2014 - IEEE Conference on Computer Communications      for short, is NP-complete. To demonstrate this, we start with the formal definition of the ORT problem.

Definition 1: For a given overlay network G(V,E) with link capacity c(u, v), (u, v) ? E, the optimal regeneration tree problem is to find a spanning tree T such that its re- generation time max{ f(u,v)c(u,v) |(u, v) ? T} is minimized, where f(u, v) = min{mu?, ?} and mu is the number of nodes in the sub-tree rooted at u.

To study the complexity of ORT problem, it is equivalent to restate this optimization problem as a decision problem, which aims to determine whether the regeneration time of an optimal regeneration tree is no more than 1. The following theorem shows that this problem is NP-complete.

Theorem 2: The ORT problem is NP-complete.

Proof: We first show that ORT ? NP. Suppose we are  given a graph G = (V,E). The certificate we choose is the optimal regeneration tree T . The verification algorithm checks, for each edge (u, v) ? T , that f(u,v)c(u,v) ? 1. This verification can be performed in polynomial time.

We now prove that the ORT problem is NP-hard by re- duction from the VERTEX-COVER problem, which is known to be NP-complete. In particular, given an undirected graph G = (V,E) and an integer k, the VERTEX-COVER problem asks whether all edges can be ?covered? by k nodes, where node u ? V can cover edge e ? E only if they are adjacent. For an instance of the VERTEX-COVER problem, we construct a regeneration scenario in an overlay network G? = (V ?, E?), such that the regeneration time is less than 1 if and only if G has a vertex cover of size k.

We construct G? in the following way. G? has four layers of nodes. The first layer has only one node that is the root t. The second layer has two nodes, node a and node b. Both a and b are connected to the root. The link capacity of edge (a, t) is k+|E|+1 and the link capacity of edge (b, t) is unlimited. The nodes in the third layer correspond to the vertices in graph G, all of them are connected to both a and b. The link capacity of their edges connected to a is unlimited and the link capacity of edges connected to b is 1. The nodes in the last layer correspond to the edges in graph G. Each node in the last layer is connected to two nodes in the third layer, which is connected by the corresponding edge in graph G. The link capacity of these edges, which connect the nodes in the third layer to the nodes in the last layer, is unlimited. Links which are not mentioned in the construction are supposed to have zero capacity.

From the construction, graph G? can be constructed from G in polynomial time. Fig. 6 shows an example of this reduction.

Fig. 6(a) is an instance (G, k = 2) of the VERTEX-COVER problem. Fig. 6(b) is the graph G? constructed from (G, k).

We next show that this transformation of G into G? is a reduction. First, suppose that G has a vertex cover set V ? ? V , where |V ?| = k. We claim that we can find a tree whose regeneration time is no more than 1. We construct this tree according to the vertex cover: for each node ei of the fourth layer, let its parent be vj which covers the edge ei in the vertex cover of G. For each node vi of the third layer, let its parent  (a) (b)  Fig. 6. Reducing VERTEX-COVER problem to Optimal Regeneration Tree problem. (a) An undirected graph G = (V,E) with k = 2. (b) The graph produced by the reduction procedure.

be a, if it belongs to the vertex cover V ?. Otherwise, let its parent be b. Finally, let the parent of a and b be the root. It can be verified the regeneration time is 1.

Conversely, suppose that G? has a tree whose regeneration time is no more than 1. Then, we claim that the edges of G can be covered by no more than k nodes. Let V ? ? V be the set of nodes that correspond to children of node a in the regeneration tree. First, V ? is a vertex cover of G since otherwise, some nodes in the fourth layer will have to be connected to the root through b, causing some flow entering b larger than 1 and the regeneration time less than 1. Second, |V ?| ? k because there are no more than k + |E| + 1 nodes transferring data from node a to root t, and as all the |E| nodes in the fourth layer must transfer data through the link a to t, the number of third layer nodes with parent a is no more than k to ensure the flow on the link a to t is no more than k + |E|+ 1.

C. The heuristic algorithm  In this section, we propose a heuristic algorithm to solve the ORT problem mentioned in Sec. III-B. The algorithm is inspired by Prim?s algorithm [14] for the maximum weighted spanning tree problem. We start from a tree containing only the newcomer and iteratively add the remaining nodes to the regeneration tree until it spans all providers. In each iteration, we try all possible positions for each remaining provider and choose the best one and position to add it to the regeneration tree. The details are shown in Algorithm 1.

The most time consuming step is to test all possible posi- tions for each provider, which has |V |2 choices. Each test takes O(|V |) to compute the regeneration time. Thus, the algorithm runs in polynomial time O(|V |3).



IV. TREE-STRUCTURED REGENERATION WITH FLEXIBLE END-TO-END TRAFFICS  In section III, we assume that each provider has the same amount of data to be transmitted to the newcomer. This as- sumption is actually not necessary. As the available bandwidth varies for different providers, we may repair faster if we allow providers to generate different number of blocks according to their bandwidths.

IEEE INFOCOM 2014 - IEEE Conference on Computer Communications      Algorithm 1 Find a regeneration tree T for a given network G(V,E).

1: Input: Network topology G(V,E), link capacity c, ?, ? 2: Output: Regeneration tree T 3: T ? v0 4: A ? V ? {v0} 5: while A = ? do 6: for all v ? A do 7: for all u ? T do 8: Compute the regeneration time of tree T ?{(v, u)} 9: If the regeneration time is better than previous  choices, update (v?, u?) ? (v, u) 10: end for 11: end for 12: T ? T ? {(v?, u?)} 13: A ? A? {v} 14: end while  In this section, we propose the Flexible Tree-structured Regeneration (FTR) scheme to further reduce the regen- eration time. The idea can be illustrated by the exam- ple shown in Fig. 1. Fig. 1(c) shows a regeneration tree computed by algorithm 1, where each provider generates ? = 80Mb coded data to be transmitted to the new- comer. We have computed that its regeneration time is 4s. Note that the bottleneck link is (v3, v0). If we re- quire provider v1, v2, v3, v4 to generate 90Mb, 90Mb, 60Mb, 90Mb data, respectively. The actual data transmitted on each link will be f(v4, v1) = f(v2, v0) = 90Mb, f(v3, v0) = 60Mb, f(v1, v0) = min{(90 + 90)Mb,? = 240Mb}, and the regeneration time is further reduced to 3s, which saves 25% of regeneration time than TR in this example.

Let ?i denote the amount of information generated by the ith provider. Note that if the providers of low-bandwidth generate less coded blocks, the high-bandwidth providers will have to generate more coded blocks to make sure the MDS property is maintained. So our first task is to analyze the explicit restrictions on ?i that ensures the MDS property.

For a regeneration tree and given ?i, i = 1, 2, ? ? ? , d, we require that the intermediate nodes perform coding on received blocks only when the number of blocks received from the child nodes plus the coded blocks generated by themselves is larger than ?. In this way, the number of blocks transmitted on each link f(u, v) will be  min{ ?  vi?S(u) ?i, ?}  where S(u) denotes the set of nodes in the sub-tree rooted at u. The following theorem provides a sufficient condition.

Theorem 3: The MDS property is maintained if in each regeneration, we choose ?i, i = 1, 2, ? ? ? , d that satisfy  d?k+j?  l=1  ?il ? min{(d? k + j)?, ?} ?j = 1, 2, ? ? ? , k  where il is a permutation of 1, 2, ? ? ? , d such that ?i1 ? ?i2 ? ? ? ? ? ?id .

Proof: We need to prove that any min-cut [U, U? ] (DC ? U ) has volume at least M .

As the capacity from a storage node to the data collector DC is set to infinity in the information flow graph, we only need to consider the case that U contains at least k storage nodes. Let v1, v2, ? ? ? , vk be the first k storage nodes of U in the topological order. If it is an output node, the storage link of capacity ? will be included in the cut. If it is an input node, set of the links repairing this node will be included in the cut.

For the j-th storage node, the number of its provider not in U will be at least d ? i + 1. According to the way how we determine the flow on the regeneration tree, the total capacity of the cutting repair links will be at least  d?k+j?  l=1  ?il ? min{(d? k + j)?, ?}  Therefore, the volume of the cut [U, U? ] will be no less than M .

According to the analysis above, we propose an algorithm to calculate the amount of blocks ?i generated by each provider.

The algorithm is based on the regeneration tree constructed in the previous section. In general, the algorithm has two steps: 1) calculate the available repair bandwidth bi, i = 1, 2, ? ? ? , d for each provider and rearrange the labels of providers such that b1 ? b2 ? ? ? ? ? bd; 2) solve the following linear programming problem for ?i:  min ? subject to: ? ? ?i/bi, ?i = 1, 2, ? ? ? , d?d?k+j  l=1 ?l ? min{(d? k + j)?, ?}, ?j = 1, 2, ? ? ? , k  0 ? ?1 ? ?2 ? ? ? ? ? ?d ? ?  (1)  Here the variable ? is introduced for representing max1?i?d{?i/bi}, which is ensured by the first d constraints.

The details are shown in Algorithm 2. Note that we must be careful calculating the available end-to-end bandwidth bi from each provider to newcomer, as the provider-to-newcomer traffics may share a common link in the regeneration tree. For a link shared by m providers, we assume each provider occupies 1/m of the link bandwidth (Line 3 - 11).

In Algorithm 2, the estimated bandwidth bi can be computed in time O(|V |3). The end-to-end traffic ?i can be computed by solving a linear programming problem of d + 1 variables and 2d+k+1 constraints, which can be solved in polynomial time as well.



V. EVALUATION In this section, we present simulation results to verify  the effectiveness of our proposed algorithms: Tree-structured Regeneration (TR) and Flexible Tree-structured Regeneration (FTR). Our most concern is the regeneration time, which is measured as the time that the newcomer spends on regener- ating the coded blocks. We ignore the the encoding time on  IEEE INFOCOM 2014 - IEEE Conference on Computer Communications      6 7 8 9 10 11 12 13 14 15 16 17 18 19     d (# of providers)  R eg  en er  at io  n T  im e(  s) MSR, n = 20, k = 5,  fileSize = 1GB, bandwidth = [10,120]Mbps     STAR RCTREE TR FTR  (a) Regeneration time  6 7 8 9 10 11 12 13 14 15 16 17 18 19 0.25  0.3  0.35  0.4  0.45  0.5  d (# of providers)  R eg  en er  at io  n tim  e pe  rc en  ta ge  MSR, n = 20, k = 5, file size = 1GB, bandwidth = [10,120]Mbps      RCTREE/STAR TR/STAR FTR/STAR  (b) Regeneration time of RCTREE, TR and FTR normalized by the regeneration time of STAR.

6 7 8 9 10 11 12 13 14 15 16 17 18 19         d(# of providers)  B ot  tle ne  ck b  an dw  id th  ( M  bp s)  MSR, n = 20, k = 5, file size = 1GB, bandwidth = [10,120]Mbps     STAR RCTREE TR(FTR)  (c) Bottleneck bandwidth  Fig. 7. Performance of four regeneration schemes for different number of providers (d). The parameters are n = 20, k = 5 and M = 1GB.

Algorithm 2 Determine the amount of coded blocks that each provider should generate.

1: Input: n, k, d,M, ?, a regeneration tree T with root v0.

2: Output: (?1, ? ? ? , ?d) 3: for i = 1 to d do 4: for all edge e from vi to v0 do 5: a ? the bandwidth of edge e 6: m ? the number of nodes in the subtree rooted at  edge e 7: s ? the smallest value of a/m 8: end for 9: bi ? s  10: end for 11: sort (b1, ? ? ? , bd) such that b1 ? b2 ? ? ? ? ? bd 12: solve the linear programming problem (1) for ?i  each provider and the decoding time on newcomer, because the encoding and decoding operations can be performed si- multaneously with the transmission [1].

For default settings, we use the same experiment setup as [1], where redundant data is produced as an (n = 20, k = 5)-MDS code. The original file size is set to 1GB. The link capacities between these nodes obey the uniform distribution U [10Mbps,120Mbps], according to the measurement of real world networks [12].

A. Effect of the number of providers d  The number of providers d is a key parameter in the dis- tributed storage system. According to [6], the total bandwidth consumed in the regeneration process decreases as d grows.

Because of this, the theoretical optimal value of d is n ? 1.

But accessing a large number of providers will introduce extra communication overhead. Thus, all feasible values of d may appear in practice. In the evaluation, we vary d from k+1 to n?1, in order to find out how the factor affect the performance of each regeneration scheme. We consider the MSR point, where each node stores M/k = 1GB/5 = 200MB data. The results are shown in Fig. 7.

The traditional regeneration schemes (STAR) proposed by  Dimakis et al. in [6] is implemented as a benchmark. We also test the regeneration time of RCTREE proposed by Li et al. in [1], although their algorithm cannot preserve the MDS property. Fig. 7(a) illustrates the regeneration time of these schemes. We can see that the regeneration time of every schemes decreases when d increases, because total repair bandwidth decreases, and the total repair traffic is dispersed to more providers.

In Fig. 7(b), we divide the regeneration time of TR, FTR and RCTREE by the regeneration time of STAR to show the relative improvement. In general, our algorithms reduce 50% ? 70% of regeneration time compared with STAR. As d grows, the performances become better. This is because the star topology has a large chance to include a low capacitated provider-to-newcomer link, which can be bypassed by a tree- structured regeneration scheme.

In previous sections, we have illustrated that, in RCTREE, the amount of data transferred through the regeneration tree is not enough for the MDS property, and we fix this problem by proposing the TR scheme, which transmits more data. Thus one might intuitively regard the regeneration time of RCTREE as a lower bound of the regeneration time of TR. However, in Fig. 7(b), we observe that TR algorithm performs even better than RCTREE when d is large. The reason is that TR can find a better regeneration tree than RCTREE.

To show this, we also measure the bottleneck bandwidth of the regeneration tree computed by the three algorithms: STAR, RCTREE and TR. The results are presented in Fig. 7(c).

The bottleneck bandwidth of RCTREE and TR is improved significantly, compared with STAR. Since STAR always uses the d providers-to-newcomer links, but RCTREE and TR can freely select a spanning tree with edges chosen from  ( d+1  )  links. Moreover, the bottleneck bandwidth of TR becomes better than RCTREE when d is large. The main reason is that RCTREE has a particular restriction on the regeneration tree, which requires d ? k + 1 providers directly connected to newcomer, while TR has no such restrictions. When d is large, the regeneration tree constructed by RCTREE is more like a star-structured topology.

The performance of FTR is always better than TR in any  IEEE INFOCOM 2014 - IEEE Conference on Computer Communications      case. Since the process of flexibly determining ? is done after TR algorithm. We also find that FTR algorithm can save more regeneration time than TR algorithm when d grows.

B. Effect of the bandwidth variance  In order to show the impact of network bandwidth variance, we run simulations with 5 different link capacity distribu- tions: U1[0.3, 120]Mbps, U2[3, 120]Mbps, U3[30, 120]Mbps, U4[60, 120]Mbps, U5[90, 120]Mbps. The number of providers d is set to 10. Results are shown in Fig. 8. In general, the performance of our algorithms is better when the vari- ance of network bandwidth is large. For uniform distribution U1[0.3, 120]Mbps, both TR and FTR can reduce 90% of regeneration time compared with the traditional STAR scheme.

When the variance of network bandwidth becomes small, for example at U4[60, 120]Mbps and U5[90, 120]Mbps, TR has the same regeneration time as STAR, but FTR still reduces the regeneration time by 10% ? 20%.

[0.3,120]Mbps [3,120]Mbps  [30,120]Mbps [60,120]Mbps [90,120]Mbps  0.2  0.4  0.6  0.8   R eg  en er  at io  n tim  e pe  rc en  ta ge  MSR, n = 20, k = 5, d = 10, file size = 1GB      RCTREE/STAR TR/STAR FTR/STAR  Fig. 8. Regeneration time of RCTREE, TR and FTR normalized by STAR for different bandwidth. The parameters are n = 20, k = 5, d = 10 and M = 1GB.

C. Effect of the storage capacity per node ?  Our previous tests mainly focus on the MSR point, which achieves the optimal storage efficiency. However, as shown by Dimakis et al. [6], the repair bandwidth can be reduced by storing more data on each storage node. Specifically, the MBR point achieves the minimum repair bandwidth. We vary the storage ? from the MSR point to the MBR point to test its impact on our algorithms.

Fig. 9 shows the regeneration time for different ?. We can see that every regeneration schemes repair faster as ? grows to the minimum repair bandwidth point and the tendencies of different repair schemes are the same. Compared with STAR, we find that the ratio of reduced regeneration time does not change much for different values of ?. This implies that our previous simulation results and conclusions for the MSR case also apply to different storage ?.

205 211 221 236 256           Storage per node ? (MB)  R eg  en er  at io  n tim  e( s)  n = 20, k = 5,d = 10, file size = 1GB, bandwidth = [10,120]Mbps      STAR RCTREE TR FTR  MSR MBR  Fig. 9. Regeneration time of STAR, RCTREE, TR and FTR vs. storage capacity of each node (?), where ? vary from MSR point to MBR point. The parameters are n = 20, k = 5, d = 10 and M = 1GB.



VI. RELATED WORK  Li et al. [15] first considered the heterogeneity of network bandwidth in data regeneration process and proposed a tree- structured regeneration scheme to reduce the regeneration time. They also proposed a scheme of building parallel re- generation trees to further reduce the regeneration time in the network with asymmetric links [11]. However, they only discussed the case that the regeneration scheme requires k providers, which means the minimal regeneration traffic is equal to the size of original file M . To further reduce the re- generation time, they considered the regenerating codes in the tree-structured regeneration scheme and proposed RCTREE in [1]. They employ a minimum-storage regenerating (MSR) codes in RCTREE, which means the minimal regeneration traffic is dk(d?k+1)M bytes, i.e., in a regeneration with d providers, each provider sends ?d?k+1 blocks to its parent node. To make sure that the newcomer has enough information to restore ? blocks, it has to receive data directly from at least d?k+1 providers. The details of how to construct an optimal regeneration tree can be found in Algorithm 1 in their paper [1]. Although they have done this in their algorithm to ensure that the degree of newcomer is at least d ? k + 1, the MDS property can not be preserved after data regeneration.

Sun et al. [16] considered the scenario of repairing multiple data losses, and proposed two algorithms based on tree- structured regeneration to reduce the regeneration time. How- ever, they assumed the amount of data transferred between providers and newcomer is designed to be the same as ? in regenerating codes. According to our analysis, their regenera- tion schemes can not preserve the MDS property either.

Some researches, such as [17, 18], considered the hetero- geneity of nodes availability and optimized the erasure code deployment to reduce the data redundancy. Some researches, such as [19?23], jointly considered the repair-cost and het- erogeneity of communication(download) cost on each links.

They flexibly determine the amount of data to minimize the total repair cost, which is different from the regeneration time.

IEEE INFOCOM 2014 - IEEE Conference on Computer Communications

VII. CONCLUSION  We reconsider the problem of how to reduce the regen- eration time in networks with heterogeneous link capacities.

We analyze the minimum amount of data to be transmitted on each link of the regeneration tree and prove that the problem of building optimal regeneration tree is NP-complete.

We propose a heuristic algorithm to construct a near-optimal regeneration tree and further reduce the regeneration time by allowing non-uniform end-to-end repair traffics. Simulation results show that our regeneration schemes are able to maintain the MDS property and reduce the regeneration time by 10% ? 90%, compared with traditional star-structured regenerating codes. With the non-uniform end-to-end repair traffics, we can flexibly determine the amount of coded data generated by each provider. The proposed Flexible Tree-structured Regeneration scheme performs even better than RCTREE.

