

Abstract: While direct association rules are dedicated to describe  the direct correlations among the items in a frequent itemset, indirect association rules are dedicated to describe the indirect correlations between the two items in a infrequent itemset. All the existing research works about indirect association rules are focused on improving the efficiency of mining algorithm for indirect association rules. Like incremental updating algorithm is important for mining association rules, incremental updating algorithm is also important for mining indirect association rules. In this paper, we put forward an incremental updating algorithm for mining indirect association rules to deal with the maintenance of discovered indirect association rules resulted from the change of the minimum support. The main idea is to re-utilize the results acquired in process with the old minimum support.

Keywords: Indirect Association Rules; Incremental Updating  1. Introduction  The association rule is an important topic in the data mining and knowledge discovery research field. A number of algorithms have been proposed to improve the running time for generating association rules and frequent itemsets since the problem was pointed out by R.Agrawal in 1993 [1], [2].

With the further research on the mining of frequent patterns, it has been recognized that some infrequent patterns can provide very useful insight view into the data set, and a new kind of knowledge discovery problems called as indirect associations has been proposed [3].

Consider a pair of item x and y, which are rarely present together in the same transaction. If both items are highly dependent on the presence of another itemsets M, then the pair of x and y is said to be indirectly associated by M called as mediator.

Since the indirect association patterns discovery problem has been proposed, we call traditional association  rules as direct association patterns for convenience in this paper. Like direct association patterns, indirect association patterns also have many real applications. For example, the indirect association patterns between a pair of words in text documents can be used in classification of query results into categories, competitive product analysis and stock market analysis [4].

In order to find indirect association patterns between item pairs, most of discovery algorithms are divided into two phases as follows [4]:  1) Extract all frequent itemsets using a certain frequent itemsets mining algorithm such as Apriori[2];  2) Find valid indirect association rules by checking all the candidate association patterns generated from the frequent itemsets.

The above algorithm is based upon the fixed minimum support and fixed number of transactions in transaction database. If the minimum support and number of transactions are changeable, how should we deal with up to now, this kind of data update problem has not been studied.

Like incremental updating algorithm is important for mining association rules [6], [7], incremental updating algorithm is also important for mining indirect association rules. We put forward an incremental updating algorithm to deal with the maintenance of discovered indirect association rules resulted from the change of the minimum support. The main idea is to re-utilize the results acquired in process with the old minimum support.

The paper is organized as follows. The definition and mining algorithm for indirect association rules are given in Section 2. We describe how to incremental updating indirect association rules in Section 3 and Section 4, and conclusion and future works are made in the last section.

2. Indirect Association Rules  Let I = {i1, i2, ? , im} be a set of literals called items.

Let the database D = {t1, t2, ? , tn } be a set of n transactions, where each transaction is a subset of I. A non-empty subset of I is called itemset. An itemset containing k items is called k-itemste. The support of an itemset X denoted as sup(X) is defines as the fraction of all transactions containing X in D. An itemset is frequent if its support is greater than or equal to user-specified threshold mini-sup.

Definition: A pair of items x and y is said to be indirectly associated via a mediator sequence M, if the following conditions are satisfied:  (1) sup({x,y})<ts; (2) There exists a non-empty set M such that:  (a) sup({x}?M)>=tf, sup({y}?M)>=tf, (b) dep({x},M)>=td, dep({y},M)>=td, where  dep(A,B) is a measure of the dependence between itemsets A and B.

The thresholds ts?tf and td are called itempair support threshold, mediator support threshold, and dependence threshold, respectively. We usually set tf >= ts in practice.

In this paper, we use the denotation x?y(M) to represent the indirect association pattern between item x and y via mediator M, and use the IS measure [5] as the dependence measure for condition 2(b). Given a pair of itemsets A and B, its IS measure can be computed as the following equation:  )()( ),(),(  BPAP BAPBAIS  ? =  Where, P represents the probability that the given itemsets appears in the transaction database.

A typical algorithm for mining indirect association patterns is shown in Figure 1. The algorithm is divided into two major phases: (1)get all frequent itemsets using Apriori (step 1); (2) discover all indirect associations by candidate generation (step 4) and candidate pruning (step 5~8).During the candidate generation step, frequent itemset Lk is used to generate candidate indirect associations Ck+1 for pass k+1.Each candidate in Ck+1 is a triplet <x,y,M>, where x and y are the items which are indirectly associated by mediator M. Ck+1 is generated joining the frequent itemsets in Lk. During the join, a pair of frequent itemsets {x1,x2, ? , xk} and { y1,y2, ? , yk } are joinable if the two itemsets have exactly k-1 items in common. If so, they generate a candidate indirect association <x, y, M>, where x and y are the different items, one from each k-itemset, and M is the set of common items. For example, two itemsets {a,b,c,d} and {a,b,d,e} can be joined together to generate a candidate indirect association <c,e,{a,b,d}>. Since the candidate indirect associations are generated by joining two frequent itemsets, they certainly satisfy the mediator support  condition. Therefore, in the candidate pruning step, only the itempair support condition and mediator dependence condition are needed to be checked.

Algorithm: INDIRECT for Mining indirect associations  1. Discover all frequent itemsets L1 , L2 ,? , Ln using Apriori, Lk (k=1,2, ? ,n)where is the set of all frequent i-itemsets.

2. SIA = ?; //set of indirect associations 3. for k = 2 to n { 4.   Ck+1 = join(Lk, Lk); 5.   for each <x, y, M> ? Ck+1 { 6.     if (sup(x, y)<ts AND dep({x},M)>=td AND  dep({x},M)>=td) 7.     SIA = SIA ? {<x, y, M>}; 8.       } 9.    }  Figure 1: the INDIRECT algorithm  There are two join steps in the INDIRECT algorithm.

One is in the first phase for generating the candidate frequent itemsets using Apriori. In Apriori, the join step is used to generate candidate frequent itemsets for pass k+1 from the frequent itemsets in Lk. The other join step is for generating indirect associations Ck+1 from Lk. Both the two join steps are quite expensive. Qian Wan argued in [4] that the join step for generating indirect associations is more expensive than the one in Apriori because the items in an indirect itempair x and y do not have to be the last item ni each frequent itemset. In fact, we can sort all itemsets in lexicographic order just like doing in Apriori, then combines the two itemsets that have identical k-1 prefix items. If doing so, some frequent itemsets may not be used to generate candidate indirect association, but the candidate indirect association between the same itempair will also be generated, the only difference is the mediators of the two candidate indirect association are different. For example, two itemsets {a,b,c,d} and {a,b,d,e} can not be joined together to generate a candidate indirect association <c,e,{a,b,d}> since they do have identical 3 prefix items.

However, two itemsets {a,b,c} and {a,b,e} can not be joined together to generate a candidate indirect association <c,e,{a,b}> since they do have identical 2 prefix items.

With the view of intuition, the indirect association created by minor mediator is more practical in the real applications.

Based on this observation, the core operations of the two join steps in the INDIRECT algorithm can be the same. So, we can discover the indirect associations between itempairs while mining the frequent itemsets with Apriori algorithm.

3. Updating of Indirect Association Rules  In this paper, the problem to be solved is how to update indirect association rules when the minimum support is changed and the number of transactions in transaction database is fixed. In fact, since the minimum support is specified by user and the user don?t know what the minimum support is appropriate, tentative method is used to set up the minimum support. In the real process of mining indirect association rules, it is necessary to continuously adjust the minimum support. In fact, a trivial straightforward method to deal with changeable minimum support is directly re-apply the INDIRECT algorithm. Since this method has an obvious disadvantage, which can not utilize the results acquired in process with the old minimum support, it is not a good choice. So, we put forward an incremental updating technique for indirect association rules.

For the convenience, we adopted several notations as follows: S,C[k], Fre[k] and InFre[k] denoted to be old minimum support, set of candidate k-itemsets, set of frequent k-itemstes and set of infrequent k-itemsets under old minimum support, respectively. Meanwhile, NewS, NewC[k], NFre[k] and NInFre[k] denoted to be minimum support, set of candidate k-itemsets, set of frequent k-itemstes and set of infrequent k-itemsets under new minimum support, respectively. Any element of the above sets has two fields, one is itemset name, the other is the support value of the corresponding itenmset.

There are two cases for the change of minimum support as follows:  (1) NewS > S, where some frequent k-itemset in Fre[k] are changed to be infrequent, and all the infrequent k-itemset in InFre[k] are remain infrequent;  (2) NewS< S, where all the frequent k-itemset in Fre[k] are remain frequent, and some infrequent k-itemsets in InFre[k] may be changed to be frequent.

In the first case, originally infrequent k-itemsets under old support S can not be frequent under new support NewS, while originally frequent under old support S can be infrequent under new support NewS, that is to say, all of the frequent k-itemsets under new support NewS must be in Fre[k], i.e., NFre[k] ? Fre[k]. Since the support value of each itemset is recorded in its support field, it is easy to update frequent itemsets and infrequent itemsets. The corresponding updating algorithm is described as follows:   (1) for (k = 1; k?m; k++ ) { (2)  NFre[k ]= {x| x?Fre[K ], x.support?NewS}; (3)   NInFre[k] = InFre[k]? { x| x?Fre[K ],  x.support<NewS }  (4)   } (5)  FreSet = ? k NFre[k]; (6)  InFreSet = ? k NInFre[k];  It is more complicated for the second case. We will discuss it in detail in the next section.

4. Incremental Updating algorithm for Indirect Association Rules  When the new support NewS is less than the old support S, all the frequent k-itemset under the old support are remain frequent under the new support. Hence, we should manage to generate the set of candidate k-itemsets without any itemset in Fre[k]. The main idea to derive indirect association rules is described as follows:  Firstly, we derive the set of frequent 1-itemsets and the set of infrequent 1-itemsets. Since the support of each 1-itemset is recorded in C[1], it is easy to select all frequent 1-itemsets unde r the new support value NewS. We will do the following two sub-steps:  (1) NFre[1] = { x| x?C[1], x.support?NewS }; (2) NewFre[1] = NFre[1]- Fre[1], where NewFre[1] is  the set of the 1-itemsets which are originally infrequent under the old support value S but become frequent under the new support value NewS.

Then, we derive the set of frequent 2-itemsets and the set of infrequent 2-itemsets by two phases: (1) generate the set of candidate 2-itemsets NC[2]; (2) counting the support value of each candidate 2-itemset, and find out the set of frequent 2-itemsets NFre[1] and the set of infrequent 2-itemsts NInFre[1] under the new support value NewS.

The key to improve the efficiency of algorithm is to generate candidate k-itemsets as less as possible. Obviously, the set NC[2] must contains the original set of candidate 2-itemsets C[2], and C[2] is generated from Fre[1]. We try to generate the new set of candidate 2-itemsets without regenerating any candidate in C[2] in the following method.

We apply the candidate generation algorithm Apriori_Gen on the NewFre[1] to generate the set of candidate 2-itemsets denoted as C?[2], then select one itemset from NewFre[1] and Fre[1] respectively to generate the set of candidate 2-itemsets denoted as C?[2] in the similar way with the Apriori_Gen. We have NC [2]= C?[2] ?C?[2] ?C[2]. Then, scan the transaction database to count the support value for each candidate 2-itemset in C?[2] ?C?[2], put each the candidate from NC[2] whose support value is greater than or equal to the new support value NewS into NFre[2], denote newly added frequent 2-itemsets as NewFre[2],i.e., NewFre[2]= NFre[2]- Fre[2].

According to the above method, we can derive the set of frequent k-itemsets NFre[k] and the set of infrequent      k-itemsets NInFre[k] as follows: We firstly construct set of candidate k-itemsets NC[k].

We apply the candidate generation algorithm Apriori_Gen on the NewFre[k-1] to generate the set of candidate k-itemsets denoted as C?[k], then select one itemset from NewFre[k-1] and Fre[k-1] respectively to generate the set of candidate k-itemsets denoted as C?[k] in the similar way with the Apriori_Gen. We have NC [k]= C?[k-1] ?C?[k-1] ?C[k-1]. Then, scan the transaction database to count the support value for each candidate 2-itemset in C?[k-1] ?C?[k-1], put each the candidate from NC[2] whose support value is greater than or equal to the new support value NewS into NFre[k], denote newly added frequent 2-itemsets as NewFre[k],i.e., NewFre[k]= NFre[k]- Fre[k].

This process is repeated until there is only one itemset in NFre[k]. We denote the number of itemset of NFre[k] to be | NFre[k]|.

The candidate algorithm Cross_Gen to generate C?[k-1] is divided into two phases as follows:  (1) Joining insert into C?[k] select p.item1, p.item2,. . . , p.itemk-1, q.itemk-1 from NewFre[k]p , Fre[k]q where p.item1= q.item1, p.item2= q.item2,. . . ,  p.itemk-2= q.itemk-2 (2) Pruning Next, delete all itemset c ? C?[k] such that some  (k-1)-itemset of c is not in NFre[k-1].

According to the above discussion, we put forward an  incremental updating algorithm for indirect association rules as follows:  Algorithm: Incremental Updating Algorithm Input: (1) transaction database D?minimum support threshold:  minsupp?itempair support threshold:ts ; mediator support threshold: tf ; dependence threshold and td and;  (2) The old minimum support is S, whereas the new minimum support is NewS, and;  (3) Candicate k-itemsets set C[k] and frequent k-itemsets set Fre[k] for all k..

Output: A set of updated indirect association rules.

Begin (1)  NFre[1]= { x| x?C[1], x.support?NewS }; (2)  NewFre[1]= NFre[1]- Fre[1]; (3)  For (k = 2; |NFre[k-1]|> 1; k++) { (4)    C?[k]= Apriori_Gen (NewFre[k-1]) ; (5) C?[k]= Cross_Gen (NewFre[k-1],  Fre[k-1]) ;  (6)  For each transaction t?D do { (7) CC?[ t ]= {c| c?C?[k], c is contained in transaction t}; (8) CC?[ t ]={c|c ?C?[k], c is contained in transaction t }; (9)  For each candidate c?CC?[ t ] do c.support++ ;  (10) For each candidate c?CC?[ t ] do c.support++ ; (11)  } (12) NC[k ]= C[k]?C?[k] ?C?[k]; (13) NFre[k]= { c | c?NC[k],c.support?NewS} (14)  NInFre[k]= NC[k]? NFre[k]; (15)  For each s ? NInFre[k] { (16)  x = last_item(S); y =secondlast_item(S ); (17)  M = S ? {x,y}; (18) If (sup(x, y)<ts AND dep({x},M)>=td AND  dep({x},M)>=td) (19)   SIA = SIA ? {<x, y, M>}; (20)    } (21) C[k]= NC[k]; Fre[k]= NFre[k];  NewFre[k]=NFre[k]-Fre[k]; /* used for next loop */ (22) } (23) Return set of of updated indirect association rules SIA (24) End.

5. Conclusions and Future Works  In real applications, in order to obtain interesting indirect association rules satisfied by users, it is necessary to continuously adjust the minimum support. So, we put forward an incremental updating algorithm to deal with the maintenance of discovered indirect association rules resulted from the change of the minimum support. The main idea is to re-utilize the results acquired in process with the old minimum support, that is to say, we should save set of candidate k-itemset C[k] and set of frequent k-itemsets Fre[k] for all k. This strategy is at cost of more space requirement obviously. The incremental updating algorithm for indirect association rules has been implemented with C++, and the computation environments are Pentium D820, memory of 1G, operating system of Windows XP.

The incremental algorithm proposed in this paper can not deal with changeable number of transactions in transaction database. As a future research, we will try to solve this problem.

Acknowledgements  This paper is supported by the postdoctoral program of China and Anhui province. It is also supported by the natural science foundation of Anhui provincial university under Grant 2006kj055B.

