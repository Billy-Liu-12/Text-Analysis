A Rule-based Language for  Deductive Object-Oriented Databases

ABSTRACT  The object-oriented view of an application world can be represented in the form of a network of chses and associations, which can be aggregation or generalization associations. At the exlensional level, objects of merent classes can be related (associated) with each other forming patterns of object associations. In this paper, we present a deductive rule-baed language for Object-oriented dorabases.

A deductive rule in this language derives new patterns of associations among objects of some selected classes these objects fall in cenain "base" or other derived patterns. The patterns o f  object associations derived by a rule are held in a subdatabase whose intension consists of some selected classes and their associarions. In other wordr. the structure of a derived subdatabase is represented using the structural constructs provided by the object-oriented data model and hence can be un@ormly operated on by other rules to further derive new subdatabases. Therefore, the world o f subdatabases is closed under this rule-baed language.

1. Introduction  Merging expert systems (ES) and database management systems (DBMS) technologies has drawn much interest in recent years [GAL84. ULL85. ST087, RASSS. MAISS]. This interest is motivated mainly by the need for future ESs that deal with large amounts of data as well as the need for future DBMSs that have deduction capabilities and, therefore, can support many of the new database application areas such as CAD/CAM, office automation, and multi-media databases.

Several efforts have been made to design and integrate a deductive PROLOG-based rule language with a relation4 DBMS [JAR84, CHAM, VAS84, ULL85, CER86. ST087, MAI88. DEL881. In this approach, deductive rules are declared in the form of a logic program against base relations in the database. Each rule defines a virtual relation that is derived from other base and/or virtual relations.

The integration of such PROLOG-based languages with relational databases is facilitated mainly by the fact that a relational database is closed under PROLOG-like deductive rules in the sense that the input to a deductive rule (i.e., the relations that the rule operates on) can be one or more relations and its output is always a relation. In other words, the output of a rule still belongs to the world of relations (i.e., it is modeled using the relational data model) and therefore can be uniformly operated on by other deductive rules to further derive new relations and so on. It is our belief that a deductive rule-based language that is designed for any data model has to preserve the closure property with respect to that data model meaning that the derived data  CH2840-7/oooo/oos8$01.00 0 1990 IEEE  must be structured and modeled using the same data model with which the "base" data are modeled.

Along a diffexent research line, the database technology itself has been actively moving towards the Object-oriented (00) approach, which is more appropriate than the relational approach for supporting the new database application areas mentioned above [HAMII, BAT85 BAN87, FIS87. "I, FOR88. SU891. Semantic and 00 data models can capture much more of the semantics of these application domains in a "natural" way. The term "00 data model'' is used in this paper to refer to a data model that is structurally and/or behaviorally object-oriented [DIT861. A structurally 00 data model is one that encompasses at least the following characteristics: (1) It allows for defining aggregation hierarchies, (2) It allows for defining generalization hierarchies, and (3) It supports the unique identification of objects, that is, each object is assumed to have a unique object identifier (OD).

The 00 view of an application world is represented in the form of a network of classes and associations, which can be aggregation or generalization associations. Object classes can be either primitive classes whose instances are of simple data types (e.g., integer, string, real) or non-primitive classes whose instances represent real world objects (e.g., Part, Employee). At the extensional level. instances of different classes can be related (associated) with each other forming patterns of object associations. In a previous work [ALA89al, we introduced the 00 query language OQL, which is a high-level, non-procedural, and set-oriented language that allows the users to query the database by specifying the desired patterns of object associations in their queries. A behaviorally object-oriented data model, on the other hand, is one in which operations that describe the behavior of the objects of a class can be defied and registered with that Class.

For a database system to be more appropriate for supporting the new database application areas cited above, the two, so far independent, research lines (i.e., deductive databases and 00 databases) need to be merged leadiig to deductive 00 databases. This can best be done by designing a deductive rule-based language that preserves the closure property with respect to 00 data models (i.e., models that support aggregation, generalization, and the unique identification of objects). In this case, the output of a rule must be represented using the constructs of the 00 data model in order to make it possible for such an output to be operated on uniformly by other rules to further produce other derived data and thus form inference chains.

In this paper, we present the design and implementation techniques of a deductive rule-based language for 00 databases. A deductive rule in this language derives new patterns of associations among objects of some selected classes if these objects fall in certain ?base? or other derived patterns. The pattems of object associations derived by a rule are held in a subdatabase (see Sections 3 and 4) whose intension (i.e., structure) consists of some selected classes and their associations. In other words, the structure of a derived subdatabase is represented using the structural constructs provided by an 00 data model and hence can be unifomly operated on by other rules to further derive new subdatabases. Therefore, the world of subdatabases is closed under this rule-based language. To our knowledge, work on deductive rule-based languages of this kind for 00 databases has not been reported in the literature.

This paper is organized as follows. After this introduction, we briefly describe the 00 view of a University application domain, which will be used in later sections for defining some example deductive rules. In Section 3, we briefly describe the notion of a subdatabase and the 00 query language OQL. Some of the constructs of OQL are used by the deductive rule-based language to be introduced in Section 4. In Section 5, we describe the transitive closure operation as can be performed in our language. The control strategies used for evaluating deductive rules are described in Section 6. Some concluding remarks are given in Section 7.

2. The Object-oriented View of Databases  We shall describe first the 00 view of a university database as modeled by the 00 semantic association model OSAM* [SU89]. The university schema shown in Figure 2.1 is then used in the remainder of this paper as the application domain for which example deductive rules are given. The concepts introduced in this paper are applicable to any 00 data model and not limited to the OSAM* model.

A database schema is represented in OSAM* as a network of associated (inter-related) object classes. Graphically, object classes are represented as nodes and associations among object classes are represented as links. The resulting diagram is called the Semantic Diagram or S-diagram. In OsAM*, there are two types of object classes: Entity object classes (E-class) and Domain object classes (Dclass) which are represented in the schema of Figure 2.1 as rectangular and circular nodes, respectively. The sole function of a D-class is to form a domain of values of a simple data type (e.g., integers, strings, etc.) from which descriptive attributes of objects draw their values. An E-class, on the other hand, forms a domain of objects which occur in an application?s world (e.g., Faculty, Department, etc.). Each object of an E- class is represented by a system-generated unique object identifier (OD).

There are five types of links (associations) in OSAM*. Two of these association types appear in Figure 2.1, namely, Aggregation (A) and Generalization (G), which are also recognized in several other semantic and 00 data models. A class can have several types of links and more than one link of each type emanating from it. In the S-diagram, links of the same type that emanate from a class are grouped together and labeled by the letter that denotes the association type.

As an example, in Figure 2.1, the Eclass Person has two types of links: Aggregation links connecting Person to the D- classes SS# and Name and Generalization links to the E- classes Student and Teacher (i.e., Student and Teacher are subclasses of the superclass Person). An aggregation link represents an attribute and has the same name as the class it COM~CU to unless specified otherwise (e.g., the link labeled Major which emanates from the class Student has a different name from the class it C O M ~ C ~ S  to). Aggregation links that emanate from an Eclass and connect to D-classes are referred to as the &scriDtive attributes of that class (e.g., the attribute section# of the class Section). A class inherits all the aggregation associations that connect to or emanate from its superclasses. Figure 2.2 shows the actual view of the class Research Assistant (RA) in which all the associations inherited by RA from its super classes are explicitly represented. A detailed description of the OSAM* model can be found in [SU89].

3. Subdatabases and the 00 Query Language OQL  In this section we first give the definition of a subdatabase as presented in [ALA89a] (in Section 4, we extend this definition by introducing the induced generalization association construct which enables a deductive rule to operate on a set of subdatabases rather than on a single subdatabase). Next, we briefly describe the object-oriented query language OQL. The motivation behind presenting OQL here is that some of the OQL constructs will also be used as part of the deductive rule-based language to be introduced in Section 4 and an example OQL query against the derived data will be given in that section.

3.1 Subdatabases  A subdatabase is a portion of the original database and consists of two parts: an intensional association pattern and a set of extensional association patterns. The intensional association pamm of a subdatabase is represented as a network of E-classes and their associations. For example, Figure 3.1 shows a certain subdatabase SDB of the original database of Figure 2.1. Figure 3.la represents the intensional association pattern of this subdatabase, which consists of the classes Teacher, Section, and Course and their associations.

An extensional association pattern is a network of instances and their associations that belong to the classes and association types of the intensional association pattem. The set of extensional patterns of a subdatabase can be represented in the fom of an extensional diagram. Figure 3.lb shows a possible extensional diagram for the subdatabase SDB, where the t?s, s?s, and c?s are the OIDs for objects from the classes Teacher, Section, and Course, respectively. The intexconnection of t3 and s4 in the figure is an example of an extensional pattem, which records the fact that object t3 is associated with object s4 (Teacher t3 is teaching Section s4).

In addition to the graphical representation, an extensional pattem can be represented as a tuple of OIDs. For example, <tls2,cl>, <c3> and <s5,c4> are some of the extensional pattems that appear in the subdatabase SDB (Figure 3.lb).

The two extensional patterns a2,s3,cl> and <t2,s3,c2> contain the same Teacher and Section instances but different     Figure 2.1 : University Schema  -?p,  Fgue 22: Class RA with all lhe inherited As? W Y  RW-d  Fgw 3.la: The Intmskd Patlern Ot a Wxkt&a8e SDB    Course instances'. In the definition of a subdatabase as given in [ALA89a] it was assumed that 9 the descriptive attributes of a class that appears in a subdatabase also appear with it, by default, in the subdatabase. However, the descriptive attributes are not shown in Figure 3.la to keep the figure simple.

An extensional pattern type is defined as the common template that is shared by several extensional patterns in a subdatabase. A pattem type is denoted by a tuple of class names. For example, aeacher, Section, Course> is one of the extensional pattem types that exist in Figure 3.lb, which has as instances all the extensional patterns that contain Teacher, Section, and Course objects, i.e., the extensional patterns <tl,s2,cl>, <t2,s3,cl>, and <t2,s3,cb. On the other hand, the extensional pattem <t3,s4> whose Course- component is Null (since the pattem does not contain any Course object) is of the type Oeacher,Section>. The five extensional pattem types present in the extensional diagram of Figure 3.lb are <Teacher,Section, Course>, 4eacher,Section>, <Section,Course>, <Teacher>, and <coufie>.

3.2 The Object-oriented Query Language OQL  The philosophy underlying OQL is to allow the user to specify, first. the desired subdatabase by specifying its intensional pattem and the set of extensional pattem & p ~ that are of interest and then the operation(s) to be performed on the classes of the subdatabase. The search engine of the underlying 00 DBMS would establish the subdatabase by identifying all the extensional patterns that belong to the specified types and then perform the operation(s). The implementation of OQL on a SUN workstation is reported in a master's thesis [TY88].

A query block in OQL consists of a Context clause and an Operation clause. The Context clause has two optional subclauses: a Where subclause and a Select subclause. This structure is shown below.

context association pattern expression  operation(s) object clasges)  where conditions select object classes and/or attributes  In the context clause, the user specifies a desired subdatabase by specifying its intensional pattem and extensional pattem types of interest (both are specified in the association pattem expression). A linear association pattem expression has the form "Class1 [intra-class conditions] op Class2 [intra-class conditions] op Class3 [inua-class conditions] ...I' where "op" is one of the association p a "  operators. Each operator separates two Eclasses that are directly associated in a schema. The intra-class conditions enclosed in brackets following a class name are optional and are expressed in the form of predicates that involve the descriptive attributes of that class.

1. We note that Section 53 is related to more than one Course instance and Section s4 is not related to any Coursc instance. Naturally. thae is a constraint on the daubase that restricts thc mapping beoreen Section and Course to Nl and another Non-null constraint on the agpgstMn sssociation of Course with Section. We .~~sume that these d t s  M waived here m order to describe t h e m o s t g d a s e .

The Where subclausg further causes the extensional patterns that do not satisfy some conditions to be dropped from the Context subdatabase (the subdatabase defined by the Context expression). The conditions that can be specified in the Where subclause are inter-class comparison conditions, which are comparisons between some descriptive attributes of two classes if these attributes are type comparable. and/or comparison conditions that involve aggregation functions (e.g., COUNT).

The Select subclause identifies the descriptive attributes and/or classes in the Context subdatabase that are to be operated on by the operation(s) specified in an operation clause. It eliminates attributes and classes that are not relevant to the operations. An operation, in the 0-Deration  can be either a system-defined data manipulation operation (e.g., Display, Update, or Print) or a user-defined operation (e.g., Rotate, Order-part, or Hireemployee). If the Display (Print) operation is specified in the operation clause, it causes the values of the descriptive attributes identifed by the Select subclause to be displayed (printed) in a tabular form.

The operators that can be used in the association pattem expression of the Context clause are the association operator and the non-association operator. In the following we give a brief description of the association operator only, which will be used by the rule-based language to be introduced in Section 4. In the remainder of this paper, capital letters are used to denote E-classes (A, B, ...) and small letters with an integer appended to each letter are used to denote objects (e.g., al, a2, ... and bl,  b2, ... are objects that belong to the classes A and B, respectively).

When the association operator (*) is applied to two directly associated E-classes A and B in a database (i.e., the expression "A * B"), it r e m s  a subdatabase whose intensional pattem consists of the two classes A and B and their association. The resulting subdatabase contains also the set of extensional pattems drawn from the operand database such that each extensional pattem contains objects of A and B (Le, extensional patterns that are of the type <A,B>).

B objects that are not associated with any A object and A objects that are not associated with any B object in the operand database are not retained in the result. The following example queries illustrate the use of the association operator.

Queq 3.1 Display the names of the teachers who teach some sections and the section#'s of these sections.

context Teacher * Section display  If the Context expression of this query is applied to the subdatabase SDB of Figure 3.1, it will return the subdatabase shown in Figure 3.2. The intensional pattem of this subdatabase consists of the classes Teacher and Section and their association (the descriptive attributes of the classes Teacher and Section are also represented in the figure). The set of extensional patterns of the resulting subdatabase is (<tl,sb, <t2,s3>, <t3,s4>). The extensional pattem <t4> (or <t4, N u b )  is not included in the result because its Section- component is Null (similarly, the pattem <s5> is not included). The result of the Display operation is a binary  select name, section#     table in which each tuple contains a name value and a seCtio@# value.

The *finition of the association operator can be easily generalized to the case when the association paaem expression contains more than two classes. For example, the expression "A * B * C returns the extensional patterns that are of the type <A$,C>. It is noted here that one can defii a single extensional pattem type using the association operator. A mechanism for defining a richer variety of extensional pattem types in a single expression is described in Section 5.

Query 3.2 Print the Department names for all departments that offer 6OOO level courses that have current offerings (sections). Also. print the titles of these courses and the textbooks used in each section.

context Depamnent * Course [aooO <= c# c 70001 * Section  select name, title, textbook print  In this query, the intra-class condition on the C# attribute of Course is enclosed in brackets following the class name in the Context expression.

We note here that the association operator can be used between any two classes whether they are connected by a generalization or an aggregation association. The types of associations between classes are explicitly defined in the schema and restating these association types in queries is unnecessary. The query processor of an 00 DBMS can make use of the type information stored in the dictionary to properly interpret the queries and enforce the relevant semantics and constraints. For example, a link that exists between an instance of the class TA and an instance of the class Grad of Figure 2.1 is an identity link. In other words, the semantics implied by the generalization association here is that the two instances are actually two diffmnt perspectives of the same real world object.

OQL makes full use of the inheritance property of the generalization association. Therefore, the expression "RA Section" is a legal expression since the class RA inherits the zggregation association with Section (Figure 2.2) along a unique generalization path. However, in some cases, a class inherits the status of being related to another class along different generalization paths. For example, the class TA inherits the status of being related to Section from both Teacher and Grad with each of them having its distinctive meaning. In this case, at least one of the classes along the intended generalization path has to be explicitly referenced in the association pattem expression to resolve the ambiguity.

Thus, the ambiguity in the expression "TA * Section" is resolved by using either one of the two expressions "TA * Grad * Section" or "TA * Teacher * Section."  4. The 00 Deductive Rule-based Language  Our rule-based language can be used to derive new subdatabases from other existing or derived subdatabases and therefore the world of subdatabases is closed under this language. A derived subdatabase is called the target subdatabase and the subdatabases used to derive it are  called the source subdatabases. A target subdatabase that is derived by a rule can be a source subdatabase of another rule. We refer to a class in a target subdatabase as a target class. The class in the sou~ce subdatabase from which a target class is derived is called the source class. The set of instances of a target class is a subset of the set of instances of the source class from which it is derived.

Before introducing our deductive rule-based language, we first extend the definition of a subdatabase as given in [ALA89al (see Section 3) by introducing the induced generalization association construct. Our objective is to provide a conceptual description for the relationships (associations) that may exist between classes even if they belong to different subdatabases. This enables using the association operator between any two associated classes that belong to two different subdatabases and therefore a rule can derive a new subdatabase out of more than one source subdatabases.

4.1 The Induced Generalization Association  Between every target class and its source class, there is a generalization association that is induced by the deductive rule, which emanates from the source class and connects to the target class. Therefore, a target class inherits al l  the aggregation associations of its source class, which establishes the inter-subdatabase connections as shown in the following example.

Let SD be a subdatabase whose intensional pattem is as shown in Figure 4.1 (SD could have been derived from the original database by a deductive rule). Let SDI and SD2 be two subdatabases (Figure 4.1) that are derived from SD by two rules. Class A that appears in SDI, which we refer to as SD1:A (i.e., by qualifying the class name with the subdatabase name using a colon), is derived from the corresponding class in SD, i.e., SD:A. Therefore, there is an induced generalization association that emanates from the source class SDA and connects to the target class SDI:A, as shown in the figure. Similarly, there is an induced generalization association emanating from SD:D and connecting to SDTD and two induced generalization associations emanating from SD:C and connecting to the classes SD1:C and SD2:C.

Each of the classes of SDI and SD2 inherits all the aggregation associations of its superclass in SD. For example. SD1:A inherits the links that connect to and the links that emanate from its superclass SD:A, which effectively means that there are aggregation associations between SD1:A and each of the classes SD:B and SD:C. The inherited association that connects SDI:A to SD:C is further inherited by SD1:C. which is a subclass of SD:C. Since this association that connects SD1:A to SD1:C is local (intemal) to the subdatabase SDI, it is explicitly represented in its intensional pattem (thus an intensional association pattem of a subdatabase consists of the classes that appear in the subdatabase and their associations). Similarly, the inherited association that emanates from SD1:A and connects to SD:C is further inherited by SDTC. This means that there is an (inherited) association between the two classes SDI:A and SD2:C, which belong to two different subdatabases.

Thus, the inheritance property of the induced generalization association establishes the connections between classes from     different subdatabases. Figure 4.2 shows an equivalent representation to that of Figure 4.1, where all the aggregation associations that the class SD1:A inherits from its superclass SD:A an! explicitly represented.

By considering the definition of the induced generalization association construct as introduced above, each of the classes of the subdatabase SDB of Figure 3.1 inherits all the aggregation associations of its source classes in the original database of Figure 2.1. For example, the class SDB:Course inherits the aggregation associations to the Eclasses Department. Transcript, and Course (through the F'rereq.

association) and to the Dclasses C#, Title, and Credit-hours from its super class Course in the original database. In the remainder of this paper, if a class name is referenced in any expression without qualifying it by a subdatabase name, the "base" class (i.e., the class that appears in the original database) is assumed.

The functionality of the association operator (*) can now be extended in such a way that it can be used to operate on two classes even if they belong to two different subdatabases provided that there is an (inherited) association between them. For example, the expression "SD1:A * SD2C" is a legal association pattern expression against the classes of Figure 4.2, which creates a new subdatabase, say X, that consists of the classes A and C. The classes X.A and X:C are subclasses of the classes SD1:A and SD2:C, respectively.

Only the instances of the classes A and C that are associated and that appear in the subdatabases SD1 and SD2, respectively, will appear in the subdatabase X.

4.2 Syntax and Semantics of Deductive Rules  A rule in OUT 00 rule-based language has an If-Then structure as follows.

if context association pattern expression  then subdatabase-id (classes)  The Context clause and its optional Where subclause are the same as described in Section 3 above. The subdatabase-id in the Then clause is a unique name to be given to the derived subdatabase. The intensional pattern of the derived subdatabase consists of the classes referenced in the argument list following the subdatabase-id in the Then clause. These classes should be a subset of the classes referenced in the association pattern expression of the If clause. Other unreferenced classes will not be retained in the derived subdatabase. The extensional pattems, on the other hand, are derived from the extensional panems that satisfy the conditions of the If clause and its Where subclause. In other words, the Then clause derives new patterns of object associations among objects of some specified classes if these objects exist in some "base" or other derived association patterns. The following rule provides a simple example.

Derive the subdatabase Teachercourse in which only the classes Teacher and Course appear such that a Teacher instance teaches a Course instance (i.e., teaches one of the sections of the course).

If context Teacher * Section * Course then Teacher-course (Teacher, Course)  where conditions  If this rule is applied to the Subdatabase SDB of Figure 3.1, it returns the subdatabase Teacher-course whose intensional pattem and set of extensional patterns are shown in Figure 4.3. The intensional pattem of Teacher-course consists of the classes Teacher and Course only. The class Section is not rerained in this subdatabase because it is not referenced in the argument list following the subdatabase name in the Then clause. Since Teacher and Course in the operand database are not directly associated but are associated through Section, a new direct association is derived between them in the resulting subdatabase (Figure 4.3a).

At the extensional level new direct links are inferred between the instances of Teacher and Course. In other words, the derived subdatabase contains a set of extensional pattems such that an extensional pattem consists of a Teacher instance and a Course instance with a direct link between them, provided that the two instances satisfy the associativity condition that is specified in the If clause, i.e., the two instances must coexist in the operand database in an extensional pattem that also contains a Section instance. For example, a direct association is derived between the instances tl and cl as shown in Figure 4.3b because tl and cl  are associated through s2 in the operand subdatabase SDB of Figure 3.1.

If a target class in a derived subdatabase is to inherit only a subset of the descriptive attributes of its source class, then these attributes should be listed in brackets following the class name in the Then clause, otherwise all attributes are inherited (i.e., the default is "all atmbutes"). For example, if the class Teacher in the subdatabase Teachercourse is to inherit only the attributes SS# and Degree, the above rule will be expressed as  If context Teacher * Section * Course then Teacher-course (Teacher [SS#, Degree], Course)  In this case, the amibute Name will not be accessible from the class Teachercourse:Teacher.

The following are some additional rules defined for the University database of Figure 2.1. Each of these rules derives a new subdatabase and illustrates certain aspects of the semantics of our rule-based language.

R2 If the total number of students who are enrolled in a &&se that belongs to the CIS department is greater than 39, then suggest offering the course in the next semester.

If context Department [name = 'CIS'] * Course * where COUNT (Student by Course) > 39)  then Suggest-offer (Course)  COUNT i s  an aggregation function that returns the number of students associated with each course (i.e., via some sections). The If clause identifies the set of extensional patterns that satisfy the association pattem expression and the condition stated in the Where subclause. In other words, this set of extensional pattems does not include the extensional pattems that contain courses with less than forty enrolled students. The derived subdatabase Suggest-offer contains only the class Course together with the Course instances that  Section * Student

I._ ................ I..." ........ - ...... "I.." .... " ........ -...-. I ...... .............. ...... l._-.l---..l"l-"l--.,  Figure 4.2 The AuwcWonr inherksd by SDI A frwn SDA     satisfy the conditions stated in the If clause (i.e., the instances that appear in the extensional patterns identifii by the If clause). Because the closure property is preserved, this subdatabase can be operated on by other deductive rules in the same manner to further derive new subdatabases as shown by the following rule.

If, for any department, the number of courses that are suggested to be offered next semester is p a t e r  than 20 courses, then the department needs more resources (i.e., budget, rooms, labs, etc.).

If context Department * Suggest-0ffer:Course then Deps-need-res (department)  COUNT here reaun~ for each department the number of courses that belong to it and that are suggested to be offered as determined by the previous rule. Since the class Course of the subdatabase Suggest-offer is a subclass of the base class Course (i.e., there is an induced generalization association between them), it inherits the aggregation link to the base class Department, hence, the expression "Department * Suggest-0ffer:Course" is a legal expression. This rule derives a new subdatabase called Deps-need-res (departments that need resources). The source subdatabases from which this subdatabases is derived are: the original database and the Suggest-offer subdatabase.

- R4 If a graduate student is currently teaching a course that is suggested to be offered, then he/she may teach the same course in the next semester.

where COUNT (Suggest-0ffer:Course by Depamnent) > U)  If context TA * Teacher * Section * Suggest-0ffer:Course then may-teach (TA, Course)  A graduate student may teach an undergraduate course (i.e.. c# c 5OOO) if hdshe has taken the course and got a grade of B or more.

if context Grad * Transcript [grade => 'B'] * Course [c# c 50001  then may-teach (Grad, Course)  Rules R4 and R5 derive extensional patterns into the same subdatabase (May-teach) but based on different conditions.

Thus, if both rules are applied, May-teach will contain the union of the two sets of extensional patterns derived by the two rules.

4.3 Querying the Derived Data  Once the deductive rules that derive new subdatabases are defined, the classes of the derived subdatabases can be referenced inlissociatl 'on pattern expressions in any OQL query in the normal way. For example, the following is an OQL query that operates on the base classes Faculty and Advising and on the class TA of the subdatabase May-teach.

!hey 4.1 For the teaching assistants who may teach a ' course in the next semester, have advisors, and whose GPA's are less than 3.5, display their names and their advisors' names.

context Faculty * Advising * May-Teach:TA [GPA < 3.51  select TA [name], Faculty [name] display  The class May-teach:TA is a subclass of the base class TA, which in tun is a subclass of the class Grad. Thus, May- teach:TA inherits the aggregation association with Advising from Grad and consequently the expression "Advising * May-teach:TA" in the above query is legal. As is the case in the above query, an attribute that appears in the Select subclause has to be qualified by its class name if it is not unique among the attributes of the classes that are referenced in the Context clause. This is done by enclosing the attribute name in brackets following the class name (e.g.. "TA [name]" in the above query).

In the backward chaining strategy (backward and forward chaining strategies are described in Section 6), this query is evaluated as follows. Since TA is referenced in the query in the context of May-teach, rules R4 and R5 will be triggered for execution to derive the subdatabase May-teach. But, in order to derive May-teach, the subdatabase Suggest-offer (which is referenced by rule R4) must be derived. This causes rule R2 that derives Suggest-offer to be triggered for execution. R2 does not refer to any other derived subdatabase, hence, the expressions of R2 are evaluated against the base classes. The result is then fed to rule R4 that participates in deriving May-teach. (similarly, the expressions of R5 are evaluated against the base classes.) The subdatabase May-teach is then used to evaluate the given query.

5. Transitive Closure  The transitive closure operation is expected to be a fundamental operation in future database systems and knowledge systems. Before describing how it can be performed in our language we describe a mechanism for defining several extensional p a "  types in a single association pattern expression. This mechanism is then used in deductive rules that perform the transitive closure operation.

5.1 Association Pattern Subexpressions  We allow more than one extensional pattern type to be identified by a single association pattern expression by enclosing a subexpression of it inside braces. This subexpression identifies a certain extensional pattem type.

For example, the expression "A * (B * C)  * D returns the subdatabase whose intensional pattern consists of the referenced four classes and whose set of extensional patterns includes all patterns that are of the types <A,B,C,D> and d C > .  In other words, this expression means to select both the instances of A,BC and D classes that are connected (associated) all the way through as well as those instances of B and C that are connected to each other but not necessarily connected to the instances of A and/or B. The braces around B * C capture the semantics of the Outerjoin concept introduced in [COD79].

If, in the above expression, an extensional pattem of the type d . C >  appears in the resulting subdatabase as part of a larger pattern of the type <A,B,C,D>, it will not appear independently in that resulting subdatabase. For example, if the original database contains only the two patterns     <al.b5,c5,d5> and <a3,b2,c2>, then the expression "A * (B * C) * D returns the extensional paaerns <al,b5,cS,d5> and cb2,cb. The extensional pattem <b5,c5> will not appear independently in the result since it already appears as a part of the extensional pattem <al,b5,c5,d5>. In gem?ral, an extensional paaem of acertain specified type will not appear indepen&.ntly in the result if it is part of a larger extensional pa"  Subexpressions can be nested to several levels. For example, the expression " ( ( (A)  * B) * C) * D identifies the extensional pattern types <A>, <AB>, <AB,c>, and <ABCD>.

Query 5J Display the S M ' s  of dl graduate students (whether they have advisors or not) and for dmsg graduate students who have advisors, display their advisors' names.

context ( Grad ) * Advising * Faculty select Grad [SM], Faculty [name]  display  The result of the display operation is a binary table each tuple of which contains a Grad's Ss# and either a faculty name or a Null value if the student has no advisor.

5.2 Transitive Clasure operntion  Different aliases (range or iteration variables) of a class can be automatidy generated in OQL by appending an  association pattem expression (e.g., Grad-1 is a an alias of Grad). This featlne is used in the clefition of the transitive  underscore and an integer to the class name in tbe  closure operation that follows.

The W t i v e  closure opetation is performed in our language by iterating over some classes and associations that form a cycle. Let A, B and C be three classes in a schema that form a cycle, i.e., A has associations with both B and C and B has an association with C. The following Iule derives a subdatabase X that contains pairs of instances of the class A that are Bssociated with each other via some B and C instances. In other words, each extensional pattern in this subdatabase contains two objects from the class A.

if context A * B * C * A-1 then X (A, A-1)  By extending the Context expression in this rule to form a second iteration, i.e., the expression "(A * B * C * A-1) * B-1 C-1 * A-2", one can derive a subdatabase that contains a three-level hierarchy of A instances. The braces are used in this expression to keep the first and second level A instances that are associated with each other even if they ace not associated with third level A instances.

This iteration can be expressed in our language by adding the "@'I sign as a superscript at the end of an association pattem expression that forms a cycle. An optional number N (Number of iterations) following the @-sign causes the underlying system to traverse the cycle N fimes. (For a certain hierarchy of instances, iteration stops when Null values are encounted or at the bP iteration, i.e., IP descendant from the root of the hierarchy.) If such a number is not present, the cycle is mversexl until Null values am  obtained for all the hierarchies of instancm (Le., the transitive closure operation is performed). Using this technique, the two expressions "(A * B * C * A-1 J * B-1 * C-1 * A-2" and " ( (A * B * C * AA)  * B-1 * C-1 * A-2) * B-3 * C-3 * A-3" are represented as (A * B * C)- and (A * B * C y ,  respectively. Our approach as &scribed above allows for representing the transitive closure operation in the form of looping rather than in a recursive form which is a simpler representation especially for end- users. The following are two example deductive rules.

a graduate student may be taught by other graduate students in some sections and also may teach other graduate students in some other sections. Derive the Grad-teaching- grd hierarchy. (It is Bssumed here that the relationship between the instances of the class Grad is not cyclic, Le., if- Grad g l  teaches Grad g2 or teaches any of the teachers of g2, then g2 cannot teach g l  nor any of the teachers of gl).

if context (Grad TA * Teacher * section * Student).

then Grad-teaching-grad (Grad, Grad_@)  T k  intensional pattem of the resulting subdalabase Grad- tcaching-grad consists of the classes Grad, Grad-1, Grad_;?, ... until Null values in all the hierarchies are encountered (tbe second argument to Grad-teaching-grad, i.e., Grad-@.

stands for Gd-1 ,  Grad-2, ...). Ia words, the intensional patkm of tbe &rived subdatabase is determined atruntime.

=Derive a subdatabase which contains only the 1st level and 3rd level in the grad-teaching-grad hierarchy.

if context (Grad TA * Teacher * Section * Sturknt)- 1&0 firsl-and-third (Grad, Grad-2)  a Coatrol strategies The two control strategies used in inferencing are forward and backward chaining of rules. In the backward chaining strategy, the evaluation of a derived subdatabase is delayed until a retrieval query that needs the derived data is issued.

date copy of the derived subdatabase is always kept available. which improves the performance of retrieval opaations. Whenever the data that is used to derive a subdatabase is updated (e.g.. by assockm 'ng, dissociating, immiug objects, etc.), the relevant deductive rules am run to maintain the &ncy between the derived subdatabase and the original database.

In the relational system POSTGRES [STO87], only one of these two control strategies (i.e., farward and backwad chaining of rules) is assigned to each rule in the system. A rule that is defined to follow the forward chaining strategy (i.e., a forward chaining rule) will be executed whenever the data that is read by the rule is updated, also, an up-to-date copy of the derived data is explicitly stored A rule that is defined to follow the backward chaining strategy (i.e., a backward chaining rule) will be triggemd for execution whenever the data that the rule derives is requested (i.e., in a query) but the derived data is not preserved after the query session. In this de-oriented control strategy, a rule is restricted to follow only one of the two control strategies at all  times.

on the contrary, in the forward chaining sbrategy, an Up-@     The disadvantage of this rule-oriented control strategy is that it imposes a restriction on the mixing of forward and backward chaining rules such that a forward chaining rule cannot read any data written by backward chaining rules [STO87]. To describe this problem, let the following be a series of rules Ra to Rd and the resuls REa to REd derived by these rules.

Ra Rb Rc Rd DB ----> R& ----> REb ----> R& ----> REd  Also, let Ra and Rb be defined as backward chaining rules and Rc and Rd as forward chaining rules. If the original database DB is updated, rules Rc and Rd, though they are forward chaining rules, will not be triggered to update the result REd until someone requests the data of REb. Thus, REd may be iriconsistent with the base data.

To overcome this problem, we use a result-oriented control strategy in which we specify for each result (derived subdatabase) whether it is to be pre-evaluated or post- evaluated. The same rule may follow the forward or backward chaining strategy depending on whether the derived subdatabae is to be pre- or post-evaluated.

To illustrate by the example above, assume that REd is defined as pre-evaluated and REb is defined as post- evaluated. Whenever the database DB is updated, the rules Ra, Rb. Rc, and Rd will be triggered in the forward chaining fashion to keep REM (which is explicitly stored) up-to-date.

REb. on the other hand, will be evaluated whenever a retrieval operation is issued against it. In this case, the rules Ra and Rb that derive REb are applied in the backward chaining fashion. Thus, Ra and Rb follow one control strategy when deriving RFxl and the other control straregy when deriving REb. This technique offers more flexibility and alleviates the restriction in POSTGRES described above.

7. Conclusion  In this paper, we have introduced the induced generalization association construct and presented a deductive rule-based language for object-oriented databases. The world of subdatabases is closed under this language, which facilitates defining inference chains in which each rule derives a new subdatabase based on the subdatabases derived by previous rules in the chain. The transitive closure operation can be specified in our language in the form of looping rather than in a recursive form. A result-oriented control strategy to be used as the underlying implementation technique has also been introduced in this paper.

ACKNOWLEDGEMENTS  Research on the rule-based language was supported by the U.S. West Advanced Technologies grant number UPN 88071315. Work on the Object-Oriented Query Language OQL was supported by the Navy Manufacturing Technology Program through the National Institute of Standards and Technology (formerly the National Bureau of Standards) grant number 60NANB4wO17 and by the National Science Foundation grant number DMC-8814989. The development efforts are supported by the Florida High Technology and Industry Council grant number UPN 85100316.

BIBLIOGRAPHY  ALA89a A.M. Alashqur, S.Y.W. Su, and H. Lar~?. "OQL A Q u y Language for Manipulating Object-onented Datah, Accepted for Publication, the 15th VLDB Int. Con., 1989.

ALA89b A.M. Alashqur. A Query Model and Query and Knowledge Definition Langwi~es for Object-oriented Databases. a Ph.D.

BAN87  BAT85  cER86  CHA84  COD79  DEL88  DIT86  HS87  FOR88  GAL84  HAM81  m 7  JAR84  LAM89  MAI88  RAS88  STO87  SU89  TY88  U 8 5  VAS84  Thesis, Univedty i f  Florida, -1989.

Jay Banerjee, et al., "Data Model Issues for Object-Oriented Aplications." ACM Trans. on Ofice Information Systems, January 1987.

D. Batory and W. Kim, "Modeling Concepts for VLSI CAD objects," ACM TODS. September 1985, pages 322-346.

Stefan0 Ceri, George Gottlob, and Gio Wiederhold, "Interfacing Relational Databases and Prolog Efficiently," Roc. of the 1st Intl. Con. on Expert Database Systems, 1986.

C. L. Chang and A. Walker, "PROSQL a PROLOG Programming Interface with SQLDS," F'mxdngs of the 1st Intl. Workshop on Expert Database Systems, 1984.

E. Codd. "Extend~ng the Database Relational Model to Capture More Meaning," ACM TODS. Vol. 4, No. 4. 1979.

Lois ML. Delcambre and James N. Etheredge, "A self- Controlling Interpreter for the relational Production Language," Roceedings of ACM SIGMOD Conference on Management of Data 1988, pages 396403.

KR. Dimich, "Object-oriented Database Systems: the Notion and Issues," Roc. of rhe Intl. Workshop on Object-Oriented Database Systems, califomia, September 1986.

D.H. Fishman, et al., "Iris: An Object-Oriented Database Management System," ACM Transaction on Oftixe Informarion Systems, January 1987. Pages 4869.

S. Ford, et al., "Zeitgeist: Database support for object-oriented rogramming," in the F" ' gs of the Second International Workshq on Object-oriented Database Systems, 1988.

Heme Gallaire. Jack Mier. and Jean-Marie Nicolas, "Logic and Databases: A Deductive Approach." ACM Computing Surveys. June 1984, Pages 153-185.

M. Hammer and D. McLeod, "Database Description with SDM A Semantic Associon Model," ACM TODS, Sepember 1981.

R. Hull and R. King, "Semantic Database Modeling: Survey, Applications, and Research Issues," ACM Computing Surveys, September 1987.

Mauhias Jark. Jim Clifford, and Yannis Vassiliou, "An Optimizing h l o g  Front-End to a Relational Query System," Roc. of ACM SIGMOD Con. on Management of Data 1984.

H.M. Lam, S. Su. and A.M. Alashqur, "Integrating the Concepts and Techniqws of Semantic Data Modeling and the Objectdented wradigm," Roc. of the 13th Intl. Computex Software and ApptiCationS Conference (COMSAC 89). 1989.

Christcphe de Maindreville and Eric Simon, "A Production Rule Based Approach to Deductive Databases," Roc. of the 4th Intl. Con. on Data Engineering, California, 1988.

L. Raschid and S.Y.W. Su, "A Transaction-oriented Mechanism to Control Precessing in a Knowledge Base Management System," Pmc. of the Intl. Con. on Expert Database Systems. 1988.

Michael Stonebraker, Eric Hanson and Chin-Heng Hong," The Design of the POSTGRES Rules System," Roc. of the 3rd Intl. Con. on Data Engineering, California, 1987.

S.Y.W Su, V. KrishnamurIhy. and H. Lam, "An Object- oriented Semantic Association Model (OsAM*)," appearing in: A.I. in Indus&l Engineering and Manufacturing: Theoretid Issues and Applications, S. Kumara. et al. (eds.), American Institute of Industrial Engineering, 1989.

Frederick Ty, "G-OQL: Graphics Interface to the Object- Oriented Query Language OQL," Master thesis, University of Florida. 1988.

Jeffrey ullman, "Implementation of Logical Query Languages for Databases," ACM TODS. September 1985.

Y. Vassiliou, J. Clifford, and M. Jark, "Access to Specific Declarative Knowledge by Expert Systems: The Impact of  hg"'ning," Decision Suppat Systems 1, 1, 1984.

