The Utility Frequent Pattern Mining Based on Slide Window in Data Stream

Abstract?In traditional study of mining data stream, each  item in the data stream is of equal importance. However, in  practice, each item has a different significance, which is  known as utility. This paper combines frequent mining item  sets with utility and proposes an efficient algorithm for  utility frequent pattern mining (UFPM). It combines bitmap  with tree structure that can store and update the pattern of  data stream quickly and completely by scanning only once.

The algorithm generated by lexicographic order, proposes a  novel tree U-tree and makes convenience for pattern  updating and user reading. With a pattern growth approach  in mining, the algorithm can effectively avoid the problem of  a mass candidacy generation by level-wise searching. The  experiments results show that our algorithm which is in high  efficiency and good scalability outperforms the existing  analogous algorithm.

Keywords-utility frequent pattern mining; slide window;  data stream; data mining  .?  INTRODUCTION  In recently years, the development of hardware  technology accelerates the ability in data gathering and  the focusing aspects in data mining are gradually turning  from static data sets mining into dynamic data stream  mining. Which is different from traditional static data  base, data stream has the characteristic [1]  of once access,  continuity, rapidity and unlimited increase. Therefore, the  mining algorithm used in static data base usually can?t be  applied to data stream mining.

In the field of data mining and knowledge discovery,  frequent itemsets play an important role, but it equally  treats each item without considering the item?s real  importance that is ?utility? [2]  . However, in real world,  each different item has a significant difference in the  importance of transaction or pattern. Pure frequent  itemsets mining based on supporting ability cannot meet  the criterion in real world. Thus, people give each item a  different value to represent its importance and then start  data mining. This thought is called utility pattern mining  compared with frequent pattern mining.

At present, the research of utility pattern mining in  data stream is rather unfocused, reference [3] first puts  the algorithm of high utility itemsets mining in data  stream?THUI-Mine. Reference [4] put forward the two  algorithms of MHUI-BIT and MHUI-TID, but the  weakness is that it causes mass candidacy frequent  itemsets and complicates the checking process, which  influences the function greatly. Reference [5] proposes  the algorithm of GUIDE, which can mine out the  maximal temporary utility sets by only once scanning but  cannot well process sequential and large scale data  stream.

This paper puts the UFPM (utility frequent pattern  mining) based on slide window. This algorithm is in  overall consideration of the item?s count and self-utility,  and also combines the two perfectly that can get the  pattern which meets the demand of utility frequency in  the data stream by scanning the data for only once. Using  the structure of bitmap to store the information of data  stream can save the time and the storing consumption of  data stream. The algorithm which uses pattern increasing  mining can avoid the problem of a mass candidacy  generation by level-wise searching in the existing  algorithm. The experiments results show that the  algorithm which is in high efficiency and good scalability  outperforms the existing analogous algorithm.

.? SOME PRELIMINARIES  Suppose a data stream DS={T ,T  ,...,T  k ,...}, among  which T i is the ith transaction in a series of sequential  transactions. T={tid,x ,x  ...x  n } is itemsets, among which  x n is its item, n is the size of the transaction and each  transaction has its special transaction id. The set of the   DOI 10.1109/ICICTA.2012.110       itemsets is called pattern X, and each pattern X is a subset  of data set A. If a transaction T includes all the data  elements in pattern X, that is T ?  X, and then we call  this transaction embodies the pattern X. Specific to data  stream DS, make it to sections. Each section includes the  same number of transaction and this kind of section is  called a basic window, noted as W. The transaction  number included in basic window is called the size of  basic window and is noted as |W|. The slide window SW  is composed with a series of sequential basic windows  and we note it as <W1,W2...,Wn>. The number of basic  windows in the slide window is called the size of slide  window and we note it as |SW|. As is conveyed above,  each item in data stream has its independent importance  that is utility, and we note as u(xi).

Definition 1. Supporting number and supporting  ability: the number of transactions which includes X in  window W is called the supporting number of X in W and  notes it as count(X). The percent of X?s transaction  number in W is called X?s supporting ability and we note  it as sup(X), thus we can get that,  sup(X)=count(X)/|W|   among which |W| is the width of W or the total  number of transactions in W.

TID 1 2 3 4 5  Transaction cba d cea ceb dcf  Table 1. Data stream  Item a b c d e f  Utility 0.2 0.5 0.3 0.4 0.8 0.2  Table 2. Utility values  Definition 2. The utility support of x i in  transaction T K  :  ( , ) ( ) ( , ) i k i i k  u x T u x count x T= ?   The utility support of pattern X:  ( ) ( , )  k i  i k  T SW x X  us X u x T  ? ?  = ? ?   The utility support of transaction T k :  ( ) ( , )  i k  k i k  x T  tu T u x T  ?  = ?   Definition 3. Utility frequency: Given a minimal  utility frequency as minus. If the utility of pattern X is  bigger than or equal to minus, that is us(X)?minus, then it  can be infer that pattern X is utility frequent. What the  so-called utility frequent pattern mining is to find out all  the patterns which meet this formula.

Definition 4. The transaction utility support of  pattern X: The sum of transaction utility supports which  include all the transactions in pattern X.

In frequent itemsets mining, ?downward closure  property? is usually used to reduce the non-frequent  patterns. The so-called ?downward closure property?  means that, if one pattern is frequent, then its sub-patterns  are all frequent. On the contrary, if a pattern is not  frequent, its super-patterns are not frequent [6]  . However,  because utility is considered as a factor in the utility  frequent pattern mining, this property cannot be used  directly. We define the transaction utility supporting  number of pattern X as:  ( ) ( )  k  q  X T SW  tus X tu T  ? ?  = ?   Definition 5. Transaction utility frequency: If the  transaction utility supporting number of one pattern X is  all bigger than or equal to minus, that is ( ) minustus X ?  ,  then we take that X is transaction utility frequent and we  also call it as frequent itemsets [3]  .

.? UFPM ALGORITHM  Considering the unlimited increasing and quickly  characteristics of data stream, the storage of data should  be space saving and easily updating. This paper uses the  structure of bitmap to represent the information of data  stream. By computing the bit, we can easily and quickly  get the pattern?s supporting number. At the same time,  according to the utility frequent pattern information  U-tree from the record window computed from the  structure of traditional FP-tree, then updates it by  increment and finally uses UFPM algorithm to process  frequent itemsets mining for the data in the window.

A. Bitmap structure  Bitmap structure refers to using the binary bit to  represent the condition of itemsets in the window. If one  of itemsets appears in the transaction, then its  corresponding sit is 1, or else is 0. According to logic  operation OR, we can quickly get the supporting number  of the itemsets. Also we can store the data by scanning  the data stream for only once.

In the following example of data stream, we make       the size of the slide window?s basic window as 1, the  slide window as 4, and then the bitmap information of the  first slide window can be shown in table 3.

Item T1 T2 T3 T4  a 1 0 1 0  b 1 1 0 1  c 1 0 1 1  d 0 1 0 0  e 0 0 1 1  f 0 0 0 0  Table 3. The bitmap information of the first window  B. Data processing in the slide window  When the window is not full, each new transaction  enters the window one by one and the front transaction  takes over its front transaction till the number of  transactions is equal to the size of the window and that is  the start of the window sliding. In the process of sliding,  we use the method of making the new transaction take  over the transaction which is about to leave the window  to distinguish the method of under fill window to update  the data. By using this new method, we can decrease the  data move for (|SW|-1) times in each slide. If the slide  window is very big, then we can save much more time.

According to this idea, the information of the second  slide window bitmap can be shown in table 4:  Table 4. The bitmap information of the second window  C. U-tree structure  In order to meet the demand of high utility frequent  pattern in mining the slide window, this paper designs an  algorithm for utility frequent pattern mining. When the  window is sliding, it first creates its corresponding bitmap  information, then according to the definition of utility  support, we compute the utility supporting number of  each pattern and do the pruning by the given minimal  utility frequent value minus so we can get the  corresponding sub-window utility frequent tree which we  name it the U-tree. The node of the tree includes 5 data  regions: the name of the node is node-name, the node?s  first transaction is named as tid, the node?s transaction  utility supporting number is node-tus, its parent node is  node-parent, and its brother node is node-brnode.

However, the node-tus has a little difference with tus(x)  defined in definition 4. Node-tus represents the sum of  the transaction utility supporting number that traverses  the tree nodes.

Data processing of the slide window and the  algorithm of the sub-window slide tree are shown as  follows:  Algorithm 1: Data storage, update, and window  sliding tree creation.

Input: data stream, slide window size |SW| and the  minimal utility frequent value minus.

Output: bitmap information, sub-window utility  frequent tree U-tree obtained by pruning.

1. Initialize the slide window, U-tree.

2. if(tid<|SW|)  {for(tid=1;tid?|SW|;tid++)  {for(fetch each item by lexicographic order  in the transaction)  {if item appears in this transaction  set the corresponding bitmap site  <tid/32,tid%32> as 1;  else set the bitmap site <tid/32,tid%32>  as 0;  compute the present utility  supporting number of the item in reading?}  compute this transaction?s utility  supporting number tus(X)?  add transaction ADD()? }  else for(tid;tid?sum of all the  transactions;tid++)  {for(fetch each item by lexicographic order  in the transaction)  {if item appears in this transaction  set the corresponding bitmap site  <(tid%|SW|)/32,tid%32)>as 1;  else set the bitmap site  <(tid%|SW|)/32,tid%32)>as 0; } }  calculate this transaction?s utility  supporting number tus(X)?  delete the transaction DELE() and  Item T5 T2 T3 T4  A 0 0 1 0  B 0 1 0 1  C 1 0 1 0  D 1 1 0 0  E 0 0 1 1  F 1 1 0 0       add transaction ADD()?}  D. Delete transaction  According to the idea above, when the window starts  sliding, the new transaction enters the window and the old  transaction is leaving, then it needs to be deleted. In the  bitmap, we use the covering method. However, in the  structure of U-tree, we first do the delete and then add the  new transaction U-tree. At the same time, because the  U-tree is built by lexicographic order, it can be easily  learned that the initial transaction mark of one node?s  child nodes can not precede this node. So, when a node  which its transaction information is all about to leave the  window, that is the time to delete the whole node, we can  delete all the child nodes which are in same with the  transaction marks.

Algorithm 2: Delete old U-tree  Input: U-tree, tid, the size of window |SW|.

Output: Delete the old U-tree.

DEL(U-tree,transaction number tid, window size  |SW|)  {for each node in U-tree// start traversing from the  root  if(p.node-tid?tid? |SW|)// decide if the node  belongs to the leaving window transaction  {if((p.tus(p)? tu(T p.node-tid  ))>0)// find out if  the node has follow-up transaction  {p.tus(p)=p.tus(p) ? tu(T p.node-tid  );//update  the node?s transaction supporting number  p.node-tid=follow-up transaction node.

node-tid;//update the node?s first transaction marks }  else{delete this node and its child nodes  which is in same with this node?s initial transaction  marks;  end the traverse;}}  else end traverse of this node and its child  nodes, then turn into other bother-nodes(if has no  bother-nodes, turn to other non-traversed nodes);  }  E. Add transaction  After deleting the old U-tree which is leaving the  window, update the U-tree with the new-added  transaction information. The specific algorithm is as  follows:  Algorithm 3 :Add new U-tree  ADD(U-tree?tid?window size |SW|)  {  if(U-tree is null)  set up the root node of U-tree?  else for each node in U-tree//start traversing from  the root node  if(for one child node A, set  A.item-name=p.item-name)// decide if need create new node  p.tus(p)=p.tus(p)+tu(T p.node-tid  );  else{create a new node N?  connect the new node with its parent  nodes?  N.node-tid=tid;//set the new node?s initial  transaction mark with the present transaction number  N.tus(N)=tu(T N.node-tid  );//set the utility  supporting number of the transaction }}  Now, we give an example of how to create a  U-tree. Using the data in form 3, we get the first slide  window. Its U-tree is shown in figure 1:                Figure 1.  Figure 1. The U-tree of the first slide window  Then, the window starts sliding, and the old  transaction T1 should be deleted. After deleting T1, we  get the U-tree shown in figure 2:                Figure 2.  Figure 2. After deleting the transaction T1  Finally, T5 enters into the slide window. The  bitmap information changes into table 4 and the U-tree is  updated, as is shown in figure 3:                             Figure 3. The second slide window after adding the transaction T5  F. Utility frequent itemsets mining  This unit emphasizes the description of UFPM  algorithm that how to mine out the utility frequent  itemsets in the data stream. UFPM algorithm follows the  pattern growing mining method. First, we create each  node?s pre-tree and the creation of pre-tree is based on the  creation of the previous sub-window U-tree. Second,  according to definition 5, delete the non-transaction  utility frequent nodes in pre-trees and get the candidacy  utility frequent pattern tree (short for candidacy tree). For  all the nodes which their transaction utility supporting  number is less than minus and all that is over than it can  be deleted. Then, by calculating each candidacy utility  frequent pattern (short for candidacy pattern)?s utility  supporting number us(X), abandon it if it is less than the  minimal utility frequent value minus. Finally, output all  the utility frequent patterns.

Take the figure 1 for example. Suppose the minimal  utility frequent value minus is 1.5. Start from the bottom  and left root ?c?. The pre-tree of ?c? is shown in figure  4(a). We get the candidacy pattern {a,c:1.9}?{b,c:1.6}?  {c:3.5}. The following figure 4(b) is the pre-tree of ?e?.

Because the transaction utility supporting number made  up by ?a? and ?e? is less than minus, ?a? and ?e? cannot  make up any candidacy patterns. So figure 4(b) is the  candidacy tree of ?e?, and we get the candidacy pattern  {a,e:1.9}?{b,c,e:1.6}?{e:2.5}. In the same way, the  candidacy pattern of ?b? is {a,b:1.9}? {b:2.6}. The  candidacy patterns of ?ce? are {b,c,e:1.6}?{c,e:1.6}.

Figure 4. Process of mining  According to definition 5, we need to calculate the  utility supporting number of each candidacy pattern by  the slide window?s bitmap information and utility value  table. Then find the utility frequent pattern from it. For  the example above, The final utility frequent patterns are  {b,c:1.6}?{b,c,e:1.6}?{c,e:2.2}.

.? ANALYSIS OF THE EXPERIMENT?S RESULTS  We use C++ language to realize the UFPM  algorithm. The experiment is operated on PC with OS of  Windows XP, CPU of 2.93GHZ, and the Internal Storage  of 2GB. This experiment chooses two classical data sets  for testing: T10I4D100K and Mushroom. The former data  set uses IBM data producing agent to create, and the latter  is the classical density data set which is from [8]. Set each  item size randomly as 0.1~0.9 utility. Set the data sets as  follows:  Properties  Data Total  items  Average transaction  length  Window size  T10I4D100K 1,000 10 10K  Mushroom 120 23 10K  Table 5. Basic facts of data sets  A. Experiment 1: The superiority of UFPM algorithm  The UFPM algorithm in this paper compares with the  THUI-Mine algorithm in reference [3] and the  MHUI-TID algorithm in reference [4]. Figure 5 and  figure 6 show the computing times of the three algorithms  in data set T10I4D100K and Mushroom. Because the  UFPM algorithm uses bitmap structure to store the data in  data stream, and remove the influence of old U-tree by  directly covering method, so it saves lots of storage space.

At the same time, the node of U-tree uses an initial  transaction mark which records the earliest transaction  that is easy for updating. However, U-tree needs to be  preserved, and its complication is very high when in the  condition of low minus. In a whole, the operating time of  UFPM algorithm runs in a rather low level which is  obviously superior to the algorithms of THUI-Mine and  MHUI-TID.

Figure 5. The comparison of operating time on dataset  T10I4D100K in different minus    Figure 6. The comparison of operating time on dataset Mushroom  in different minus  B. Experiment 2: Algorithm?s extensibility testing  Set minus as 0.005, and each of the slide window?s  width is 5K, 10K, 15K, and 20K. We test the average  operating time on every slide window in data set  T10I4D1000K. The results are shown in figure 7. We can  learn from the figure that the operating time of UFPM  algorithm is in a linear increasing with the increase of  window?s width. This means UFPM algorithm has a  rather good extensibility.

Figure 7. UFPM algorithm?s extensibility  .? CONCLUSION  This paper proposed a new method to mine out the  utility frequent itemsets in data stream?UFPM. It  combines the bitmap structure and tree structure that can  easily and quickly store and update data. It fetches data  according to lexicographic order and it can mine out all  the utility frequent patterns in data stream for only once.

It uses mining method by increasing pattern which can  avoid the problem of a mass candidacy itemsets by  level-searching in existing algorithm, so it can obviously  reduce the number of candidacy itemsets and the  operating time. The experiment?s result shows that this  algorithm has a better efficiency in time and space than  the existing algorithm which uses utility pattern mining.

