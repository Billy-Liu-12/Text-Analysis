Average Distance and Routing Algorithms in the  Star-Connected Cycles Interconnection Network

Abstract  The star-connected cycles (SCC) graph was recently pro- posed as an attractive interconnection network for parallel processing, using a star graph to connect cycles of nodes.

This paper presents an analytical solution for the problem of the average distance of the SCC graph. We divide the cost of a route in the SCC graph into three components, and show that one of such components is affected by the routing algorithm being used. Three routing algorithms for the SCC graph are presented, which respectively employ random, greedy and minimal routing rules. The computa- tional complexities of the algorithms, and the average costs of the paths they produce, are compared, Finally, we discuss how the algorithms presented in this paper can be used in association with wormhole routing.

1. Introduction  An interconnection network is characterized by four dis- tinct aspects: topology, routing,jlow control, and switching [ 111. The topology of a network defines how the nodes are interconnected by links, and is usually modeled by a graph.

Routing determines the path selected by a packet to reach its destination, and is usually specified by means of a rout- ing algorithm. Flow control deals with the allocation of links and buffers to a packet as it is routed through the net- work. Switching determines the mechanism by which data is moved from an incoming link to an outgoing link of a node (e.g., store-and-forward, circuit switching, virtual cut- through, and wormhole routing are examples of switching techniques found in parallel architectures).

In this paper, we continue the study of topological and routing aspects of the star-connected cycles (SCC) intercon- nection network [lo], which was recently proposed as an attractive extension of the star graph [ 11. An SCC graph is related to a star graph in the same way a cube-connected  'This research was supported in part by Conselho Nacional de Desen- volvimento Cientifico e Tecnol6gico (CNPq - Brazil), under the grant No.

200392/92- 1 .

0-8186-'7683-3196 $05.00 0 1996 IEEE  cycles graph [I21 is related to a hypercube [13]. Namely, an SCC graph is formed from a star graph by replacing the nodes of the latter with cyc:les or rings of nodes. The SCC graph constitutes an efficient architecture for execution of parallel algorithms, which include broadcasting [2] and FFT [ 141. Mesh algorithms are ailso supported in SCC graphs via embeddings [3]. The SCC graph inherits many of the in- teresting properties of the star graph [ 11, while employing at most three VO ports per node. This last aspect catego- rizes the SCC graph as a bounded-degree network (other examples arc in [12, 151). Networks with bounded degree favor area-efficient VLSI layouts, and scale more easily than variable-degree networks.

Previously known topological aspects of SCC graphs in- clude degree, symmetry, di ameter, and fault-diameter, and were derived in [4, 101. Here, we continue the study of these by investigating the average distance (or average diameter) of SCC graphs. Our interest in this property is twofold: 1 ) to obtain a metric for comparing the performance of routing algorithms, and 2) to provide continued characterization of the graph theoretical aspects of SCC networks.

In the absence of other network traffic, modern switching techniques (e.g., wormhole routing [6]) achieve a communi- cation latency which is virtually independent of the selected path length [I  11. In this ideal environment, the two factors which contribute to the communication latency experienced by a packet are the start-up latency and the network latency [ 111. In a realistic environment in which congestion oc- curs, however, a third factor known as blocking time also contributes to the communication latency.

Regardless of the flow control and switchingmechanisms being used in the network, (congestion can usually be mini- mized if fewer links are used when routing apacket [5]. For communication-intensive parallel applications, the blocking time (and, consequently, the communication latency) is ex- pected to grow with path length [5]. In such cases, a routing algorithm should ideally compute paths whose average cost matches the average distame of the network.

In this paper, we show that routes in an SCC graph may contain up to three classes of links, which we refer to as lateral links, MI local links, and MB local links (see Sec. 3 for definitions). Exact expressions for the average number     of lateral links and M I  local links between two nodes in an SCC graph, and an upper bound on the average number of MB local links, are derived. When combined, these expressions produce a tight upper bound on the average distance of the SCC graph.

We show that the number of MB local links is affected by the routing algorithm being used, and propose three dif- ferent algorithms for the SCC graph: random, greedy, and minimal routing. The proposed routing algorithms are com- pared according to criteria such as computational complexity (which affects their implementation in hardware) and aver- age routing cost, for which figures were obtained by means of simulation. The results obtained with the minimal rout- ing algorithm provide exact numeric solutions for the aver- age distance of SCC graphs. Our simulations indicate that the greedy routing algorithm performs close to the minimal routing algorithm, while requiring a smaller complexity. We show that the random routing algorithm presents the small- est complexity among the three algorithms described in this paper, and provide average and worst-case routing cost met- rics for it. Finally, we discuss how the three algorithms can be implemented in combination with wormhole routing [6].

2. Background  2.1. The star graph  An n-dimensional star graph, denoted by S,, contains n!

nodes which are labeled with then! possiblepermutations of n distinct symbols. In this paper, we use the integers (1, . . . , n }  to label the nodes of Sn. A node a = p l  . . . pa . . .pn is connected to (n- 1) distinct nodes,respectively labeled with permutations ai = pi  . . . pi-1p1pi+l . . . p n ,  2 5 i 5 n (i.e., a; is the permutation resulting from exchanging the symbols occupying the first and the ith position in a) [l]. Each of these (n  - 1) possible exchange operations is referred to as a generator of Sa. Two nodes a and ai of S, are connected by a link iff there is a generator gi such that a . gi = ai. The link connecting T and ai is referred to as an ith-dimension link and is labeled i. S, has ( n  - 1) . (n!/2) links. S, is a regular graph with degree S(Sn)  = n - 1 and diameter 4(Sn)  = [3(n - l ) /2J .  S, is vertex- and edge-symmetric, and has hierarchical structure. The degree and diameter of S, are sublogarithmic on the size of the graph [l], which makes the star graph compare favorably with the hypercube.

2.2. The star-connected cycles (SCC) graph  An n-dimensional SCC graph, denoted by SCC,, is a bounded-degree variant of S, [lo]. SCC, is formed by replacing each node of S, with a supernode, i.e. a ring of ( n  - 1) nodes. The connections between nodes inside the same supernode are referred to as local links. Each supernode is connected to ( n  - 1) adjacent supernodes, using lateral links inherited from S, . Figure 1 shows SCC,.

Nodes in SCC, are identified by a label (i, a), where i is an integer such that 2 5 i 5 n and a is a permutation of  n symbols. Two nodes (i, a) and (i?, w? )  are connected by a link (( i, a), (i?, T? ) )  in SCC, iff either: 1) ((i, a), (i?, T? ) )  is alocallink,i.e. T = a?andmin(~i- i ?~,n- l -~i- i ?~)  = 1, or2) ( ( i ,  T ) ,  (i?, a?)) is alaterai link, i.e. i = i? and a differs from a? only in the first and the i th  symbols, such that a(1) = ~ ? ( i )  and ~ ( i )  = ~?(1) .

(3 ,34121 I I  13.1243)  ( 2 , 4 1 2 3 1  ( 3 . 1 3 4 2 )  12 .4132)  ( 4 , 3 1 4 2 1  14 ,2143)  Figure 1 .  The SCC, graph  For similarity with S,, the label of the supernode con- taining nodes (2, a), . . . , (n ,  T )  is T .  Also, the lateral link connected to node (i, a) is labeled i. For simplicity, supern- ode and lateral link labels are not shown in Fig. 1.

SCC, contains ( n  - 1). n! nodes, ( n  - 1). n! local links, and ( n  - 1) . (n!/2) lateral links. Thus, the size of SCC, is comparable to that of Sn+l. Local links account for 2/3 of the links of SCC,, and can be laid out very efficiently due to the ring topology of the supernodes. Moreover, SCC, has about n times fewer lateral links than Sn+l, which further reduces the complexity of a VLSI layout for SCC, when compared to Sn+l. SCC, is vertex-symmetric, and has degree S(SCC,) = 2 (for n = 3), and S(SCC,) = 3 (for n 2 4). In addition, the diameter of SCC, is given by [ 101:  for n = 3 for even n (1) + n - 4),  + 3n - S), for odd n 2 5  3. Average distance of the SCC graph  3.1. Preliminaries  Let the cost of aroute P between node (i, a) and theiden- tity node (io, ag) = (2,12 . . . n)  in SCC, be d = lat + Zoc, where lat and loc respectively denote the number of lateral links and the number of local links in P. Because SCC, is vertex-symmetric, its average distance can be computed by finding minimal cost routes to the identity from every node in the graph, and averaging those over ( n  - 1) . n!.

Before we can derive the average distance of SCC, , some definitions related to lateral links are needed. We may organize the symbols of permutation a as a set of r-cycles? - i.e., cyclically ordered sets of symbols with the property that each symbol?s desired position is that occupied by the next symbol in the set. In this paper, all r-cycles are written in canonical form [8] (i.e., the smallest symbol appears first in each r-cycle). For example, a permutation a = 265431 can be written in cyclic format as (1 2 6)(3 5)(4). Note that a symbol already in its correct position appears as a 1-cycle.

Let Ci = (io . . . &-I) be an r-cycle in a, 2 5 r 5 n.

Let R . Ri be the permutation produced from a by moving the symbols in Ci to their correct positions. The execution of an r-cycle Ci is, by definition, a minimal sequence of lateral links2 Ri, leading from supernode a to supernode a & (note that local links are not an issue here). Ri can be expressed by [7,9]:  (2) if io = 1 { ( i 0 , i 1 , . . . , i r - 1 , i ~ ) ,  i f i o  # 1  In the case io # 1, Ci can actually be executed with r different sequences of lateral links [7, 91. Hence, for j : 0 4 r - 1, such sequences can be expressed as:  ( i l l  iz, . . . , &.-I), Ri =  ( i j m o d r ,  i ( j + l ) m o d r , . .  . l  i ( j+r - l )modr ,  i j m o d r )  (3)  The minimum number of lateral links in a route from supernode a to a0 does not depend on the order chosen to execute the r-cycles in a, and is given with [ 11:  if a?s first symbol is 1 (4) { :?- 2, if a?s first symbol is not 1, lat =  where c is the number of r-cycles of length at least 2 in a and m is the total number of symbols in these r-cycles.

Routes in SCC, often consist of sequences of lateral links interleaved with local links. In what follows, we give some definitions that relate to local links.

Recall that loc denotes the contribution of the local links to the total cost of a route P from (i, a) to (io, T O ) .  loc can be further divided into two components, which we denote by MI(loc) and MB(loc), and define as follows:  MI(loc) - the number of move-in (MI} local links existing in the route from (i, a) to (io, T O ) .  By def- inition, these are local links that must be traversed between two lateral links belonging to the execution sequence of an r-cycle in a.

MB(loc) - the number of move-between (MB} local links existing in the route from ( i ,  a) to (io, no). By definition, M B  local links are: 1) local links that must be traversed between the executions of two consecu- tive r-cycles in a, 2) local links that must be traversed  r-cycles provide a convenient means to represent permutations [8] and should not be confused with physicul cycles or rings, which constitute the supemodes of SCC, .

2Throughout the paper, we distinguish the notation of an r-cycle from that of a sequence of lateral links by using commas in the latter.

in supernode a, and are required to move from (i, a) to the lateral link that initiates the execution of the first r-cycle of a, and 3) local links that must be tra- versed in supernode: TO, and are required to move from the lateral link that finishes the execution of the last r-cycle of a to (io , TO) .

Thus, d = lat + loc =I lat + MI(loc) + MB(l0c). AS an example, consider routing from (3,34125) to (2,12345) in SCCs. The cyclic representation of permutation 34125 is (1 3)(2 4)(5). One possible route uses the sequences of lateral links (2,4,2) and (3). Figure 2 shows the MI local links and the MB local links in such a route.

Supernode labels )-4J7= A  5 2 1  5 2 ;  5 2 ;  5 2 1  5 2 1  Legend: a Sourcenode 81 Destination node - Lateral link ..--_... MI local link .---.-.. MB local link Figure 2. Types of links in a route in SCCB  Note that from the topological viewpoint there is no dis- tinction between MI and .MB local links. A particular local link used by a route in SCC, is considered to be either an MI or an MB local link, depending on the conditions stated above. Therefore, the same local link can be classified as an MI local link for some routes, and as an MB local link for others.

The cost components lat ,  MI(loc), and MB(loc) ex- ist in any route in SCC,, (although in some short routes one or more of these components may be null). Due to vertex symmetry, one cain derive the average distance of SCC, by computing the average numbers of lateral links, MI local links, and MB local links in a route from (i, a) to ( i o  , a~). We denote such average numbers by lat ,  MI(  loc), and MB( loc), respectively. The average distance of SCC,, denoted by 4(SCCn), can then be expressed by:  --  - - qqSCC,) = lat + MI(l0C) + MB(l0c) ( 5 )  Finally, the average number of local links existing in a route from (i, a) to (io, T O )  in SCCn is, by definition, - - ~- lac = MI(l0C) + MB(l0C).

3.2. Average number alf lateral links  The number of lateral links in the route between any node of SCC, and the identity node is exactly equal to the cost of the corresponding route in the underlying n-star graph [ 101. Therefore, lat is exactly equal to the average distance of S,, which is given by [ 11:  - 2 lat = n -t H ,  + - - 4,  n where H ,  = CL=, is the nth Harmonic number [8].

3.3. Average number of MI local links  The number of MI local links in a route in SCC, can be calculated as follows. Consider routing from ( i ,  T) to the identity node ( i o  TO), and let the number of r-cycles of length at least 2 in T be c. Let Ci = ( i o  . . . &.-I) be one of these r-cycles, and let Ri be an execution sequence for Ci (Eq. 2). Moving between two consecutive lateral links i,, i b  in Ri requires d( i ,  i b )  M I  local links, where [lo]:  d(ia1ib) = min(li, - ib1,n - 1 - li, - i b l )  (7)  The total number of MI local links that must be tra- versed during the execution of C;, denoted by MI(loc, Ci), is therefore the sum of the distances d(i,, i b )  between all pairs of consecutive lateral links (i,, i b )  in Ri:  Lemma 1 The number of MI local links that must be tra- versed in a route between any two nodes of SCC, is inde- pendent of the order chosen to execute the r-cycles existing between those nodes.

Proof: We first show that MI(loc, Ci) does not depend on the sequence of lateral links Ri chosen to execute C,. If io = 1, there is only one such sequence (Eq. 2) .  If i o  # 1, there are r different possible sequences (Eq. 3). However, due to the cyclic nature of these sequences, they all have the same cost MI(loc, Cz) (Eq. 8). By extension, the total number of MI local links in the route, MI(loc),  must also be an invariant. 0  An immediate consequence of Lemma 1 is that the num- ber of MI local links between two nodes of SCC, can be derived without further considerations about routing. (As- suming, of course, that routing is accomplished in adherence to Eqs. 2 and 3, as is the case with all routing algorithms presented in this paper.) As an example, consider an r-cycle C, = ( 2  6 4), and let n = 7. C, can be executed with a sequence of lateral links R, = ( 2 , 6 , 4 , 2 ) .  The number of MI local links required in the execution of this sequence is MI(loc, C,) = d ( 2 , 6 )  + d(6,4) + d(4,2) = 2 + 2 + 2 = 6 .

Theorem 1 The average number of MI local links that must be traversed in a route in SCC, is:  Proof: The average number of local links that must be traversed between two adjacent lateral links is:  The average number of local links that must be traversed in the execution of an r-cycle Ci = ( i o  . . . &-I) is:  MI(lOC,Ci) = - d(1oc) ( r  - 2 ) ,  if i o  = 1 if i o  # 1 (11) { -  d(1oc) . r ,  Over all n! possible permutations of n symbols and for each integer T ,  2 5 r 5 n, there is a total of (n  - l)! r-cycles that include symbol 1 ( i o  = 1 )  and n! /r  - ( n  - l ) !  r-cycles that do not include symbol 1 ( i o  # 1). The average number of MI local links over all n! permutations is therefore:  3.4. Average number of MB local links  Recall that M B  local links are needed to move between execution sequences of adjacent r-cycles (2 5 r 5 n), to move into the first lateral link, and to move out of the last lateral link in a route in SCCn.

Theorem 2 The average number of MB local links that must be traversed in a route in SCC,, under a random ordering of r-cycles, is:  H,(n - 1) - 2 n2 - 3n + 2 MB(loc, r a n d )  =  Proof: Over all n! possible permutations of n symbols and for each integer r ,  2 5 r 5 n, there is a total of n ! / r r-cycles. The total number of r-cycles of length at least 2 in the n! Dossible Dermutations of n svmbols is. therefore, N, = x:=2(n!/rj  = n! . (H, - 1). I  The average number of r-cycles, 2 5 r 5 n, in a per- mutation of n symbols is F = N,/n! = H, - 1. The average number-of M B  local links that must be traversed between these r-cycles is MB(loc, mid) = (T-l ) .d(doc)  =  n - 2 Let (i l  n) be the source node, and let the first lateral link  in the route be ik, 2 5 i k  5 n. The average number of local links that must be traversed between (i, n) and (ik, T )  . , - is d ( i n )  = - 1 Cy=2 d(i, 2 )  = k1 1W  n - 1  n - 1  ' I "  - ." A -  Note that d ( i n )  differs from d(loc) (Eq. lo), since to compute d ( i n )  we must consider the case i = i k .  Simi- larly, the average number of local links that must be tra- versed between the last laterallinkin the route and the destination node is d(out) = d ( i n ) .  Then, the average number of M B  local links that must be traversed in a route in SCC,, assuming a random ordering of r-cycles,  -     is MB(loc, rand) = d(in) + MB(loc, mid) + d(out). The theorem follows. 0  As described in Sec. 4, a properly designed routing algo- rithm can optimize the ordering of the r-cycles and reduce the average number of M B  local links further below the value provided by a random ordering of r-cycles (Eq. 12).

The average number of M B  local links, considering that the shortest route between any two nodes of an SCC graph is determined by a minimal routing algorithm, is therefore bounded by:  MB(doc) 5 MB(loc, rand) (13)  3.5. Average distance in the SCC graph  Theorem 3 The average distance of SCCn is bounded by: n $(SCCn) n + Hn + - - 4 + [:J LqJ (-+ -) H ,  - 2 (14)  Proof: Follows directly from Eqs. 5, 6,  9, 12 and 13. 0  4. Routing algorithms in the SCC graph  4.1. Ordering of r-cycles  Routing between two nodes ( i s ,  w s )  and ( i d ,  T d )  in SCCn is equivalent to routing from (is, nd,) to (id, no), where rids = nil . w s ,  TO = 123. . . n, and T;? is the inverse or reciprocal of permutation T d  [ 1, IO].

Let P(t1 t+ e,) denote a route from from (is, s,) to ( i d ,  T d )  in SCC, , which traverses a sequence of f lateral links R(l1 I+ t f )  = ( l 1 ,  &, . . , ,tj). The total cost of P(el H e , )  is given with: IP(t1 Ht,>l = f +d(i, ,el)+C:=:d(t~,t j+l)+  d(ff , i d )  (15) Depending on the order chosen to execute the r-cycles  in Td,, different routes P(!l w e,) are produced. As explained in Sec. 3, a common feature to any of these routes is that they all have the same number of lateral links (aut) and MI local links (MI(loc)). Finding the shortest route from ( i s ,  w, )  to ( i d ,  a d )  is therefore a matter of choosing an r-cycle ordering which minimizes the number of M B  local links (MB(Zoc)). A routing algorithm which achieves this goal is given in Subsec. 4.4. Non-minimal (but simpler) routing algorithms are presented in Subsecs. 4.2 and 4.3.

To illustrate the different cost components in a route, and how they are affected by the order chosen to exe- cute the r-cycles, assume routing from node (3,34125) to node (2,12345) in SCC,. A route along the sequence R(2 H 3) = (2,4,2,3) contains four lateral links, four MI local links, and three MB local links (i.e., IP(2 I-+ 3)1 = 4 + 4 + 3 = 11). However, if the sequence of lateral links  R(3 H 2) = ( 3 , 2 , 4 , 2 )  is used, a route with four lateral links, four MI local links, and one MB local link results (i.e., IP(3 H 2)1 = 4 + 4 + 1 = 9).

In some cases, the number of M B  local links in a route from (is, w, )  to ( i d ,  ~ d )  #can be further reduced by inter- leaving (rather than executing separately) the r-cycles in r d , .  For example, some possible sequences of lateral links from supernode r d s  = 23154 = (1 2 3)(4 5) to supernode TO = 12345 in SCC5 are (2, 3, 4, 5, 4), (2, 3, 5, 4, 5), (4,5,4,2,  31, (5,4,5,2,3),  (2,4,5,4,3) and (2,5,4,5,3).

The last two of these sequences interleave r-cycles (1 2 3) and (4 5). All of the routing algorithms presented in this paper account for the possibility of interleaving r-cycles.

4.2. Random routing algorithm  A simple routing algorithm for SCC, consists of choos- ing a random order to execute the r-cycles in r d s .  Particu- larly, a possible algorithm that can be used for this purpose is the routing algorithm of the star graph 171:  Algorithm 1 (Non-deterministic routing in the star graph):  Repeat until T d ,  = 70:  1. If the first symbol in x d ,  is 1, then exchange it with any symbol not in its correct position.

2. If the first symbol in T d s  is z # 1, then either exchange it with the symbol a t  position z, or exchange it with any symbol in an r-cycle of length at least two, other than the r-cycle containing x.

Algorithm I requires at most c + m steps of complexity O(1) each, and therefore its complexity is O(c + m), or o(n), since 0 5 c 5 ln/2J and 1 5 m 5 n.

4.3. Greedy routing algorithm  A simple approach to minimizing the number of MB local links in the route between nodes ( i s ,  w s )  and ( i d ,  T d ) consists of using a greedy algorithm. Such an algorithm uses the following data structures and variables:  0 S, - the set of r-cycles of length at least 2 in rids.

0 S, - a subset of the symbols of T d s ,  such that: 1) if (1 il . . . i!s an r-cycle of rids, 2 5 r 5 n, then i l  E S, and 1, i z ,  . . . , i,-l # S,, and 2) if ( i o  . . . ir-l) is an r-cycle of T d s ,  2 5 T 5 n, such thatio , . . .  ,i,.-1 # 1,thenio , . . . ,  i,-l ES,.

0 ij - an integer varialble initialized to i j  = i s .

Algorithm 2 (Greedy routing in the SCC graph):  1 .  If ?Tds = TO, then route inside the supernode and exit.

2. Identify the r-cycles of length at least 2 that exist in s d s ,  and initializes,:, s,, and ij.

Choose a symbol i, E S, such that d( i j  , i,) is min- imal. Let C, be the r-cycle that contains symbol i,.

Once i, is chosen, make ij = i,.

If Ca has the form (1 i, i p  . . . &..-I), then make  and S, = S, - {i,} + { i p } .  Otherwise, make S, = S, - {C,} and S, = S, - {symbols(C,)}, where symbols(C,) denotes a function that returns the set of symbols in r-cycle Ca.

S,=S,-((l i , ip . . .  i , -1)}+{(l ip  . . .  &-I )}  Repeat Steps 3 and 4 until S, = 8.

The greedy approach used by Alg. 2 consists of choosing the r-cycle that has the minimum distance from ij as the next one to be executed. If the selected r-cycle Ca includes symbol 1, then only the first lateral link of C, is taken, wbich allows for an interleaved execution of that r-cycle. If C, does not include symbol 1, then C, is executed completely.

The complexity of the greedy routing algorithm is O(cm), or O(n2) since 0 5 c 5 Ln/2J and 0 5 m 5 n. The ordering of r-cycles chosen by this algorithm, however, may not produce a minimal route.

4.4. Minimal routing algorithm  We now present a minimal routing algorithm which finds the shortest route between a pair of nodes (is, n,) and (id, ~ d )  in SCC,. The output of the algorithm con- sists of a sequence of lateral links R(!l H !,), for which lP(!l H !,)I is minimal (Eq. 15). We note that an earlier version of our minimal routing algorithm appeared in [lo].

The algorithm we present here improves that of [ 101 in two ways: 1) it employs more selective heuristics to further con- strain the search space generated by the algorithm, and 2) it accounts for the possibility of interleaving r-cycles, which is not possible with the algorithm in [lo].

The algorithm performs a depth-first search on a weighted tree structure. The tree is built by expanding at each step only those r-cycle orderings that seem to result in a min- imal number of local links. Although the search tree can virtually examine all possible r-cycle orderings, including interleaved r-cycles, its size is significantly constrained in our algorithm. To guarantee that a minimal route is always found, backtracking is used to enable expansion of previ- ous r-cycle orderings that seem to be better than the most recently expanded orderings.

In the following discussion, we use the term vertex to refer to an element of the search tree. In addition, we use the term edge to refer to the logical connection between vertices in the search tree, which is usually implemented with pointers or some form of indexing. The following data structures are stored within each vertex wa of the search tree and are used by the algorithm:  0 ( t i ,  a;) - the label of the node reached so far by the routing algorithm.

0 B; - a subset of the symbols of n;, such that: 1) if (1 il . . . is an r-cycle of n;, 2 5 T 5 n, then il E Bi and 1, i2,. . . , i,-l $! Bi, and 2) if (il . . . &.-I) is an r-cycle of r i ,  2 5 T 5 n, such that il ,  . . . , i,-l # 1, then il,  . . . , i,-l E Bi.

The symbols in Bi represent all possible lateral links that can be selected by the routing algorithm while expanding the search tree f rop a given vertex wi.

For convenience, we define a function bsymbols to generate B; from ni, such that& = bsymbols(ni).

-0 Fa - a subset of the symbols of-/ni, such that: 1) if (1 il . . . i,.-l) is an r-cycle of T ; ,  2 5 T 5 n, then i,-l E F; and 1, il, . . . , i,-2 F;, and 2) if (io . . . &.-I) is an r-cycle of ri, 2 5 T 5 n, such that io, . . . , i,-l # 1, then io, . . . , i,-l E F;.

The symbols in 3; represent all lateral links that can be possibly selected by the routing algorithm to enter supernode no (i.e., all possible r-cycle orderings that can be selected from a given vertex w i  necessarily end with a lateral link I?, E F;). For convenience, we define a function fsymbols to generate 3; from A;, such that F; = fsymbols(n;).

0 L; - the number of local links used so far by the rout- ing algorithm in the route from (is, nd,) to ( I ? ; ,  .;).

0 Mi - an estimate of the minimum number of local links that may be needed to reach node (id, TO) from node (is, nd,), using the route already constructed by the algorithm up to the intermediate node (ti, n;). For convenience, we define a function dubbed minloc, which computes M; as follows:  Mi = minloc( L; , ti, ri, id) = L; + min(d(!; , b; ) ) + Ml(loc,  Ca) + min(d(fi, id)), (16)  C,?*,  where bi E Bi and fi E 3 i .

Note that minloc is computed under the optimistic as- sumption that the route from (!;, n;) to (id, no) selects the best possible lateral links in Bi and F;. In addi- tion, the summation term which computes the number of local links needed to execute all r-cycles C; E ~i (see Eq. 8) assumes that an optimal r-cycle ordering requiring no local links to move from one r-cycle to the next can be found by the routing algorithm.

e e; - an enableidisable bit which indicates whether or not the tree should be expanded from vertex w;.

In addition, the tree structure generated by the minimal routing algorithm has the following characteristics:  0 The search tree has at most lat + 2 levels, with lat being given by Eq. 4. We number levels from 0 to lat + 1, starting from the root level.

0 Let vi be the parent of a vertex vi in the search tree. Let { ( l i  , ai), ai, Fi, Lj , Mi,  ei } and {(ti ,  ai), l?i,Fi, Ll ,  M i ,  e;} denote thedatastored in  and vi, respectively. The weight of the edge (vi, vf) corresponds to the number of local links that are re- quired to route from (&, ai) to (ti, n:) in SCC, and is given by d(.&, ti). Hence, L: = Li + d(Li, e:) .

Note that routing from (ti ai) to (e ; ,  n:) also requires one lateral link if 7 ~ i  # n;, and zero lateral links otherwise. Since the number of lateral links in a route from (is, rids) to (id, no) can be computed a priori (Eq. 4), the routing algorithm focuses on accounting for the local links only.

0 Vertices located at level lat + 1 in the tree have minloc( Li , id, no, id) = La. Vertices located at level lat have (ti, x i )  = (e, ,  TO) (with l j  being the lateral link used to enter supernode no), Bi = Fi = 0, and Mi = minloc(Li, e,, T O ,  id) = Li + d ( t f ,  id).

0 The backtracking mechanism is triggered by com- paring the estimated minimum number of local links (Mi) stored in the most recently generated child ver- tices with a global variable referred to as T. This variable is updated whenever a backtracking proce- dure occurs, meaning that the minimum number of local links that is required in the route from (is rids) to (id, no) is actually greater than the previous value of T. The search becomes more selective as T in- creases, which not only limits the width of the search tree, but also makes the backtracking mechanism less likely to be triggered again.

Given the definitions above, the minimal routing algo- rithm for the SCC graph follows :  Algorithm 3 (Minimal routing in the SCC grauh):  ( t i , ~ i )  =   id,^^), Bi = Fi = 0 and Mi =  1. If T d s  = no, then route inside the supernode and exit.

2. Create a root vertex with (ti, ni) = (is, rids), Bi =  bSymbdS(Td, ) ,  Fi = fSY?7IbdS(7Fd8), Li = 0, Mi = minloc(0, i,, ads, id) and ea = ON. Also, ini- tialize T with the value T = minloc(0, is, rids, id).

3. Generate child vertices for all enabled vertices, such that the label !f for each child corresponds to exactly one of the symbols stored in the set Bi of each parent vertex. Set ea = OFF at each recently expanded parent vertex. Also, obtain permutation n: for each child vertex by swapping the 1st and the C:th symbols of ai, and make Bi = bsymbo l s (n ; ) ,  Fi = f s y m b o l s ( n i ) ,  Enabled vertices located at level lat of the search tree must be expanded similarly. However, they generate a single child with la = id, a: = ni, Bi = 0, Fi = 0, L: = Li + d(!i, id), and M,! = La. In any case, a child vertex is enabled with e: = ON if M i  5 T.

Otherwise, we set e: = OFF.

L: = Li + d( .ei ,e:) ,  M i  = minloc(L:,!;,n;,id).

4. If a child vertex has (e:, a:) = (id, TO)  and e: = ON, then a minimal route has been found. The optimal sequence of lateral links R(tl H l j )  can be obtained in reverse order by backing up towards the root of the tree and listing the value ti stored in each vertex located between the: latth and the 1st levels. Once R(tl H e , )  has been obtained, exit the algorithm.

5.  If none of the enabled child vertices has (!;, n:) = (id, no), go to Step 3.

6. If there are no enabled child vertices, do a backtrack- ing search in the tree. Among all existing child ver- tices, select those with the smallest value of Mi and set T to this value. Also, enable the selected nodes and go to Step 4.

The height of the search tree is O(n),  since its maximum value is d(Sn) + 2 = 13 ( n  - 1)/2J + 2. A worst-case analysis of the width of the search tree can be done under the following pessimistic assumption: considering that all possible orderings of r-cycles in permutation T d s  are exam- ined by Alg. 3, the lowest level in the search tree would have at most m! vertices. This is due to the fact that there are at most m! possible ways to move the m misplaced symbols in T d s  to their correct posil.ions, using the minimum number of lateral links given by Eq. 4. In practice, the constraints placed on the number of vertices by the heuristics of Alg. 3 (i.e., the estimated minimum number of local links Mi)  limit the width of the search tree considerably. Simulations car- ried out for 4 < n < 9 revealed that a very small number of vertices is enabled at each step, which makes the maximum width of the tree virtually proportional to m. Figure 3 illus- trates an example of the search tree constructed by Alg. 3.

The main computations incurred upon creation of a vertex of the search tree refer to IO:, Fi and M i .  Fortunately, each of these computations can be accomplished in O( 1) time by using the corresponding values ai, Fi and Mi that are stored in the parent vertex, and taking into account the differences in the r-cycle structures of permutations ni and n:.

The reasoning above results in a worst-case complexity of O(m!n). As explained above, such computational require- ments were not observed during simulations of the minimal algorithm. The potential need for backtracking searches in the tree, added to fact that the maximum width of the tree is in practice proportionall to m, results in a complexity of O(mn2),  on the average (or O(n3),  since 0 5 m 5 n).

5. Simulation results;  The performance of routing algorithms for SCC, was evaluated with simulation programs which compute the route of all ( n  - l)n! nodes of the graph to the identity.

The routing algorithms that were tested are: 1) a random routing algorithm that generates all possible routes to the identity with equal probatlility, which is based on Alg. 1,2) Alg. 2, and 3) Alg. 3. Tht: simulations were carried out for 3 5 n 5 9. A log of worst-case routes that may result from the random routing algorithm was also made.

ti = 5 ~i = (1 5 3)(2 4)(6) Bi = {2,4,5) 3i = {2,3,4) L;=O M ; = 6  e ;=OFF    2o  Dimensionality of the SCC graph: n = 6 Source node: (5, (1 5 3)(2 4)(6)) Destination node: (3, (1)(2)(3)(4)(5)(6)) Backtracking threshold used: T = 6 Optimal sequence of lateral links found: (5,4,2,4,3) Number of lateral links in the minimal path: 5 Number of local links in the minimal path: 6 Total length of the minimal path: 11  k - -A Average distance /?\ /? - W Average number of local links  e-* Average number of MI local links *---*Average number of lateral links  /? /?  A.

ai = (4) 3i = (3)  t?i = (3)  ai = 0  Figure 3. Example of search tree used for minimal routing in SCC,  Table 1 and Fig. 4 show the simulation results obtained with the minimal routing algorithm. Values for lat and MI(Zoc) match exactly the theoretical values provided by Eqs. 6 and 9. Also, the simulation results obtained for MB(loc) under a minimal routing algorithm are closely bounded by Eq. 12.

As expected, only the average number of M B  local links varied among the different routing algorithms that were  9 4  + - -0 Random routing (average, theoretical) /I  & - - A  Random routing (worst-case) .z H Random routing (average, simulation) x - - - x  Greedy routing  m - D-.-.-a Minimal routing m  Y  - - - ?  5 -  /?  I 3 4 5 6 7 8 9  n  Figure 5. MB(Zoc) vs. routing algorithms  tested. Fig. 5 compares simulation results for MB(loc).

Note that the results for the random routing algorithm are very close to the theoretical values provided by Eq. 12. The model used to derive that equation seems to result in an error proportional to l /n!,  which is negligible considering that Eq. 12 is still a close upper bound for MB( loc). As ex- pected, both the greedy and the minimal routing algorithm outperform the random routing algorithm, as far as the av-     n I 3 1  4 1  5 1  6 1  7 1  8 I 9  Graph diameter (q5(SCCn)) Average number of lateral links (E)  Average number of MI local links (MI(loc)) Average number of MB local links (MB(Zoc))  I Graph size ( ( n  - 1) e n!)  I 12 I 72 I 480 I 3,600 I 30,240 I 282,240 I 2,903,040 6 8 16 19  1.500 2.583 3.683 4.783 0.667 1.500 3.200 5.000 0.833 1.222 1.925 2.337  1.500  3.000  Average number of local links (L) Average distance (d(SCC,))  2.722 5.125 7.337  5.306 8.808 12.121  Table 1. Average distance of SCC graphs under minimal routing    g 200000   E L  &  = 100000    erage number of M B  local links is concerned. Also observe that, for 3 5 n 5 4, the greedy routing algorithm performs as well as the minimal routing algorithm. Besides, our re- sults indicate that the performance of these algorithms is quite similar for 5 5 n 5 9, which makes the less complex greedy routing algorithm particularly attractive.

Average costs of paths produced by the three routing al- gorithms are summarized in Table 2. The random routing algorithm has a complexity of O(n)  and performs reason- ably well on the average. Utilization of such an algorithm may, however, result in variations in the average cost of routes up to the worst-case values shown in Table 2.

- Minimal routing -  andom rout. (worst case) -  -  -  -  n   Minimal Greedy Random routing rout. rout. Theor. Simul. Worst-case 3.000 3.000 3.000 3.084 3.167  I 1  I I I I I   I I I I I  5.306 5.305 5.500 5.514 5.694 8.808 8.812 9.261 9.264 9.775  Table 2. Average costs vs. routing algorithms  Figure 6 shows distribution curves comparing the three routing algorithms in the case of an SCC, graph. A point (01, N I )  in one of  these curves indicates that the corre- sponding routing algorithm will compute a route of cost D I to the identity for N I  nodes in the SCC graph. The aver- age distribution for the random routing algorithm is shown, but the results for that algorithm may actually vary from the minimal to the worst-case distributioncurves due to the non- deterministic nature of the algorithm. It is also interesting to observe that the greedy routing algorithm provides a dis- tribution curve which is close to that of the minimal routing algorithm, presenting however a smaller complexity.

6. Considerations on wormhole routing   In this section, we briefly describe how the algorithms presented in the paper cam be combined with wormhole routing [6], which is a popular switching technique used in parallel computers.

All three algorithms can be used with wormhole routing, when implemented as source-based routing algorithms [ 111.

In source-based routing, tlhe source node selects the entire path before sending the packet. Because the processing delay for the routing algorithm is incurred only at the source node, it adds only once to the communication latency, and can be viewed as part of the start-up latency. Source-based routing, however, has two disadvantages: 1) each packet must carry complete information about its path in the header, which increases the packet length, and 2) the path cannot be changed while the packet is being routed, which precludes incorporating adaptivity into the routing algorithm.

Distributed routing eliminates the disadvantages of source-based routing by invoking the routing algorithm in each node to which the packet is forwarded [ll].  Thus, the decision on whether a packet should be delivered to the local processor or forwarded on an outgoing link is done     locally by the routing circuit of a node. Because the routing algorithm is invoked multiple times while a packet is being routed, the routing decision must be taken as fast as pos- sible. From this viewpoint, it is important that the routing algorithm can be easily and efficiently rendered in hardware, which favors the random routing algorithm over the greedy and minimal routing algorithms.

Besides being the most complex algorithm discussed in this paper, the minimal routing algorithm includes a feature which precludes its distributed implementation in associa- tion with wormhole routing, namely its backtracking mech- anism, Distributed versions of the random and greedy al- gorithms, however, can be used in combination with worm- hole routing. A near-minimal distributed routing algorithm which supports wormhole routing can be obtained by re- moving the backtracking mechanism from Alg. 3. Such an algorithm is likely to have computational complexity and average cost that lie between those of the greedy and the minimal routing algorithm.

Due to its non-deterministic nature, the random routing algorithm also seems to be a good candidate for SCC net- works employing distributed adaptive routing [ 1 I]. Adap- tivity is desirable, for example, if the routing algorithm must dynamically respond to network conditions such as conges- tion and faults. Some degree of adaptivity is also possible in the greedy and minimal routing algorithms, which in some cases can decide between paths of equal cost.

7. Conclusion  This paper compared the average cost and the complex- ity of three different routing algorithms for the SCC graph.

We divided routes into three components (lateral links, MI local links and MB local links) and showed that only the number of M B  local links may be affected by the routing algorithm being considered. Exact expressions for the aver- age number of lateral links and the average number of MI local links were presented. Also, an upper bound for the average number of MZ? local links was derived, considering a random routing algorithm. As a result, a tight upper bound on the average distance of the SCC graph was obtained.

Simulation results for a random, a greedy and a minimal routing algorithm were presented and compared with theo- retical values. The complexity of the proposed algorithms is respectively O(n),  O ( n 2 ) ,  and O(n3) ,  where n is the dimensionality of the SCC, grap.h. The results under mini- mal routing produce exact numerical values for the average distance of SCC,, for 3 5 n 5 9.

Results for the greedy algorithm match those of the min- imal algorithm for 3 2 n 5 4. The greedy algorithm also performs close to minimality for 5 5 n 5 9, and is an in- teresting choice due to its O(n2) complexity. The random routing algorithm has an O(n)  complexity and performs fairly well on the average, but may introduce additional MB local links in the route under worst-case conditions.

Finally, we discussed how each of the routing algorithms can be used in association with the wormhole routing switch-  ing technique. Directions for future research in this area in- clude an evaluation of requirements for deadlock avoidance (e.g., number of virtual channels).

