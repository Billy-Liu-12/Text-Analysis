Parallel Matrix Factorization for Binary Response

Abstract?Predicting user affinity to items is an important problem in applications like content optimization, computa- tional advertising, among others. While matrix factorization methods provide state-of-the-art performance when minimizing RMSE through a Gaussian response model on explicit ratings data, applying it to imbalanced binary response data presents additional challenges that we carefully study in this paper.

Data in many applications usually consist of users? implicit response that is binary ? clicking an item or not; the goal is to predict click rates (i.e., probabilities), which are often combined with other measures of utilities to rank items at runtime.

Because of the implicit nature, such data is usually much larger than explicit rating data but often has an imbalanced distribution with a small fraction of click events, making accurate click rate prediction difficult. In this paper, we address two problems. First, we show previous techniques to estimate factor models with binary data are less accurate compared to our new approach based on adaptive rejection sampling, especially for imbalanced response. Second, we develop a parallel matrix factorization framework using Map-Reduce that scales to massive datasets. Our parallel algorithm is based on a ?divide and conquer? strategy coupled with an ensemble approach. Through experiments on two benchmark data sets and a large Yahoo! Front Page Today Module data set that contains 8M users and 1B binary observations, we show that careful handling of binary response is needed to achieve good performance for click rate prediction, and that the proposed adaptive rejection sampler and the partitioning and ensemble techniques significantly improve performance.



I. INTRODUCTION Personalized item recommendation is an important task  in many web applications, such as content optimization [4], computational advertising [8], and others. Such systems recommend a set of items like article links, ads, product links, etc for each user visit; users respond by clicking and/or engaging in other activities post-click. Personalizing such recommendations typically leads to better user engagement and profit for organizations. Accurate prediction of pij , the probability of user i clicking item j, is an important input to facilitate such personalization.

If we let rj denote the utility of clicking item j (e.g., the  ad revenue associated with a click on item j), the system may rank items based on some function of rj and pij to maximize the utility. In computational advertising for instance, ranking is based on the expected revenue rjpij .

Click probabilities are usually estimated through a statistical model trained on past click data. Intuitively, we can think of the click data as a binary matrix Y , such that entry yij = 1 if user i clicked item j, and yij = 0 if user i viewed but  did not click on j. We note that Y is a highly incomplete matrix with many unobserved entries since each user usually views a small number of items, the goal is to predict pij for unobserved (i, j) pairs. We also note that in many web applications the click-rates are small giving rise to highly imbalanced binary response data.

Matrix factorization is a popular method for predicting  unobserved entries in matrix Y and tends to provide state-of- the-art performance, especially for movie rating prediction problems [1], where the entries in Y are numeric (not binary) and the goal is to minimize RMSE (root mean squared error).

The basic idea of matrix factorization is to approximate the response Y by UV ?, where U and V are two unknown low rank matrices; i.e., approximate yij by u?ivj , where u?i is the ith row of U representing the latent profile of user i, and v?j is the jth row of V representing the latent profile of item j.

The unknown latent factors, the ui?s and vj?s, are estimated by min  ? ij(yij ? u  ? ivj)  2 over observed (i, j) pairs with appropriate regularization. Methods [2] have been developed to provide good performance for both ?warm-start? scenarios (users and items with many ratings in training) and ?cold- start? scenarios (users or items with no or few ratings in training) by leveraging available user and item features through a Monte Carlo EM (MCEM) algorithm.

Although much progress has been made, applying factor-  ization methods to web applications is still challenging for the following reasons: ? Imbalanced binary response: Many web applications depend on implicit user feedback that are in the form of events like clicks, conversion, etc., which are usually rare; this gives rise to imbalanced binary response data.

Accurate estimation of probabilities with imbalanced binary response is known to be a difficult problem [22] even in the case of ordinary logistic regression; per- forming such estimation for elaborate matrix factoriza- tion introduces additional challenges.

? Large scale data: As every display of an item to a user generates an observation, data collected from these applications is massive for many websites. In fact, the entire data often does not fit into memory and resides in large distributed data clusters. Scalable model fitting using a distributed computing paradigm like Map-Reduce is attractive, but also challenging (e.g., the MCEM algorithm in [2] is not easily parallelizible).

We address both of the above challenges in this paper by extending the MCEM algorithm for fitting the regression- based latent factor model (RLFM) [2] which seamlessly combines collaborative filtering and content-based filtering      through feature-based regression priors. Specifically, we make the following contributions: ? We propose an adaptive rejection sampling (ARS) tech- nique for the E-step of the MCEM algorithm, and show that ARS significantly improves prediction accuracy over the variational approximation method in [2].

? We find that model identifiability issues when dealing with imbalanced binary response can hurt accuracy, and show that enforcing a few additional constraints on the factors can effectively handle the issues.

? We develop a simple and effective parallel matrix factorization framework by (a) creating several ran- dom partitions of data and fitting separate models to each in parallel, (b) using an ensemble approach to refine the factor estimates, (c) careful initialization that synchronizes factor estimates across partitions, and (d) appropriate data partitioning.

? We report extensive experiments on benchmark data and illustrate impressive gains on a real content opti- mization problem of the Today Module on Yahoo! Front Page using a dataset of 8M users and 1B observations.



II. MODEL In this section, we describe a probabilistic matrix fac-  torization model that leverages features to handle the cold- start problem and has been shown to provide state-of-the-art performance on a number of relatively small datasets [2, 29].

We only describe the Logistic model for binary response, and refer the readers to [29] for the Gaussian model for numeric response and Poisson model for count data.

Notation:. Let yij ? {0, 1} denote whether user i clicks item j. Since we always use i to denote a user and j to denote an item, by slight abuse of notations, we let xi, xj and xij denote feature vectors of user i, item j and pair (i, j). For example, the user feature vector xi may include age, gender and behavioral features. The item feature vector xj may include content categories, keywords, named entities, etc.

The feature vector xij contains observation-specific features that are not entirely attributable to either user or item, e.g., time-of-day of the observation, position of the item on the displayed web page.

Model: Our objective is to model the unobserved probability pij that user i would click item j. Specifically, we assume a Bernoulli model using the Logistic link function: yij ? Bernoulli(pij). Let sij = log  pij 1?pij  denote the log odds. We model sij by sij = f(xij) + ?i + ?j +u?ivj , where f(xij) is a regression function based on feature vector xij ; ?i and ui are latent factors representing the user bias and the r- dimensional latent profile of user i, respectively; and ?j and vj are latent factors representing the item popularity and the r-dimensional latent profile of item j.

Flexible Regression Priors: Because the above model is usually over-parametrized with a large number of latent factors, it is important to regularize the factors to prevent overfitting. A common practice is to shrink the factors to- ward zero. However, it fails to handle the cold-start problem because the predicted factor values of new users or items will  all be zero. A better approach is to shrink factors to values predicted based on features [2, 29]. Specifically, we put the following priors on ?i, ?j , ui and vj :  ?i ? N(g(xi), ? ?), ui ? N(G(xi), ?  uI),  ?j ? N(h(xj), ? ?), vj ? N(H(xj), ?  vI),  where g and h are any choices of regression functions that return scalars, and G and H are regression functions that return r-dimensional vectors. These regression functions can be linear as in [2] or non-linear (e.g., decision tree, forest, etc.) as in [29].

To better understand the usefulness of regression priors,  take ui for example. If user i is a new user, then ui is predicted by G(xi), where the regression function G is learned based on users who interacted with some items in the training data. Let G(xi) = (G1(xi), ..., Gr(xi)). One example of G is to use a regression tree Gk for each latent dimension k to predict the value of the kth dimension of a user?s latent profile based on his/her feature vector. If features are predictive, we would be able to make accurate click rate prediction for new users.



III. MODEL FITTING FOR BINARY DATA In this section, we describe several model fitting proce-  dures based on the Monte Carlo Expectation Maximization (MCEM) algorithm for datasets that can fit in a single machine. One major contribution of this paper is the model fitting procedure using adaptive rejection sampling method (ARS) in Section III-C.

A. The MCEM Algorithm Let ? = (f, g, h,G,H, ?2?, ?2u, ?2? , ?2v) be the set of prior  parameters (also referred to as hyper-parameters). Let ? = {?i, ?j , ui,vj}?i,j be the set of latent factors (also referred to as random-effects). Let y denote the set of observed binary response. For M users and N items, the complete data log-likelihood is given by  logL(?;?,y) = log Pr[y,?|?] = constant ?  ? ij log(1 + exp((1? 2yij)(f(xij) + ?i + ?j + u  ? ivj)))  ? 12?2?  ? i(?i ? g(xi))  2 ? M2 log ? ?  ? 1 2?2  ?  ? j(?j ? h(xj))  2 ? N2 log ? ?  ? 12?2u  ? i ||ui ?G(xi)||  2 ? Mr2 log ? u  ? 12?2v  ? j ?vj ?H(xj)?  2 ? Nr2 log ? v .

To apply the standard EM algorithm [12], we can treat ? as missing values and find the optimal estimate of ? that maximizes the marginal likelihood Pr[y|?] =? L(?;?,y) d?. The EM algorithm iterates between an  E-step and a M-step until convergence. Let ??(t) denote the current estimated value of ? at the beginning of the tth iteration.

? E-step: We take expectation of the complete data log likelihood with respect to the posterior distribu- tion of the latent factors ? conditional on observed data y and the current estimate of ?; i.e., compute     qt(?) = E?[logL(?;?,y) | ?? (t),y] as a function of  ?, where the expectation is taken over the posterior distribution of p(? | ??(t),y) and ??(t) is treated as a set of constants. The output of the E-step consists of a set of sufficient statistics to be used in the M-step.

? M-step: We maximize the expected complete data log likelihood from the E-step to obtain updated values of ?; i.e., find ??(t+1) = argmax? qt(?).

B. Variational Method in E-Step Since E?[logL(?;?,y) | ??(t)] is not available in closed  form, we compute the Monte-Carlo expectation based on L samples generated by a Gibbs sampler [13]. The Gibbs sampler repeats the following procedure L times. In the following, we use (? |Rest), where ? can be one of ?i, ?j , ui, and vj , to denote the conditional distribution of ? given all the other latent factors and the observations y. Let Ij denote the set of users who rated item j, and Ji denote the set of items rated by user i.

The variational approximation is based on [18] and was  proposed in [2] to factorize binary matrices. We note that there is a typo in the variational approximation formula in [2]. The variational method can be described as follows: Let ?ij be a parameter associated with each observed yij .

We can set all ?ij = 1 initially.

? Before each E-step, create pseudo Gaussian response for each binary observation yij ? {0, 1}. The pseudo Gaussian response is rij =  2yij?1 4?(?ij)  with variance ?2ij =  2?(?ij) , where ?(?) = 14? tanh  ( ?  ) .

? Run the E-step using Gaussian pseudo observations (rij , ?  ij) (using the E-step described in [29, 2] ).

? Run the M-step in Section III-D.

? After the M-step, for each yij , set ?ij = ?  E[s2ij ].

C. Adaptive Rejection Sampling in E-Step Although for binary data and logistic link function the  conditional posterior p(?i|Rest), p(?j |Rest), p(ui|Rest) and p(vj |Rest) are not in closed form, precise and efficient sampling from the posterior can still be achieved through adaptive rejection sampling (ARS) [15]. ARS is an efficient method to draw samples from an arbitrary univariate density provided it is log-concave. In our E-Step, we can draw a sample from the joint posterior distribution of? by drawing one number at a time sequentially from the univariate posterior distribution of each individual random effect given all the others using Gibbs sampling. We note that the univariate conditional posterior distributions p(.|Rest) are all log-concave; hence ARS can be applied.

In general, rejection sampling (RS) is a popular method  used to sample from a univariate distribution. Suppose we want to draw a sample from a non-standard distribution with density p(x). If one can find another density e(x) that is easier to sample from and approximates p(x) well and has tails heavier than p(x), then e(x) can be used to do rejection sampling. The key is to find a constant M such that p(x) ? Me(x) for all points x such that p(x) > 0. The algorithm then is simple: We repeat the following steps until we obtain  a valid sample. First we draw a number x? from e(x). Then with probability p(x  ?) Me(x?) , we accept x  ? as a valid sample; otherwise, we reject it.

We use the derivative-free ARS process from [15] which  can be briefly described as follows: Suppose we want to obtain a sample x? from a log-concave target density function p(x). We start from at least 3 initial points such that at least one point lies on each side of the mode of p(x) (this is ensured by looking at the derivative of the density, which does not require actual mode computation). A lower bound lower(x) of log p(x) is constructed from the chords joining the evaluated points of p(x) with the vertical lines at the extreme points. An upper bound upper(x) is also constructed by extending the chords to their intersection points. The envelope function e(x) (upper bound) and the squeezing function s(x) (lower bound) are created by exponentiating the piece-wise linear upper and lower bounds of log p(x); i.e., e(x) = exp(upper(x)) and s(x) = exp(lower(x)). Let e1(x) be the corresponding density function derived from e(x); i.e., e1(x) = e(x)? e(x)dx . The sampling produce works as follows: Repeat the following steps until we obtain a valid sample. a) Draw a number x? from e1(x) and another number z ? Unif(0, 1), independently. b) If z ? s(x  ?) e(x?) ,  accept x? as a valid sample. c) If z ? p(x ?)  e(x?) , accept x ?  as a valid sample; otherwise, reject x?. d) If x? is rejected, update e(x) and s(x) by constructing new chords using x?.

This goes on iteratively until one sample is accepted. Note  that using the squeezing function as the acceptance criteria implies partial information from the original density p(x); Testing x? based on the squeezing function first is to save computation since the squeezing function is readily available from the constructed envelope and evaluation of p(x?) is usually costly.

The ARS-based E-step works as follows: Repeat the  following steps L times to draw L samples of ?.

? Sample ?i from p(?i|Rest) for each user i using ARS.

The log of the target density is given by log p(?i|Rest) = constant ?  ? j?Ji  log(1 + exp((1? 2yij)(f(xij) + ?i + ?j + u ? ivj)))  ? 1 2?2?  (?i ? g(xi)) 2.

? Sample ?j for each item j (similar to above).

? Sample ui from p(ui|Rest) for each user i. Since ui is an r-dimensional vector, for each k = 1, ? ? ? , r we sample uik from p(uik|Rest) using ARS. The log of the target density is given by  log p(uik|Rest) = constant ?  ? j?Ji  log(1 + exp((1? 2yij)(f(xij) + ?i + ?j  + uikvjk + ?  l ?=k  uilvjl)))?  2?2u (uik ?Gk(xi))  .

? Sample vj for each item j (similar to above).

Initial points for ARS: The rejection rate of ARS depends on the initial points and the target density function. To reduce the rejection rate, Gilks et al. [16] suggest using the     envelope function from the previous iteration of the Gibbs sampler to construct 5th, 50th and 95th percentiles as the 3 starting points. We adopted this approach and observed roughly 60% reduction in rejection rates.

Centering:We note that the model proposed in Section II is not identifiable. For example, if we let f?(xij) = f(xij)? ? and g?(xi) = g(xi)+?, the model using f? and g? is essentially the same as the one using f and g. To help identify the model parameters, we put constraints on the factor values.

Specifically, we require  ? i ?i = 0,  ? j ?j = 0,  ? i ui =  0 and ?  j vj = 0. These constraints induce dependencies among user factors and item factors. Instead of dealing with these dependencies in sampling, we simply enforce these constraints after sampling by subtracting the sample mean; i.e., after sampling all factors, compute ?? =  ? i ??i/M and  set ??i = ??i? ?? for all i, and so on. Here, M is the number of users and ??i is the posterior sample mean of ?i.

D. M-Step In the M-step, we find the parameter setting ? that  maximizes the expectation computed in the E-step  qt(?) = E?[logL(?;?,y) | ?? (t)].

It can be easily seen that (f, ?2), (g, ?2?), (h, ?2?), (G, ?2u), and (H,?2v) can be optimized by separate regressions. Here we simply describe how to estimate (G, ?2u) since everything else is quite similar. Let u?ik and V? [uik] denote the posterior sample mean and variance of uik computed based on the L Gibbs samples obtained in the E-step. It is easy to see that  argmax G  qt(?) = argmax G  ? i  ||u?i ?G(xi)|| 2.

Note thatG is part of?, and finding the optimalG is solving a least squares regression problem using xi as features to predict multivariate response u?i. For univariate regression models, we consider G(xi) = (G1(xi), ..., Gr(xi)), where each Gk(xi) returns a scalar. In this case, for each k, we find Gk by solving a regression problem that uses xi as features to predict u?ik. Let RSS denote the total residual sum of squares. Then, ?2u = (  ? ik V? [uik] + RSS)/(rM), which is  obtained by setting the derivative of qt(?) with respect to ?2u to zero.

We note that obtaining the optimal f (i.e.,  argmaxf qt(?)) is actually difficult because of the expectation of the log of some combination of factors.

Thus, we use plug-in estimates; i.e., solve a logistic regression problem that uses xij as features to predict yij with offset ??i + ??j + u??iv?j .



IV. PARALLELIZED MODEL FITTING FOR LARGE DATA In this section, we consider fitting algorithms for large  data sets that reside in distributed clusters and cannot fit into memory of a single machine. For such scenarios, fitting algorithms described in Section III do not work. We provide a fitting strategy in a the Map-Reduce framework. We first apply the ?divide and conquer? approach to partition the data into small partitions (mapper), and then run MCEM on  each partition to obtain estimates of ? (reducer). The final estimate of ? are obtained by averaging over estimates of ? from all the partitions. Finally, given ? fixed, we do n ensemble runs, i.e. re-partition the data n times using different random seeds, and for each re-partitioning we only run E-Step jobs on all partitions and then average the results from them to obtain the final estimate of ?. This algorithm is described in Algorithm IV.

Algorithm 1 Parallel Matrix Factorization Initialize ? and ?.

Partition data into m partitions using random seed s0.

for each partition ? ? {1, ...,m} running in parallel do Run MCEM algorithm forK number of iterations using VAR or ARS to obtain ???, the estimates of ? for each partition ?.

end for Let ?? = 1  m  m? ?=1  ???.

for k = 1 to n running in parallel do Partition data into m partitions using random seed sk.

for each partition ? ? {1, ...,m} running in parallel do Run E-Step-Only job given ?? and obtain the pos- terior sample mean ??k? for all users and items in partition ?.

end for end for For each user i, average over all ??k? that contain user i to obtain ??i and u?i.

For each item j, average over all ??k? that contain item j to obtain ??i and v?i.

Partitioning the data: Extensive experiments conducted by us showed that model performance depends crucially on data partitioning strategy used in the Map-Reduce phase, especially when data is sparse. A naive way of randomly partitioning observations may not give good predictive ac- curacy. For applications such as content optimization [4], the number of users are often much larger than the number of items. Also, the number of observations available per user is small for a large fraction of users; a typical item tends to have a relatively larger sample size. In such cases, we recommend partitioning the data by users, which guarantees that all data from a user belongs to the same partition, so that good user factors can be obtained. Similarly, when the number of items is larger than the number of users, we recommend partitioning the data by items. An intuitive ex- planation of this can be gleaned by looking at the conditional variance of user factor ui using variational approximation given as Var[ui|Rest] = ( 1?2u I +  ? j?Ji  vjv ?  j  ?2ij )?1. Assuming  item factors are known for the moment (or estimated with high precision), if the user data is split into several partitions, the average information gain (inverse variance) from the partitioned data is the harmonic mean of information gain from individual partitions. The information gain from the non-partitioned data can be written as the arithmetic mean     of the individual information gains. Since harmonic mean is less than arithmetic mean, information loss in estimating user factor by partitioning is the difference in arithmetic and harmonic means. When the information in partitions becomes weak, this gap increases. Hence, with sparse user data, it is prudent to partition by users.

Estimates of ?: We note the ? estimate obtained from each random partition is unbiased, fitting a model on each partition and then averaging the M-step parameters ??? for ? = 1, ? ? ? ,m provides an estimate that is still unbiased and has lower variance due to lack of positive correlations among estimates. The correlations are absent due to the random partitioning. Before running the MCEM algorithm, the initial values of ? for all partitions are the same. In particular, we start with zero mean priors; i.e., g(xi) = h(xj) = 0 and G(xi) = H(xj) = 0. To improve parameter estimation, one may synchronize the parameters among partitions and run another round of MCEM iterations; i.e., one may re- partition the data and use the obtained ?? as the initial values of ? to run another round of MCEM iterations for each partition to obtain a new estimate of ?. However, we observe in practice that iteratively running this process does not give significantly better predictive accuracy, but instead adds complexity and training time.

Estimates of?: For each run in the ensemble, it is essential to use a different random seed for partitioning the data, so that the mix of users and items in partitions across different runs would be different. Given ??, for each run in the ensemble, we only need to run E-step once for each partition and obtain the final user and item factors by taking the average. Like in the case of?, running full MCEM again instead of just the E-step does not significantly improve predictive accuracy. Again, the random partitioning ensures uncorrelated estimates from members of the ensemble and leads to variance reduction through averaging.

More identifiability issues: After centering the model is in fact still non-identifiable because of two reasons: (a). Since u?ivj = (?ui)  ?(?vj), switching signs of u and v (also the corresponding cold-start parameters) does not change the log-likelihood. (b). For two factors uik, vjk and uil, vjl, switching uik with uil, vjk with vjl simultaneously also would not change the log-likelihood, given that the corresponding cold-start parameters are also switched. We have found empirically that both of the identifiability is- sues do not matter for small data sets, especially single- machine runs. However, for large data sets such as the Yahoo! frontpage data and G, H defined as linear regression function, we observe that for each partition after the MCEM step we obtain significantly different fitted values of G and H , so that after averaging over all the partitions the resulting coefficient matrices for G and H become almost zero. Hence the identifiability issue can become severe while fitting parallelized matrix factorization for large data sets.

Solution to the identifiability issues: For (a), we put positive constraints on the item factor v. This can be done through simply putting a sampling lower bound (i.e. always sample positive numbers) in ARS. Note that after using  this approach we do not need to do centering on v any more. For (b), we first let ?2v = 1 and change the prior of ui from N(G(xi), ?2uI) to N(G(xi),?u), where ?u is a diagonal variance matrix with diagonal values ?u1 ? ?u2 ? ? ? ? ? ?ur. The model fitting is very similar, except after each M-step we re-sort all the factors by the fitted ?uk?s for k = 1, ? ? ? , r to satisfy the constraint.



V. RELATED WORK Our work extends the rich literature on factorization  models to provide a better model fitting strategy with rare binary response that is commonplace in web applications.

We also provide a new model fitting strategy to scale these methods to massive datasets using Map-Reduce.

Matrix factorization is well known to provide state-of-the-  art performance for recommender problems. A theoretical perspective of this problem was first provided in [27]. Bell et al. and others [6, 1] have successfully used this strategy in collaborative filtering applications such as the Netflix challenge. Salakhutdinov and Mnih [24, 25] formulate a probabilistic framework using a hierarchical random-effects model where the user and item factors are multivariate random-effects (factor vectors) that were regularized through zero-mean multivariate Gaussian priors. These studies seek to solve pure collaborative filtering problems; they do not work well in applications with significant cold-starts which is commonplace in several applications.

To solve the cold-start problem, several methods that  combine content and collaborative filtering have been stud- ied. For instance, Balabanovic and Shoham [5] present a recommender system that computes user similarities based on content-based profiles. In [10], collaborative filtering and content-based filtering are combined linearly with weights adjusted based on absolute errors of the models. In [21], content-based models are used to fill up the rating matrix followed by recommendation based on similarity (memory) based methods [7]. In [17] and [23], filterbots are used to improve cold-start recommendations. Schein et al. [26] ex- tend the aspect model to combine the item content with user ratings under a single probabilistic framework. In [2, 28], a principled solution is proposed by treating user and item factors as random effects and using linear model regression priors on the user and item factors through features. This is generalized in [29] so that the regression priors can be non-linear functions which further improves accuracy.

To scale matrix factorization, stochastic gradient descent  (SGD) is popular [19]. To handle large data sets using Map-Reduce, Zinkevich et al. [30] propose a parallelized SGD with the simple ?divide and conquer? idea and a rigorous convergence proof. Gemulla et al. [14] propose a parallelized SGD algorithm for matrix factorization that can scale up to millions of rows and columns. However, these model fitting algorithms usually consider only the observed response but not user/item features for ?cold-start? problems.

We provide a solution that can scale factorization methods which use both response and features in a Map-Reduce framework using a Gibbs sampling approach. DeCoste [11] also uses ensemble methods to improve maximum margin matrix factorization methods. However, the ensembles are trained by initializing the factors at different values, our     ensemble approach is used to partition the data and improve estimates of factors.



VI. EXPERIMENTS We evaluate the proposed methods to address two main  questions: (1) How do different techniques for handling binary response compare? (2) How do different methods perform in a real, large-scale Web recommender system?

For the first question, we compare variational approximation, adaptive rejection sampling and stochastic gradient descent on balanced and imbalanced binary datasets created from the public MovieLens 1M dataset. For the second question, we first evaluate the predictive performance using a small sample of heavy users of the Today module on the Yahoo!

front page to allow comparison in the single-machine fitting scenario, and then provide complete end-to-end evaluation in terms of click-lift through a recently proposed unbiased offline evaluation method [20] (which was shown to be able to approximate the online performance) based on massive imbalanced data collected from the Today module.

Methods:We consider the following different models/fitting methods, all used with 10 factors per user/item throughout the experiments: FEAT-ONLY is the feature-only factor- ization model which serves as our baseline. Specifically, the model is sij = f(xij)+g(xi)+h(xj)+G(xi)?H(xj), where g, h, G and H are unknown regression functions, fitted by the standard conjugate gradient descent method on each partition and averaging over estimates from all partitions to obtain estimates of g, h, G and H; no ensemble run is needed. MCEM-VAR is our matrix factorization model fitted by variational approximation in the MCEM algorithm.

MCEM-ARS is our matrix factorization model fitted by centered adaptive rejection sampling algorithm in each E- step of the MCEM algorithm.MCEM-ARSID is our matrix factorization model fitted by centered adaptive rejection sampling algorithm in each E-step of the MCEM algorithm, incorporating positive constraints on the item factor v and ordered diagonal prior covariance matrix of u (see Section IV for more details). Note that FEAT-ONLY , MCEM-VAR , MCEM-ARS and MCEM-ARSID use linear regression functions for g, h, G and H . SGD is a method that fits a similar factorization model using stochastic gradient descent.

We obtained the code from [9]. Specifically, the model is sij = (?i + ui + Uxi)  ?(?j + vj + V xj), where U and V are unknown coefficient matrices for cold-start to map the feature vectors xi and xj into the r-dimensional latent space. For binary response with logistic link function, it minimizes the following loss function ?  ij  yij log(1 + exp(?sij)) + ?  ij  (1? yij) log(1 + exp(sij))  +?u ?  i  ?ui? 2 + ?v  ?  j  ?vj? 2 + ?U?U?  2 + ?V ?V ? ,  where ?u, ?v, ?U and ?V are tuning parameters, and ?U? and ?V ? are Frobenius norms. Since this code has not been parallelized, we only use it in experiments on small datasets. Trying different tuning parameter values can be computationally expensive. In the experiments, we set ?u = ?v = ?U = ?V = ? with ? varying from 0, 10?6, 10?5, 10?4 and 10?3. We also tuned the learning rate by trying 10?5, 10?4, 10?3, 10?2 and 10?1.

Table I AUC OF METHODS ON THE IMBALANCED AND BALANCED MOVIELENS DATASETS (#PARTITIONS= 1 INDICATES SINGLE-MACHINE RUNS)  AUC Method # Partitions Imbalanced Balanced SGD 1 0.8090 0.7413  MCEM-VAR 1 0.8138 0.7576 MCEM-ARS 1 0.8195 0.7563  2 0.7614 0.7599 MCEM-VAR 5 0.7191 0.7538  15 0.6584 0.7421 2 0.8194 0.7622  MCEM-ARS 5 0.7971 0.7597 15 0.7775 0.7493  A. MovieLens 1M Data We first compare three techniques for fitting binary re-  sponse (MCEM-VAR , MCEM-ARS and SGD) on the benchmark MovieLens 1M dataset.

Data: We create training-test split based on the timestamps of the ratings; the first 75% of ratings serve as training data and the rest 25% as test data. This split introduces many new users (i.e. cold-start) in test data. To study how different techniques handle binary response with different degree of sparsity of the positive response, we consider two different ways of creating binary response: (1) An imbalanced dataset is created by setting the response value to 1 if and only if the original 5-point rating value is 1; otherwise it is set to 0.

The percentage of positive response in this dataset is around 5%. (2) A balanced dataset is created by setting the response to 1 if the original rating is 1, 2, or 3; otherwise it is set to 0. The percentage of positive response in this dataset is around 44%. We report the predictive performance of SGD, MCEM-VAR and MCEM-ARS in terms of the Area Under the ROC Curve (AUC) for both datasets in Table I.

Comparison between MCEM-ARS and MCEM-VAR : As can be seen from the Table I, MCEM-ARS and MCEM- VAR have similar performance and both slightly outperform SGD when running on a single machine (i.e., #partitions = 1). It is interesting that when running on multiple machines with 2 to 15 partitions, MCEM-ARS and MCEM-VAR still have similar performance on the balanced dataset, while on the imbalanced dataset MCEM-VAR becomes much worse when the number of partitions increases (causing more severe data sparsity). We note that the degradation of performance as the number of partitions increases is expected due to the increase of data sparsity.

Comparison with SGD: Since SGD is a popular fitting method for matrix factorization [19], we also discuss how our sampling-based methods compare to SGD. To obtain good performance for SGD, one has to try a large number of different values of the tuning parameters and learning rates, while our methods does not need such tuning be- cause all the hyper-parameters are obtained through the EM algorithm. Trying different tuning parameter values can be computationally expensive, and it is less efficient in exploring the parameter space compared to EM. After our best-effort tuning using the test data, for imbalanced data, SGD achieves best performance 0.8090 with ? = 10?3 and learning rate = 10?2. For balanced data, SGD achieves     Table II AUC OF DIFFERENT METHODS ON THE SMALL YAHOO! FRONT PAGE DATASET (#PARTITIONS= 1 INDICATES SINGLE-MACHINE RUNS)  Method # Partitions Partition Method AUC FEAT-ONLY 1 ? 0.6781  SGD 1 ? 0.7252 MCEM-VAR 1 ? 0.7374 MCEM-ARS 1 ? 0.7364 MCEM-ARSID 1 ? 0.7283  2 User 0.7280 MCEM-ARS 5 User 0.7227  15 User 0.7178 2 User 0.7294 5 User 0.7172  MCEM-ARSID 15 User 0.7133 15 Event 0.6924 15 Item 0.6917  best performance 0.7413 with ? = 10?6 and learning rate = 10?3. Even tuning SGD on test data, the best AUC numbers of SGD on both balanced and imbalanced datasets are still slightly worse than the those of MCEM-VAR and MCEM-ARS (which did not touch test data before testing).

B. Small Yahoo! Front Page Data We now evaluate different methods on a previously ana-  lyzed Yahoo! front page dataset [2], which allows compari- son of these methods to prior work. The data comes from the Today module, which displays article links on four positions labeled as F1 through F4, where F1 has a large, prime area.

Data: This dataset consists of 1.9M binary response values obtained from about 30K heavy users interacting with 4,316 news stories published in the Today module on the Yahoo!

front page. The observations were sorted by their timestamps and the first 75% of them are used as training data and the rest 25% as test data. The set of user features include age, gender, geo-location and browsing behavior that is inferred based on users? network-wide activity (e.g. search, ad-clicks, page views, subscriptions etc.) Since the original set of user features is large, dimension reduction was done through principal component analysis [2], and finally we obtained around 100 numerical user features. Item features consist of 43 hand-labeled editorial categories. Because of a special way of interpreting positive and negative events (see [2] for details), the percentage of positive response is close to 50% ? it is a balanced data set.

Single-machine results: We first discuss the AUC per- formance for FEAT-ONLY , MCEM-VAR , MCEM-ARS and MCEM-ARSID running on a single machine (i.e. 1 partition), shown in Table II. We observe that MCEM-VAR , MCEM-ARS , MCEM-ARSID and SGD all outperform FEAT-ONLY significantly. This is because these models allow warm-start user factors (those users having data in the training period) to deviate from purely feature-based predictions, in order to better fit the data. On the other hand, since the test data consists of many new users and new items, handling cold-start scenarios is still important. It has been shown in [2] that, for this data set, MCEM-VAR significantly improves upon matrix factorization models that use zero mean priors for factors, which is commonly applied in many recommender system problems such as Netflix, and MCEM-  VAR also significantly outperformed various other collab- orative filtering algorithms. We note that the performance of MCEM-VAR , MCEM-ARS and MCEM-ARSID are all close. This suggests that for balanced datasets, different fitting methods for logistic models are similar. We also note that MCEM-ARSID perform slightly worse than MCEM- ARS , because adding constraints on the item factors v reduces the flexibility of MCEM-ARSID . We defer the discussion on when MCEM-ARSID can provide significant benefit to Section VI-C.

Comparison with SGD: Similar to what we see in Sec- tion VI-A, even with SGD tuned on test data, the best AUC 0.7252 (? = 10?6 and learning rate = 10?3) is still slightly worse than the AUC of MCEM-VAR , MCEM-ARS and MCEM-ARSID for single machine runs.

Number of partitions: In Table II for MCEM-ARS and MCEM-ARSID (10 ensemble runs for both), as the number of partitions grows, we observe the expected degradation of performance because, with more partitions, each parti- tion would have less data, which usually leads to a less accurate model for the partition. However, even with 15 partitions on such a small data set MCEM-ARS and MCEM- ARSID (user-based partitioning) still significantly outper- forms FEAT-ONLY .

Different partition methods: In Table II we also show the performance of our parallel algorithm MCEM-ARSID (10 ensemble runs) with different numbers of partitions and various partition methods. As mentioned in Section IV, we note that partitioning the data by users is better than event- based or item-based partitioning in our application, because user partitions are less sparse since there are generally more users than items in the data.

C. Large Yahoo! Front Page Data In this subsection we show the performance of our parallel  algorithms on a large Yahoo! front page dataset where single-machine algorithms are not feasible. An unbiased evaluation method is used to estimate the expected click- lifts if these algorithms were used in the production system.

Data: The training data was collected from the Today module on Yahoo! front page during June 2011, while the test events were collected during July 2011. The training data includes all page views by users with at least 10 clicks in the Today module, and consists of 8M users, ?4.3K items and 1 billion binary observations. To remove selection bias in evaluating our algorithms, the test data is collected from a randomly chosen user population where, for each user visit, an article is selected at random from the content pool and displayed at the F1 position. We shall refer to this as random bucket, which consists of 2.4M clicks with both cold-start and warm-start users.

Each user is associated with 124 behavior features that  reflect various kinds of user activities on the entire Yahoo!

network. Each item is associated with 43 editorial hand- labeled categories. A click on an F1 article link is a positive response, while a view of an F1 article link without a subsequent click is a negative response. The percentage of positive response here is much lower than that of the small     dataset ? the increased sparsity and imbalance introduces additional challenges.

Experimental setup: Because article lifetimes in the Today module are short (6-24 hours), almost all items in the test period are new. To provide good performance for new items, one may frequently retrain factorization models in the test period. However, frequent retraining is not feasible due to the data size. A viable solution is to train an online logistic regression (OLR) model for each item and update the model in an online batched fashion as described in [3], where the OLR model utilized user features to predict different users? click rate on the item. Thus, in this set of experiments, we consider to use the trained user factors to improve over the existing 124 behavior user features. More precisely, let xit denote the existing behavior feature vectors of user u at time t and uit denote the user factor vector produced by a factorization method. For each article j, we fit an OLR model with log-odds x  ?  it?jt + u ?  it?jt, the unknown parameters (?jt, ?jt) are updated online after each epoch as we collect more data on each item. The OLR models also have a prior (?j0, ?j0) ? MVN(0, ?2I). Notice that different factorization methods generate different uits. The performance of a method is based on click-lift of the item recommendations ranked by the OLR models using the uits.

Unbiased Evaluation: The goal of this set of experiments is to maximize total clicks. The precision@1 metric computed on the random bucket test set was shown to provide an unbiased measure of an algorithm?s performance when it is actually implemented in production [20]. We provide a brief description of the evaluation metric here: For an epoch t (5-minute interval), we first compute the predicted CTR of all articles in the pool for each event in epoch t under the model. The estimates can use all data before epoch t. For each event in t, we select the article j? from the current pool with the highest predicted probability. If the article that was actually served in the logged data matches j?, we record this matched event; otherwise, we ignore it.

At the end, we compute CTR metrics based on the  recorded events and these estimates are unbiased [20].

Because each article in the random bucket has an equal probability to be displayed to users, the number of matched view events for any model is expected to be the same. A better model to optimize CTR can match more click events.

We thus can compute the overall CTR from these matched events and use these metrics to compare different models.

For large amounts of data as in our case, the variance in overall CTR metrics for matched events have little variance; all differences reported in our experiments have small p- values and are statistically significant due to large sample size in the test data.

Two baseline methods:. To show that factor-based user features provide state-of-the-art performance to personalize content on Yahoo! front page, we compare with two baseline methods of generating user features based on users? past interaction on the front page: ITEM-PROFILE: Using training data we pick top 1000  items with highest number of views. We construct 1000- dimensional binary user features to indicate whether in  Table III THE OVERALL CLICK LIFT OVER THE USER BEHAVIOR FEATURE (BT)  ONLY MODEL.

Method #Ensembled Overall Warm Cold  Runs Start Start ITEM-PROFILE ? 3.0% 14.1% -1.6%  CATEGORY-PROFILE ? 6.0% 20.0% 0.3% MCEM-VAR 10 5.6% 18.7% 0.2% MCEM-ARS 10 7.4% 26.8% -0.5% MCEM-ARSID 1 9.1% 24.6% 2.8% MCEM-ARSID 10 9.7% 26.3% 2.9%  training this user has clicked on this item (1 is clicked and 0 is non-clicked). For cold-start users who did not show up in training, we simply let the binary profile vector be all 0.

CATEGORY-PROFILE: Since each item has 43 binary  feature indicating content categories to which it belongs, we build user-category preference profiles through the fol- lowing approach: For user i and category k, denote the number of observed views as vik and number of clicks as cik. From the training data we can obtain the global per-category CTR, denoted as ?k. We then model cik as cik ? Poisson(vik?k?ik), where ?ik is the unknown user- category preference parameter. We assume ?ik has a Gamma prior Gamma(a, a), hence the posterior of ?ik becomes (?ik|vik, cik) ? Gamma(cik + a, vik?k + a). We use the log of the posterior mean, i.e. log( cik+a  vik?k+a ) as the profile  feature value for user i on category k. Note that if we do not observe any data for user i and category k, the feature becomes 0. a is a prior sample size parameter and can be obtained through cross-validation. By trying a =1, 5, 10, 15 and 20, we have found that a = 10 is optimal.

Experimental Results: We evaluate all methods by re- porting click-lift obtained through the unbiased evaluation method relative to an online logistic model that only uses behavioral (BT) features xit; such a model does not incor- porate users? past interaction with items ? its performance on heavy users has large room for improvement. In Table III, we summarize the overall lift, warm start lifts (users seen in the training set), and cold-start lifts (new users). All models produce lifts but the performance of MCEM-ARSID is the best for overall and cold-starts, and MCEM-ARS is the best for warm-starts. The reason that we see no lift for cold- start users on MCEM-ARS is because of the identifiability issues addressed in Section IV. Although imposing positive constraints on the item factors leads MCEM-ARSID to have slightly inferior performance than MCEM-ARS , it solves the identifiability issues quite well and hence gives the best performance for the cold-start users. It is also interesting to see that MCEM-VAR is worse than CATEGORY-PROFILE, especially for warm-starts. We also observe that using the ensemble trick improves results as evident from comparing MCEM-ARSID with 1 and 10 ensemble runs.

To further investigate the performance of algorithms in  different kinds of warm-starts based on user activity on Today Module in training period, we look at click-lifts by Today Module activity levels in Figure 1. We split the users in the test data into several segments by their number of clicks in the training data. As expected, we see a monotone trend; users with more activity are personalized better by using their prior Today Module activity data. From Figure     Figure 1. The click lift over the user behavior feature (BT) only model for different user segments. The segments are created from the number of clicks in the training data.

1 we observe that MCEM-ARSID is uniformly better than CATEGORY-PROFILE and ITEM-PROFILE over all the user segments. Comparing performance of MCEM-ARSID, MCEM-ARS and MCEM-VAR we find the MCEM-VAR to be quite inferior to MCEM-ARS and MCEM-ARSID.

Potential issue with variational approximation: To in- vestigate issues with MCEM-VAR with data sparsity, we examined the factor estimates of the fitted ui and vj after 30 EM iterations for MCEM-VAR and MCEM-ARS , both with 10 factors and 100 partitions. While the fitted user factors for both MCEM-VAR and MCEM-ARS are in the similar scale, the item factors produced by MCEM-VAR is approximately one order of magnitude smaller than those produced by MCEM-ARS . This phenomenon is surprising and shows that MCEM-VAR tends to over-shrink the factor estimates when fitting rare response. This explains why the performance of MCEM-VAR deteriorates as the binary re- sponse gets rare. It seems that the variational approximation leads to too much shrinkage for rare response.



VII. CONCLUSION In this paper, we introduced the adaptive rejection sam-  pling (ARS) to our probabilistic matrix factorization frame- work to better fit data with binary response, which is quite common in web applications such as content optimization and computational advertising. We also extended our model fitting methods to handle large data sets using Map-Reduce.

By extensive experiments on benchmark datasets and the Yahoo! FrontPage Today Module data sets, we show that our model and fitting algorithms are stable and can significantly outperform variational approximation proposed by [2, 29] and several other baselines.

