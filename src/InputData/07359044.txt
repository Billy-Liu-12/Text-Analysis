Vertical Association Rule Mining:   Case Study Implementation with Relational DBMS

Abstract? Data mining remains as one of the most important research domain in Knowledge Discovery and Database (KDD).

Moving deeper, Association Rule Mining (ARM) is one of the most prominent areas in detecting pattern analysis especially for crucial business decision making. It aims to extract interesting correlations, frequent patterns, association or casual structures among set of items in the transaction databases or other data repositories. Even though most of these data repositories are dealing with flat files, current trend is focusing on using relational Database Management System (DBMS) for the more systematic and structured management of data. In response to the importance of adopting relational database, in this paper we implement MySQL (My Structured Query Language) as our association rule mining database engine in testing benchmark dense datasets which available from Frequent Itemset Mining (FIMI) online repository. Our study is focusing on Eclat algorithm as well as its variants in generating frequent and interesting rule, as a continual from our previous studies. The performance result shows a promising signal as to confirm on the benefits of relational database mechanism in storing any transaction data.

Keywords- Association Rule Mining; relational database; MySQL; Frequent itemset; Eclat algorithm; association rule (AR)

I. INTRODUCTION  Association rules mining still remains as one of the important and advanced techniques in data mining. The main objectives of association rules mining are to find the correlations, associations or casual structures among sets of items in the data repository. After almost a decade, most of today?s mining techniques are based on flat file mining by which little interactions between mining engine and database.

Most of the algorithms deployed today typically based on in- memory data structures where data is stored into and retrieved from flat files [7,9]. However, to cater for big data issues, current trend is more focusing on relational database where the issues of huge and massive data will be able to manage in a systematic and structured mechanism. The integration of data mining with database systems is an emergent trend, maybe due to the following reasons:  a) Explosion of data - results in the increase of massive amount of data in database such as Data Warehouse and federated database  b) Database capability - which provides powerful mechanisms especially in the issues of indexing, accessing, filtering and handling of data duplication  c) Structured Query Language (SQL) capability - which support ad-hoc mining operation by allowing the mining of arbitrary query results from multiple abstract layers of database system.

The previous researches have mainly focused on language  proposal to extend SQL support such as in [1,2,3,4,7]. The need for fast discovery of association rule and a tightly couple relationships between association rule and database system have been discussed and presented in [5,6]. Further issues of database mining in depth first searching is discovered by the Propad algorithms [8] and also an alternative approach using data access methods and programming techniques for the efficiency of mining the data is studied in [9]. A frequent itemset mining based on FP-Growth, called DBFP-Growth is presented in [10] that use ORACLE PL/SQL which perform faster than using SQL directly. In this paper we will focus on the implementation of depth first intersection searching and vertical database representation layout in our chosen relational DBMS (RDBMS), MySQL in generating frequent and interesting itemsets based on Eclat and Eclat-variants algorithms [12,14,15,17].

The rest of the paper is organized as follows. Section 2 describes the related works of integrating association rule mining with database. Section 3 explains the theoretical background. Section 4 outlines on data representation layouts and its merits. This is followed by Eclat and Eclat-variants algorithm in section 5. Finally, conclusion and future direction is reported in section 6.

2015 International Symposium on Technology Management and Emerging Technologies (ISTMET), August 25 - 27, 2015, Langkawi, Kedah, Malaysia

II. RELATED WORKS  The language called Data Mining Query Language (DMQL) [1] is a mining query language designed in DBMiner project to support most of the common mining tasks. It consists of specifications of four main primitives, which include the subset of data relevant to the mining query, the type of task to be performed, background knowledge, and as well as constraints or ?interestingness? measures. The MSQL [2], a rule query language is an extension of SQL to generate and selectively retrieve sets of rules from a large database.

Data and rules are treated uniformly, allowing various optimizations to be performed; one could manipulate generated rules or one could perform selective, query-based rule generation. The MINE RULE SQL operator [3] extends the semantics of association rules with the extension of relational algebra, allowing more generalized queries to be performed.

The Query Flocks [4] uses a generate-and-test model of  data mining; it extends the Apriori [5] technique of association mining to solve more general mining queries. In [6], a tight- coupling of association rule mining with database is studied where it uses user-defined functions to push parts of computation inside the database system. Then, a comprehensive study of several architectural alternatives for database and mining integration is studied in [7] especially in the context of association mining which include loose- coupling through SQL cursor, encapsulating mining algorithm in a stored-procedure, caching data on a file system on-the-fly before mining, using user-defined functions for mining and then the SQL implementation. They studied four (4) approaches using SQL-92 and another six (6) in SQL-OR (SQL with object relational extensions). Here, they experimentally concluded that Cache-Mine approach, which is an enhanced version of the flat-file Apriori method is superior, while SQL-OR approaches come within a factor of two. The SQL-92 approaches were not competitive with the alternatives.

Since the focus on the vertical database performance, a  systematic comparison of the performance of horizontal and vertical ARM approaches utilizing flat file and a range of indexed databases is presented by [8]. In this study, the measurement of run time as a function of database and minimum support threshold is analyzed. Also, it explores techniques for determining what kinds of data benefits from pruning and when pruning is likely to benefit. The Propad (Projection Pattern Discovery) is introduced in [9], is an algorithm for finding frequent patterns from transaction table.

It is fundamentally projects the transaction table into frequent itemsets to avoid making multiple passes over the large original transaction table while generating a huge sets of candidates. The performance evaluation is made on IBM DB2 and experimental result shows the proposed method can get and efficient performance.

Subsequent work by [10] is done where a new implementation with FP-Growth approach called DBFP- Growth is introduced to create disk-based FP-Tree based on ORACLE/PL/SQL. This approach can execute faster if compared to using SQL directly. Also, an SQL-based method called DRRW can remove duplicate records from database without temp table generation.



III. THEORETICAL BACKGROUND  Following is the formal definition of the problem defined in [11]. Let I = {i1, i2,?im} for |m| > 0 be the set of items. D is a database of transactions where each transaction has a unique identifier called tid. Each transaction T is a set of items such that ? ? ?. An association rule is an implication of the form ? ? ? where X represent the antecedent part of the rule and Y represents the consequent part of the rule where ? ? ?, ? ? ? and  ? ? ? =  ?. A set ? ? ? is called an itemset. An itemset with k-items is called a k-itemset. The itemset that satisfies minimum support is called frequent itemset. The rule ? ? ? holds in the transaction set D with confidence c if c% of transactions in D that contain X also contain Y. The rule ? ? ? has support s in the transaction set D if s% of transaction in D contains ? ? ?.  Illustration of support-confidence framework is given as below:   The support of rule ? ? ? is the fraction of transactions in D containing both X and Y.

??????? (? ? ?) = ? ? ?  |?|   where |D|is the total number of records in database  The confidence of rule ? ? ? is the fraction of transactions in D containing X that also contain Y.

?????????? (? ? ?) = ???? (? ? ?)  ???? (?)    A rule is frequent if its support is greater than minimum  support (min_supp) threshold. The rules which satisfy minimum confidence (min_conf) threshold is called strong rule and both min_supp and min_conf are user specified values [12]. An association rule is considered interesting if it satisfies both min_supp and min_conf thresholds [13].



IV. DATA REPRESENTATION FORMAT  A. Vertical and Depth First Search (DFS)  Vertical layout or depth first search (DFS) appears to be more natural and efficient choices for achieving fast association rule mining results. Previous outstanding researches performed by [11,12,14,15,16] demonstrates how vertical database layout has major advantages over horizontal database layout. Firstly, computing supports of itemsets is much simpler and faster since it involves only intersections of tids and the number of tids automatically indicates the support. In contrast, a complex hash-tree data structures and functions are required for horizontal layouts [11,20]. Secondly, an automatic ?reduction? of the database before each scans where only those relevant     itemsets to the following scan of the mining process are accessed from disk.

B. Database and Searching Strategy  Database representation format plays a vital role in determining the efficiency of searching strategy of the frequent items. Either with horizontal data format or vertical data format, one must take into account on the search space strategy employment regardless the database condition of whether it is sparse database or dense database. Apriori-inspired algorithms [14] perform well with sparse datasets when the longevity of frequent patterns are short. However, when the longevity of frequent patterns are long with dense datasets such as bioinformatics and telecommunication, the performance degrades drastically due to many passes over the database that automatically incurs I/O overheads and it is computationally expensive in checking large sets of candidates by pattern matching. For m items, there could imply 2m ? 2 additional frequent patterns that will explicitly examined by each algorithms. It is important to generate as few candidates as possible since computing the supports is time consuming [14].

As the best case, only frequent itemsets are generated and counted, unfortunately, the idea is impossible in general.

In the horizontal layout, each transaction ??  is represented  as ??: (???, ?) where ??? is the transaction identifier and ? is an itemset containing items occurring in the transaction.  The initial transaction consists of all transactions ?? .

In the vertical layout, each item ??  in the item base ?  is represented as ??: {??, ?(??)}  and the initial transaction database consists of all items in the item base. For both layouts, it is possible to use the bit format to encode tids and also a combination of both layouts can be used [15,16]. Fig. 1 below illustrates example of horizontal and vertical layout of data representation by [15].

Figure 1. Transformation from horizontal to vertical layout   In fig. 1, the items in B consist of {a,b,c,d,e} and  each  itemsets are allocated with unique identifiers (tids) for each transactions. This is clearly visualized in horizontal format. To switch to vertical format, every items {a,b,c,d,e} are then organized where all items are allocated with their corresponding tids. When this is done, it is clearly visualized the support of each items through the counting number of every item?s tids.



V. EXPERIMENTATION  A. Database Platform  All experiments are performed on a dell N5050, Intel ? Pentium ? CPU B960 @ 2.20 GHz with 2GB RAM in a Win 7 64-bit platform. The software specification used is MySQL version 5.5.27 ? MySQL community server (GPL) for our database server, Apache/2.4.3 (Win32) OpenSSL/1.0.1c PHP/5.4.7 for our web server and phpMyAdmin with version 3.5.2.2. For the kick-off experimentation, we start with simple synthetic dataset. In addition, we have retrieved benchmark datasets from http://fimi.ua.ac.be/data/ in a *.dat file format.

For the ease of use in MySQL, we convert datasets into comma separated value (csv) format. The characteristics of benchmark datasets with the average size include chess and mushroom is depicted in table 1. For the faster results of a depth first with intersection searching strategy in database mining, we have split chess and mushroom datasets into benchmark trained datasets. There are four (4) sub divisions of each i.e. chess1000x10, chess1500x10, chess2000x10, chess2500x10, mushroom1000x10, mushroom1500x10, mushroom2000x10 and mushroom2500x10 respectively.

TABLE I.  DATABASE CHARACTERISTICS  Database Size (KB)  Average Length  (attribute)  Records (transaction)  Chess (original) 335 37 3196 Chess1000x10 25.4 10 1000 Chess1500x10 38.1 10 1500 Chess2000x10 50.9 10 2000 Chess2500x10 63.6 10 2500  Mushroom (original)  558 23 8125  Mushroom1000x10 27.9 10 1000 Mushroom1500x10 41.9 10 1500 Mushroom2000x10 55.8 10 2000 Mushroom2500x10 70.0 10 2500   Table 1 shows the database characteristics of chess and  mushroom. The size in KB represents the file size, the average length represents the attributes of chess or it is labeled as column in database table while the records of transactions are labeled as row in Eclat database table.

B. Empirical Results  Fig. 2 illustrates the graphical user interface of our Eclat tool.

Figure 2. Eclat Tool     Fig. 3 to fig. 10 below are the illustration the graphs of total number of association rule (AR) in various min_support results prior to experiment with Eclat and Eclat-variants algorithms namely Eclat tidset [17], diffset [14] and sort diffset [15]. Fig. 3 to fig. 10 indicates the graph of total association rule at various minimum supports in chess and mushroom databases i.e. chess1000x10, chess1500x10, chess2000x10, chess2500x10, mushroom1000x10, mushroom1500x10, mushroom2000x10 and mushroom2500x10. In fig. 9, sortdiffset shows more ARs than tidset and diffset at four different min_support. At the rest min_support, it shows very minor ARs as compared to other two algorithms. The pattern of graph in fig. 10 is quite peculiar. Tidsets generates many ARs only at earlier interval i.e. from min_support from 0 to 600. Then, in later intervals, it reduces drastically to be approximately quite similar number with diffset and sortdiffset.

From all the graphs, it is clearly imitated that there exist a difference performance in terms of total number of AR generated between tidset, diffset and sortdiffset algorithms.

The number of total AR in tidsets is very high but it drops drastically in diffset and sortdiffset. By contrast, the performance in speed of processing or execution time (in seconds) shows a major difference between the algorithms as depicted in fig. 11 and fig. 12. In both chess and mushroom datasets, the sortdiffset algorithm outperforms diffset and tidset. Especially in fig. 12, execution time shows a drastic reduction in diffset and sortdiffset compared to tidsets.

Subsequet difference of execution time is portrayed in fig. 11 from diffset to sortdiffset but it is about a minor difference only.

Figure 3. AR in chess1000x10      Figure 4. AR in mushroom1000x10     to be approc     Figure 5. AR in chess1500x10          Figure 6. AR in mushroom1500x10        Figure 7. AR in chess2000x10       Figure 8. AR in mushroom2000x10            Figure 9. AR in chess2500x10        Figure 10. AR in mushroom2500x10    oom2500x10       Figure 11. Execution time (sec) in chess between three (3) algorithms           Figure 12. Execution time (sec) in mushroom between three (3) algorithms

VI. CONCLUSION AND FUTURE DIRECTION  Experimenting ourselves in association rule database mining with the selected benchmark datasets conforms to what the other previous researchers have proven. In this paper, we have successfully adopted a depth first search (DFS) with intersection strategy through Eclat and Eclat-variants algorithms within a benchmark transaction database in mining association rules, rather than breadth first search strategy or depth first with divide-and-conquer strategy. The important advantages in database mining that we disclose here are firstly, the ease of indexing mechanism. Secondly the ad-hoc query support mechanism and thirdly, is the interoperability and flexibility of data storage to facilitate the altering (either adding or deleting of row/column) in a data table.On the other hand, the disadvantage of database mining as compared to flat file mining is pertaining to the issue of memory and space.

Our next future direction is to address in memory and spacing issues where the massive dense datasets or even sparse datasets need to be overcome either by incremental or parallel techniques. The issues are in conjunction with big data explosion and when the big data comes from various sources in a various types, then database integration method as in [18] needs to be adopted to give benefits to end users.

