Egocentric Storylines for Visual Analysis of Large Dynamic Graphs

Abstract?Large dynamic graphs occur in many fields. While overviews are often used to provide summaries of the overall structure of the graph, they become less useful as data size increases. Often analysts want to focus on a specific part of the data according to domain knowledge, which is best suited by a bottom-up approach. This paper presents an egocentric, bottom-up method to exploring a large dynamic network using a storyline representation to summarise localized behavior of the network over time.

Keywords?information visualization; dynamic graphs; story- lines; egocentric views;

I. INTRODUCTION  Relational data, consisting of a set of entities and a network of relationships between them, is one of the primary classes of information (some other examples being spatial data, n- dimensional data, or text data). This kind of data turns up in many different disciplines, including sociology, biology, engineering, computer networks, and many more. Analysis of these networks can lead to important insights, but as with other kinds of data, the scale of network data is readily increasing.

Facebook, for instance, now has over a billion users forming an incredibly complex network of friendships, communication, and more. As such networks become increasingly larger and more complex, reasoning social dynamics via simple statistics or even many traditional visalization techniques are no longer feasible options.

Many visualizations follow the top-down information vi- sualization mantra of ?Overview first, Zoom and filter, Details on demand? [35]. However, as the scale increases, overviews become less useful; since the capacity of the display (and the human eye) has an upper bound, as the data size increases, an overview will convey a diminishing percentage of the total information in the dataset. This is particularly problematic if the analyst already knows what part of the network they want to focus on, as overviews tend to abstract away the specific details that the analyst is looking for. As an alternative, many visualization approaches take a bottom-up approach of ?Search, Show context, Expand on demand? [38]. While these approaches depend on domain knowledge or statistics to provide a starting point, they are often helpful for large data analysis, as the amount of information provided to the user at any time can be controlled independently from the size of the data set.

Another challenge is that many graphs are not static; data collected in real world applications are often intrinsically time- varying. For instance, in a social network over time, new friendships can be made, or old friendships lost. While the problem of visualizing static networks has been studied quite extensively, work on dynamic network visualization is still in its infancy. Most existing works focus on the layout stability of time-varying node-link diagrams, either shown as animation or small multiples. However, for large data, animation can take a long time to watch, and small multiples reduce the already limited screen space. A few works investigate methods of creating time-lines for dynamic graphs to statically summarize the evolution of dynamic graphs. However, these methods suffer from the same overview limitations mentioned above.

This paper presents a method for visualizing a dynamic graph that combines both bottom-up network exploration and a static timeline representation. The result is an egocentric sto- ryline based visualization that summarizes the behavior of the local network surrounding user-selected foci. This approach was also designed as a streaming algorithm, making it viable for online dynamic graph data.



II. RELATED WORK  A common method for visualizing dynamic graphs is to animate the transitions between time-steps [25], [10], [12], [15], [3], [13]. This approach yields dynamic visualization with nodes appearing, disappearing and moving to produce readable layout for each time-step. Alternatively, multiple time-steps can be staticly placed next to each other using ?Small Multiples? [37]. This eases the comparison of distant time-steps but the area devoted for each time-step is small and this reduces the readability of each graph. An empirical study to compare the advantages and drawbacks of these approaches (?Animation? vs. ?Small Multiples?) has been performed by Archambault et al. [1].

A major issue for both methods is to ensure the stability of the layout [19], [13], [5], [17]. A stable layout helps preserve the user?s mental map as there is less movement between time-steps, but sacrifices quality in terms of readability for later time-steps as their layout depends on previous time-steps.

Many experiments has been proposed to examine the effect of preserving the mental map in dynamic graphs visualization [29], [32], [30]. The results of [30] were quite surprising be- cause the most effective visualizations were the extreme ones,     i.e. the ones with very low or high mental map preservation: visualizations with medium preservation performed less well.

However, most of these works do not demonstrate scalability.

The work of Sallaberry et al. [33] is one of the few dynamic graph layout approaches that has been shown to scale to tens or hundreds of thousands of nodes, but it still relies on visualizing the entire network at once, so even it can not handle the millions or billions of nodes that can occur in modern graphs.

Hu et al. [17] proposed a method based on a geographical metaphor to visualize a summary of clustered dynamic graphs.

They also use a clustering approach similar to ours, though it sacrifices some local quality for calculation efficiency and additional temporal stability.

An alternate visualization approach for dealing with dy- namic large directed graphs is to directly represent time as an axis. In the work of Burch et al. [6], vertices are ordered and positioned on several vertical parallel lines, and directed edges connect these vertices from left to right. Each time-step?s graph is thus displayed between two consecutive vertical axes.

Storyline visualizations have become popular in recent years for showing evolution of clusterings [22], [27], [18], [31], [9], [36]. Most of these works reference hand-drawn diagrams such as XKCD?s movie narrative charts [22] as inspiration, in which entities are represented as lines which move together when in the same group and separate when they are not.

?Plotweaver? [28] is a tool to aid in semi-automatic generation of storyline plots, but it still requires a lot of user interaction.

The works of Ogawa et al. [27] and Tanahashi et el. [36] aim to automate the process. However, producing good results with these algorithms is computationally expensive, so they do not scale well to large data [36]. Working with larger data can make the lines start to blend together into larger flow-like structures similar to sankey diagrams [9], [26]. To apply storyline techniques to dynamic graphs, an intermediary step of dynamic clustering must be derived [31], [33]. These approaches use bins to more efficiently lay out the storylines.

Since overviews are less useful for enormous networks, researchers have introduced several bottom-up techniques.

These approaches start from a single selected node and its immediate context. Additional relevant nodes and connections are revealed only on demand, based on graph structure or specialized degree-of-interest functions. Moscovich et al. [21] designed two intuitive interaction techniques called ?Link Sliding? and ?Bring & Go? for navigating large networks.

Heer and Boyd [16] presented a visualization method which only shows a focus node?s neighboring nodes up to a certain level. Similarly, Elmqvist and Fekete [11] described a bottom- up system based on hierarchy traversal methods, including above traversal, below traversal, and level traversal. These methods are useful when the inherent graph structure is more important than other properties for the task at hand. For other applications, where node/edge attributes are the focus of analysis, researchers create specialized degree-of-interest (DOI) functions. Furnas [14] introduced a DOI function to evaluate the importance of a selected node based on distance and a priori interest. Van Ham and Perer [38] extended this function to operate on embedded attributes and graph topology, as well as user-generated search actions. Their system can then suggest nodes with the highest degrees of interest for users to explore. Crnovrsanin et al. [8] combine this concept with an  Fig. 1. Our overall process. The user selects a focal node (in green), the system loads the graph data one timestep at a time (grey), clusters the time step (blue), derives relevence values (orange), uses the relevence values to filter the timestep (cyan), and appends the timestep to the storylines (red).

interaction history based importance similar to Amazon?s item- to-item collaborative filtering [20]. Our approach works with dynamic graphs, so we can use temporal history as well as interaction history.



III. APPROACH  Storylines depict the evolution of dynamic clusters over time. So to use storylines to depict a dynamic network, the first step in our approach is to derive such a dynamic clustering.

Once we have this clustering, we want to be able to focus on small portions of the network at a time. We employ an egocentric approach to start with a single focal point and use a recommendation algorithm to provide the local context.

Once we have this localized subset of the data, we employ an efficient storyline layout algorithm to create the resulting visualization. These storylines can then be explored either through expansion via user selection of new foci or temporally via user selection of time steps to view in more detail.

A. Dynamic Graph Clustering  A dynamic graph can be defined formally as an agglomer- ate graph G = (V,E) and an ordered sequence of subgraphs S = {G1 = (V1, E1), G2 = (V2, E2), ..., Gk = (Vk, Ek)} where each Gt is the subgraph of G at time t. V, V1, V2, ..., Vk are finite and non-disjointed sets of nodes, E,E1, E2, ..., Ek are finite and non-disjointed sets of edges such that V = V1 ? V2 ? ... ? Vk and E = E1 ? E2 ? ... ? Ek. What we need is to create a time-varying clustering, i.e. a set of clusters evolving over time. The clustering method we describe here is a two step algorithm. The first step consists of partitioning the nodes for each time step independently. Then, we associate these clusters through time to derive time-varying clusters.

1) Time-step Clusterings: Finding a partition of the nodes of a static graph according to its structure is a well studied problem. Schaeffer has published a good overview of graph clustering methods[34]. For our approach, we need to cluster a dynamic graph, which is a less studied problem. We do this by first finding a partition for each time step, i.e. a set of clusterings C = {C1, C2, ..., Ck} where Ct = {ct1, ct2, ..., ctlt} is a partition of the nodes Vt of Gt. In this paper, we call each Ct a ?time-step clustering? where cti is the ?time-step cluster? i at time t, and cti ? Vt for 1 ? i ? lt, Vt = ct1 ? ct2 ? ...ctl and cti ? ctj = ? for i ?= j,     Our algorithm is based on the so-called modularity function [23]. It represents the sum of the number of edges linking nodes of the same clusters minus the expected such sum if edges were distributed at random. For a graph Gt = (Vt, Et) and a partition Ct of its nodes, the modularity Q(Ct) is defined by:  Q(Ct) =  2|Et| ?  u,v?Vt  [ Auv ? kukv  2|Et| ] ?(ct(u), ct(v))  where |Et| is the number of edges, Auv is 1 if there is an edge between u and v and 0 otherwise, ku =  ? v Auv is the  number of edges attached to u, ct(u) is the time-step cluster of Ct containing u, ?(ct(u), ct(v)) is 1 if ct(u) = ct(v) and 0 otherwise.

A partition that maximizes this function helps to dis- cover clusters of densely connected communities. Moreover, as shown by Noack [24], optimizing the modularity is the same as optimizing an energy function in graph layout. This equivalence implies that our layout based on such a clustering algorithm yields a good representation of the graph.

The problem of finding a partition that maximizes the modularity is hard, and the corresponding decision problem is NP-complete [4]. We use the heuristic proposed by Blondel et al. [2], which works well in terms of both the quality of the results and the computation time. Initially, each node belongs to its own cluster. Then pairs of clusters are recursively merged such that the modularity of the partitioning increases.

If two possible merges involve the same cluster, the merge that improves the modularity the most is performed.

2) Cluster Tracking: We define a time-varying clustering of a dynamic graph G as a set of time-varying clusters V C = {V C1, V C2, ..., V Cl}. Each of these time-varying clusters is an ordered sequence V Ci = {vc1i , vc2i , ..., vcki } where k is the number of time steps and each vcti is a subset of the vertices Vt at time t. That is, each time-varying cluster V Ci is a cluster whose membership can evolve over time, where vcti represents the set of nodes in the cluster i at time t. As the number of clusters can change between timesteps, not every cluster exists at every timestep, so the total number of time-varying clusters l can be larger than the number of time step clusters at any time step.

Our overall approach is to compare the time-step clusters pairwise between neighboring time-steps and putting the most similar time-step clusters into the same time-varying cluster.

We start from an empty set V C of time-varying clusters and we create a time-varying cluster V Ci for each time-step cluster c1i of the first time-step clustering C1. The set of nodes of these time-varying clusters V Ci at time 1 are initialized with the time-step clusters c1i : vc  i ? c1i .

Then, starting with this partition of the graph at time 1, for each vc2i we search for the time-step cluster of C2 that is the most similar to vc1i . Let c  a be such a cluster, then vc  i ? c2a. If  no similar cluster can be found in C2, then vc2i is an empty set (i.e. the time-varying cluster has disappeared at time-step 2). If there is a time-step cluster c2a in C2 that cannot be associated with a vc2i , then a new time-varying cluster V Cb is created  with vc1b ? ? and vc2b ? c2a. We iterate this process for each time-step.

The crux of this algorithm is how to decide which time- step cluster of Ct is the most similar to a cluster of Ct?1.

The solution we use is based on a similarity function between time-step clusters of Ct?1 and clusters of Ct. Results of this function can be stored in a matrix M such that Mij denotes the similarity between ct?1i and c  t j . Starting from the highest  value of this matrix and the corresponding clusters ct?1i and ctj , we assign c  t j to the time t of the dynamic cluster V Ci  that contains the cluster ct?1i at the time t ? 1. Then we do the same for the second highest value of the matrix and so on. Any values corresponding to pairs of time-step clusters that have already been assigned a dynamic cluster are skipped, as a better match was already found earlier in the algorithm.

This process ends when there are no more time-step clusters or when the highest similarity value is under a given threshold.

Finally, any remaining time-step clusters become new dynamic clusters.

In our implementation, we use the Jaccard index to com- pute the similarities. For two clusters ct?1i and c  t j , this is  defined by the equation |ct?1i ? ctj |/|ct?1i ? ctj |. There are two main advantages in using this metric. First it takes into account the number of shared nodes as well as the total number of nodes, which guarantees homogeneity between consecutive steps of a time-varying cluster. Secondly it returns a value normalized between 0 and 1 which is helpful for empirically defining a threshold.

B. Egocentric Context Recommendation  Rather than trying to show all clusters simultaneously, we opt for a bottom-up technique. In this approach, the user selects a single node of interest (the ?ego?), and the system determines and presents what is relevant with respect to the selection.

We do this by applying a recommendation algorithm to the network. Similar to the Degree Of Interest (DOI) functions of Furnas [14], Van Ham and Perer [38] or Crnovrsanin et al. [8], we use a weighted combination of several relevence functions. We combine a network relevence metric with a temporal relevence history and an interaction relevance history.

1) Network Relevence: Many existing works use centrality sensitivity calculations to derive relative network-based impor- tance [7], [8]. However, at the scale of data we were analyzing, we found that the standard centrality algorithms were too expensive to calculate dynamically, and the sensitivities used too much storage space to be viable, as they consist of an entire |V |2 sized matrix for each time step. So instead, we use graph distances directly. Since we have a single focal vertex, these distances can be computed very efficiently using Dijkstra?s algorithm. Then, we define the network relevance simply as the inverse of the graph distance to the focal node. That is:  NRi,j,t =  di,j  2) Temporal Relevence: As in dynamic graph layouts, it is important that the storylines be stable over time [36]. Thus, rather than computing the overall relevance exclusively on the current time step being worked with, we want to incorporate     previous timesteps into the relevance metric. However, it would be wasteful to recalculate the relevances of previous timesteps, so we cache them for a user controllable number of previous timesteps. That is, for each of the k time steps before the current time step t (i.e.: Gt?k, Gt?k+1, ..., Gt?1), we save the network relevances between each pair of nodes. So for each pair of nodes i and j in the current time step, we have an array of the network relevances from the previous k timesteps {NRi,j,t?k, NRi,j,t?k+1, ..., NRi,j,t?1}. In order to combine these into a single temporal relevance value, one could simply average them together, but this would not produce a very smooth/stable value, as outliers would have a strong effect for many time steps. Instead, we compute a triangular weighted average by applying a linear weight wt?a = k?a+1k for 1 ? a ? k. Thus, we compute the overall temporal relevance as:  TRi,j,t = NRi,j,t?k ? wt?k + ...+NRi,j,t?1 ? wt?1  wt?k + ...+ wt?1 This creates a sliding window which allows the effect of old values to fade out smoothly. Higher order window functions could be applied (e.g. quadratic or cosine weights), but we found the linear window to be sufficient.

3) Interaction Relevence: In order to aid the user in keep- ing mental track during their exploration, we want to preserve some of the context of their previous steps. Each time the user selects a new focal node, we want to preserve the importance of the previous selection to maintain context. One way to do this would be to cache the relevences of the most recent selections, and weight them to have them fade out as more selections are made, similarly to temporal relevance. However, if we cache the combined relevence, then each cached value would already include the previous timestep, weighted by the combination function, and recursively, every time step before that. As long as the weighting is less than 1, this will produce an exponential fall off. Thus, we calculate the interaction relevance as:  IRi,j,t = CRk,j,t  where CRk,j,t is the combined relevence at time t of node j with respect to the previously selected node k.

4) Combined Relevence Metrics: We combine these 3 metrics with a user controllable linear summation:  CRi,j,t = ? ?NRi,j,t + ? ? TRi,j,t + ? ? IRi,j,t where ?, ?, ? are controlled via the interface. However, to seperate the layout from the filtering computation, we use 2 sets of constants to define 2 combined metrics: one used for filtering and one used for layout. This allows for more flexible control: e.g. the user can set it so that the filtering uses IRi,j,t but not the layout, so that previous selections are still included in the plot, but do not interfere with the layout of the current selection.

C. Streaming Storyline Layout  With a good layout, storylines have been shown to be effective for visualizing evolution of dynamic clusters. But computing a good layout can be costly; e.g. Tanahashi?s layout uses a genetic algorithm to find a global optimization [36], which produces good results but takes a long time. In order to lay out large, streaming data, we need a more efficient  Fig. 2. An example of our UI. One node is searched for and selected from a list. Then the relevant nodes are plotted in the storyline view, laid out with the selected node at the bottom and more relevant neighbors placed closer.

The lines are colored either according to the clustering or node id.

approach. Since we have a focal point and have computed relevance metrics with respect to this focal point, we can use the nodes? relevences to give semantic meaning to the ordering and placement of the storylines. Towards these goal, we employ a greedy layout algorithm, which makes a best- effort to quickly lay out each time step one at a time while using the relevence information.

Similarly to the works of Sallaberry et al. [33] and Reda et al. [31] our layout algorithm is a bin-based algorithm. For each cluster in the current time step, we use the average relevence of the cluster?s nodes and the cluster?s assigned slot from the previous time step (if it existed in the previous time step) to determine the optimal bin to assign the cluster to. If the optimal bin is already occupied, then the algorithm assigns the cluster to the next available bin instead. Once assigned, the cluster does not get reassiged to a different bin, so the order of insertion is important. Stability is more important than rigorous ordering, so priority is given to clusters that existed in the previous time steps. Within both groups (pre-existing and new clusters), the clusters are inserted in order of importance according to the relevence metric.

Once the clusters have been arranged into bins, we need to arrange the individual lines within the cluster. One simple way to do this would be to simply order them by relevance.

However, this can yield many gaps between lines and does not offer any guarantee of stability. Instead, we carry over any placement from the previous time step, insert any remaining nodes ordered by relevence, and finally remove any gaps if there are any. In this manner, the ordering will not be perfectly by relevence, but the layout will be far more stable.

Since our layout is a greedy approach, it can get stuck in local minima (e.g. when the optimal bin is already occupied).

While this does sacrifice some level of quality compared to a global optimization, we found that the results are still sufficient for our purposes.

D. Interactive Exploration  Any bottom up approach needs to provide the user a way to search for and select a starting point. We provide a simple table with a search/filter mechanic that can be sorted or filtered on arbitrary data attributes. This way, if the user has a starting point in mind, they can find it quickly. Alternately, the user     (a) Selecting Node 15  (b) Selecting Node 55  Fig. 3. MIT reality mining dataset. Selecting various nodes reveals differing patterns. Node 15 changes clusters almost every timestep as the similarity between clusters fell under the clustering threshold. Node 55 is more stable, but also shifts cluster membership as other nodes leave or join its cluster.

can start with a more generic search, such as starting from nodes of high degree. Figure 2 shows an example of such a selection via our user interface.

Once the user makes an initial selection, a storyline plot is generated. From this plot, the user can select any of the plotted lines to refocus the plot on the selected line. In this manner, the user can expand the view to include neighboring nodes.



IV. RESULTS  We demonstrate our approach on several data sets. First, we apply it to the phone records from the MIT reality min- ing dataset, aggregated per day (|Vt| ? [750, 1400], |Et| ? [1500, 2500]). This data set contains many transient nodes due to external phone calls, so it is quite noisy at times.

But our approach reveals some interesting patterns. Figure 3 shows some examples. In both images, there are many lines that exist for only one timestep. Node 15 (Figure 3(a)) is clustered with many of these, so it does not have a consistant clustering over time. Node 55 (Figure 3(b)) has a more consistent set of neighbors, and hence a more consistant clustering over time. The autonomous systems (AS) of the Internet provide a much larger and more interesting test case (|Vt| ? [12k, 33k], |Et| ? [23k, 71k]). Figure 4 shows several examples from a year and a half subset of the available time range. AS8307 (Figure 4(a) is clustered with a number of other stable nodes, but their cluster changes cluster ID a few times as it gradually incorporates nodes from the other cluster shown in the plot. AS9695 (Figure 4(b)) on the other hand has many chaotic neighbors in its cluster, but little interaction with other clusters. Larger autonomous systems such as AS174 or AS3356 (Figures 4(c) and 4(d)) interact with many other autonomous systems, and often serve as bridges between clusters. Thus, their cluster assignment is somewhat less stable, and they are tightly connected to numerous other clusters. Another interesting pattern that occurs is when a node starts as a member of one cluster, then splits off to form a new cluster, such as AS3707 or AS10189 (Figures 4(e) and 4(f)).

Extending our approach to a decade?s worth of time steps of the Internet dataset yields a large and more chaotic storyline  plot, but which still has patterns similar to those in the smaller set, as shown in Figure 5. While screenspace starts to be an issue as the number of timesteps grows, our approach streams each time step, so it scales well computationally.



V. FUTURE WORK  While our approach works through the data one timestep at a time, it is still not truly streaming, where individual changes would be streamed in and handled one at a time. The clustering and relevance calculation can be computationally expensive, and it would be beneficial for them to be replaced with alternatives that could handle incremental changes. The heuristic approach of Hu et al might be a good place to start [17]. Then the approach might even be efficient enough for real-time analyses. The other direction that could be pursued is to improve the stability of the clustering itself. While this could detract from the localized cluster quality, it would improve the readability of the visualization overall. The system could also use a detailed view of the underlying network itself. As in the work of Sallaberry et al. [33], the storyline plot can be used to define a 2-dimensional graph layout via a space filling curve.

Since the storylines guarantee clustering and aim for stability, they would define a stable and useful dynamic layout.



VI. CONCLUSION  We have presented a new, bottom-up approach to large dynamic graph visualization. While overviews are still helpful to convey the overall structure of a large network, they can be computationally costly and can either be overly cluttered or overly simplified. Bottom-up approaches such as the one presented here enable analysts to more directly impart domain knowledge into the analytics process and more practically explore the specific regions of the network of interest. We have demonstrated the effectiveness of our approach by applying it to several fairly large networks, but the method was designed with even larger future networks in mind. Techniques such as ours will become even more vital analysis tools as the size of data is ever increasing.

