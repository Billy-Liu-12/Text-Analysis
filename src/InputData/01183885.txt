Mining Molecular Fragments:  Finding Relevant Substructures of Molecules

Abstract  We presenr an algorithm 10 Jind fragments in a ser of molecules rhat help to discriminate beween dif/erent classes oJ for instance, activih in a drug discovep context.

instead of carving our U brurerforce search. our method generates fragments by embedding rhein in all appropriare molecules in parallel arid prunes the search free based on a local order of the atoms and bonds, which resulrs in sub- stantially faster search by eliminaring the need for freqoenr, compurarionall~ expensive reembeddings arid by suppress- ing redirndanr search. We prove the usefulness of our al- gorithm by demonstraring rhe discoven of activiryrelated groups of chemical compounds in the well-knonw National Cancer lnsriture s HIV-screenbig doraset.

1. Introduction  Many data mining tasks in bioinformatics consist in ana- lyzing large collections of molecules with the goal to find some regularity among molecules of a specific class. Possi- ble applications are manifold. One example is drug discov- ery, where the biologist wants to find new drug candidates based on experimental evidence of activity against a cer- tain disease gathered by screening hundreds of thousands of molecules. A second, more recent emphasis comes from chemical synthesis success prediction, where the goal is to find molecular features that inhibit the desired reaction.

Current approaches to find regularities among molecules are often based on so-called descriptors. which usually con- sist of thousands of binary features, representing (some- times in a hashed manner) certain substructures of interests.

such as aromatic rings or some other predefined small group of atoms 141. Other descriotors model Dairwise atom dis-  rive similarity measures based on transformations of these graphs were also proposed 191. However, such notions of similarity, hased on a particular descriptor with a corre- sponding metric, only model limited aspects of molecular similarity well. Therefore altempts to directly extract rel- evant substructures from a collection of molecules are of persistent interest.

Recently an approach was presented that finds linear frag- ments [7], i.e. chains of atoms, using an algorithm similar to the well-known Apriori association rule mining method [I] .

However, the restriction to linear fragments is limiting in many real-world applications, since substructures of inter- est often contain rings or branching points. Nevertheless, the idea to use an association rule mining algorithm by re- garding the molecules as a set of nodes (instead of the usual bit sets) has  sparked considerable interest. A more recent approach [ 5 ]  finds arbitrary connected substructures by de- riving canonical labels for each graph. The search is again based on the Apriori algorithm and hence still relies on frequent reembeddings of fragments in order to determine valid intermediate candidates throughout the search.

In this paper we present an algorithm that also finds ar- bitrary connected substructures but avoids frequent reem- beddings by using a different search strategy. The algo- rithm maintains parallel embeddings of a fragment into all molecules throughout the growth process and exploits a lo- cal order of the atoms and bonds of a fragment to prune the search tree, which results in faster search and allows for a restricted depth first search algorithm, similar to the Eclat association rule mining algorithm [IZ].

We first present the main algorithm, followed by adiscus- sion of results obtained on the HN-screening dataset from the National Cancer Institute [ 1 I ]  and conclude with a brief discussion of possible extensions of our method. . .

lances or 3D molecule arrangements. Prediction algorithms then simply use a distance function on these descriptors to define similarity between molecules. More sophisticated algorithms attempt to find boolean combinations of some of these features that are related to different classes [IO].

Approaches that try to regard molecules as graphs and de-  2. The Induction Algorithm  In this section we describe our algorithm by developing it from algorithms for the well-known task of association rule induction. We start by reviewing the search schemes for fre-  0-7695-1754-4102 $17.00 Q 2002 IEEE 51  mailto:horgelt@iws.cs.uni-magdeburg.de mailto:berthold@tripos.com   &3 Figure I:  A search tree for five items a,b,c,d,e.

quent itemsets in  Section 2.1 and then transfer their ideas to the more complicated case of finding molecular substruc- tures in  Section 2.2. In Section 2.3 we describe how our algorithm prunes the search tree based on a local order of the atoms and bonds of a fragment. In section 2.4 we dis- cuss a simple example and in Section 2.5 we study why it is impossible to avoid all redundant search. Finally, in Sec- tions 2.6 and 2.7, we describe how to embed core structures to start the search from and how to find contrast structures that distinguish between groups of molecules.

2.1. Association Rules and Frequent Itemsets  The induction of association rules is a powerful method for market basker analysis, which aims at finding regularities in the shopping behavior of customers of supermarkets, mail- order companies. on-line shops and the like. With it one tries to find sets of products that are frequently bought to- gether, so that from the presence of certain products in a shopping cart one can infer (with a high probability) that certain other products are present. The main difference to our task of finding frequent substructures of molecules is that in market basket analysis we have only simple seis of irems to deal with, while in molecular substructure analy- sis we have to take the chemical connectivity, i.e. the bonds connecting individual atoms, into account as well.

The best-known association rule algorithms are Apriori [ I ]  and Eclat [12]. Both work in two steps: First thefre- quent itemsets (often misleadingly called large iremsers) are determined. These are sets of items that have at least a given minimum support, i.e., occur in  at least a given percentage of all transactions. In the second step association rules are generated from these frequent itemsets. Here we focus on the first step, because we are not concerned with generating rules. However, research in association rule induction usu- ally does the same, because finding the frequent itemsets accounts for the greater part of the processing time.

In order to find frequent itemsets, one has to count the transactions different itemsets are contained in. This task consists in traversing a tree like the one shown in Figure 1 and determining the values of the counters in its nodes.

Each box represents a counter. The edge labels on a path from the root to a node indicate the common part of the itemsets for which there are counters in that node. The tree is unbalanced, because we are dealing with sets. not sequences: abc, for instance, is the same as bca and thus  only one of these counters is needed. Mathematically, the search tree is a substructure of the subset lattice, having ex- actly one path to any itemset. In addition, both Apriori and Eclat exploit the simple observation that no superset of an infrequent itemset can be frequent. This observation can he used to further prune the tree. because all counters for item- sets having an infrequent subset can be discarded.

The main differences between Apriori and Eclat are how they traverse this tree and how they determine the counter values. Apriori does a breadth first search and determines the support of an itemset by explicit subset tests on the trans- actions. An efficient implementation can use a data struc- ture like the tree shown in Figure 1 to store the counters [2 ,  31. However, the need to build a data structure like this can also be a severe disadvantage, as it can consume a lot of memory Furthermore, the subset tests can he costly.

On the other hand, Eclat does a depth first search and de- termines the support of an itemset by intersecting the trans- action lists for two subsets. the union of which is the item- set. The advantage is that not all counters have to be kept in memory, especially if one allows for some unnecessary tests, which could be avoided only by checking all subsets.

A disadvantage is that several transaction lists have to be kept in  memory at the same time-lists that can he very long, especially for small itemsets. More sophisticated ap- proaches try to combine the advantages. using Apriori for the first levels of the tree (usually only 2 or 3) and Eclat as soon as the transaction lists are short enough [12,6].

2.2. Frequent Substructures of Molecules  In order to capture the bond structure of molecules, we model them as attributed graphs, in  which each vertex rep- resents an atom and each edgc a bond between atoms. Each vertex carries attributes that indicate the atom type (i.e., the chemical element), a possible charge, and whether it is part of an aromatic ring. Each edge carries an attribute that indi- cates the bond type (single. double, triple, or aromatic).

Our goal is to find substructures that have a certain min- imum support in a given set of molecules, i.e.. are part of at least a certain percentage of the molecules. However, in  order to restrict the search space, we consider only con- necred subsrrucrures, i.e., graphs having only one connected component. For most applications, this restriction is harm- less, because connected substructures are most often exactly what is desired. We do  not constrain the connectivity of the graph in any other way: The graphs may be chains or trees or may contain an arbitrary number of cycles. With this we go beyond [71, who considered only lineur subsrrucrures, i.e., simple chains of atoms without branches. Such simple chains are rarely sufficient in  real-world applications.

Most naturally, the search is carried out by traversing a tree of fragments of molecules, similar to the tree of item- sets shown in figure 1. The root of the tree is the core struc- ture to start from, which for now we assume to be a sin- gle atom (more complex cores are discussed below). Going     down one level in.the search tree means to extend a sub- structure by a bond (and maybe an atom, if the bond does not close a ring), just like going down in the tree shown in Figure 1 means adding an item to an itemset. That is, with a single atom at the root of the tree, the root level contains the substructures with no bonds, the second level those with one bond, the third level those with two bonds and so on.

As indicated above, there are basically two ways in which the search tree can be traversed We can use either a breadth first search and explicit subset tests (Apriori) or a depth first search and intersections of transaction lists (Eclat). For our task the Eclat approach is clearly preferable, because the disadvantages of the Apriori approach become consid- erably more severe: Even subset tests can be costly, but sub- structure tests, which consist mathematically in checking whether a given attributed graph is a subgraph of another at- tributed graph, are extremely costly. Furthermore, the num- ber of small SubStNCtureS (1 to 4 atoms) can be enormous, so that even storing only the topmost levels of the tree can require a prohibitively large amount of memory.

Of course, the Eclat approach also suffers, because the transaction lists are now lists of embeddings of a subsuuc- ture into the given molecules. Since there can be several em- beddings of the same substructure into one molecule, these lists tend to get longer. This drawback can make it necessary to start from a reasonably sized core structure (see below).

To be more specific, our algorithm searches as follows: The given core structure is embedded into all molecules, resulting in a list of embeddings. Each embedding consists of references into a molecule that point out the atoms and bonds that form the substructure. Remember that a list of embeddings may contain several embeddings for the same molecule if the molecule contains the substructure in more than one place or if the substructure is symmetric.

In a second step each embedding is extended in every possible way. This is done by adding all bonds in the cor- responding molecule that start from an atom already in the embedding (to ensure connectedness and, of course, to re- duce the number of bonds that have to be considered). This may or may not involve adding the atom the bond leads to, because this atom may or may not be part of the embed- ding already. More technically, by following the references of an embedding the atoms and bonds of the corresponding molecule are marked and only unmarked bonds emanating from marked atoms are considered as possible extensions.

The resulting extended embeddings are then sorted into equivalence classes, each of which represents a new sub- structure. This sorting is very simple, because only the added bond and maybe the added atom have to be com- pared. In our implementation we use a hash table and an array of lists of embeddings to sort the extensions. The hash table associates an embedding with an array index, using a hash code that is computed from the type of the bond that was added in the preceding step, the position (in the sub- structure) of the atom it starts from, and the position and  the type of the atom it leads to. After all extended embed- dings have been processed, each m a y  element contains the list of embeddings of a new substructure. Each of these new substructures corresponds to a child node in the search tree, each of which is then processed in turn by searching recur- sively on the list of embeddings corresponding to it.

2.3. Search Tree Pruning  Of course, subtrees of the search tree can be pruned if they refer to substructures not having enough support, i.e., if too few molecules are referred to in  the associated list of em- beddings. We call this support based pruning. We may also prune the search tree if a user-defined threshold for the number of atoms in a fragment has been reached. We call this size based pruning. However, when we reviewed the search for frequent itemsets, we also considered a third type of pruning, which we refer to as structuralpruning. It is re- sponsible for the unbalancedness of the search tree shown in Figure 1: As pointed out above, we do not need a counter for bca, because it is the same itemset as abc. Structural pruning ensures that every itemset is considered in one branch only, even though adding items in different orders can yield the same itemset. In the following we consider how such struc- tural pruning can be done in the search for frequent sub- structures of molecules, because, obviously, adding bonds in different orders can result in  the same substructure.

In order to find a structural pruning scheme, let us ana- lyze the structural pruning of the itemset tree in more detail.

Figure 1 shows the basic idea very clearly. The items are ordered, which is indicated by the symbols a ,  b, etc. This order is, of course, arbitrary. But once it is fixed, the item- sets processed in a node can be Constructed as follows: Ex- tend the set of items used as edge labels on the path to the node with an item following the last edge label. Consider, for example, the second node on the third level (count from top to bottom and from left to right): The path to this node has labels a and c. Therefore the set {a ,  c }  has lo be ex- tended by items following c, i.e. by d and e. Consequently there are counters for the sets { a ,  c, d }  and { a ,  c, e} in this node. The same holds for any other node. Obviously, this scheme fixes an order in  which items can be added and thus each itemset can be reached only in one possible way.

We organize the nodes of the search tree for molecular substructures in a very similar way. The main difference is that we cannot define a global order of the atoms of the molecules, which would correspond directly to the order of the items. Rather, we number the atoms in a substructure and record how a substructure was constructed in order to constrain its extensions. The number we assign to an atom reflects the step in which it was added. That is, the core atom is numbered 0, the atom added with the first bond is numbered 1 and so on. Note that this number does not tell anything about the type of the atom, as two completely dif- ferent atoms may receive the same number, simply because they were added in the same step.

Figure 2: A set of six example molecules.

Whenever an embedding is extended, we record in the resulting extension the number of the atom from which the added bond started. When the extended embedding is to be extended itself, we consider only bonds that start from atoms having numbers no less than this recorded number.

That is, only the atom extended in the preceding step and atoms added later than this atom can be the starting point of a new bond. This rule is directly analogous to the rule that only items following the item added last may be added to an itemset. With this simple scheme we immediately avoid that two bonds, call them A and B,  which start from different atoms, are added in the order A,  B in one branch of the search tree and in the order B, A in another. Since either the atom A starts from or the atom B starts from must have a smaller number, one of the orders is ruled out.

However, two or more bonds can start from the same atom. Therefore we also have to define an order on bonds, so that we do not add two different bonds A and B that start from the same atom in the order A, B in one branch of the search tree and in the order BI A in another. This order on bonds is, of course, arbitrary. In our implementa- tion, single bonds precede aromatic bonds, which precede double bonds, which precede triple bonds. Finally, within extensions by bonds of the same type starting from the same atom, the order is determined by (1) whether the atom the bond leads to is already in the substructure or not and (2) the type of this atom. To take care of the bond type etc., we record in each embedding which bond was added last.

The above rules provide us with a structural pruning scheme, but unfortunately this scheme is not perfect and making it perfect would be very expensive computationally.

The problem is that we do not have any precedence rule for two bonds of the same type starting from an atom with the same number and leading to atoms of the same type, and that it is not possible to give any precedence rule for this case that i s  based exclusively on locally available in- formation. We consider the problems that result from this imperfection and our solution below, but think it advisable to precede this consideration by an illustrative example of the search process as we defined it up to now.

2.4. An Illustrative Example  As an illustration we consider how our algorithm finds the frequent substructures of the six example molecules shown  Figure 3: The search tree for the six molecule ex- ample. The tables below the fragments indicate the numbers of embeddings per molecule.

in Figure 2'. staning from a sulfur atom. We use a minimum support of 50%. i.e.. a substructure must occur in at least three of the six molecules to qualify as frequent.

First the sulfur atom is embedded into the six molecules.

This results in six embeddings, one for each molecule, which form the root of the search tree (see Figure 3; the ta- ble in the root node records that there is one embedding for each molecule). Then the embeddings are extended in all possible ways, which leads to the four different substruc- tures shown on the second level (i.e., S-C, S-N, S-0.

S=N). These substructures are ordered, from left to right, as they are considered by our algorithm, i.e., extensions by sin- gle bonds precede extensions by double bonds. and within extensions by bonds of the same type the element type of the atom a bond leads to determines the order. Note that there are two embeddings of S-C into both the molecules b and c and two embeddings of S - 0  into the molecule a.

In the third step the extensions of the substructure S-C are constructed. This leads to the first five substructures on the third level (i.e.. C-S-C, C-S-N, C-S-0 .  C-S=N and C-C-S). Again the order of these substructures, from left to right, reflects the order in  which they are consid- ered. Since we search depth first, the next substructure to be extended is C-s-C.2 However, this substructure does not have enough support and therefore the subtree is pruned.

The substructure C-S-N is considered next etc. How- ever, we confine ourselves to pointing out situations in which specific aspects of our method become obvious. Ef- fects of the structural pruning can be seen, for instance, at the fragment C-S-N, which does not have a child in which a second carbon atom is attached to the sulfur atom. The reason is that the extension by the bond to the nitrogen atom rules out all single bonds leading to atoms of a type preced- ing nitrogen (like carbon). Similarly, C-S=N does not have children with another atom attached to the sulfur atom by a single bond, not even an oxygen atom, which follows ni- trogen in the periodic table of elements. The reason is that     3) C-S-N 3 (50%) 3 (50%) 5 (83%)  ?

1 )  C-S-N 2) C-C-S-N  4) C-S-0 5 )  C-S=N 6 )  C-S 4 (67%) 3 (50%) 6 (100%)  Figure 4: The six frequent substructures that are found in the ex- ample in the order in which they are generated.

a double bond succeeds a single bond and thus the exten- sion by the double bond to the nitrogen atom rules out all single bonds emanating from the sulfur atom. Finally, the structure C-C-S has no children at all, even though it  has enough support. The reason is that in  this substructure a bond was added to the carbon atom adjacent to the sulfur atom. This carbon atom is numbered 1 and thus no bonds can be added to the sulfur atom. which has number 0. Only the carbon atoms can be starting points of a new bond, but there are no such bonds in the molecules a, b. and d.

During the recursive search all frequent substructures en- countered are recorded. The resulting set of six frequent substructures, together with their absolute and relative sup- pon is shown in Figure 4. Note that C-C-S is not re- poned, because it has the same support,as its superstruc- tureC-C-S-N. Likewise, 0-S-N, S=N,and Sarenotre- ported. This example makes i t  clear that our algorithm can find arbitrary substructures, even though it does not show how cyclic S ~ N C ~ U E S  are treated. Unfortunately, search trees for cyclic structures are too big to be depicted here.

2.5. Incomplete Structural Pruning  We indicated above that our structural pruning is not per- fect. In order to understand the problems that can arise, con- sider two molecules A and B with the common substruc- ture N-C-S-C-0. We try to find this substructure starting from the sulfur atom. Since the two bonds emanating from the sulfur atom are equivalent, we have no precedence rule and thus the order in  which they are added to an embedding depends on the order in which they occur in the correspond- ing molecule. Suppose that in molecule A the bond going to the left precedes the bond going to the right, while in molecule B it is the other way round. As a consequence, in embeddings into molecule A the left carbon atom will pre- cede the right one, while in embeddings into molecule B it will be the other way round. Now consider the substruc- ture C-S-C and its extensions. In molecule A the carbon numbered 1 (the left one) will be extended by adding the nitrogen atom and thus the oxygen atom can be added in the next step (to the carbon on the right, which is numbered 2), resulting in the full substructure. However, in molecule B the nitrogen atom has to be added by extending the carbon atom numbered 2 (again the left one; in  embeddings into molecule B the right carbon is numbered I) .  Hence it is not  possible to add the oxygen atom in the next step, because this would mean adding a bond starting at an atom with a lower number than the atom extended in the preceding step.

Therefore the common substructure is not found. This ex- ample also shows that it does not help to look ?one step ahead? to the next atom, because there could be arbitrarily long equivalent chains, which differ only at the ends.

If, however, we accept to reach identical substructures in different branches of the search tree in cases like this, we can correct the imperfection of our structural pruning.

Whenever we have extended an embedding by following a bond, we allow adding an equivalent bond in the next step, regardless of whether it precedes or succeeds, in the corre- sponding molecule, the bond added in the preceding step.

This relaxation explains why there are two embeddings of the substructure C-S-C into both the molecules b and c of our example. In one embedding the left carbon atom is num- bered 1 and the one at the bottom is numbered 2, while in the other it is the other way round (cf. Figure 2).

Note that considering the same substructure several times cannot lead to wrong results, only to multiple reporting of the same substructure. Multiple reponing, however, can be suppressed by maintaining a list of frequent substruc- tures and suppressing new ones that are identical to already known ones. It is more important that the missing rule for equivalent bonds can lead to considerable redundant search in certain structures, especially molecules containing one or more aromatic rings. We are currently trying to tackle this problem by collapsing rings into special vertices.

However, it should be noted that even if we could amend the weakness of our structural pruning, we would still be unable to guarantee that each substructure is considered in only one branch. If, for instance, some substructure X can be embedded twice into some molecules and if there are fre- quent substructures that contain both embeddings (and thus X twice), then these substructures can be grown from either embedding. If the connection between the two embeddings of X is not symmetric, the same substructure is reached in two different branches of the search tree in this case. Obvi- ously, there is no simple way to avoid such situations.

2.6. Embedding a Core Structure  Up to now we assumed that we start the search from a sin- gle atom. This usually works fairly well as long as this atom is rare in  the molecules IO work on. For example, sulfur or phosphorus are often good starting points in biochemical applications, while starting with carbon is a bad idea: Ev- ery organic molecule contains several carbon atoms, often twenty or more, and thus we end up with an already very high number of embeddings of the initial atom. As a conse- quence, the algorithm is likely to run out of memory before reaching substructures of reasonable size.

However, if we cannot start from a rare element, it is sometimes possible to specify a core-for instance, an aro- matic ring with one or two side chains-from which the     search can be started. Provided the core structure is specific enough, there are only few, at best only one embedding per molecule, so that the list of embeddings is short.

While it is trivial to embed a single atom into a molecule, embedding a core structure can be much more difficult. In our implementation we rely on the following simple obser- vation: Embedding a core structure is the same as finding a common substructure of the molecule and the core that is as big as the core itself. This leads to the idea to grow a sub- structure into both the core and the molecule until it com- pletely covers the core. That is. we do a substructure search for the core and the molecule starting from an arbitrary atom of the core and requiring a support of 100% (i.e.. both the core and the molecule must contain the substructure). In addition, we can restrict the search to one embedding of a substructure into the core at all times, since we know that it must he completely covered in the end. (For the molecule, however, we must consider all possible embeddings.)  Note that the same mechanism of growing a substructure into two molecules can also be used for substructure tests as they are needed to suppress multiple reporting of the same fragment (see above) as well as reporting redundant frag- ments (fragments that are substructures of some other frag- ment and have the same support as this fragment).

2.7. Finding Contrast Structures  Our approach to find frequent substructures can easily be extended to find contrasf sfrucfures. that is, substructures that are frequent in a predefined subset of the molecules and infrequent in the complement of this subset. Finding con- trast structures requires two parameters: a minimum sup- p r t  for the focus subset and a maximum support for the complement. The search is carried out in  exactly the same way as described above. The only difference is that two support numbers are determined one for the focus subset and one for the complement. Only the support in the focus subset is used to prune the search tree. The support in the complement determines whether a frequent substructure is recorded or not, thus filtering out those substructures that do not satisfy the requirements for a contrast structure.

3. Experimental Results  We applied the presented approach to a number of confi- dential data sets with substantial success. In order to be able to report results in more detail, we used a well-known, publicly available dataset from the National Cancer Insti- tute, the DTP AIDS Antiviral Screen dataset. This screen utilized a soluble formazan assay to measure protection of human CEM cells from HIV-1 infection. Full details were published in [I I]. Compounds able to provide at least 50% protection to the CEM cells were retested. Compounds that provided at least 50% protection on retest were listed as moderately active (CM). Compounds that reproducibly  Atom C Carbon 0 Oxygen N Nitroeen  CA C M  and CI 325 (100.0%) 36828 (99.95%) 311 (95.7%) 33029 (89.64%) 276 ( 84.9%) 29234 (79.34%) ? ,,  S Sulfur 11 143 (44.0%) I 10926 (29.65%) ... ... I1 I  Se Selenium 11 6 ( 1.9%) 1 132 (0.36%) Table I :  Some single-atom fragments occurring in molecules of the HIV database, together with their Occurrence frequencies.

provided 100% protection were listed as confirmed active (CA). Compounds not meeting these criteria were listed as confirmed inactive (CI). Available online [8] are screening results and chemical structural data on compounds that are not covered by a confidentiality agreement. Available are 41,316 compounds of which we used 37,171. Out of these, a total of 325 belongs to class CA, 877 are of class CM and the remaining 35,969 are of class CI.

NCI lists 75 known active compounds, which are grouped into seven classes: ( I )  Azido Pyrimidines, (2) Natural Prod- ucts or Antibiotics, (3) Benzodiazepines, Thiazolobenzim- idazoles and related Compounds, (4) Pyrimidine Nucleo- sides, (5) Dyes and Polyanions. (6) Heavy Metal Com- pounds. and (7) Purine Nucleosides.

As described above, our molecular fragment mining al- gorithm requires a seed fragment, which may be empty.

For the HIV dataset an empty core results in numerous em- beddings of trivial fragments. such as single carbon atoms or small combinations of carbon atoms only. However, fragments of interest contain at least one non-carbon atom, which enabled us to seed the algorithm using the remaining atoms. The list of atoms can be obtained through various methods. We simply started from an empty core, restricted the fragment size to one atom, and ran our molecular frag- ment miner. Parts of the resulting list of atoms together with their occurrence frequencies are listed in Table I  Obviously, due to space constraints, we cannot report in detail about seeding the algorithm with each of these atoms.

In the following we therefore concentrate on a few exper- iments to demonstrate how the proposed method picks out relevant fragments in some of these groups.

3.1. Nitrogen based Fragments  First we focus on compounds containing a nitrogen atom.

We used a minimum support of 15.0% for compounds of class CA and a maximum support of 0.1% for the comple- ment? (classes CM and CI). 171 fragments were generated  3Thresholds were selected %p-down?. i.e., starting with large rellings (that quickly resulted in no reponed fragmens) the thresholds were subne- quentially lowered until a small number of fragments was reponed.

Fragment 1 Fraamenl2 Fragment 3 C A  17.75% CA: 17.75% CA 22.46% Ct/CM: 0.061% CI/CM: 0.062% CI/CM: 0.092%  Fragment 1: CA 11.0% Fragment 2 CA 11.9% CVCM 0.3% CVCM: 0.4%  Figure 7: The two largest fragments with a sulfur atom. These fragments are common to I I of the 13 Dyes and Polyanions.

Figure 5:  The three largest fragments containing a nitrogen atom.

Fraamenl 1 #639762 (CM)  #254064 MO2670  NIN:N A 0 -A .N:N Figure 6: One pmicular compound (#254064) along with a repre- sentative of the normal structure (#602670).

within approximately 20 minutes! The three largest frag- ments found are shown in Figure 5.

Note how the first two fragments have essentially the same coverage. The only difference is one additional com- pound of class CI that contains fragment 2. In this com- pound the three nitrogen atoms are connected to the 4- carbon-oxygen ring through an intermediate carbon. This results in a fragment where the carbon connected to the three nitrogen atoms is part of a ring in all cases but one, which prevents the search algorithm from closing the ring.

The ring was closed in the first fragment. however, result- ing in one less inactive compound being covered. Figure 6 shows this specific compound along with another compound of class CA that exhibits the more typical structure.

The third fragments coverage is substantially different, even though its structure is almost identical. The only differ- ence is the double bond between two carbons that closes the second ring in the fint fragment, which is missing in Frag- ment 3. However, some active compounds have a single bond instead of a double bond between these carbons and hence not closing this ring results in a slightly smaller frag- ment with a much higher coverage. This fragment success- fully picks out compounds of class Azido Pyrimidines, a well-known inhibitor of HIV-I. Below we will discuss how "softening" the matching criteria allows us to tolerate such small differences between otherwise identical fragments, which makes this approach also more useful for chemists, who tend lo regard such structures as similar.

3.2. Sulfur based Fragments  Next we seeded the algorithm with a sulfur atom. We chose the thresholds support=lO% and complement=O.S%, which  'We used a Java implemenlalion of our algorithm on a lGhz Xeon Dual-Rocerror machine with IGB of main memory uringjrel.3.1.

#639763 (CM) @$a d* t1639767 (CA)  Fragment 2 #639764 (CI) &Q freq. CA: 33.3% freq. CI/CM: 3.0% &a I It639772 (CA)  Figure 8: Fragments (left) and corresponding compounds (right) containing a Selenium atom. The two compounds of class CA are members of the group of Heavy Metal Compounds.

generated a list of 122 fragments in under one minute. The first two (which also happen to be the largest ones with 18 atoms and 19 bonds, resp.) are shown in Figure 7.

Note how these two fragments differ only in the loca- tion of the SO3 group. Both fragments exhibit a lift of well above 25 and pick out 1 I of the 13 molecules listed as Dyes and Polyanions. We miss only two of the remaining Dyes and Polyanions (it9617 and #65849), which contain uncom- mon structures for this family of compounds.

3.3. Selenium based Fragments An interesting effect of the current method to find fragments can he seen when seeding the algorithm with a Selenium atom (Se). Figure 8 (left) shows the two fragments that are found for a minimum support of 30% and a maximum complement support of 5%.

Clearly the first fragment is sufficient to pick out all 7 compounds from the database (shown on the right of Fig- ure 8). However, the second fragment covers one compound less (#639766) and tries to complete the aromatic ring in both directions in parallel. This results in  a conflict with the nitrogen atom in compound #639766 and a fragment which is neither a subset of the other fragment nor has exactly the same coverage. For our algorithm these two fragments are therefore unique and are not pruned.

single bond # aromatic bond single bOnd = aromatic bDnd  d CBO Figure 9 Two fragments extracted from a sei of steroids. On the left, single and aromatic bonds were treated as different bond types. on the right. they were treated as the same bond type.

3.4. Treatment of Aromatic Bonds  An important aspect of molecular fragment mining is the treatment of aromatic rings. Since ammaticity is not clearly defined and can be modeled differently (i.e. explicit aro- matic bonds vs. alternating single and double bonds) it is desirable to be able to take it into account throughout the mining process itself. We achieve this by modeling aro- matic bonds as either single or double bonds with a flag that indicates aromaticity. This allows us to choose to ignore this flag during mining and hence to find fragments that contain either aromatic or single resp. double bonds. The following example illustrates why this is desirable.

Using a small set of steroid compounds we derived frag- ments that occur in ail of them (support=100%) using the standard algorithm. Figure 9 (left) shows the correspond- ing fragment. Note how only two rings with an incomplete third ring are discovered of the four ring structure that is typical for steroids. However, if we model aromatic bonds as single+flag and allow the algorithm to ignore this flag, the resulting fragment contains all four rings (see Figure 9 (right)). For some steroids this fourth ring consists of sin- gle bonds, while others have an aromatic ring at this posi- tion. However, most chemists still regard this as the same 4- ring structure. Such selective ?tolerance? against some mis- matches can therefore make the presented algorithm more useful for real applications.

4. Conclusions  We presented an algorithm to find relevant molecular frag- ments in large chemical structure databases. The algorithm allows us to focus on fragments that help to discriminate be- tween different classes of molecules. The underlying search method, which is based on a depth first search with struc- tural pruning, makes it possible to find such fragments effi- ciently, without the need for frequent reembeddings of frag- ment candidates, which is a known problem of previously reponed approaches. We have shown how the proposed method finds relevant fragments using data from a well- known HIV-screening compound database. The extracted fragments successfully model several of the activity classes known for this dataset.

Future work will focus on  making the presented approach more meaningful for the underlying application. In partic-  ular, finding fragments that match exactly is not of prime interest to chemists. As demonstrate above, some types of ring structures are considered functionally equivalent, which should be taken into account by the search algorithm as well. We are currently exploring ways to include such ?fuzziness? into the underlying search algorithm directly.

