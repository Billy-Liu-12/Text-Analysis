Modeling a Web Application for Cloud Content Adaptation with ASMs

Abstract?This paper introduces a new idea of designing Web Applications, guiding the development phases from the require- ments to the implementation. Abstract State Machines (ASMs) method is used to create ground models which describe the behavior of several agents engaged in the client-Cloud interaction.

For solving the problem of Cloud-based applications? adaptation to various channels and end-devices (in particular with respect to needs arising from mobile clients) we need to include rigorous analysis and definitions prior to code development. This implies the creation of ASM ground models based on content adaptation techniques (e.g.:server-side and client-side adaptation).



I. INTRODUCTION  In our research project we are addressing problems asso- ciated with the client side of Cloud Computing, this being highlighted by our goal of solving the problem of adaptivity to services, devices, preferences and environment in Cloud Computing. By adaptivity we understand that all the services available inside our Cloud should be adapted to the different contexts mentioned above. The formal model of the Cloud architecture we are using for retrieving the clients? services is defined in [1].

Our primary focus is to be able to describe formal models of the client-Cloud interaction. To achieve this, we started by investigating different mechanisms for the adaptation of Cloud- based applications? content to different Operating Systems (OSs), browsers, and types of devices (smartphones, tablets, laptops).

How can we make the Cloud services available on all de- vices? We need a general application that will adapt to different end-devices on-the-fly. The solution is the implementation of a Web Application which brings the services from the Cloud to the user. A Web Application can be accessed from everywhere and the user does not have to install extra tools for using it. This solves the problem of adaptivity regarding different OSs (by implementing a Web Application we no longer need to implement an application for every OS). For solving the content and presentation adaptation problem we use client and server side adaptation based on device and user information.

A. Background  For our research which is related to the creation of formal models of the clients interaction with the Cloud, we searched for a method by which we could compose abstract models that reflect the requirements and design decisions, and serve as a basis for implementation. Abstract State Machines [2] is a system engineering method which is capturing the semantics  of distributed systems with high degree of parallelisation in a formal and mathematical way. As mentioned in [2], ASMs are improving the system development by creating precise high- level modeling which is connected to executable code. Using this method, the system is described in an understandable way also for the client. When a system reaches the point of having some results, then it can be validated using the ASM specification, and its correctness can be proved. ASMs are not a new method, and this is also proved by the many industrial projects where they were applied. They have proven their usefulness by establishing the correctness of Java and C# compilers.

The ASM method defines the concept of ground model [3] by which we can realize a reliable requirements capture.

A characteristic of ground models [4] is a direct correspon- dence between the interpretation of the system requirements to be modeled and their abstract state machine representation.

Because we do not really have a strict way to prove the cor- rectness or completeness of the requirements and/or the design, the transition from informal to formal is simplified by using ground models. ASM ground models, by their characteristic, offer us the possibility of establishing correctness and com- pleteness of a model through observation and experimentation [4]. Together with the refinement method, the ASM ground models are generating a documentation which can be used for inspection, reuse and maintenance. The definition and the scheme of the ASM refinement method are presented in [2] and [5] as being some notions of equivalence of the abstract data from different state machine runs.

As we already mentioned, we want to adapt our solution to different end-devices. For achieving this, we need to dig into the content adaptation subject. The topic presented major interest for the mobile devices direction. Different solutions for cross-platform mobile development are available, like cross- platform compilers/applications, building HTML5 or HTML5 hybrid applications [6]. Native mobile applications are not applicable to our problem, because we don?t want to create a corresponding application for every mobile OS; our scope is developing a general application which respects an ASM specification.

Server-side and client-side adaptation could be used to achieve an interface which is adapted to different end-devices.

[7] explains shortly the different mobile web content adaptation techniques. The conclusion is to choose the technique that better suits the requirements. Each technique has its own advantages and disadvantages, but choosing the right one for the project in case is the proper solution. In our case the hybrid   DOI 10.1109/CLOUDCOM-ASIA.2013.76    DOI 10.1109/CLOUDCOM-ASIA.2013.76     approach suits the best, so we want to achieve something similar to what [8] presents, but still with some differences, because we intend to use the device detection database as little as possible and also the way we will use the client-side information on the server-side will be different. Responsive Design is combining the CSS media queries with the flexible images and it is using the flexible grid technique to scale the page [7]. An example of how to use Responsive Design for creating a mobile application is presented in [9].

For each of the two main content adaptation techniques which were mentioned before, server-side and content-side adaptation, it already exists frameworks or third-party tools that could be used during the development of an applica- tion. The server-side adaptation is realized with the help of the device detection databases, which are available both in the open source format (e.g.: OpenDDR [10]) and in the commercial format (e.g.: WURFL [11], DeviceAtlas [12]).

A significant difference between the open source and the commercial solutions is how often the databases are being updated. Commercial databases are more reliable, because most of them are daily updated. This is an important issue to check when a device detection database is considered, because an out of dated database could result in the delivery of erroneous data to the devices. For the client-side adaptation the ?modernizr? JavaScript framework [13] could be used. The problem of missing browser functionalities could be solved by using replacement code done in JavaScript, the so called ?polyfills?. Small visual layouts could be also solved on the client side. A big advantage of the server-side adaptation is the loading time, everything that loads on the server, will load faster [14]. When significant changes have to be done, the server offers a high-level of control in fine-tuning. Both of the above mentioned techniques are presenting limitations in discovering all the properties of a device. On the client side the physical nature of the device cannot be determined (e.g.: OS version, model, maximum HTML size), but on the server side is not possible to determine the real-time information (e.g.: GPS coordinates, device orientation). On the server side the user could cause problems in detecting the device by changing the UA (User Agent). The UA is a string available in the HTML header of a web page and it is used to query the device detection databases. A similar problem could happen on the client side, even without the intervention of the user - many browsers return false positives for certain query tests.

B. Problem  Our task is to adapt the applications deployed on the Cloud to different end-devices. In figure 1 we can observe the following situation: let?s imagine that we will deploy on the Cloud a database manager application, which could be in this case also a desktop application. The user should be able to use the application (we can think of an application as of a list of services available in the Cloud for that user) from any device he/she logs in without having to install any other application.

The problem now is how to access this application from another computer, tablet or mobile without creating specific applications for each device. Our solution proposes to create a Web Application for displaying the information to the end user and the client-Cloud interaction part to be wrapped into a middleware software in order to control the interactions between the end users and the Cloud.

Fig. 1. Problem Description  The idea is to have a formal specification for the client- Cloud interaction which will lead to the development of a prototype by refinement steps. In the end we will have a prototype containing a Web Application as the user interface and a middleware software which will realize the connection to the Cloud. The formal model should be able to express any behavior of the Web Application [15] and to abstract the parts which will make the modeling process too complex or too difficult to understand.

In this paper we propose to use the ASMs method, instead of other modeling methods (e.g.: Unified Modeling Language (UML), Finite State Machine (FSM)), for realizing the design of the client-Cloud interaction system, because its properties can guarantee that the system?s features are satisfied. ASMs method [2]:  ? is able to design and analyze both procedural single- agent and asynchronous multiple-agent distributed systems. In ASMs an action can be replaced in a refinement step by multiple parallel actions [5], which means that by going from the current state to the next state, the set of rules are executed simultaneously [3].

Because of these attributes, ASMs method was chosen over the FSM.

? creates a high-level modeling at the level of abstrac- tion and links the descriptions in a chain of coherent system models using stepwise refinement. The former characteristic improves upon the loose character of UML description, and the second one also fills in a breach in UML [2].

C. Outline  In Section II we introduce the system architecture of the client-Cloud interaction including the third-party tools that we need for transforming the data. Section III presents the ASM ground models we created for the client-Cloud interaction followed by section IV, where we show how the ground models can be refined to pseudo-code-like descriptions. In section V we conclude our work presented in this paper and describe the future work we want to achieve by completing our project.



II. THE SYSTEM ARCHITECTURE  The system architecture illustrated in figure 2 introduces the main parts of our project: the Cloud, the middleware and the client (here represented by his/her devices). We distinguish between different devices: smartphones, tablets, laptops and desktop computers, because we are interested to adapt the Cloud services interfaces to these devices. Another important thing which we took into consideration is the fact that we have to deal with different OSs and different browsers. The middleware software realizes the communication between the client and the Cloud. The client starts the interaction by logging in. After the log in, the user will select a service made available by the Cloud (a list of services will be displayed corresponding to the credentials). The middleware will forward all client requests to the Cloud and wait for the corresponding answers. Meanwhile, a device profile will be created, using the third-party tools and frameworks.

The modernizr framework will be used to create JavaScript tests which will execute on the client side and the information will be saved in the session to be accessed by the middleware software for creating the profile. If we need some extra information regarding the device, and we cannot get it using modernizr, then we use a device detection database tool, which in our case is WURFL (it deals very well in discovering the mobile devices and its API is well documented). The device profile is saved also locally on the server, to be able to reuse the information when the user logs in again from the same device. As it was mentioned before, the session is used to communicate the device details, but also for optimization.

Another reason for saving the information locally is also the client-client interaction. One client could choose to send the output of a service from Cloud to another client, which is logged in from another device, which means sending the answer from the Cloud not only to the device for which we have the profile in the session, but also to another device, for which we can read the information from the database.

When the answer arrives from the Cloud, we parse and process it using the device information. If the device does not support an image or a video format we will generate the necessary media in the proper format using again an existing third-party tool (we did not decide yet which converters we will use; this will be part of the implementation step). When the parsing and adaptation of the answer arrived from the Cloud is done, the message is send back to the device. In the case some JavaScript tests exist, they will be executed on the client side for getting new information about the device, afterwards updating the session. When the loading finishes, the message is displayed on the device.

The middleware acts like the virtual provider described in [16]. In our case we leave out for now the sending and receiving part and concentrate only on the adaptation.



III. ASM GROUND MODELS  For modeling the client-Cloud interaction and the Web Application we will use the ASM method to build the ground models as models that reflect the system?s intended behavior.

We modeled the main components of the system, such that the refinement of the abstract models will be a description of the future implementation.

We designed four models for the client-Cloud interaction including only aspects with respect to content adaptation and  displaying. One agent acts on the client side and the others on the server side.

A. Display Output Agent  Figure 3 illustrates the ASM ground model for displaying the output on the client?s device. The agent finds itself in three states, Waiting for message, Execute client tests and Displaying the message, where the first one is the initial state and the last one is the final state.

The agent starts its execution with the initial state. The messages sent by the middleware to the client are saved in a queue. If a message is available, then the agent executes the macro Decrypt message. After the decryption of the message, the flow goes further with the condition Client tests available.

The agent checks if the JavaScript code contains some tests for the device properties. If yes, then the agent goes to the state Execute client tests. This is an abstract state, because it is executed internally by the browser, and it is a durative action (there is an interval of time between starting and ending the execution). When the JavaScript execution finishes, the agent retrieves the new device information and updates the cookie, in this way communicating to the server the new values of the device properties. The flow goes to the next guard, the same as when no client tests would exist. The guard Extra resources checks if extra data (e.g.: images, videos) are necessary. If we need extra resources for displaying the page, then the system downloads them (the abstract macro Download extra resources does this action). Afterwards the agent?s state changes to the final control state Displaying the message. The same thing happens also when no extra resources are necessary.

B. Receive Request Agent  Figure 4 displays the ASM ground model for receiving the request from client on the server side.

The algorithmic idea consists in having only two control states: the initial state Waiting for requests and the final state Waiting for answers from Cloud. Again we use a queue to store the requests sent by the client. When the guard Requests available is satisfied the agent executes in parallel two actions.

One is forwarding the requests to the Cloud (this is fulfilled by the Send requests to Cloud macro) and the second one is another condition, which by using the guard Device info available in the session/cookie splits the algorithm in two main branches.

When the above mentioned condition is false, it means that this is the first request coming from the client, because we do not have the device profile saved in the session. In this case we first check to see if we have information regarding the client?s device saved locally on the server. If we find the device details on the server, then it means that this is not the first time that the user logs in from this device. In this case we retrieve the device details from the local database by executing the Retrieve the local device profile macro. The algorithm goes further with checking another condition, which is Device profile retrieved. When the device profile is available the agent writes the data in the session, such that we can easily retrieve it when a new request comes, without having to query again the database, or we can already use the information when the answer corresponding to the current request comes back from Cloud. Another reason for saving the information in the     Middleware  Client Devices  Different OSs Different Browsers Different Devices  PCs  Tablets  Smartphones  Device and Feature Detection  FrameworksAudio & Video Converter  Image Converter  Receive request  Web application  User Agent  Send requ est  Saving device & feature information  Saving feature information  Receive answer  Processes answer  uses  uses  Send answer  Feature inform ation  Device informa tion  Fig. 2. Application Architecture  Waiting for message  Message arrived Decrypt message Client tests available  Execute client tests  Yes  Update cookie profile with feature info  Extra resources  Download extra resources  Yes  No  Displaying the message  No  Fig. 3. Display Output ASM  Waiting for requests  Requests available  Send requests to Cloud  Yes  Device info available in the session/cookie  Device profile up-to-date on the server  Device profile available on the server  No  Yes  Save device profile on the serverNo  Write client tests for determining device featuresNo  Retrieve the local device profile  Yes  Device profile retrieved Update session/cookie with device info  Waiting for answers from cloud  Yes  Fig. 4. Receive Request ASM     session is the communication with the client. If there are some properties which changed since the previous user access, then we should update them with the new values. After finishing this action the agent waits for answers from the Cloud, by reaching the final control state.

If the guard Device profile available on the server will not be satisfied, then we have to write client tests for retrieving the values of all the device properties that are necessary for the code?s adaptation. To achieve this, the agent is responsible in executing the macro Write client tests for determining device features and changing its state to Waiting for answers from Cloud.

The client?s tests will be created by writing JavaScript code which will use the modernizr framework to determine the device and browser capabilities. This code will be written on the server and executed on the client when the first message from server will arrive on client side. The ASM macro for the JavaScript interpretation [17] will be contained by the Update session/cookie profile with feature info macro, which can be seen by the reader in figure 3. These tests will be written only once, when the first request comes. Because the execution will happen on the client side, the information will be available only starting with the second request to the server, when the information can be read on the server by accessing the session.

The consequence will be, that the first page displayed on the client?s device will be a simple page, that will render on the device only using the browser abilities.

In this ground model we also have the option when the request in case is not the first one coming from the client, which means that we already have the information available in the session. The agent has to check if the device is ?new?, if this is the first time when the user logs in using the device from which the request came. This condition is fulfilled by the guard Device profile up-to-date on the server. If we already have the device information available in our local database and if no property needs to be updated, then the agent goes directly to the final state. In the case the device local information is not up-to-date, or is not at all available in the local database, then we go on by saving the device profile locally or by updating the corresponding properties (the agent executes the macro Save device profile on the server). At this point, the agent reaches the final state.

C. Receive & Process Answer Agent  The algorithm presented in the ground model from figure 5 lines up the steps done after the answer comes back from the Cloud. The agent finds itself in four different control states: Waiting for answers from Cloud, Filter and adapt content, Message format transformed, Send answer to client.

The starting control state is Waiting for answers from Cloud and the final state is Send answer to client.

The agent waits for answers from Cloud after it finished the preparation for the adaptation of the code. The answers coming from the Cloud are also kept in a queue, so when there are elements inside, the agent should pick up the first answer and start processing it. This means that the agent can go further when the condition Message available is fulfilled. The first verification done after we have an answer from the Cloud, is to check if the format of the code is supported, which means, we check if the answer is written as HTML content (this check is contained by the guard Message format supported). If the  message format is not supported, we will have to transform it in an HTML or XHTML format. The format should be supported by the browser installed on the device. By executing the macro Transform the message format (html/xhtml), the agent goes to the state Message format transformed.

If we have a format which can be displayed in the browser, we go further by investigating if the device details are available. The corresponding condition for this is Device information available. What is this guard actually doing?

It checks to see if the device profile is available in the session. If this is the first answer coming from Cloud, the one corresponding to the first request from client, and this is also the first time when the user logs in from the corresponding device, then the information will not be available in the session.

The flow goes on with the next condition, without adapting the HTML code. In this case, the first page will be displayed on the device in its original state. As mentioned before, we will let the browser to deal with the small adjustments (we will design a very simple and general page) necessary for displaying the first page.

If this is not the first request, then we retrieve the infor- mation available in the session, by using the macro Retrieve device information and set the agent?s state to Filter and adapt content. This action is replaced in a refinement step by multiple parallel actions (described by the ground model in figure 6). After the adaptation finishes the agent reaches the same condition as the one reached when the device information is not available.

The guard Client tests per request necessary checks if we need to write extra JavaScript code to test the device capabilities which can change by every request. For example, we might need to use the GPS location in our page. GPS information is something that could change each time the user makes a new request, because he/she might change his/her position (imagine that the user is in a train or a car, when accessing the Cloud). If there are no tests per request required, the agent has one more step to do before going to the final state, which is Encrypt message. When this macro is the executed the control state Send answer to client is reached. If the agent has to create tests per request, then the macro Write client tests for the properties changeable at every request is executed.

The agent goes then to the next condition which is given by the guard Client tests per requests finished. Using this guard, the agent checks if everything is ready for encryption, if the JavaScript tests are finished. The same flow as for the ?No? branch follows, the macro Encrypt message is executed and the final state is reached.

D. Filter & Adapt Content Agent  In [18] we can see how we can specify with ASMs the parsing of an HTML code. We will continue that work to make it suitable for our problem. In our case we will have to design a general HTML parser which will check every HTML attribute, for every page coming from the Cloud.

In figure 6 we can observe the algorithm of the Filter and adapt content model, which was mentioned as a control state in the previous ground model (figure 5). This ASM ground model contains five control states, in which the agent can reach: Parsing the content, which is also the initial state, Waiting for device information, Resources ready, Element adapted, and the final state Content adapted.

Waiting for answers from Cloud  Message available  Message format supported  Transform the message format (html/xhtml) No  Message format transformed  Device information availableYes  Retrieve device information  Yes  Filter and adapt content  Client tests per request necessaryNo  Write client tests for the properties changeable at every request  Yes  Client tests per request finished  Encrypt message  No  Send answer to client  Fig. 5. Receive and Process Answer ASM  Parsing the content  Elements available Device profile contains the elementYes  Ask 3rd-party tools for device information  No  Waiting for device information  Update device profile on the server  Update session/cookie with device info  Extra resources needed  Yes Generate resources (images/videos)Yes  Resources ready  Adapt elementNo  Element adapted  Content adapted  No  Fig. 6. Filter and Adapt Content ASM  The adaptation algorithm starts with the parsing of the HTML content. This content represents the answers which came from the Cloud. At the beginning, the agent checks if there are elements available for adaptation. This check is done by verifying the queue where the HTML elements are inserted by parsing the content. If there are elements available, then the agent goes to the next condition Device profile contains the element. In this case the agent verifies if there already exists information regarding the chosen element.

If the device profile does not contain the element, then a device detection database third-party tool is used. A query containing the specific element is sent to the device detection database.

When the agent reaches the macro Ask 3rd-party tools for device information the state changes to Waiting for device information. This is also a durative action and depends on how fast the device detection database returns the result. When the  answer from the device database tool comes back, the agent acts in parallel by executing two macros and stepping further to the guard Extra resources needed. The information from the device database is used to Update device profile on the server and Update session/cookie with device information. We update the information in the session and in the local database, because, in this way, we will not have to query again the third- party tool regarding the same HTML element for the possible future requests.

We decided to use the existing device detection database, and not creating our own database, because this would cost us a lot of time, mainly because of the database maintenance, and this is not the scope of our project.

The algorithm goes further with the condition Extra re- sources needed. Under this condition the agent checks if the element?s (for example, an image or a video) format is     supported by the browser running on the current device. If not, then we will use again a third-party tool to Generate resources (images/videos). The same thing as in the case of the existing device detection database tool, we do not want to implement our own image/video converters, because there are already available tools for this task, and this is not part of our research project. When the resources are generated, the current control state is updated to Resources ready. The next step is the same as the one when no extra resources are needed.

The Adapt element macro does the job of changing the HTML element corresponding to the device profile. If, for example, we would have to display a very complex list on a smaller device, on which the user should scroll too much for seeing the information, then the list should be changed by eliminating the not so important information and make it expandable, such that the user could easier read the information and reach faster the information which is interesting for him/her. Another example would be the replacement of an image which is not supported by the browser/device with the newly generated image. By executing this last macro the agent sets the state of each element to Element adapted. We need to change the state of each element, because in this way we will know when all elements were parsed and adapted. The agent goes to the final state, Content adapted, when all elements reach the state Element adapted.



IV. THE USE OF ASM GROUND MODELS  In the previous section, the Web Application?s constraints/assumptions were expressed by the creation of ASM ground models. Our scope includes the development of a flexible and extendable piece of software by using successive refinement steps that adapt the abstract models to changing requirements. The requirements change based on the device that is querying the Cloud services.

For reaching the compilable code we need to define the macros mentioned in the ground models by using pseudo- code-like descriptions. Typically, there are necessary more steps to reach the code, because we start with a not so precise model and we gradually introduce more details with each step, taking into account the requirements of the system [3].

Below we exemplify how we refined the Display Output Agent ground model from figure 3 by describing the agent?s signature and the ASM macros.

First, we introduce the agent?s signature. The ctl state={Waiting for message, Execute client tests, Displaying the message} variable represents the agent?s states and has as initial value the state Waiting for message.

The queue messages(self) registers the messages that are coming from the middleware; its initial value is the empty set. By cookie(deviceProfile) ? COOKIE we store the device profile, where the set COOKIE contains key ? value elements (initial value = undef ).

headPage:messages(self) ? html is a function that returns the html text that is available for reading at the head of the queue containing the messages sent by the middleware.

Its initial value is undef . Modernizr represents the set of features tested by using modernizr framework. And below are the definitions of the macros.

CLIENTDISPLAYOUTPUTMACROS = if MESSAGEARRIVED then  DECRYPTMESSAGE  if CLIENTTESTSAVAILABLE(headPage( messages(self))) then ctl state := executeClientTests UPDATECOOKIE  end if if EXTRARESOURCES then  DOWNLOADEXTRARESOURCES end if ctl state := displayingTheMessage  end if  Where, MESSAGEARRIVED = (messages(self) ?= empty) DECRYPTMESSAGE - abstract CLIENTTESTSAVAILABLE(page) =  (?t ? htmlTags tagName(t) = ?SCRIPT? and CONTAINSMODERNIZRTESTS(t))  CONTAINSMODERNIZRTESTS(scriptTag) = if hasAttribute(scriptTag, src) then  let url = valueOfAttribute(scriptTag, src) in ?c ? contentOfFile(url) c = ?Modernizr.addTest?  else ?c ? contentOfTag(scriptTag)  c = ?Modernizr.addTest? end if  EXTRARESOURCES = (extraResources ?= empty) DOWNLOADEXTRARESOURCES - abstract UPDATECOOKIE = if ctl state = executeClientTests then  for all f ? self.Modernizr do insert f into self.cookie(deviceProfile)  end for end if  CLIENTTESTSAVAILABLE macro verifies if there are mod- ernizr tests defined in the JavaScript part of the page. The tests can be declared directly in the SCRIPT section of the page (we search using the tagName function) or through another JavaScript file (we check using the valueOfAttribute function), using the ?Modernizr.addTest? method available in the modernizr framework.

UPDATECOOKIE macro parses all the features provided by the modernizr framework, after the client?s tests were executed, and creates the agent?s cookie.

By building an abstract model from the requirements, which satisfies the CoCoCo-properties: Consistency, Correct- ness and Completeness [3], we can check whether the Web Application satisfies the requirements [15]. To fulfill these properties, it means to directly solve the following problems: communication, verification and validation. Using ASMs for ground models we can satisfy the properties mentioned before.

The simplicity and generality of the ASMs language solves the communication problem. The verification problem can be solved by applying standard (pseudo-)code inspection and reasoning. The validation of ASM models can be realized by simulation of the ASM runs using the existent tools [2] (e.g.: ASM Workbench [19], .NET-executable AsmL engine [20]).

We will use CoreASM1 to simulate the implementation and  1CoreASM is an Eclipse plugin, which gives the possibility of writing an executable ASM - http://sourceforge.net/apps/mediawiki/coreasm/index.php?

title=Main Page     execution of the ASM macros mentioned in the ground models.



V. CONCLUSION  In this paper we have presented the ASM ground models of a content adaptation system used for the interaction between the client devices and the Cloud. Every application deployed on the Cloud will be treated as a service available for the users. The user should be able to connect from any device, smartphone, tablet, laptop or desktop computer, and use his/her services without having to install any extra application on his/her device. In this paper the readers can discover how the client-Cloud interaction can be represented using ASM ground models and how these models are useful in the further development. We identified four different agents, which will execute the algorithms defined by the corresponding ground models. The project?s novelty is not only the creation of a general system for the interaction between the client and the Cloud, which adapts to different end-devices, but mostly the fact that this system, formed by a middleware software and a Web Application, is design by using a formal modeling method, which can be also used for the system?s verification and validation.

The next step in our research will be the refinement of all the ASM ground models presented in this paper, as we did in session IV, which means that we will go on with writing the ASM macros, refine them and finally reach the development phase. The refinement of the ASM macros will lead to the system prototype?s implementation.

Future research includes the specification of the adaptation rules for each HTML element corresponding to different categories. It is not mandatory to have a different rule for every device, we could also define a rule per group/category.

[21] and [22] are also dealing with HTML adaptation, by using the DOM content extraction and rule repositories, respectively by adopting description logics for the creation of a hierarchical ontology. In our case, the rules will be specified in terms of ASMs.

