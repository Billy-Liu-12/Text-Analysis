Analysis of Effectiveness of Apriori Algorithm in  Medical Billing Data Mining1

Abstract? Apriori  algorithm  has  been  successfully  used  for finding  the  frequent  item sets  in  retail  data.  This  research  is about finding associations between diagnosis and treatments. It has shown that the algorithm is equally beneficent for finding the large  item  sets  and  thus  generating  the  association  rules  in medical  billing  data.  Resemblance  between  medical  bill  and purchase bill is the motivation of using Apriori algorithm in this research  work.  Healthcare  is  a  data  rich  domain.  Medical practices,  insurance  companies  and  other  health  related organizations  have  collected  huge  volumes  of  data,  thus attracting  data  mining  researchers  to  explore  it  and  find something beneficent from it.

Keywords: Data mining, Association rules, Medical billing

I.Background Association  rule  mining,  one  of  the  most  famous  techniques of data mining, was first introduced in [1]. It aims to extract associations   among sets of items in the transaction databases or other data repositories. The formal statement of association  rule  mining  problem  was  first  stated  in  [1]  by Agrawal et al. Let I={I1, I2, ? ? ? , Im} be a set of m distinct items; T be a transaction that contains a set of items. D is a database with different transaction records. An association rule is an implication in the form of X?Y, where X, Y are sets of items called itemsets. X is called antecedent while Y is called consequent.  The  rule  means  X  implies  Y.  There  are  two important  basic  measures  for  association  rules;  support  (  ) denoted as s and confidence ( ) denoted as c. Support ( ) of an association rule is defined as the percentage/fraction of records that  contain X and Y to the total  number  of  records  in  the database. The count for each item is increased by 1 every time the item is encountered in different transaction of database D during the scanning process. It means the support count does not take the quantity of the item into account. Confidence of an association  rule  is  defined  as  the  percentage/fraction  of  the number  of  transactions  that  contain  X  and  Y  to  the  total number of records that contain X. If the percentage exceeds the predefined threshold of confidence then X?Y is an interesting association rule.  Confidence  is  a measure of strength of  the association  rules.  Association  rule  mining  is  to  find  out association rules that satisfy the pre-defined minimum support and  confidence  from  a  given  database  [2].  The  problem is usually decomposed into two sub-problems. One is to find the itemsets whose occurrences exceed a predefined threshold in the database; the itemsets are called frequent or large itemsets.

The second problem is to generate association rules from the large itemsets with the constraints of minimal confidence.

A. Healthcare IT (HIT) Application  of  information  technology  in  Healthcare  domain has  emerged  as  a  new multi-million dollar  industry.

Huge  investments  being  made  by  many  government,  and private  organizations  to  produce  health  related  tools.  EMR (Electronic Medical  Record) also known as EHR (Electronic Health  Record)  is  one  of  the  major  healthcare  IT  software, being used by medical  providers.  Similarly a  lot  of  revenue being generated by those IT organizations, which are related to healthcare. Top company of 2003 ?GE Healthcare? founded in 2000  has  annual  revenue  of  $2.7  billion.  And  the  100th company ?MED 3000 Inc.? (Founded in 1985) has $7.3 million annual revenue [3].



II.Adaptation of Apriori Algorithm Apriori  algorithm famous  for  finding  frequent  item sets,  initially used in sales ? purchase domain, now being tested and utilized in various domains. This basic algorithm has proved to be the starting point of all association rules mining algorithms.

A. Apriori Algorithm Apriori algorithm based on a priori property of data i.e. all  the subsets of a frequent itemset are always frequent. So when a  k-itemset  is  not  frequent,  it  is  not  used  for  generating candidates of k+1-itemsets. Basically there are two parts of this rule  generation  algorithm.  At  the  end  of  first  part,  frequent itemsets (i.e. having support greater than minimum support) of maximum size are returned. Items in each itemset are assumed to be lexically sorted. Then a simple approach is used i.e. to generate rules from these frequent itemsets by finding there all subsets.

B. Modifications in Apriori Algorithm In order to meet the requirements two main modifications  have been done in Apriori algorithm in this research work, one modification in main Apriori algorithm and other modification in rule generation algorithm. First of all an additional argument G, which is a set of items given by the user as antecedent, is passed to the algorithm.  In candidate generation those itemsets are kept as frequent  itemsets which are being closed i.e. not being able to combine with any other k-itemset. So these closed  ______________________________ This work is supported by Higher Education Commission (HEC) of Pakistan  under 5000 Indigenous Scholarship Scheme  IEEE-ICET 2008 Rawalpindi, Pakistan, 18-19 October, 2008     itemsets  are  kept  in  all  iteration  of  finding  the  frequent itemsets.  At  the  end  first  phase  results  in  frequent  itemsets (have  support  greater  than  minimum  support)  of  unequal length  are  returned.  Then  in  the  second  phase  instead  of considering  all  the  subsets,  of  each  frequent  itemset,  as antecedent only the given G is considered as antecedent and F- G as consequent (where F is a frequent itemset). Rule is saved if it qualifies the minimum support and minimum confidence criteria.  Modified  Apriori  algorithm is  shown below as  lisp version of Apriori-modified algorithm.

C. Prototype Software For  the  research  purpose,  prototype  software  has  been  developed  in  Allegro  CL 3.0.2  version  of  Lisp.  A  total  of approximately  75000  records  loaded  with  this  software.

Apriori and Apriori-modified algorithm applied on total 16487 records of claims and charges combined. All this data is stored in  the  form  of  text  files  and  loaded  in  the  memory  when software runs. Requirement of data in the memory is one of the weaknesses of Apriori algorithm which has not been overcome in this research work. All the internal memory management of the data structure has been done by Lisp itself.

Front  end  of  the  software,  consists  of  a  main  starting window. Rule generation feature is provided on claim window, which is also used for displaying the claims. Note that there exists no form for data entry, saving the records. The data entry is assumed to be done by the provider from the EMR.

Data used in this prototype software is fully anonymous.

Patient  demographics  (i.e.  patient  personal  information) although  part  of  data  base  design  but  not  populated  with records,  for  Protected  Health  Information  (PHI)  security reasons. Currently there is a single rule generation window, but during  testing  the  need  of  multiple  rule  generation  and association visualization windows is realized. User gives one or  more  initial  International  Classification  of  Disease  (ICD) also  known  as  Diagnosis  Code  (DxCode)  and/or  Current Procedure  Terminology  (CPT)  code  which  are  used  as antecedent of all the rules. User also mentions the minimum threshold frequency and confidence criteria. Association rules are  generated  using  Apriori-modified  algorithm.  Payment values  (total  and average  charged  amount,  paid amount and due amount) are also calculated for all the association rules. In graphical window these association rules are displayed in the form of bar graph shown in Figure 2 and Figure 3. Each value has  been  made optional,  by  providing  a  check  box,  for displaying or not displaying in the graph. Further user can sort all the rules in ascending or descending order on the basis of any of the attribute values. Lisp version of Apriori-modified algorithm and its related functions are given below;  (defun apriori-modified(support confidence &optional (database *ex-database*) items) (do* ((k 1 (+ k 1)) (Ck (if (null items) (mapcar #'list  (all-single-intemsets database))) (Candidates (mapcar #'cdr  Fk))) (Fk (prune Ck support database)  (prune Ck support database)) (ans nil) ) ((null Fk) (remove-redundent-items ans)) (setq ans (append ans FK)) ) )  (defun find-all-association-rules-modified (&optional (support 0.0) (confidence 0.0) (database   *ex-database*)) (generate-rules (APRIORI-MODIFIED support confidence  database)  confidence support  database))  (defun generate-rules-for-given-antecedent (G &optional (minsup 0.0) (confi 0.0) (database *ex-database*)) (let* ((SDB (remove-if #'(lambda(a) (not (subsetp G a :test  'equalp))) database )) (IS (all-single-intemsets SDB )) (substs (cons nil (generate-all-subsets  (set-difference IS G :test   #'equalp)))) (Rules nil) (dblen (length database)) (sdblen (length SDB)) (supp1 (float (/ sdblen dblen))) ) (do ((A substs (cdr A)) (supp2 nil ) ) ((null A) Rules) (if (null (car A)) (setq supp2 (float (/ (count G SDB :test #'ex-equal) dblen))) (setq supp2 (float (/ (count (car A) SDB :test #'subsetp) dblen)))) (if (and (>= supp2 minsup) (>= (/ supp2 supp1) confi) ) (setq Rules (cons (list (/ supp2 supp1) supp2 supp1 G (car A)) Rules))) )))  (defun Candidates(Fk) (do ((A Fk (cdr A)) (ans nil) ) ((null A)  (remove-duplicates (remove-if #'null   ans)  :test #'(lambda(x y) (and (subsetp  x y :test #'equalp ) (subsetp  y x :test #'equalp)))))  (setq ans    (append ans (mapcar #'(lambda(bb) (if (and (equal (length (car A)) (length bb)) (some #'(lambda(x) (subsetp (remove x (car A) :test 'equal) bb :test 'equal)) (car A)) (some #'(lambda(x) (subsetp (remove x bb :test 'equal) (car A)  :test 'equal)) bb) (not (subsetp (car A) bb :test 'equal)) (not (subsetp bb (car A)  :test 'equal)) ) (remove-duplicates (append (car A) bb) :test #'equalp) )) (cdr A)) ))) )  (defun prune(Ck support &optional (database *database*)) (do ((A Ck (cdr A)) (ans nil) ) ((null A) (remove-if #'(lambda(x) (< (car x) support))  ans )) (setq ans (cons  (cons (float (/ (find-frequency (car A) database) (length  database))) (car A)) ans)) ) )  (defun all-single-intemsets(&optional (database *ex- database*)) (remove-duplicates (apply #'append database)  :test #'equal) )  (defun find-frequency(ele &optional (database *ex- database*)) (count-if  #'(lambda(x)  (subsetp ele x  :test #'equalp)  ) database) )  D. Rule format Logically a rule is an implication i.e. if__then__ construct.

Condition part is known as antecedent and then part is known as consequent. In prototype software of this research work a rule  is  represented  by  a  list  of  thirteen  values,  including antecedent  and  consequent.  Format  of  the  rule  and  its associated values is shown below;  (Confidence,  Support,  Total_Adjusted_Amount, Total_Due_Amount,  Total_Paid_Amount, Total_charged_Amount,  Average_Adjusted_Amount, Average_Due_Amount, Average_Paid_Amoun,  Average_Charge,_Amount,Claim_no_List, Antecedent Consequent)  Antecedent and consequent are given at the end, are the list of ICD and/or CPT codes. Antecedent list is given by the user  while  consequent  list  is  generated  by  Apriori-modified algorithm.

Claim_no_List is the list of those claim numbers which are supporting this rules i.e. both antecedent and consequent  codes are present in those claims. All the payments values show the payment  pattern  for  those  codes  which  are  present  as antecedent and consequent. These values are shown graphically in Figure 2 and Figure 3.

Support of all the generated rules is always greater than the MinSupport  entered by the user.  Similarly confidence,  value stored as first element of rule list, is the ratio between number of  claim  records  containing  both  antecedent  and  the consequent,  with  the  number  of  records  containing  only antecedent. For some rules it is shown in Figure 1.

Figure 1 Graphical From Showing Confidence of Each Rule  Figure 2.  Graphical Form Showing Total Amounts  Figure 3 Graphical Form Showing Average Amounts

III.Results As mentioned by Agrawal  [2],  Apriori  algorithm can be  used  for  laying  the  foundations  many other  rule  generation algorithms in future. It has been proved that Apriori algorithm is good in finding the frequent item sets of large size. But still modifications are required to adopt it to the requirements (as done in this research work).

Apriori  algorithm generates Boolean association rules. In this research work payments values has been associated with each rule,  hence quantitative processing can be done on the basis  of  any  of  these  payment  values.  This  is  one  of  the possible future enhancements,  which has been mentioned by Agrawal in [2], and implemented in this research.

A. Discovered Characteristics of Medical Billing Data Data of every domain has its own characteristics; this was  the basic intuition behind applying same algorithm (with some modification)  in  different  domain.  During  testing  following characteristics of medical billing data have been found;  1)Small range of size of itemsets In database of retail store one transaction or itemset can has  maximum of as many items as is the total number of unique items. This affects the rule generation part of Apriori algorithm which  is  exponentially  based  on  the  size  of  itemsets.  This limitation  is  not  affecting  due  to  ?small  sized  itemset? characteristic of billing data. An itemset (i.e. claim) consists of a  minimum of  two codes  (one  DxCode and  one  CPT)  and maximum  of  ten  (maximum  four  DxCode  and  six  CPT).

Although there is no restriction on number of CPTs applied but existing sample of data does not have more than six CPTs in one claim.

2)Low frequency of individual items Because of the fact that a billing company accumulates data  from practices of different specialties, no CPT or ICD code has large  frequency.  But  if  we  take  sample  of  data  from  one practice it will give relatively higher frequencies.

The maximum frequency of CPT codes is 25 %, with only 3  CPTs  greater  than  10  %  frequency  and  26  CPTs  with frequency greater than 1 %, while remaining CPTs (a total of 3748) have frequency less than 1 %. Top 5 frequent CPTs are shown in table 1 below;  TABLE 1 . TOP 5 FREQUENT CPTS  SR Code Description Frequency 1 99213 OFFICE/OUTPATIENT VISIT, EST 25.511 % 2 99313 SUBSEQ NURSING FACILITY  CARE - LEVEL 3 15.24 %  3 99214 OFFICE/OUTPATIENT VISIT, EST 11.38 % 4 99333 DOMICILIARY/HOME VISIT;  ESTAB PT-LEVEL 3 9.001 %  5 99203 OFFICE/OUTPATIENT VISIT, NEW   6.38 %  Maximum frequency  of  DxCodes  is  15  %  with  only  3 DxCodes greater  than 10 %. There are  56 DxCodes having frequency  greater  than  1  %.  Top  5  frequent  DxCodes  are shown in table 2 given below.

TABLE 2.  TOP 5 FREQUENT DXCODES  SR DxCode Description Frequency 1 401.0 MALIGNANT ESSENTIAL  HYPERTENSION 15.18 %  2 250.0 DIABETES MELLITUS WITHOUT COMPLICATION TYPE II OR  UNSPECIFIED TYPE NOT STATED AS UNCONTROLLED  11.50 %  3 401.1 BENIGN ESSENTIAL HYPERTENSION  10.50 %  4 428.0 CONGESTIVE HEART FAILURE UNSPECIFIED  5.43 %  5 272.0 PURE HYPERCHOLESTEROLEMIA  5.00 %  Note that  in rule generation process  only those rules are selected  in  which  combined  frequency  of  antecedent  and consequent  is  greater  than  the threshold frequency  given  by user. If we use most frequent DxCode as antecedent and most frequent CPT as consequent, their combined frequency is 1.93 % which is lower than the expected value.

The highest  combined frequency  is  3.29 % which is  for DxCode 401.0 and 250.0.  While the combined frequency of most frequent CPT code (i.e. 99213) is 2.784 %, which is with DxCode 401.1. Thus we don?t expect any rule with frequency (support) higher than 5 %.

3)Regular patterns in payment values The prototype  software developed for  this research work  does  not  only  finds  the  associations  between  DxCodes  and CPTs  but  also  shows  us  payments  patterns  against  those associations. Payment record has four values, first one Charged Amount, it is the amount charged, or claimed by the provider in a  patient  claim,  it  is  always  highest  among  other  payment values,  second  one  is  the  adjusted  amount  it  is  that  part  of charged amount which is removed, rejected, or not paid by any of the payers. Third value is the paid amount, which refer to that  amount  which  is  paid  by  any  of  the  payers  (normally primary insurance of a patient).  Fourth value is due amount, which represent the pending amount of a claim. Initially all the charged amount is due amount. But mostly after payment from primary insurance, some part of charged amount is left as due amount, which is later on paid by secondary insurance or the patient himself/herself.

During  the  result  analysis  phase,  it  is  revealed  that charged amount has relatively less consistent pattern. On the other  hand  paid  amount  appears  to  be  more  systematic  and having consistent patterns. That might be due to the reason that any  insurance  carefully  analyze,  evaluate,  and  process  the claims before making a payment.

B. Empty Rule Generation Rule  generation  part  of  Apriori  algorithm  has  been modified  to  generate  empty  rules.  In  an  empty  rule consequent  part  of  the  rule  is  empty  or  nil,  and  the antecedent  part  provided  by  the  user.  A  greater confidence value of such a rule tells the medical service provider not to add any further code to the claim.



IV.Future Possibilities  There are a lot of possibilities and room for future research work. Some of them are mentioned below.

A. Multiple Rule Generation Current  prototype  software  has  one  rule  generation  window, but during the testing it was realized that it would be better  to  have  multiple  rule  visualization  windows  for  one algorithm  and  multiple  rule  generation  algorithms  can  be implemented. This will give us a comparative view of outcome and the performance of rule generation algorithms.

B. Diagnostic Decision Support Decision support in diagnosing process is an old research  area, but up till now it has been constrained by the dependency on human medical experts for the population of knowledge in the  system.  Now  data  mining  features  embedded  in  such systems,  will  add  up  another  dimension  view  in  diagnostic decision making process.

C. Distributed Data Mining At billing company data from all practices is collected. A  provider  can  perform  data  mining  operations  on  its  own practice side by using the EMR. This can be extended to the data mining operations on the data of the billing company, a global database. Results of the data mining operations on the global  database can be sent,  compared and utilized with the data mining operations on local database of a single practice.



V.Conclusion After having all the results and trying different approaches,  it is found that it is a priori property (i.e. a frequent set can only be  generated  from  frequent  subsets)  which  makes  Apriori algorithm  good  for  finding  frequent  itemsets  from  billing database.  Although some modifications have been made in the  algorithm  to  cope  with  the  requirement,  but  basic  rule generation process is same as that of Apriori algorithm.

It is found that use of high level language can overcome the requirement of lexical sorting of transaction records, which was one  weak  point  of  original  implementation  of  Apriori algorithm. Further the use of higher level  language like lisp, can allow us to associate some quantities (like payments) with association rules and thus perform quantitative analysis in rule generation process. But these higher language features may be costing some response time.

There is a margin of improvement in rule generation part of Apriori algorithm as currently it is exponentially based on the size of itemsets. This weakness is not affecting the performance of the prototype software developed for this research due to the ?small itemset size? characteristic of billing database.

Decision  support  module,  based  on  Apriori-modified algorithm, is useful for increasing the consistency of charged amount thus can improve payments. And due to less processing time on insurance side it will reduce aging of claims.

Acknowledgements Many  thanks  to  Dr.  Mohammad  Jamil  Sawar  and  Mr.

