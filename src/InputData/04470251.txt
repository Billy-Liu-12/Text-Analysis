Mining statistical information of frequent fault-tolerant patterns in transactional databases

Abstract  Constraints applied on classic frequent patterns are too strict and may cause interesting patterns to be missed.

Hence, researchers have proposed to mine a more relaxed version of frequent patterns, where transactions are allowed to miss some items in the itemset they support. Patterns exhibiting such ?faults? are called frequent fault-tolerant patterns (FFT-patterns) if they are significant in number. In this paper, the term ?pattern? is distinguished from ?item- set? as referring to a pair (tidset ? itemset).

Unlike classical frequent patterns, the number of FFT- patterns grows exponentially not only with the number of items, but also with the number of transactions. Since the latter may reach millions, mining FFT-patterns by enu- merating them becomes infeasible. Hence, the challenge is to represent FFT-patterns concisely without losing any useful information. To address this, we draw on the ob- servation that, in transactional databases, the transactions themselves are not important from the data mining point-of- view; i.e. researchers are interested in finding itemsets con- tained in lots of transactions, rather than in the transactions per se. Therefore, we propose to mine only the frequent itemsets along with the statistical information of the sup- porting transaction sets, rather than enumerate entire FFT- patterns. Then we present our approach - the BIAS frame- work, consisting of Backtracking algorithm, Integer Linear Programming (ILP) constraints, and aggregation statistics to solve this problem. Algorithms under this framework not only increase the efficiency of the FFT-patterns mining pro- cess by more than an order of magnitude, but also provide a more comprehensive analysis of FFT-Patterns.

1 Introduction  The frequent patterns mining problem [2] has been widely studied in data mining. Some researchers use the  terms pattern and itemset interchangeably, but in this paper, we distinguish the term pattern as pair (tidset ? itemset) instead of itemset only.

a, b4  a, b, d3  b, c2  c, d1  ItemsetTID  a, b4  a, b, d3  b, c2  c, d1  ItemsetTID      dcba      dcba  Figure 1. Transactional database: table and matrix form  Yang et al [14] argued that analysts would find it use- ful to mine groups of similar transactions that share most of the items, but these cannot be discovered by traditional approaches due to their harsh definition of support. Hence, they proposed to mine a more relaxed version of frequent patterns, where transactions are allowed to miss some items in the itemset they support.

Patterns significantly supported in such a manner are called frequent fault-tolerant patterns (FFT-patterns for short). Let us consider the transactional database as shown in Figure 1, which will be used as a running example in the rest of this paper. The database consists of a set of transactions (henceforth called tidset for brevity) over an itemset, and is illustrated in table and matrix forms. Here, we highlight some examples of FFT-patterns. We can see that when supporting transactions are allowed to miss one item in the itemset they support, three transactions, viz.

2, 3, 4 support itemset {a, b}; when supported items are al- lowed to be missed by one transaction in their supporting set, itemset {a, b, c, d} is supported by tidsets {1, 3}, {1, 4} and {2, 3}; and when three such transaction-item misses are allowed in a pair (tidset ? itemset), ({2, 3, 4} ? {a, b, c}), ({1, 2, 3}?{b, c, d}), ({2, 3}?{a, b, c, d}) satisfy the crite-   DOI 10.1109/ICDM.2007.48    DOI 10.1109/ICDM.2007.48    DOI 10.1109/ICDM.2007.48    DOI 10.1109/ICDM.2007.48    DOI 10.1109/ICDM.2007.48     ria. These examples while not comprehensive, illustrate the variety of FFT-patterns.

Consequently, several definitions of FFT-patterns have been proposed [9, 10, 12, 3, 6, 7, 8, 11] to accommodate this diversity. However, a general problem with FFT-patterns is that they not only grow exponentially with the number of items, but also with the number of transactions. Since the number of transactions may reach millions, this implies that mining FFT-patterns is infeasible. Several approaches have been proposed to tackle this problem: [9, 14] relax the constraints, while [3, 10] add more constraints, and [14, 7, 8] perform approximation. Nevertheless, all of these approaches either still produce too many results, or might lose interesting patterns.

In transactional databases, the transactions themselves are not important from the data mining point-of-view, i.e.

the interest is in finding itemsets which are contained in a lot of transactions, instead of finding the transactions them- selves. Therefore, we propose to mine all frequent itemsets, along with the statistical information of the supporting- transaction sets (formally defined in section 3.1). We choose this approach because (1) this approach doesn?t lose any interesting itemsets (no false negatives), and (2) we find that the statistical information can concisely describe the characteristics of huge data.

In this paper, we formulate the general definitions of FFT-patterns in terms of basic relaxation criteria, and show how new and existing variants of such patterns can be formed from combinations of those criteria. Then we present our BIAS framework1, consisting of Backtracking algorithm, Integer Linear Programming (ILP) constraints, and aggregation statistics to solve this problem, and demon- strate its application for all problem variants. Note that ILP is used here to define constraints of a combinatoric prob- lem, and not to optimize an objective function as in usual LP. This framework can be used to mine statistical informa- tion of the FFT-patterns efficiently without generating the patterns themselves.

The rest of this paper is organized as follows. Section 2 discusses previous works related to the problem of FFT- patterns mining, and links them to the variants described in our paper. Section 3 presents the general problem defini- tion, and shows how variants of FFT-patterns can be derived from constraints. Section 4 describes the BIAS framework to mine frequent itemsets as well as the statistics of their supporting-tidsets, and algorithms under this framework are explained in detail for each variant in section 5. These ap- proaches are compared with related techniques, and section 6 shows the experimental results of these comparisons. Fi- nally, section 7 concludes with some directions for future work.

1BIAS is an acronym for Backtracking, Integer linear programming, and Aggregation Statistics  2 Related Work  Pioneering work in FFT-patterns mining was by Yang et al [14] in 2001, where the amount of relaxation is pro- portional to the size of the pattern. An FFT-pattern, also called strong-ETI, is defined as a sub-matrix of itemset and transaction-set, where each transaction contains a certain proportion of the itemset. Besides [14], other papers min- ing FFT-patterns using proportion are [10, 7, 8]. In [10] and [14], the objective is to find interesting patterns, while [7] and [8] aim to approximate the pure frequent itemsets in a noisy data.

FFT-patterns mining with proportional relaxation, though natural, is intractable [3], because this problem lacks the anti-monotonicity property2 of itemsets. With anti- monotonicity property, we can safely stop extending an itemset once it is not frequent, so the mining complexity is proportional to the number of frequent itemsets. This is not the case when mining using proportional relaxation. More- over, techniques using fixed-value relaxation [9, 12, 3, 11] demonstrate that interesting itemsets can be mined in real- world data. Since our paper focuses on fixed-value fault- tolerance, we skip details on these other variants.

The first piece of work using fixed-value as relaxation on FFT-patterns mining was authored by Pei et al [9]. The definition of FFT-pattern here is similar to the one given in [14], but they employ fixed-value relaxation instead of proportional relaxation, i.e. every transaction is allowed to miss a fixed number of items. This definition is equiv- alent to that of FFTT -pattern in our paper (c.f. section 3.2).

To mine such patterns, the authors used an apriori-based method. Koh and Yo [6] tackled the same problem using a backtracking approach, and empirically showed that their approach improves the efficiency of the previous approach by an order of magnitude.

A more complicated problem was tackled by Sim et al [11], where the objective is to mine maximal quasi- bicliques in bipartite graphs. A quasi-biclique is maximal if it is not a proper subset of any other quasi-biclique. In [11], the relaxation criteria is applied to both sides of the bipartite graph, i.e. each vertex is allowed to disconnect to at most ? vertices in the other partite-set. To solve this prob- lem, they proposed algorithm CompleteQB which is based on the backtracking approach. The constraints for this prob- lem are exactly the same as for our FFTT I-pattern (c.f. sec- tion 3.2).

Besson et al [3] relate transactional databases with for- mal concept analysis in lattice theory. They performed comparisons on several definitions of FFT-patterns (DRBS, CBS, and FBS) with the objective of finding interesting patterns. However, all those definitions incorporate a con-  2Anti-monotonicity property means if f(X) is true for a function f and a set X , then f(X? ? X) is also true.

sistency constraint, which restricts all transactions (resp: items) outside the patterns to contain lesser items (resp: transactions) than those inside the pattern. The implications of this constraint are illustrated in Example 1.

Example 1. Consider the database as depicted in Figure 1. Let the minimum support be 3, and the allowed num- ber of misses in each transaction and item be 1. No FFT- pattern with itemset {b, c} can include transactions 3 and 4 together, since they both miss item c (no. of misses for item c becomes 2). Conversely, neither of them can be ex- cluded from any pattern that contains transaction 2, as it would violate the consistency constraint. As a result, {b, c} is not considered interesting (frequent). On the other hand, if the dataset had contained only transactions 1, 2 and 3 (or 1, 2 and 4), we find patterns that support itemset {b, c}, which is now considered interesting. Therefore we conclude that such constraints are not appropriate for mining item- sets with fixed tolerance in transactional databases.

3 Problem Definition  3.1 Basic Definition and Notation  In this paper, we deal with transactional databases. A transactional database D consists of transactions T over a set of items I, and can be represented by a (T ? I) matrix of transactions and items.

T (x ? I) (resp: T (X ? I)) represents a tidset where each transaction contains item x (resp: itemset X). Sim- ilarly I(y ? T ) (resp: I(Y ? T )) represents an itemset where each item is contained in transaction y (resp: tidset Y ).

Definition 1. [PATTERN] A pattern is defined as a sub- matrix ((Y ? T ) ? (X ? I)) of D. A pattern (Y ? X) is said to be associated with itemset X .

In classic frequent itemset mining, a pattern P is inter- esting if all its transactions contains all its items, i.e. all (tid, item) pairs in the pattern are present in the database.

In fault-tolerant mining, we relax this interesting constraint by allowing P to contain a constant number of (tid, item) pairs which are actually missing in the database. This re- laxation is formally defined by the following relaxation cri- teria, where we distinguish between the allowed number of misses in each transaction, each item, and the entire pattern.

Transaction relaxation In a pattern (Y ? X), the total number of misses in each transaction are at most ?t, i.e. ?y ? Y , |I(y) ? X| ? |X| ? ?t. This relaxation permits more transactions to be included in the pattern.

Item relaxation In a pattern (Y ? X), the total number of misses in each item are at most ?i, i.e.

?x ? X , |T (x)?Y | ? |Y |??i. This relaxation allows more items to be included in the pattern than would be allowed by the classic definition.

Pattern relaxation In a pattern (Y ?X), the total number of misses in the pattern are at most ?p, i.e.?  y?Y |I(y) ? X| ? |Y |.|X| ? ?p. This relaxation deals with the associativity of transactions and items in the pattern.

The set of all patterns satisfying the relaxation criteria may be very large and undesirable. In order to reduce this, we consider the utility of the patterns in terms of the support for their itemsets and maximality of their tidsets, where the support of a pattern is calculated as the size of its tidset.

The set of such patterns can be limited by the following constraints.

Support constraint A pattern (Y ? X) is frequent, i.e.

|Y | ? ?, where ? is the minimum support threshold desired by the mining process. This constraint ensures that any interesting behavior captured in the pattern is observed by a substantial number of transactions.

Maximality constraint A pattern (Y ?X) relaxed by any combination of the relaxation criteria is maximal.

This implies that ?(Y ? ? X), Y ? Y ? ? T satisfy- ing the given combination of relaxation criteria.

Support constraint and maximality constraint are de- noted as utility constraints. Note that these constraints only restrict support and maximality in the tidsets, and not in the entire pattern as in usual terminology.

Definition 2. [FFT-PATTERN] An FFT-pattern is a pattern satisfying all utility constraints and any given combination of relaxation criteria.

Definition 3. [SUPPORT-TIDSET] Tidset Y supports item- set X if (Y ? X) is an FFT-pattern. The set of all support- tidsets of X is denoted as S(X).

Definition 4. [FREQUENT ITEMSET] An itemset X is fre- quent if S(X) ?= ?.

As mentioned earlier, instead of mining all FFT-patterns, we propose to mine all frequent itemsets along with the statistics of their support-tidsets. In this work, we calculate the maximum support, the average support, and the number of FFT-patterns associated with an itemset as the statistical information, which we consider useful for itemset analysis.

Other statistical information such as median and mode can also be mined without adding much complexity.

In a market basket database, while |I| may reach thou- sands, the maximum size of any practical itemset is around 10 [13]. We denote the maximum size of an FFT-itemset as Xmax and use it to provide a tight upper bound for some operations (c.f. section 5), since Xmax << |I| in practice.

3.2 Variants of the FFT-pattern  In this paper, combinations of above relaxation criteria have been used to form three variants of the FFT-pattern, viz. FFTT -pattern (using transaction relaxation), FFTT I- pattern (using transaction relaxation and item relaxation), and FFTP -pattern (using pattern relaxation). Variables sub- scripted with T , T I, or P belong to the corresponding spe- cific variants of FFT-pattern.

The aim of introducing three different variants is mainly to show how the BIAS framework addresses each relaxation criteria. Depending on the dataset, some relaxation crite- rion by itself might not be pertinent, as the resulting pat- tern may be sparse. However, combining the criteria can produce good variants, like FFTT -pattern [9] and FFTT I- pattern [11] which have already been successfully applied to real world problems. Differences among the variants in term of the patterns mined are shown in Example 2.

Example 2. Consider the database as illustrated in Fig- ure 1. Let ?t = ?i = ?p = 1, and ? = 1. Itemset X = {b, c}, is associated with (a) one unique FFTT -pattern, ({1, 2, 3, 4}?X), and its corresponding ST (X) is a single- ton {{1, 2, 3, 4}}; (b) two FFTT I-patterns, ({1, 2, 3}?X) and ({1, 2, 4}?X), with ST I(X) = {{1, 2, 3}, {1, 2, 4}}; and (c) three FFTP -patterns, ({1, 2} ? X), ({2, 3} ? X), and ({2, 4} ? X), with SP(X) = {{1, 2}, {2, 3}, {2, 4}}.

Despite these differences, all the FFT-pattern variants share the anti-monotonicity property.

Theorem 1. FFT-pattern is anti-monotone.

Proof. Since every relaxation criterion on the FFT-patterns is based on fixed-value, the allowed number of misses is a constant. The number of misses in an FFT-pattern is thus in- variant to it?s size, and addition of items and/or transactions will never reduce the amount of misses.

This property is very important for designing algorithms to mine FFT-itemsets. If an itemset is not frequent (regard- less of the definition), then none of its supersets are fre- quent. Based on this property, we can enumerate all results using the pattern growth approach [2], and safely prune when the current itemset is not frequent.

4 BIAS framework  The BIAS framework, consisting of Backtracking algo- rithm, Integer linear programming (ILP), and aggregation statistic, is designed as follows. First, the backtracking al- gorithm iterates all necessary and relevant itemsets, while concurrently maintaining the necessary aggregation statis- tic of the transactions. For each itemset X , the statistical information of S(X) is determined by ILP incorporating the corresponding aggregation statistic.

Algorithm 1: Backtracking algorithm 1: call Backtrack(?); 2: 3: Function Backtrack(X) :: void 4: for each item i extension of X 5: extend itemset X with item i while  maintaining aggregation statistics; 6: Form ILP based on the aggregation statistics; 7: if (X) is frequent 8: output the statistical information of S(X); 9: call Backtrack(X);  10: exclude item i from X while maintaining aggregation statistics;  4.1 Backtracking Algorithm  The backtracking algorithm (Algorithm 1) enumerates the itemsets by inserting items one by one. Once it fin- ishes enumerating all itemsets containing an item, it back- tracks, then inserts another item. The complete process can be seen as an enumeration tree [4]. As FFT-itemset is anti- monotone, once an itemset is not frequent, we can safely prune it by not traversing its subtree.

Since we enumerate all FFT-itemsets, this backtracking algorithm combined with pruning, traverses all necessary and relevant result states. This means that we cannot expect any algorithm that iterates the itemsets to be asymptotically more efficient than this algorithm.

4.2 ILP Constraints  Given an itemset X generated by the backtracking step, the aim of ILP is to find the statistical information of associ- ated FFT-patterns. We first present the algorithm to mine all S(X), and then show how to calculate the statistics without enumerating all tidsets.

The problem of enumerating S(X) can be translated to a system of binary linear inequalities where the variables represent the transactions. We denote this system of integer linear equalities as an integer linear program (ILP ). This ILP consists of |T | variables, denoted by integer array A = (a1, a2, ..., a|T |). Each variable ai, 1 ? i ? |T |, represents one transaction and is constrained to be 0 or 1 (binary). A value 1 of variable ai means transaction i is present in the tidset.

The relaxation criteria and utility constraint on the pat- tern (c.f. section 3.1) presented in terms of the variables are as follows.

Transaction Relaxation (ILPT )  ?i ? {1..|T |}, ai ? (|X \ I(ti)|) ? ?t (1)     Item Relaxation (ILPI)  ?x ? X, ?  j,tj ??T (x) aj ? ?i (2)  Pattern Relaxation (ILPP )  |T |? i=1  ai ? (|X \ I(ti)|) ? ?p (3)  Maximality Constraint (ILPmax) Let A?k = (a  ? 1, a  ? 2, ..., a  ? |T |)  a?i = {  ai if i ?= k; ai + 1 if i = k.

?k,A?k satisfies relaxation criteria (4)  Support Constraint (ILPsup)  |T |? i=1  ai ? ? (5)  Note that we haven?t changed the problem statement, in- stead we have only represented it in a mathematical form.

Analyzing the variables, we note that this problem is in- tractable since the number of transactions can be potentially large. Especially, it is because integer programming in gen- eral is NP-Hard.

This problem can be resolved by reducing the number of variables. Equivalent variables are substituted by one combined-variable, representing the equivalence classes.

In any definition of relaxation criteria, two transactions ta and tb are equivalent if they contain the same itemset in X , i.e. I(ta) ? X = I(tb) ? X . This equivalent condition is even stronger in FFTT -pattern and FFTP -pattern, where two transactions are equivalent if they contain the same number of itemsets in X , i.e. |I(ta)?X| = |I(tb)?X|. By this reduction, the number of variables is equal to the num- ber of equivalence classes. Let us call ILP with reduced variable as ILP red, with variables B = (b0, b1, ..., b|B|) where |B| is the number of equivalence classes. A value k of variable bi means there are k transactions from equiva- lence class i in the tidset, hence it is constrained to be at most the number of variables it substitutes. Variable reduc- tion is illustrated in example 3.

Example 3. Consider mining FFTT -pattern from the database in Figure 1. Let the itemset X = {a, b}. As de- scribed previously, transactions containing same number of items in X are considered equivalent. Hence, transaction 3 (resp: variable a3) is equivalent to transaction 4 since they both contain 2 items, while transactions 1 and 2 are dif- ferent since they contain 0 and 1 item respectively. Hence,  there are 3 equivalence classes, b1 representing tidset {1}, b2 representing tidset {2}, and b3 representing tidset {3, 4}.

These variables are constrained to be at most 1, 1, and 2 re- spectively.

Using this technique, this problem becomes tractable since the number of variables is generally small, as is shown in Section 5. Having a solution B for ILP red, the number of support-tidsets satisfying B, denoted as |SB(X)| can be computed using equation (6), where ni is the number of transactions in equivalence class i.

|SB(X)| = |B|? i=1  ( ni bi  ) (6)  Example 4. Continuing Example 3, we have n1 = 1, n2 = 1, and n3 = 2. If we consider one transaction of class 1 (b1 = 1), none of class 2 (b2 = 0), and one of class 3 (b3 = 1), B = (1, 0, 1) representing  (  ) ?  (  ) ?  (  ) = 2  tidsets, viz. {1, 3} and {1, 4}.

Total size of all transactions in SB(X) can be calculated as |SB(X)| ?(  ?|B| i=1 bi). Summing these sizes for all B so-  lutions of ILP red gives the total size of all support transac- tions, from which the average transaction size can be com- puted.

Since there can be multiple solutions A and B for ILP and ILP red, the set of all distinct solutions A and B is de- noted as A and B respectively. To summarize, the objective of ILP is to enumerate B, in order to find the statistical information of A.

In order to obtain the equivalence classes of transactions, we need to maintain an aggregation statistic which con- cisely represents the connectivity in the database.

4.3 Aggregation Statistic  The choice of the aggregation statistic needed depends on the variant of FFT-patterns being considered. Example 5 gives a broad view of what aggregation statistics are main- tained and how to calculate them.

Example 5. Consider the problem of mining ST (X). In this problem, all transactions containing the same number of items are equivalent. Hence, we maintain the number of misses of every transaction. To speed up the variable reduc- tion process we can also maintain the number of transac- tions containing the same number of items as another ag- gregation statistic. The speed up occurs because instead of enumerating all transactions, we only need to enumerate the equivalence classes.

Let us consider current itemset X = {a, b} in the database in Figure 1. We maintain the statistic that transac- tion 1 contains zero item, transaction 2 contains one item,     and transactions 3 and 4 contain both items. To speed up the reduction process, we can also maintain the statistic that there are two transactions (regardless of which transactions they are) that contain both items, one transaction that con- tains one, and one transaction that contains no items in X .

These aggregation statistics can be maintained effi- ciently. Since we are using a backtracking algorithm, at most one item is added or removed at one time. Thus, in the worst case this operation needs O(|T |) iterations. Details of the specific aggregation statistic used in each variant are explained in section 5.

5 Algorithms  In this section, we present algorithms based on the BIAS framework for the three FFT-pattern variants described in section 3.2.

5.1 FFTT -pattern  Recalling the definition, a pattern (Y ? X) is an FFTT - pattern if it satisfies the criterion of transaction relaxation as stated in section 3.2 (ILPT in section 4.2). Since there is no relaxation on the number of misses on each item, each transaction is independent of each other. Hence the tidset Y supporting X is unique, i.e. the set of all transactions containing at least |X| ? ?t items in X .

In this problem, the information about the number of ap- pearances or number of misses of each transaction is suffi- cient to determine ST (X). These two variables can be used interchangeably since the number of appearances equals the size of the itemset less the number of misses. For the sake of efficiency, we use the number of appearances as the ag- gregation statistic.

5.1.1 Number of appearances as aggregation statistic  Given itemset X , one way to calculate its frequency is by maintaining the number of appearances of each transaction, denoted as counta. If x is the last added item in the back- tracking step, counta can be maintained by increasing the count of all transactions containing x. Hence, every update needs |T (x)| iterations. The complexity is O(|T |) in the worst case but O(?.|T |) in the expected case where ? is the density of database. This approach has complexity propor- tional to the database?s density, which is desirable since the database is generally sparse.

To deduce the supporting tidsets, we need to maintain another aggregation statistic, which stores the number of transactions for every distinct value in counta. This is de- noted as countc, i.e. countcx = |{t|countat = x}| (see Ex- ample 5). This statistic can be maintained concurrently with  the former, therefore the additional cost needed is constant.

The support of an itemset can be calculated by summing countc from index |X| ? ?t to |X|, which needs ?t + 1 iter- ations. This technique requires |T | integers to store counta, and Xmax integers to store countc.

5.1.2 Bitmap representation of aggregation statistic  Another way to represent the aggregation statistic is by us- ing Xmax bitmaps, where bit t in bitmap c is set if and only if transaction t misses c items. The insertion process is shown in following pseudo-code. A similar algorithm can be derived for the removal process. As before, x cor- responds to the last added item, and missx is the bitmap corresponding to transactions not containing item x. This operation needs O(? ? Xmax ? |T |) iterations for each up- date and O(? ?Xmax ? |T |) space. The symbol ? represents the ratio between bit-wise and integer operations which is roughly 1/32 in a 32 bits processor, where 32 operations can be performed in one clock cycle.

countXmax := countXmax ? ?missx for i := Xmax ? 1 down to 0  counti+1 := counti+1 ? (counti ? missx) counti := counti ? ?missx  By sacrificing space, we can reduce Xmax to ?t by main- taining ?t + 1 bitmaps in all recurrence levels. In this case, the maximum space allocated is O(? ? Xmax ? ?t ? |T |), but each update only needs O(? ? (?t + 1) ? |T |) iterations. This approach even though asymptotically inefficient, is very fast in practice because of the architecture of current processors.

5.1.3 Comparisons with other techniques  A similar problem has been tackled by Pei et al in [9] and Koh and Yo in [6]. Both their algorithms, as ours, iterate the itemsets and then find their supporting transactions. Pei et al proposed the FT-Apriori algorithm [9] that enumerates itemsets using an apriori-like approach. FT-Apriori first finds all frequent itemsets with size ?t + 1. Then for each k, it generates candidates of size k + 1 whose k-subsets are frequent. Once these candidates are accumulated, they are all checked using one pass of the database.

To generate one candidate X , the algorithm checks whether all its subsets are frequent in O(|X|2) time, and then verifies whether X is frequent in another pass of the database taking O(|T | ? |X|) time.

The number of candidates generated in this approach is relatively small compared to that in backtracking. However, generation of the candidates itself is an expensive process, consuming most of the mining time. Another disadvantage     Approach #Iterations Space  BIAS(appear) |T (x)| + ?t |T | + |X| BIAS(bit) ? ? (?t + 1) ? |T | ? ? (?t + 1) ? |T | ? |X|  FT-Apriori[9] |X|2 + |T | ? |X| N ? |X| VB-FT-Mine [6] ? ? (?t + 1) ? |T | ? ? (?t + 1) ? |T | ? |X|  Table 1. FFTT -pattern mining approaches  of this approach is that it needs another database pass while processing itemsets of each size.

Koh and Yo presented VB-FT-Mine [6] which uses a backtracking technique similar to ours. However instead of using an aggregation statistic, they analyzed the recur- rence relation of the support-tidset. Let P (X, d) be the set of transactions which support itemset X when ?t = d. They show that P (X?{x}, d) = P (X, d?1)?(P (X, d)?T (x)), hence this problem can be solved using dynamic program- ming [4]. The time and space complexity of VB-FT-Mine is exactly the same as ours using bitmap. This algorithm is fast because the recurrence relation happens to be simple, and using bitmaps is efficient.

Both approaches limit each item x ? X to be contained in at least ? supporting transactions. Our technique can eas- ily be adjusted to this requirement by iterating each item x ? X , as is done in [9] and [6]. However, this constraint is neglected for the sake of consistency among all variants discussed in this paper.

A summary comparison among these three approaches is presented in Table 1. Our approaches representing the aggregation statistic as appearances and bitmaps are char- acterized by BIAS(appear) and BIAS(bit) respectively. N denotes the total number of frequent itemsets, and the con- stant ? represents the ratio of time taken for bit operations to integer operations, which in this case is roughly 1/32.

Table 1 shows that no approach is totally superior com- pared to others. Given a sparse database and large tolerance ?t, ILPFT (appear) seems promising, while ILPFT (bit) and VB-FT-Mine [6] might be faster in a dense database and with small ?t. These results must be viewed in light of the main focus of this paper which is to mine the statistical information of support-tidsets. This variant is incorporated to illustrate how the BIAS framework handles the criterion of transaction relaxation.

5.2 FFTT I-pattern  FFTT I-pattern is defined as a pattern that satisfies the criteria of item relaxation and transaction relaxation as de- fined in section 3 (ILPT and ILPI in section 4.2). This problem is seemingly more complicated compared to the FFTT -pattern problem since each itemset might have mul- tiple support-tidsets.

Since the approach used in FFTT -pattern can be applied to handle the transaction relaxation, the pending problem is to generate FFT-patterns that satisfy the criterion of item relaxation.

5.2.1 Finding the maximum sized STI A pattern is frequent if the size of its largest support-tidset is greater than or equal to ?. Therefore finding the largest sized support-tidset can verify whether the pattern is fre- quent. This problem can be expressed as the ILPI ob- jective function to maximize  ?|T | i=1 ai. Clearly, finding the  maximum sized ST I is at most as difficult as generating ST I . While it may seem easier, we show that finding the maximum result in ILPI is an NP-Complete problem.

Lemma 2. Finding maximum ?|T |  i=1 ai in ILPI is NP- Complete.

Proof. To prove NP-Hardness we take the problem of find- ing Maximum Independent Set (MIS) in a graph which is a well-known NP-complete problem, and prove that MIS can be reduced into this problem. Given a graph G, the ob- jective of MIS is to find a maximum set of vertices, such that there is no edge between any pair of them. The reduc- tion is as follows. For every edge e(u, v), add inequality u + v ? 1 in ILPI . This reduction is complete since the result of ILPI will be the maximum set of variables (ver- tices) which are not connected. Since this case is a subset of ILPI , the ILPI problem is at least as hard as MIS, im- plying that it is NP-Hard. Proving the completeness of its decision-problem (  ?k i=1 ai ? K) is straight-forward.

Since this problem is NP-Complete, we cannot expect to have a practically efficient solution unless P = NP . In our implementation, we check if itemsets are frequent by calculating the statistical information of the FFT-pattern.

5.2.2 Finding statistical information of STI As in section 4.2, we reduce the number of variables by finding the equivalence classes. In this variant, two transac- tions are equivalent if they contain exactly the same itemset in X . It is easy to see that the maximum number of equiv- alence classes is bounded by min(k, 2|X|). Since |X| is less than 10 in many real-world datasets [13], the number of variables is at most 1024, hence enumerating all solutions is feasible.

To make this process more efficient, we introduce some heuristics, i.e., we iterate from the most constrained variable and from the highest possible value (most constraining), to reduce the search space as much as possible. Our experi- mental results show that all solutions can be found fast.

Once a solution B for ILP redI is obtained (section 4.2), we can calculate the desired statistic using equation (6).

5.3 FFTP-pattern  A pattern (Y ? X) is an FFTP -pattern if it satisfies the criterion of pattern relaxation as given in section 3 (ILPP in section 4.2). In this problem, transactions are equivalent if they miss the same number of items in X . Let variable bi represent the equivalence class for transactions missing i items in X . Note that only transactions that miss one to ?p items are important. Therefore, the number of equivalence classes, which is also the number of variables in ILP redP , is equal to ?p. ILP redP itself is formulated as follows:  ?p? i=1  bi ? i ? ?p (7)  5.3.1 Finding the maximum sized SP Let Ymax be the largest tidset in SP . The problem of find- ing Ymax can be optimally solved using a greedy algorithm which continuously takes transactions with the lowest num- ber of misses, until the total number of misses exceeds ?p.

This algorithm takes O(|T |) iterations. By maintaining the number of transactions that miss the same number of items, the complexity can be reduced to O(?p).

5.3.2 Finding statistical information of SP As in FFTT I-pattern, we can find the statistical information by enumerating B in ILP redP (c.f. (7) and section 4.2). To show the bound of the number of solutions, we first intro- duce the term partition number [1].

Definition 5. [PARTITION NUMBER] Partition number of an integer n means the number of distinct multi-sets of pos- itive integers that add-up to n, denoted as part(n). For example, part(3) = 3, since 3 = 3, 2+1, and 1+1+1.

part(4) = 5, since 4 = 4, 3+1, 2+2, 2+1+1, and 1+1+1+1, and so on. Each multi-set that adds-up to n is called a par- tition of n.

Let the number of transactions missing i items be de- noted as ni. We show that |B| is bounded by part(?p).

Lemma 3. |B| is bounded by part(?p).

Proof. It should be clear that if the number of transactions that miss i items, ni = ? for all i, then |B| is equal to part(?p). Now if the total number of misses in B equals ?p, then it is a partition of ?p. Otherwise, b1 = n1, i.e. all transactions missing one item are already considered in B.

This is true, because if b1 < n1, we can always increase b1 (i.e. we can add transactions missing one item to B), implying that B was not maximal. Assuming we have n1 = ?, we can always increase b1 until the number of misses in B equals ?p, so that it becomes a partition of ?p. This  partition is a unique extension for any maximal B. Hence, all B are subsets of distinct partitions of ?p, implying that |B| is at most part(?p).

Lemma 3 shows that the number of maximal B is bounded by part(?p), which is quite small for small ?p. For example, part(10) = 42 and part(20) = 627. In a prac- tical situation, we don?t need ?p to be larger than 20, and hence enumerating all solutions is feasible.

The algorithm to generate B is same as the one in section 5.2.2. We iterate the variable from the most constrained (having most number of misses), and most constraining (choosing the variable with highest value, so that we start with the largest number of transactions possible). The num- ber of iterations is bounded by O(?p ? part(?p)). It can be shown by assuming we have enough n1 that this algorithm will generate subsets of partition of ?p (similar to the proof of Lemma 3).

6 Experimental Results  All approaches are implemented in C++ and evaluated on an AMD 2.2 GHz machine with 2GB main memory. In all experiments the items are sorted in a non-decreasing or- der of appearances in the database. This performs best com- pared to other ordering techniques in our empirical studies.

For the experiments we used synthetic datasets gener- ated using the IBM market-basket data generator. We used two different datasets, a small database (400 items, 10,000 transactions) to show the effect of parameters and com- parison between approaches, and a practical-sized database (1,000 items, 100,000 transactions) to show the scalability of our approach in real world applications. The density of the databases is varied from 0.5% to 4% as in real-world market basket data.

6.1 FFTT -pattern  We demonstrate this problem using the small database.

The result of FT-apriori algorithm isn?t plotted since it takes too long. Figure 2(a) shows the scalability of the algorithms while varying minimum support. We observe that in this case, BIAS(appear) performs best, followed closely by VB- FT-Mine then BIAS(bit). This is due to the operation?s com- plexity, while VB-FT-Mine only needs one ?and? and one ?or? operations, BIAS(bit) needs 2 ?and?s, 2 ?or?s, and 1 ?not? operations (refer to section 5.1).

However, VB-FT-Mine only finds the number of trans- actions which miss less than or equal to ?t items, while both BIAS(appear) and BIAS(bit) maintain the number of trans- actions that miss all 0 to ?t items. In the case this statistic is useful - as in other variants, VB-FT-Mine cannot be used (i.e. it needs post processing).

1,000  1,200  4% 6% 8% 10% Minimum Support  T im  e (s  ec )  BIAS(appear) BIAS(bit) VB-FT-Mine  (a) Density = 1%, ?t = 2    1,000  1,500  2,000  2,500  2.5% 5.0% 7.5% 10.0% Density  T im  e (s  ec )  BIAS(appear) BIAS(bit) VB-FT-Mine  (b) ? = 2%, ?t = 1         2% 3% 4% 5%  Minimum Support  T im  e (s  ec )  Density = 1% Density = 2% Density = 4%  (c) ?t = ?i = 1  1E-72  1E-60  1E-48  1E-36  1E-24  1E-12  2% 3% 4% 5%  Minimum Support  |F I|  / |F  P |  ei = 1 ei = 5 ei = 10  (d) Density = 4%, ?t = 1            1 5 10  |F I|  Density = 1% Density = 2% Density = 4%  ei  (e) ? = 2%, ?t = 2          0.5% 1.0% 2.0% 3.0%  Minimum support  T im  e (s  ec )  Density = 1%  Density = 2%  Density = 4%  (f) ?p = 5   0.2  0.4  0.6  0.8   1.2  0.5% 1.0% 2.0% 3.0% 4.0% 5.0%  Minimum support  |F I|  / | F  P |  ?p = 2 ?p = 5  ?p = 10  ?p = 20  (g) Density = 4%             1 2 5 10 20  |F I|  (t h  o u  sa n  d s) Density = 1% Density = 2% Density = 4%  ep  (h) ? = 0.5%  Figure 2. Experimental result for FFT-patterns mining. Figures (a)-(b) show the FFTT -pattern variant, figures (c)-(e) show the FFTT I-pattern variant, and figures (f)-(h) show the FFTP -pattern variant  Figure 2(b) shows that BIAS(appear) is more affected by density compared to BIAS(bit). From this experiment, we can conclude that if we have a sparse database, we should use BIAS(appear) to maintain the aggregation statistic, and otherwise use BIAS(bit). All of these behaviors are as ex- pected as they follow the characteristics given in Table 1.

As we?ve already mentioned, this problem tries to re- duce the number of FT-patterns by relaxing the constraint (it doesn?t consider item relaxation). In practical-sized database and ?t > 1, this problem is intractable. To con- clude, this problem is not scalable in terms of database size and ?t as has also been discussed in [9].

6.2 FFTT I-pattern  For this problem, we use the practical-sized dataset. Fig- ure 2(c) shows the scalability of our algorithm. Even though CompleteQB [11] doesn?t tackle exactly the same problem,  it is used as competitor because to the best of our knowl- edge, there are no other relevant references. In our work, the objective is to mine all frequent itemsets along with the statistical information of associated patterns, while that of [11] is to mine all maximal quasi-bicliques.

It can be seen that the number of frequent itemsets in- creases as the density increases and as the minimum sup- port decreases. Using the BIAS framework, the time taken is almost linear to the number of frequent itemsets. Com- pleteQB [11] algorithm takes longer than one hour (the operation was terminated), because the number of FFT- patterns is much larger than the number of frequent itemsets as shown in Figure 2(d). The results also show that enumer- ating all results in market-basket database is meaningless since we might get as many as 1072(!) FFT-patterns, while there are only 1,600 frequent itemsets.

Experimenting with the value of ?i, it is interesting to observe that the value of ?i doesn?t increase the number of     frequent itemsets much, even though the number of FFT- patterns grows exponentially (Figure 2(e)). This fact can- not be discovered if we enumerate all patterns as in Com- pleteQB.

6.3 FFTP-pattern  Since this variant hasn?t been mentioned previously, we can?t compare the efficiency of BIAS with any other ap- proach. However, the experimental results in a practical- sized dataset indicate that this algorithm is efficient and scalable. Figure 2(f) shows that the time needed is ap- proximately linear to the number of frequent itemsets. The number of frequent itemsets itself scales similar to classical frequent-itemsets, which grows exponentially as the density increases and/or as the minimum support decreases.

In this problem, the number of frequent itemsets is also much smaller compared to FFTP -patterns, even though the ratio is not as dramatic as in FFTT I-pattern. For example in database with 4% density and 0.5% minimum support, with ?p = 20, the proportion is 46K frequent itemsets to 637K FFT-patterns, which is around 7%.

As seen in Figure 2(g), the ratio becomes smaller as ?p increases and minimum support decreases. Similar to the previous problem, the value of ?p doesn?t affect the number of FFT-itemsets much (Figure 2(h)).

7 Conclusion  We have generalized the problem of mining fixed-value FFT-patterns into relaxation criteria and constraints, and have shown that these criteria and constraints can be used to derive several available variants of FFT-patterns, as well as many new definitions. For FFT-patterns mining in trans- actional database, we proposed to mine only statistical in- formation of the corresponding FFT-patterns, and we have shown with several experiments that such statistics are suf- ficient to describe the characteristic of an itemset.

We have developed a new framework called BIAS framework for mining FFT-patterns based on backtracking algorithm, ILP constraints, and aggregation statistics. We have also shown that this framework can be used to effi- ciently mine several variants of FFT-patterns.

For future work, we plan to analyze the utility of statis- tical information in real world data. We are also interested in analyzing the impact of each relaxation criteria, and in researching the problem using proportional relaxation. This technique may also be applied to other problems such as sequential mining, stream mining, and graph mining.

