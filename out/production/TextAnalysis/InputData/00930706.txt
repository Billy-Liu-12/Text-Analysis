Discovering Calendar-based Temporal Association Rules*

Abstract  A temporal association rule is an association rule that holds during spec@ time intervals. An example is that eggs and coffee are frequently sold together in moming hours. This paper studies temporal association rules dur- ing the time intervals specijied by user-given calendar schemas. Generally, the use of calendar schemas makes the discovered temporal association rules easier to under- stand. An example of calendar schema is (yeal; month, day), which yields a set of calendar-based pattems of the form (d3, dz, d l ) ,  where each d i  is either an integer or the symbol *. For example, (2000, *, 16) is such a pattem, which cor- responds to the time intervals, each consisting of the 16th day ofa month in year 2000. This paper defines two types of temporal association rules: precise-match association rules that require the association rule hold during every interval, and fuuy-match ones that require the association rule hold during most of these intervals. The paper extends the well- known Apriori algorithm, and also develops two optimiza- tion techniques to take advantage of the special properties of the calendar-based pattems. The experiments show that the algorithms and optimization techniques are eflective.

1. Introduction  Among various types of data mining applications, the analysis of transactional data has been considered impor- tant. The notion of association rule was proposed to capture the cooccurrence of items in transactions 111. For example, given a database of orders (transactions) placed in a restau- rant, we may have an association rule of the form egg+ coffee (support: 3%, confidence: 80%), which means that 3% of all transactions contain the items egg and coffee, and 80% of the transactions that have the item egg also have  *The work was partially supported by ARO under contract number DAAG-55-98-1-0302. Work of Wang was also partially supported by the NSF Career award 98751 14.

the item coffee in them. The two percentage parameters are referred to as support and conjidence respectively.

An interesting extension to association rules is to include a temporal dimension. For example, if we look at a database of transactions in a supermarket, we may find that turkey and pumpkin pie are seldom sold together. However, if we only look at the transactions in the week before Thanksgiv- ing, we may discover that most transactions contain turkey and pumpkin pie, i.e., the association rule ?turkey + pump- kin pie? has a high support and a high confidence in the transactions that happen in the week before Thanksgiving.

The above suggests that we may discover different asso- ciation rules if different time intervals are considered. Some association rules may hold during some time intervals but not during others. Discovering temporal intervals as well as the association rules that hold during the time intervals may lead to useful information. For example, by considering each IP packet in a computer network as a transaction and the attributes in the IP header as items in the transaction, we can use temporal association rules to represent normal network activities in different time periods of a day; attacks to the network may be flagged when the network behaves differently from its normal behaviors.

Informally, we refer to the association rules along with their temporal intervals as temporal association rules. In this paper, we propose to use calendar schemas as frame- works to discover temporal association rules. A calendar schema is determined by a hierarchy of calendar units. For example, a calendar schema can be (year, month, day). A calendar schema defines a set of simple calendar-basedpat- tems (or calendar pattems for short). For example, given the above calendar schema, we will have calendar pattems such as every day of January of I999 and every I6th day of January of every year. Basically, a calendar pattem is formed for a calendar schema by fixing some of the cal- endar units to specific numbers while leaving other units ?free? (so it?s read as ?every?). It is clear that each calendar pattem defines a set of time intervals.

We assume that the transactions are timestamped so we can decide if a transaction happens during a specific time  0-7695-1 107401 $10.00 0 2001 IEEE 111  mailto:ise.gmu.edu   interval. Given a set of transactions and a calendar schema, our first interest is to discover all pairs of association rule and calendar pattern such that for each pair ( T ,  e ) ,  the as- sociation rule r satisfies the minimum support and confi- dence constraint among all the transactions that happen dur- ing each time interval given by the calendar pattern e.  For example, we may have an association rule turkey i pump- kin pie along with the calendar pattern every day in every November. We call the resulting rules temporal association rules w . ~ t .  precise match.

In some applications, the above temporal association rules may be too restrictive. Instead, we may require that the association rule hold during ?enough? number of inter- vals given by the corresponding calendar pattem. For ex- . ample, the association rule turkey -+ pumpkin pie may not hold on every day of every November, but holds on more than 80% of November days. We call such rules temporal association rules w.r.t. fizzy match.

Our data mining problem is to discover from a set of timestamped transactions all temporal association rules w.r.t. precise or fuzzy match for a given calendar schema.

We extend an existing algorithm, Apriori [2], to discover all such temporal association rules. In addition, based on the observation that the calendar patterns formed from a calen- dar schema are not isolated but related to each other, we de- velop two optimization techniques called temporal aprior- iGen and horizontal pruning, which can be applied to both classes of temporal association rules with some adaptation.

Our contribution in this paper is two-fold. First, we de- velop a new representation mechanism for temporal associ- ation rules based on calendars and identify two classes of interesting temporal association rules. Our representation  -  requires less prior knowledge than the previous methods and the resulting rules are easier to understand. Second, we extend Apriuri and develop two optimization techniques to discover both classes of temporal association rules. Experi- ments show that our optimization techniques are effective.

The rest of the paper is organized as follows. The next section defines temporal association rules in terms of cal- endar patterns. Section 3 extends Apriori to discover large itemsets for temporal association rules and presents our op- timization techniques. Section 4 presents the experimental evaluation of our algorithms. Section 5 describes the related work, and section 6 concludes the paper.

2 Problem Formulation  2.1 Simple Calendar-based Pattern  A calendar schema is a relational schema R = (G, : D,, G,-1 : D n - l , .  . . , G1 : 0 1 )  with a valid constraint.

Each attribute G ,  is a granularity name like year, month and week. Each domain D ,  is a finite subset of the positive  .

integers. The constraint valid is a Boolean function on D , x D,-1 x , . . x D1, specifying which combinations of the values in D, x D,-1 x . . . x D1 are ?valid?. The purpose is to exclude the combinations that we are not interested in or that do not correspond to any time intervals. For example, if we do not want to consider the weekend days and holidays, we can let valid evaluate to False for all such days. For brevity, we omit the domains D ,  and/or the constraint valid from the calendar schema when no confusion arises.

Given a calendar schema R = ( G ,  : Dn,Gn--l : Dn-1,. . , G1 : D l ) ,  a simple calendar-based pattem (or calendar pattem for short) on R is a tuple of the form (d , ,  d,-1,. . . , d l ) ,  where each d,  is in D ,  or the wild-card symbol *. The calendar pattern (dn,  dn-1,. . . , d l )  repre- sents the set-of time intervals intuitively described by ?the 4h G1 of the dih G s ,  . . ., of dkh G,.? If d,  is the wild- card symbol ?*?, then the phrase ?the dth? is replaced by the phrase ?every?. For example, given the calendar schema (week, day, hour), the calendar pattern (* , 1 , l o )  means ?the 10th hour on the first day (i.e., Monday) of every week?.

Each calendar pattern intuitively represents the time inter- vals given by a set of valid tuples in D ,  x D,-1 x . . . x D 1 .

We say a calendar pattern e covers another calendar pat- tern e? in the same calendar schema if the set of time in- tervals of e? is a subset of the set of intervals of e.  For example, given the calendar schema (week, day, h u w ) , ( l ,* , lO) covers ( l , l , l O ) .  It is easy to see that for a given calendar schema (G,, G,-1, .  . . , GI), a calendiir pattern (GI,, dn-l ,  . . . , d l )  covers another calendar pattern (d;, d L p 1 , .  . . , d i )  if and only if for each i, 1 5 i 5 n , either d, := ?*? or d,  = d:.

For simplicity, we require that in a calendar schema (G,, G,- 1,. . . , GI), each unit of G, is contained in a unit of G,+1 for 1 5 i < n. For example, (month,day) is allowed since each day is contained a unique month. How- ever, the schema (year, month ,  week) is not allowed be- cause a uleek may not be contained in a unique month.

For the sake of presentation, we call a calendar pattem with k wild-card symbols a k-star calendar pattem (de- noted e,& and a calendar pattern with at least one wild-card symbol a star calendarpattem. In addition, we call a calen- dar pattern with no wild-card symbol (i.e., a 0-star calendar pattern) a basic time interval if the combination is ?valid?.

2.2 Teimporal Association Rules  Let us first review the concept of association rule, which was originally presented in [l]. Let Z denote a set of data items. Both transaction and itemset are defined to be sub- sets of 1. Given a set 7 of transactions, an association rule of the form X -+ Y is a relationship between the two dis- joint itemsets X and Y. An association rule satisfies some user-given requirements. The support of an itemset by the     set of transactions is the fraction of transactions that contain the itemset. An itemset is said to be large if its support ex- ceeds a user-given threshold minsupport. The confidence of X -+ Y over 7 is the fraction of transactions contain- ing X that also contain Y. The association rule X + Y holds in 7 if X U Y is large and its confidence exceeds a user-given threshold mincon f idence.

We assume that each transaction is associated with a timestamp (e.g., November I ,  2000). Given a basic time interval t (or a calendar pattern e )  on a calendar schema, we denote the set of transactions whose timestamps are covered by t (or e)  as 7 [ t ]  (or 7 [ e ] ) .

Syntactically, a temporal association rule over a calen- dar schema R is a pair (r, e), where r is an association rule and e is a calendar pattern on R. However, multiple mean- ingful semantics can be associated with temporal associa- tion rules. For example, given a set of transactions, one may be interested in the association rules that hold in the transactions on each Monday, or the rules that hold on more than 80% of all Mondays, or the rules that hold in all trans- actions on all Mondays (i.e., consider the transactions on all Mondays together). In the following, we identify two classes of temporal association rules on which we focus in this paper. Other kinds of temporal association rules may be interesting, but we consider them as possible future work.

Precise Match Given a calendar schema R = (G, ,  G,-1, . . . , GI) and a set 7 of timestamped transactions, a temporal association rule (r, e) holds w.st. precise match in ?T if and only if the association rule r holds in 7 [ t ]  for each basic time interval t covered by e. For example, given the calendar schema (year, month, Thursday), we may have a temporal asso- ciation rule (turkey -+ pumpkin pie, (*, 1 1 , 4 } )  that holds w.r.t. precise match. This rule means that the association rule turkey -+ pumpkin pie holds on all Thanksgiving days (i.e., the 4th Thursday in November of every year).

Fuzzy Match Given a calendar schema R = ( G n , G , - l , . . . , G 1 ) ,  a set 7 of timestamped transactions, and a real number m (0 < m < 1 ,  called match ratio), a temporal association rule (r7 e) holds wxt .  fuuv  match in 7 if and only if for at least loom% of the basic time intervals t covered by e, the association rule r holds in 7 [ t ] .  For example, given the calendar schema (year, month, day) and the match ratio m = 0.8, we may have a temporal association rule (turkey + pumpkin pie, (*, 11,  *)) that holds w.r.t. fuzzy match.

This means that the association rule turkey -+ pumpkin pie holds on at least 80% of the days in November.

Given a calendar schema, we want to discover all inter- esting association rules with all their calendar patterns w.r.t precise match and fuzzy match respectively. Note that in many cases, we are not interested in the association rules that only hold during basic time intervals.

Temporal Association Rules w.r.t.

Temporal Association Rules w.r.t.

3 Finding Large Itemsets  3.1 Overview of Our Algorithms  Mining temporal association rules can be decomposed into two steps: (1) finding all large itemsets for all star cal- endar patterns on the given calendar schema, and (2) gen- erating temporal association rules using the large itemsets and their calendar patterns. The first step is the crux of the discovery of temporal association rules; in the following, we will focus on this problem. The generation of tempo- ral association rules from large itemsets and their calendar patterns is straightforward and can be resolved using the method discussed in [2] .

The algorithm Apriori consists of a number of passes.

During pass k, the algorithm tries to find large k-itemsets Lk (i.e., itemsets with IC items that have at least the min- imum support) from a set of candidates, Ck, through counting the support of each candidate against the entire database. The set of candidates, c k ,  is generated from the set of large (k-1)-itemsets, Lk-1, ensuring that all (IC - 1 ) - item subsets of each candidate in ck are in Lk-1.

We extend Apriori [2] to discover large itemsets w.r.t.

precise and fuzzy match. When precise match is consid- ered, the input of our algorithms consists of a calendar schema R, a set 7 of timestamped transactions, and a min- imum support minsupport. When fuzzy match is consid- ered, an additional input, a match ratio m, is given. De- pending on the data mining tasks, our algorithms output the large itemsets for all possible star calendar patterns on R in terms of precise match or fuzzy match.

Figure 1 shows the outline of our algorithms. (This out- line is generic for both precise and fuzzy match as well as with and without our optimization techniques discussed later. For different algorithms, appropriate procedures will be supplied.) The algorithms work in passes. In each pass, the basic time intervals in the calendar schema are pro- cessed one by one. During the processing of basic time interval eo in pass IC, the set of large k-itemsets Lk(eo) is first computed, and then Lk(e0) is used to update the large k-itemsets for all the calendar patterns that cover eo.

The first pass is specially handled. In this pass, we com- pute the large 1-itemsets for each basic time interval by counting the supports of individual items and comparing their supports with minsupport. In the subsequent passes, we divide the processing of each basic time interval into three phases. Phase I generates candidate large itemsets for the basic time interval. Phase I1 reads the transactions whose timestamps are covered by the basic time interval, updates the supports of the candidate large itemsets, and discovers large itemsets for this basic time interval. Phase III uses the discovered large itemsets to update the large itemsets for each star calendar pattern that covers the basic     (1) forall basic time intervals eo do begin (2) (3) (4) (5) end (6) for ( k  = 2; 3 a star calendar pattern e such that  (7)  ( 8 )  (9) (10) - subset (Ck(eo), T); // ccount + + if  / IC E Ck (eo) is contained in T (11)  L1 (eo) = {large 1-itemsets in ??-[eo]} forall star patterns e that cover eo do  update L1 (e )  using LI (eo);  Lk-l(e) #0;Ic++)dobegin ford basic time intervals eo do begin  // Phase I: generate candidates generate candidates ck (eo) ; // Phase II: scan the transactions forall transactions T E ??-[eo] do  &(eo)  = {c E Ck(eo)lc.count 2  // Phase 111: update for star calendar patterns forall star patterns e that cover eo do  minsupport};  (12) ( 1 3 ) .  update & ( e )  using Lk(e0); (14) end (15) (16) end  Output ( L k  (e ) ,  e) for all star calendar pattern e.

Figure 1. Outline of our algorithms for finding? large k-itemsets  time interval. At the end of each pass, it outputs the set of large k-itemsets L k  (e )  for all star pattems e w.r.t. precise or fuzzy match.

Phase I is the-critical step. Indeed, the fewer candidate large itemsets are generated in phase I, the less time phase II will take. Several observations can be used to reduce the number of candidate large itemsets. We will discuss phase I in detail in the following subsections.

Phase II is performed in the same way as in Apriori by using the candidate large itemsets generated in phase I. We use a hash tree to store all candidate itemsets for a basic time interval eo and scan all transactions in T[eo]  to com- pute their supports. In Figure 1, function subset traverses? the hash tree according to transaction T and increments the supports of the candidate itemsets contained in T. Then the set of large itemsets for eo ( L k  (eo)) is computed by remov- ing the itemsets that do not have the minimum support.

Now let us explain phase 111. After the basic time interval eo is processed in pass k ,  the large k-itemsets for all the calendar pattems that cover eo are updated as follows. For precise match, this is done by intersecting the set Lk(e0) of large k-itemset for the basic time interval eo with the set Lk(e) of large k-itemsets for the calendar pattem e (i.e., Lk(e) = Lk(e) n Lk(e0)). (Certainly, Lk(e) = Lk(e0) when Lk(e) is updated for the lirst time.) It is easy to see that after all the basic time intervals are processed, the set of large Ic-itemsets for each calendar pattem consists of the  k-itemsets that are large for all basic time intervals covered by the pattem.

Update for fuzzy match is a little more complex. We as- sociate a counter capdate with each candidate large item- set for each star calendar pattem. The counters are ini- tially set to 1. When Lk(e0) is used to update Lk(e) in phase 111, the counters of the itemsets in L k ( e )  that are also in Lk(e0) are incremented by 1, and the itemsets that are in Lk(e0) but not in Lk(e) are added to Lk(e) with the counter set to 1. Suppose there are totally N basic time intervals covered by e and this is the n-th update to L (e).

We drop an itemset if its counter c-update does not satisfy c-update + (N - n) 2 m . N .  It is easy to see that a dropped itemset cannot be large for e; on the other hand, if an item- set remains in Lk(e), then its counter c-update > m . N since it is not dropped in the last update.

3.2 Generating Candidate Large Itemsets  3.2.1 Direct-Apriori  A naive approach to generating candidate large itemsets is to treat each basic time interval individually ahd directly apply Apriori?s method for candidate generation. We call this approach Direct-Apriori (for precise or fuzzy match de- pending on the context). Phase I of Direct-Apriori is instan- tiated as follows.

Ck(e0) = aprioriGen(Lk-l(e0))  Here function aprioriGen is used to generate Ck(eo), the set of candidate large k-itemsets, from the set of large (k-1)- itemsets, L k - l ( e o ) ,  ensuring that all (IC - 1)-item subsets of each ciindidate in Ck(e0)  are in Lk-l(eo).

. According to Apriori [2], the set of candidate large k-  itemsets, CI, (eo), is a super set of all the large k-itemsets for eo. Thus, phase I1 of the algorithm will correctly gen- erate the set of large k-itemsets for eo. By the argument in subsection 3.1, for each calendar star pattem e, Lk(e) will consist of the k-itemsets that are large (w.r.t. precise or fuzzy match) for e after all the basic time intervals are processed.

3.2.2 Temporal-Apriori  Note that in many cases, we may not be interested in the as- sociation rules that only hold in basic time intervals. Direct- Apriori does not take this into consideration and thus may lead to unnecessary data processing. In the following, we present two optimization techniques, which we call tempo- ral aprioriGen and horizontal pruning, to improve the can- didate generation for situations where temporal association rules for basic time intervals are not considered. The re- sulting algorithm is called Temporal-Apriori (for precise or fuzzy match according to the context).

Temporal aprioriGen is partially based on the assump- tion mentioned above. Since we do not need to find the large itemsets for basic time intervals, we do not need to count the supports for all the potentially large Ic-itemsets generated by Ck(e0) = aprioriGen(lk-l(e0)) for each basic time interval eo. Indeed, we only need the supports of the itemsets that are potentially large for some star calendar patterns that covers eo. In other words, given a basic time interval eo, if a candidate large k-itemset cannot be large for any of the star calendar pattems that cover eo, we can ignore it even if it could be large for eo. Therefore, we can generates candidates Ck (eo) as follows.

Example 1 Consider a fuzzy-match temporal association rule discovery using the calendar schema R = (week : {1 , - . . ,5} ,day  : {1 , . . . , 7 } ) .  Suppose we have com- puted the following large 2-itemsets: L2((3,2)) = { A B , AC, AD, AE,  BD, C D ,  CE} ,  L2((*,2)) = { A B , AC, AD, BC, BD,  C E } ,  L2((3,*)) = { A B ,  AC, AD, BD, CD},  and L2((*,*)) = { A B ,  AD, BD, CD, AC, AE}. To compute the candidate large 3-itemsets for the basic time interval (3,2),  we first get LT = L2((*,2)) n L2((3,2)) = { A B ,  AC, AD, BD, C E }  and then gener- ate C3((*,2)) = aprioriGen(LT) = {ABD}.  Similarly, wecanget C3((3,*)) = {ABD,ACD} andC3((*,*)) = {ABD, ACE}. Then the set of candidate large 3-itemsets is C3((3,2)) = C3((*, 2 ) )  U C3((3, *>) U C3((*, *)) {ABD,  ACD, ACE}. 0  =  The above method works well for both precise and fuzzy match. (Note that we can use Lk-l(e) instead of Lk- l ( e )  n Lk-l(eo) for precise match, since Lk-l(e) is a subset of Lk-1 (eo).) Moreover, we can improve the can- didate generation for precise match on the basis of the fol- lowing Lemma.

Lemma 1 Given a star calendar pattem e, an itemset is large for e wxt. precise match only if it is large w.r.t. precise match for all 1-star calendarpattems covered by e.

Consider CI, (eo), the set of candidate large k-itemset for eo. We only need Ck (eo) to generate large itemsets for pat- terns e that cover eo. According to Lemma 1, an itemset is large for a given star calendar pattern e only if it is large for all 1 -star calendar patterns covered by e. Thus, we can generate the candidate large k-itemsets (k > 1) for precise match as follows.

Crc(eo) = U,, COuerS eo aprioriGen(b-l(e1)) Example 2 Consider a precise-match temporal association rule discovery using the calendar schema R = (week : {1 , . . . ,5} ,day  : { 1 , . . - , 7 } ) .  Suppose we have the fol- lowing large 2-itemsets: L2((3 ,2) )  = { A B ,  AC, AD, AE, BC, BD, CD, CE} ,  L2((*,2)) = { A B ,  AC,   AD, BC, BD,  CE},  andL2((3,*)) = { A B ,  AC, AD, BD, CD}. To compute the candidate large 3-itemsets for (3,2), we will first generate C3((*, 2 ) )  = {ABC, ABD} and C3((3,*)) = {ABD,ACD}.  Then the set of candidate large 3-itemsets is C3((3,2)) = C3((*,2)) U C3((3,*)) = {ABC, ABD, ACD}. In contrast, if we use Direct-Apriori, we will generate the candidates from L2((3,2)) and have the set of candidate large 3-itemsets as CA((3,2)) = {ABC, ABD, ACD, ACE, BCD}. 0  Our second optimization technique, horizontal pruning, is also based on Lemma 1, but applied during a pass.

We first discuss the precise match case. Consider pass k.

For each basic time interval eo, we update (among oth- ers) Lk(e1) for each el that covers eo. After the first time Lk(e1) is updated, for every eo processed, we update &(el) to be Lk(e1) n Lk(eo), i.e., drop the itemsets in Lk(e1) that do not appear in Lk(e0). Hence, after the first time L k  (e l )  is updated, LI,  (e l )  always contains all the large Ic-itemsets for el (plus other itemsets that will eventually be dropped). In other words, at any time of the processing (ex- cept before the first update), if a Ic-itemset 1 does not appear in Lk(el),thenl is notlarge forel.

Now we can use the tentative Lk(e1) (i.e., updated at least once) to prune the candidate large k-itemsets in C k  (eo) as follows. If an itemset 2 in Ck(e0) does not appear in any of the tentative Lk(el) ,  where el is a 1-star pattern that covers eo, then 1 cannot be large for any star pattern e that covers eo. Indeed, any star pattern e covering e 0 must cover at least one of the 1-star pattems that cover eo. Let this particular 1-star pattern be e:. Since I is not large for any 1- star pattern that covers eo, 1 is not large for e;. By Lemma 1, 1 cannot be large for e, and we may drop 1 from ck (eo).

Example 3 Let us continue example 2. Suppose when (3,2) is being processed, we already have L3((*, 2)) = {ABD} and L3((3,  *)) = {ABD,  ACD}. Then we can further prune C3((3,2)), which is {ABC,ABD,ACD}, by C3((3,2)) = (73((3,2))n (J53((*, 2 ) )  U L3((3, *))) = {ABD,  ACD}. 0  Horizontal pruning for precise match cannot be directly applied to fuzzy match. This is because fuzzy match al- lows a large itemset to be small for some basic time inter- vals. Nevertheless, a similar idea can be applied to fuzzy match. The idea is based on the observation that an item- set is not large for a calendar pattern if it is not large for a certain number of basic time intervals covered by the pat- tern. For example, an itemset 1 can never be large for 80% of all Mondays if it is already known not to be large for 20% of the Mondays. Therefore, we discard the candidate large itemsets (for eo) that cannot be large for any star pattern e that covers eo even if these itemsets are large for eo.

Example 4 Let us continue example 1. We already have c3((3,2)) = {ABD,  ACD, ACE}. Suppose all of L3((*, 2 ) ) ,  L3((3, *)), and L3((*, *)) have been up-    dated at least once. Then we can update a copy of L3( (*, 2)) with C3( (3,2)) and get the result, for example, C3((*, 2)) = { A B D ,  A B E } .  If we also get C3((3, *)) = { A B D ,  A C D }  and C3((*, *)) = { A B D } ,  then C3((3,2)) canbeprunedasC3((3,2)) = C3((3,2))n(C3((*,2))U  We prove the correctness of Temporal-Apriori for pre-  cise match as follows. First, we show that the algorithm has the same output as Direct-Apriori if for each e 0 ,  it uses a super set of the union of large k-itemsets for all 1-star calendar patterns that cover eo. Then we prove the equiv- alence of Temporal-Apriori and Direct-Apriori by showing that the set of candidate large IC-itemsets used for each basic time interval in Temporal-Apriori is such a super set. The correctness of Temporal-Apriori for fuzzy match is proved similarly. This result is summarized in the following Lem- mas arid Theorems. Please refer to [SI for the details.

Lemma 2 If Temporal-Apriori for  precise match uses a su- per set of U e ,  covers eo Lk(e1) as the set of candidate large k-itemsets for  each eo, then it has the-same output as Direct- Apriori f o r  precise match.

Theorem 1 Temporal-Apriori for  precise match is equiva- lent to Direct-Apriori for  precise match.

Lemma 3 I f  Temporal-Apriori forfuzzy match usesa super set of U, covers eo Lk(e) as the set of candidate large k - itemsets for  each eo, then it has the same output as  Direct- Apriori forfuzzy match.

Theorem 2 Temporal-Apriori for  fuuy match is equivalent to Direct-Apriori for fuzzy match.

C3((3, *)) U C3((*, *))) = { A B D ,  A C D } .

4 Experiments  To evaluate the performance of our algorithms and opti- mization techniques, we performed a series of experiments using both a real-world data set (KDD Cup 2000 [7]) and synthetic data sets. Due to space reasons, we only report the results on the synthetic data sets in this paper. A de- tailed description of the experiments is available in [8] .

In order to generate data sets with various characteris- tics, we extend the data generator proposed in [2] to in- corporate temporal features. For each basic time interval eo in a given calendar schema, we first generate a set of maximal potentially large itemsets called per-interval item- sets and then generate transactions 7 [ e o ]  from per-interval itemsets following the exact method in [2]. Specifically, the sizes of each transaction and each per-interval itemset are picked from Poisson distribution with mean p equal to IT1 and 111 respectively. Each per-interval itemset is gen- erated by copying a half of its items from its previous one (the first per-interval itemset is generated totally randomly), and randomizing the other half. Each per-interval itemset  -  Meaning Number of transactions per  Avg. size of the transactions Average size of the maximal  potentially large itemsets Num. of per-interval itemsets Num. of items  basic time interval  Pattern-ratio Num. of star calendar patterns  Der oattem itemset  Default value 10,Ooo   1 ,OOo 1 ,OOo 0.4  Figure 2. Parameters for data generation  is also assigned a weight from an exponential distribution with unit mean. After all per-interval itemsets are gener- ated, eaclh transaction is formed by incorporating a set of per-interval itemsets selected according to their weights.

To model the phenomenon that some itemsets may have temporal patterns but others may not, we choose a subset of the per-interval itemsets from a common set of itemsets calledpanern itemsets shared by all basic time intervals but generate the others independently for each basic time inter- val. We use a parameterpattern-ratio, denoted Pr , to decide the percentage of per-interval itemsets that should be cho- sen from the pattern itemsets.

To decide which pattern itemsets should be used for a ba- sic time interval, we associate several star calendar patterns with each pattem itemset. For each basic time interval, we choose itemsets repeatedly and randomly from the pattern itemsets >until we have enough number of pattern itemsets.

Each time when a pattern itemset is chosen, we use it as a per-intend itemset if it has a calendar pattern that covers the basic time interval; otherwise, theitemset is ignored.

We use a parameter N, to adjust this feature such that the number of calendar patterns assigned to each pattern item- set conforms to a Poisson distribution with mean N,.

The calendar patterns assigned to pattem itemsets are se- lected from the space of all star calendar patterns. In order to model the phenomenon that the calendar patterns cover- ing more basic time intervals are less possible than those covering fewer ones, we associate with each calendar pat- tern a weight, which corresponds to the probability that this calendar pattern is selected. The weight of a calendar pat- tern is set to 0.5k ,  where IC is the number of wild-card sym- bols in the calendar pattern. The weight is then normalized so that the sum of the weights of all calendar patterns is 1.

Our data generation procedure takes the calendar schema (year : { 1995 - 1999}, month, day) and the parameters shown in1 Figure 2. To examine the performance of the al- gorithms, we generated a series of data sets by varying one parameter while keeping others at their default values. The size of thie data sets ranges from 739 MB to 5.41 GB.

O ' h !  Minimum support (%)  1owM"  (d) Fuzzy malch (mO.9. minsup=0.75%)  3 4 5 6 Pass Number  (a) Precize match tnmwtk0.75%)  + TemporaLApliori - Diruct-Apriwi  zoo  4 5 6 Avg. sized potentially large temseo (Ill) Q) Furry match (m0.0. mhup=O 75%)  O3  -  Minimum supxt  (%) (e) Pm&a match (minsup.O.75%)  I--  (h) Furry match (mO.9, mlnsupO.75%)  ~~~ m 1 0.95 0.9 0.8 0.7  Match ratio (in)  I 3 4 5 6  Paso Number (f) P& match ( m W . 7 5 % )  1woO  (I) Scale-up tests for TemporaU\prkri (mhsup=0.759  -  Figure 3. Experimental result on synthetic data sets  Figures 3(a) and 3(b) show the effectiveness of our opti- mization techniques. For precise match, Temporal-Apriori is 5 to 22 times faster than Direct-Apriori; for fuzzy match, Temporal-Apriori is 2.5 to 12 times faster than Direct- Apriori. Figures 3(c) and 3(d) give the total number of candidate large itemsets for the experiments with the min- imum support 0.75%, showing that the optimization tech- niques greatly reduced the number of candidates in each  pass. In figures 3(e) through (k), we generate different data sets by varying parameter PT, Np  and m. In all experiments, Temporal-Apriori performs significantly better than Direct- Apriori. Figure 3(1) shows that Temporal-Apriori scales well when the number of transactions grows large.

5 Related Work  Since the concept of association rule was k s t  intro- duced in El], discovery of association rules has been ex- tensively studied. The concept of association rule was also extended in several ways, including generalized rules and multi-level rules (e.g., [SI), quantitative rules (e.g., [12]), and constraint-based rules (e.g., [4]). Among these exten- sions is the discovery of temporal association rules.

There are several kinds of meaningful temporal associ- ation rules [3, 5, 10, 9, 111. The problem of mining cyclic association rules (i.e., the association rules that occur pe- riodically over time) has been studied in [9]. Several al- gorithms and optimization techniques were presented and shown effective; however, this work is limited in that it cannot deal with multiple granularities and cannot describe real-life concepts such as the first business day of every month. In [ l l ] ,  the work in [9] was extended to approx- imately discover user-defined temporal patterns in associ- ation rules. The work in [ll] is more flexible and practi- cal than [9]; however, it requires user-defined calendar al- gebraic expressions in order to discover temporal patterns.

Indeed, this is to require user?s prior knowledge about the temporal patterns to be discovered.

Our work differs from [9] and [ l l ]  in that instead of using cyclic patterns or user-defined calendar algebraic ex- pressions, we use calendar schema as a framework for tem- poral patterns. As a result, our approach usually requires less priori knowledge than [9] and [ l l ]  (i.e. we need not know or describe each individual ?interesting? temporal pattern). In addition, unlike [ l l ] ,  which discover temporal association rules for one user-defined temporal pattern, our approach considers all possible temporal patterns in the cal- endar schema, thus we can potentially discover more tem- poral association rules.

6 Conclusion and Future Work  In this paper, we proposed two classes of temporal as- sociation rules, temporal association rules w. r.t. precise match and temporal association rules w.r.t. f u u y  match, to represent regular association rules along with their tem- poral pattems in terms of calendar schemas. An immedi- ate advantage is that the-corresponding data mining prob- lem requires less prior knowledge than the prior methods and hence may discover more unexpected rules. In addi- tion, we extended Apriori to discover temporal association rules w.r.t. both precise match and fuzzy match. To deal with the situation when we are not interested in the tem- poral association rules involving only basic time intervals (i.e., time intervals represented by a calendar pattern with 0 wildcard symbols), we developed two optimization tech- niques by studying the relationships among calendar pat-  terns. Our experiments showed that our optimization tech- niques are quite effective. Similar optimization techniques apply to situations where we are only interested in time in- tervals iepresented by a calendar pattern with at least k > 1 wildcard symbols.

The fuiture work includes two directions. First, we would like to explore other meaningful semantics of temporal as- sociation rules and extend our techniques to solve the cor- responding data mining problems. Second, we would like to consider temporal patterns in other data mining problems such as clustering.

