RESEARCH OF DYNAMIC RULE ENGINE IN FINANCIAL

Abstract: It applies a rule engine design scheme with dynamic  programming algorithm and optimal policy in financial  management system. The scheme adopts backward reasoning  method, when the facts and rules change in a small way, the  results of constant parts are kept by the algorithm, and it just  needs to calculate the changing parts. Thus, the massive  repeated calculating workload can be reduced, which  enhances system performance greatly. When the facts and  rules have big changing, the algorithm still retains a high  efficiency. The testing result shows that the average response  time to system is far lower than both of forward reasoning and  ordinary backward reasoning method in same circumstances.

Keywords: Rule Engine; Backward Reasoning; Dynamic  Programming; Optimal Policy  1. Introduction  With the development of the information technology,  both of the market and the demands of customers are  changing inevitably. In order to meet the changes in a  longer period, it?s essential for the financial management  software to face the fundamental issue that the business  rules are changing [1]. The rise of rule engine technology  has provided rule-based programming with a better way to  achieve integration and realization. By separating the  instable business logic from financial management system  and processing it as the structure objects, the complex  business logic can be decomposed into every simple  business rule. Then the complicated logical relationship  between the businesses rules will be given to the engine for  reasoning, enabling the system accommodates business  logic change [2].

RETE algorithm is the most common rule engine  algorithm, but it?s not practical in the situation that  application business rules change in a big way [3]. There  are still some urgent issues need to be solved immediately,  like how to solve reasoning problems and improve the  efficiency of rule reasoning mechanisms and rule match, as  well as reduce the response time when there are mass rules,  facts and big changes[4].

2. Structure analysis of financial software  2.1. Traditional structure  The traditional financial software is generally based on  the C/S structure, the server accepts request from the client,  implements business logic operation, operates the database  to complete the corresponding process ,finally the results  will be returned to the client to get the display; the client  needs to install a specific program called ? fat client?. The  development of Internet technology gives rise to the  emergence of financial system based on B/S hierarchical  structure [5]. For example, E-Bank, stock exchange system,  etc.In the new structure, we form a specialized mid-layer  application server by separating the numerous business  logic and financial computing from the client, and setting  them as mid-layer. The client has to access the mid-layer  application server via the web browser. When the financial  business logic changes, we just have to modify the  corresponding mid-layer components which are used as  reusable components for financial applications.

Consequently, the adaptability and expansibility of the  system can be enforced, as shown in Figure 1.

DataBase  Persistent Layer  DataBase  Client  Browser  Application  Server  (Mid-Layer)  Component 1  C omponentN  Figure 1. Financial system based on the C/S structure  This multi-layered structure is more flexible compared  with the previous C/S structure,however,as the financial       business process become more and more complicate, the  structure shows in Figure1 presents some limitations,  mainly as follow:  (1)The mid-layer components express the financial  business logic more explicitly, but the business model and  business logic remains mixed, the business logic and code  logic haven?t been separated thoroughly. To a certain extent,  there is still a drawback that the logical layers are not  explicit [6].

(2) Although these mid-layer components are reusable,  yet we have to go through a series of steps to accommodate  business logic changes, such as coding, compiling,  release,ect., which makes it become less flexible and  adaptable ,and makes it more complicate for system  upgrade and maintenance.

2.2. Structure based on rule engine  The structure of financial software based on business  rule engine, as shown in Figure 2. A rule server has been  add to the mid-layer in this structure, which including two  models: business model and business rule. The business  rule model can be configured dynamicly.Also, there is an  application server at the mid-layer, which including some  reusable components.

A system based on business rule usually consists of  four parts: rule engine, rule warehouse, rule languages, and  rule management tools. Rule engine is the software  components of business rules implementation, and it?s the  core module of system. Rule warehouse is used for storing  rules and rules metadata, as well as rules attributes. Rule  languages are used to define business rules. Rule  management tools are graphical tools, used for managing,  creating, modifying, and deploying business rules.

Figure 2. Financial system based on rule engine  3. Dynamic programming technology  3.1. Definition  Decomposing the entire process into a series of similar  structure subproblems, the number of variables for each  subproblem can be reduced greatly, and the constraint set  become much simpler, which makes it easier to obtain  global optimal solution. As to optimal problems which can?t  be solved by the analysis form, such as constraint set,  conditions shift, and target function, ect.we can solve every  subprocess by means of enumeration. The more the  constraint conditions are, the smaller decision-making  searching domain will be, thus, making it easier to get the  solution [7].

3.2. Basic principle  For the initial state , policy  is the base condition of the optimal  policy, to any  value:1 , there has:  1x X? 1 *  n  n  )   * *  1 1{ , }nP U U= k K< <=  1 1 1 1 1  *  1 1 1 1 1 1 1 1 ( )  ( , ) ( [ ( , )], k k  n n k k p p x  V x p opt V x p ? ?  ? ? ?  = ?  ( )  [ ( , )] kn kn k  kn k kn p p x  opt V x p ?  3.3. Optimal policy  Suppose the optimal policy is , can  take any value1 , the sub-policies   are also  optimal policy towards the later subprocess initiated with  *  1 1 ( )n nP P x? k K n< < *  knP  *  kx which is defined by  and . Whatever the  initial conditions and decision variables over some initial  period, the remaining decisions must is optimal policy, with  the state resulting from the early decisions [8].

1x *  1 1kP ?  According to the basic principle conclusion, we can  obtain the dynamic programming equation:  1 1 ( )  1 1 1  ( ) { ( ( , ), ( ))},  ,  ( ) ( )  k k k  k k k k k k k k u u x  k k k  x n n  f x opt v x u f x x  x u n  f x x  ?  ?  + + +1 ?  + + +  = =  ? ( ),? =1,2,?, =  With the terminal condition of  decision-making 1 1 1 ( ) ( )x n nf x x?+ + += , here  is a  known function, the terminal condition is called fixed  terminal when take a fixed state, and it?s called free  terminal when is able to vary in the terminal set  .The final optimal target function must obey the  ?  1nx +  1nx +  1nX +      equation .1 1 1 1{ } { ( )}n  x X  opt V opt f x ?  =  4. Backward reasoning based on dynamic  programming  4.1. Terms  Some terms in the paper defined as follows:  (1)Facts buffer A memory buffer is built in the  memory for storing the facts.

(2)Rules buffer A memory buffer is built in the  memory for storing the rules.

(3)Derivation Tree According to the conclusion we  are going to make, firstly search for the relevant rules, then  for the facts that conform to the rule, finally build a  derivation tree that originates from conclusions to rules,  then to facts. As shown in Figure 3.

(4)Derivation Tree Region A memory region which  stores Derivation Tree, so as to search, add, delete, and  modify the relevant reasoning conclusion.

(5)Mid-conclusion node The Mid-conclusion node is  used to store the fact index that conform to relevant rules,  and the rules that generate the node. As described in Figure  3 midcon1 node [9].

conclusionconclusion conclusion  rule 1 rule 2 rule 3  facts 1 facts 3midcon1  rule221 rule222 rule223  facts 2  root  Figure 3. Model of derivation tree  4.2. Algorithm design  In this paper we defines a priority for each rule, the  engine will implement the rule instances one by one  according to sequence of the rule implementation queue.

The rule implementation is probable to change the data  object in the work area, some rule implementation instance  will fail owing to the conditions change, which must be  removed from the queqe.The rules that don?t initially  conform to the condition will possibly be activated, and  generate new rules, enter the queue by implementing  instance. Consequently, a kind of ?dynamic? rule  implementation chain has emerged, forming the reasoning  mechanism of rules. The ?chain? responses of rules are all  driven by data in work area [10].

The performance of the engine is determined by the  efficiency of rule conditions matching, the engine requires  testing data objects from work area, to find out the rules  that conform to conditions from the loading rule set, finally  generate the rule implementation instance. In this paper, we  build an index for facts and rules according to the semantics  [11].

4.3. Reasoning algorithm description  Step I:  If (the reasoning information exists)  {return result ;}  Step II:  else { //the reasoning information doesn?t exist  if (single rule)  { according to the rule condition, initiate with rule  conclusion, go to  }  else {// there is the rule combination to which several  rules must obey simultaneously  Initiate with the highest-priority rule, search  whether there is reasoning information of this rule in such  condition;  If (the reasoning information of this rule in such  condition doesn?t exist)  {search for the rule conditions among all facts, find  out the relevant facts, and then generate a midcon;  build a branch L which connects root node to midcon;  load the relevant facts into facts buffer, load the  relevant rules into rules buffer;  load the relevant fact index into midcon ;}  initiate with the second highest-priority rule,  search for facts according to rules, the fact can be found in  the index facts among the midcon just generated, the rest  can be deduced by analogy.

If we can find the fact in the last rule, that means the  reasoning is successful, and we should build an intact  branch;  submit the result information to the user;  or else, submit non-result information to the user ;}  }  4.4. Derivation tree maintenance algorithm description  Step I:  if (rule delete) then {delete the relevant branch; delete      the branch that is not connected with the root node ;}  Step II:  if (fact delete) {delete index relevant to the fact among  the midcons; delete index relevant to the fact among the  fact nodes;  if (midcon m1 is null) delete m1 ;}  if (fact node f1 is null) {delete fl ;}  if (branch L1 is not connected) {delete L1 ;}}  Step III:  While (add fact/rule) {reason the derivation tree and  the relevant conclusion again, according to the rules or facts  semantics ;}  Step IV:  While (modify fact/rule) {firstly delete, then add.}  4.5. Characteristic of the algorithm  (1)Conclusions to Conditions  The backward reasoning algorithm is different from  the forward one, it initiates with conclusion, so as to search  for conditions with conclusion whose quantity is generally  far less than that of conditions.

For instance, consider we are searching for those who  have used the credit card more than 3 years, given that the  index is built based on binary tree sequence. Suppose  is the total of people, is the total of resident city. select  individual from ,thus the ordering time of forward  reasoning is (order by name),and the query time  is ;However, do the backward reasoning that  firstly order by city, then by name, thus the ordering time  of backward reasoning is  , the query time is  ;Obviously, the backward reasoning cost less  than the forward reasoning. We can conclude that,  backward reasoning is much more efficient, because it  initiates with the conclusion whose quantity is generally far  less than that of conditions.

m  h  k m 2( )O m  ( lg )O k m  2 2 2( * ) ( ) / ( )O h m O m h O k+ + (lg )O h k+  (2) Efficiency  The algorithm keeps the mid-conclusion, so that the  later reasoning can build on the existing conclusion. As to  the done reasoning, take the conclusion directly rather than  reason again. When the facts and rules change in a small  way, as the results of constant part are kept by the  algorithm, it just need to calculate the changing parts, thus,  the massive repeated calculating workload can be reduced,  which enhance system performance greatly.

5.  Experiment  In this paper, we make a test on the PC which has a  Pentium 2.8G CPU and a 2.0G memory. One hundred  thousand records related to credit card information have  been put at Oracle database, as the fact information of rule  engine. Moreover, we have put 10000 rules at the database  as the foundation of reasoning, then process the test. From  Figure 4, we can find that, the time cost of forward  reasoning is about 15 millisecond, however, while 1.8  millisecond of backward reasoning.Obviously, the  backward reasoning has great efficiency.

cost  1 5 9 13 test sequence  forward reasoning ms/per  backward reasoning ms/per/  Figure 4. Cost compare of reasoning  As shown in Figure 5, the reasoning response time  change with the exist of dynamic programming. The  average response time of backward reasoning  (non-dynamic programming) is 3.8951 millisecond. When  the rules and facts change in a small way, the response time  of backward reasoning based on dynamic programming is  about 0.8233 millisecond.So, the backward reasoning  algorithm based on dynamic programming can improve the  performance of the system obviously.

cost  dynamic backward reasoning  normal backward reasoning  test sequence 1 5 9 13  Figure 5.Response time of dynamic and normal  backward reasoning  6. Conclusions  There are so many flexible business rules in modern  financial management system, which makes it much more      difficult to develop such system successfully. In this paper,  it applies the dynamic programming algorithm to backward  reasoning of rule engine,Everytime the reasoning is  implemented, it firstly to find whether this reasoning has  been done before, if it has, took the conclusion  directly.otherwise,implement the reasoning and retain the  mid-conclusion, so that the later reasoning can build on the  existing conclusion. In this way, it can reduce the times of  reasoning and shorten the response time. The testing result  shows that the average response time is less than 4ms,  which is far lower than both of forward reasoning and  ordinary backward reasoning method in same  circumstances. Thus the algorithm can improve the  performance of financial management software obviously,  and we can provide a high-performance scheme for large  financial system based on business rules flow.

Acknowledgements  This paper is supported by the Research Fund of  Guangdong Ocean University, and the Science and  Technology Planning of Guangdong Province.

