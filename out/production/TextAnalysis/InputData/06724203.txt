Association Rule Based Frequent Pattern Mining in Biological Sequences

Abstract?To find all frequent patterns present in a set of strings is computationally intensive. An exhaustive search, where every possible candidate is taken into consideration, is not practical for larger pattern widths due to exponential compu- tational complexity. Other approaches apply heuristics, where algorithm tries to reduce search space, but may compromise the accuracy of results to certain extent. We used modified Apriori algorithm to mine possible patterns in a very long sequence, especially most frequent substring pattern of a fixed length in biological sequence. The algorithm gives good performance by rapid reduction in search space, and computations using bit-wise operations instead of expensive string comparison operations.

This algorithm outperform existing pattern finding methods such as MEME in terms of execution time.

Keywords?Most Frequent Pattern, Apriori, Genomic Sequences

I. INTRODUCTION  Pattern matching problem has been extensively studied due to its wide applications, and numerous algorithms have been developed. The practical applications of pattern match- ing especially string matching ranges from word processors, information retrieval, to bio-informatics and many others. The matching problem are of two types-exact and inexact string matching. The exact string matching searches for presence of a given string in another one while inexact allows some tolerance in matching. Let X be a string of length m and Y be a string of length n, the simple and direct method to search for Y on X will have a time complexity of O(mxn). Since the sub string Y can be start at any location from the first to (m ? n + 1)th position of X, each comparison requires a maximum of n comparisons, total number of comparison is up to n(m+ n? 1). Knuth-Morris-Prat algorithm and Boyer- Moore [1] algorithm, reduces the number of comparisons to O(m+n), by introducing pre-processing steps such as right- to-left scan, Bad character rule and Good suffix rule. Another break through in the area is algorithms with suffix tree. A suffix tree represent internal structure of any given string. For given string X of length m, the suffix tree consists of exactly m leaf nodes. Once tree has been constructed, any arbitrary string Y of length n can be matched O(n) time. Though the naive method for construction of suffix require O(m2) time, Esko Ukkonen developed an algorithm for tree construction in linear time[2].

Another difficulty is space requirement, which is impractical for very long strings, as even most efficient representation,  a rank selection operation requires m log2m + O(m) bits [3]. Abhilash Srikantha and Ajith S Bopardikar developed an algorithm for fast exact sequence search on large DNA sequence by making use of hash tables and Q-grams[4]. In the case of inexact string matching, strict one to one match between the alphabets is not intended. In this context the word sequence is more appropriate than string. When two sequences are compared the measure of their similarity can be determined, in terms of the number of identical symbols in them. Such a sub-sequence present in both sequences are called common sequence. A Longest Common Sequence(LCS) is sequence which is having maximum length.

The string matching dimension is exploded when it is required to find all occurrences of unknown patterns in a given set of strings. In given input of length N, finding all pattern exist in it is a NP-hard problem[5]. Pattern discovery is a fundamental problem in bio-informatics. Repeated patterns of small and large sequences are common in biological sequences. Some authors suggest that these patters are deciding factors in structural and functional properties of molecules[6]. There are many types of repeats such as Short Sequence Repeats(SSR), Palindrome Repeats, Tandem Repeats, and Highly Periodic Repeats[7], [8]. Tandem Repeats are adjacent patterns of two or more nucleotides in a DNA sequence. For example the pattern A-T-T-C-G is repeated twice in A-T-T-C-G-A-T-T-C-G. SSR are also called micro satellites. When exactly two nucleotides are repeated, it is called dimers, and when three, four, five and six nucleotide repeats are called trimers, tetramers, pentamers, and hexamers respectively. When 10-60 nucleotides are repeated, it is called mini satellites.



II. RELATED WORKS  The term motif is generally is used to describe a short pattern that is found in upstream of transcription sites of genes, and are responsible for gene regulation[9]. Motifs belong to the inexact string matching category, since strict pattern adherence is not mandatory. The motif discovery algorithms belongs to three different categories- Enumeration, Deterministic Optimization and Probabilistic Optimization.

First one is a exhaustive search which enumerates all possible patterns, but algorithm is suitable only for short patterns as its computational complexity is exponential. Timothy L. Bailey     and Charles Elkan developed an algorithm named MEME to identify motifs in unaligned sequences[10], [11]. MEME works on the principle of Expectation Maximization[12].

Expectation Maximization(EM) aligns a set of sequences without knowing the starting position of possible motif.

By initial assumption of a motif, it find out the probability estimate of a motif that starts at position j in sequence i. Then, re-estimates the probability that a symbol l appear in column c of the motif. This process of estimation and re-estimation continues until convergence is possible. MEME is extension of EM, where EM is applied only once from starting point derived from the a given subsequence, choose a model of shared motif with highest likely hood, and then run EM until its convergence. AlignACE is algorithm based on Gibbs sampling developed by Roth and Hughes[13]. AlignACE uses MAP(Maximum apriori log likelihood) score as a measure of comparison between expected random occurrence and actual degree of presentation of a motif. MotifLab[14] is a recent tool capable of accessing existing motif discovery tools like MEME, MDScan[15], BioProspector[16], AlignACE and other tools. It provides facility for analysis and visual representation of identified motifs. Wenyuan discusses an algorithm which finds frequent sub-graphs for identifying most frequent patterns from biological networks such as protein-protein interaction, gene functions etc.[17].

Association rules find relationship between a set of data items[18]. These relationships are not generally inherent in data, thus the algorithm has been employed for data mining, especially, finding frequent patterns in transaction databases and similar applications. In biological data analysis, these rules were applied to find the association between different genes and gene expression [19]. A known Association rule algorithm is Apriori algorithm, generate candidates itemsets of a fixed size and scan a database to see whether it is frequent. Let Ci denotes candidate item-set in scan i, and Li denotes set of large (most frequent) items during the scan i, then only items in Li, which is a subset of Ci, are used to generate candidate itemset,Ci+1, for the next database scan.

This is based on the principle of Item-set Property, which says any subset of large item-set must be large. Thus, if we know an item-set is small, we need not generate any super set of it as candidates, because they must also be small. However, this algorithm has serious drawbacks as it requires potentially large number of database scan. So the algorithm assumes that the database is memory resident which in turn limits the size of database. This paper proposes a novel algorithm for identifying most repeated substring from a biological databases.



III. MOST FREQUENT PATTERN GENERATOR  We used a technique that combines Apriori and Partitioning algorithm to find most repeated substrings of any desired size from a set of biological sequences. The biological sequences could be RNA, DNA or Protein sequences. Our attempt is to improve performance of algorithms in two ways, one end by utilizing computationally less intensive operations instead of string comparison and on other hand by drastic reduction in search space as the algorithm progresses.

Fig. 1. Candidate Set Generation  The algorithm works as follows: At first the biological sequence, for example a DNA sequence, is translated to binary sequence by substituting A with 00, C with 01, G with 10 and T with 11. The iterative search begin with single nucleotide sequence (monomers) A, C, G, and T, then proceed with larger sequences using Algorithm 2 BioApriori algorithm. In each iteration, sub-sequences with lesser support are eliminated. Reason for elimination is that sequence cannot be frequent unless a subset is frequent. Let Li is set of most frequent substrings of level i, then candidate set for next iteration is generated by a Algorithm 3 BioSeqGen algorithm.

All combinations substrings in Li are taken into consideration, even a string with itself. Assume S1 and S2 are two strings of size i. Then, candidate substrings of size i+1 is generated if right most (i ? 1) ? 2 bits of substring S1 is same as left most (i? 1) ? 2 bits of second string S2. if so, S1 and S2 are combined to form a new candidate.

Figure 1 illustrates working of algorithm with an example.

The (BioApriori) algorithm in its first iteration counts the strings, A, C, G and T. Assume, all four strings have sufficient support in order to participate generation of candidates in level 2. The BioSeqGen algorithm takes all combinations of A, C, G, and T without any constraints as length of sub-string is just one. The candidate set is AA, AC, AG, AT, CA, CC, CG, CT, GA, GC, GG, GT, TA, TC, TG, TT. Assume that only a subset AA, AG, CG, GC, GT, TA and TG are having sufficient support. The value for support is fixed based on the output requirement. So the combinations of these sub-strings are applied to generate next level candidate item. In level 3, AA and AG combined to generate new candidate AAG, since they a common string ?A? left and right AG and AA extracted. AAA is included in the new candidate set since AA can be combined to itself. Therefore, candidate sets of size 3 are AAA, AAG, AGC, AGT, CGC, CGT, GCG, GTA, GTG, TAA, TAG, TGC, TGT and assume that a substring having sufficient support are AAA, AAG, AGT, CGC, GCG, GTG, TGC. The combinations for these sustrings with a match two symbols produce candidate substrings of size 4.

So GCG combined with CGC could form the candidates GCGC and CGCG. Finally, AGTGC and CGCGC are found as common sequences repeated in the given genomic sequence.

Algorithm 1     Input: 1. Genomic Sequence, eg-DNA sequence //Applicable to  RNA sequence too with minor modification Output: 2. Most frequent pattern // The most frequent substring  (pattern) of a given length Procedure Frequent Pattern Generator 3. Translate Genome sequence into bit sequence (Eg: A -00,  C-01, G-10, T-11) 4. Divide genome into number of blocks with 10% overlap 5. Find most frequent m patterns of a given width from each  block using BioApriori Algorithm 6. Eliminate duplicates due to overlap and division multiple  blocks 7. Sort remaining patterns based on number of occurrences  Algorithm 2 Input: 1. I = {A,C,G, T} //The alphabets of sequence 2. D //The Database - DNA Sequence 3. s // Support 4. n // width of pattern to be identified Output: 5. L // Most frequent pattern identified Procedure BioApriori 6. k = 0 // used as scan number 7. C1 = I // Initialize candidates sets 8. repeat 9. k = k + 1 10. Lk = ? 11. for each Ii ? Ckdo 12. ci = 0 // Initialize count 13. for each Ii ? Ck do 14. while not end of sequence D do 15. tj = leftmost 2 x k bits of D 16. if (IiXORtj == 0) then 17. ci = ci + 1 //increment count 18. shift D left for len(Ii) bits 19. else 20. shift D left for 2 bits 21. if (ci ? S) then 22. Lk = Lk ? Ii 23. Ck+1 = BioSeqGen(Lk) 24. until Ck+1 = ? or k = n // Max pattern width or no  more candidates  Algorithm 3 Input: 1. Li //Frequent pattern of size i Output: 2. Ci+1 // Candidate of size i+1 Procedure BioSeqGen 3. Ci+1 = ? 4. for each I ? Li do 5. for each J ? Li do 6. if (right most (i?1)?2 bits of I == leftmost  (i? 1) ? 2 bits of J) then ?7. Ci+1 = Ci+1 ? (I+ right most 2  bits of J)  TABLE I. NUMBER OF FREQUENCY PATTERN(N.F.P.) AND AGGREGATED CANDIDATES COUNT (A.C.C), WITH SUPPORT = 10 FOR  VARYING SEQUENCE LENGTH (M) IN HUMAN CHROMOSOME 21  width m = 10000 m = 20000 m = 40000 m = 100000 n 4n N.F.P. A.C.C. N.F.P. A.C.C. N.F.P. A.C.C. N.F.P. A.C.C.

1 4 4 4 4 4 4 4 4 4 2 16 16 20 16 20 16 20 16 20 3 64 61 81 64 84 64 84 64 84 4 256 180 261 214 268 240 324 255 339 5 1024 244 505 475 773 668 992 884 1223 6 4096 219 724 491 1264 902 1894 1992 3215 7 16384 202 926 403 1667 729 2623 1898 5113 8 65536 188 1114 352 2019 559 3182 1382 6495 9 262144 179 1293 319 2338 510 3692 1158 7653  10 1048576 168 1461 291 2629 482 4174 1077 8730  TABLE II. NUMBER OF FREQUENCY PATTERN(N.F.P.) AND AGGREGATED CANDIDATES COUNT (A.C.C), WITH SUPPORT = 15 FOR  VARIYING SEQUENCE LENGTH (M) IN HUMAN CHROMOSOME 21  width m = 10000 m = 20000 m = 40000 m = 100000 n 4n N.F.P. A.C.C. N.F.P. A.C.C. N.F.P. A.C.C. N.F.P. A.C.C.

1 4 4 4 4 4 4 4 4 4 2 16 16 20 16 20 16 20 16 20 3 64 56 76 64 84 64 84 64 84 4 256 157 233 203 287 225 309 252 336 5 1024 182 415 374 661 553 862 827 1163 6 4096 176 591 353 1014 606 1466 1422 2585 7 16384 162 753 304 1318 493 1959 1181 3766 8 65536 143 896 263 1581 426 2385 891 4657 9 262144 122 1018 226 1807 401 2786 800 5457  10 1048576 98 1116 188 1995 368 3154 775 6232

IV. RESULTS AND DISCUSSION  The factors which affect the time complexity of Frequent Pattern Generator Algorithm are number of constituent alphabets of genomic sequences, length of sequence to be analyzed(m), length of pattern(n) to be identified, and support threshold(s). The algorithm starts from a basic set of candidates and progresses further by finding most frequent set in each iteration. Algorithm ensures that candidate sets are not grown exponentially, because of the fact that, when any linear sequence of fixed length is examined, all enumerable substrings derive from it, cannot be frequent at the same time, except for some trivial cases. Also the support value fixed have inverse affect on candidate generation. A higher value of support substantially reduce the candidate because, in the kth iteration it combines most frequent patterns from (k ? 1)th iteration and two of them are combined only if (k ? 2) alphabets of two are the same.

The dataset used for evaluation of different design pa- rameters and performance of algorithm has been prepared from human chromosome 21. It consists of multiple sequence segments, each segment having 10000 nucleotides length. The Frequent Pattern Generator algorithm has been applied to the dataset, and time required for pattern discovery for different sequence lengths have been recorded. Here, the time indicates total time required to find all patterns with a given support.

Then, the same dataset has been applied to the motif discovery tool based on MEME algorithm. Both online version and stand alone version MEME are available as free of cost. It can be used to find motifs of given width from set sequences. The total sequence length is limited to 60000 nucleotides. It can     TABLE III. COMPARISON OF EXECUTION TIME REQUIRED TO FIND PATTERNS IN Frequent Pattern Generator AND MEME ALGORITHM  Len.

of  Width Execution time in Seconds  Seq.(m) (n) Freq. Pat. MEME Algorithm Gen. motif1 motif2 motif3 motif4 motif5  20000 10 44.37 15.21 30.48 44.20 59.49 74.33 30000 10 87.38 30.92 62.58 94.50 127.21 159.41 40000 10 147.43 53.56 108.33 161.67 215.43 269.31 50000 10 233.25 96.58 194.06 290.91 381.34 472.79 20000 20 54.85 23.25 46.45 69.37 92.31 114.31 30000 20 121.2 58.77 116.52 174.57 234.20 293.76 40000 20 194.89 104.29 207.12 310.40 408.84 511.98 50000 20 293.83 146.31 290.03 432.21 575.60 718.07  also specify the number of motifs to be identified. MEME gives as output the discovered motifs in their order of significance, and time spent to detect it and many other detailed information.

The experiment started with the use of MEME to discover five motifs from a set consisting of two sequences, each having 10000 nucleotides. The width of motif discovered has been fixed at 10. The experiment has been repeated for three, four and five sequences, and the execution time for each motif discovery has been recorded. Again, the dataset has been used to identify pattern width of 20 nucleotides wide. The Table III and figure 5 shows the execution time in seconds for pattern discovery in Frequent Pattern Generator and MEME. In the case MEME, it is evident from the values in the table that motif discovery time increases according to the number of motifs to be identified. The first row shows results of two sequences of length 10000 nucleotides each, and first motif has been discov- ered in 15.21 seconds and fifth one detected with a total time of 74.33 seconds, whereas the complete set of patterns have been discovered by Frequent Pattern Generator in 44.37 seconds.

In terms of execution times required the Frequent Pattern Generator has outperformed MEME without compromising accuracy of results. The Frequent Pattern Generator algorithm  Fig. 2. Aggregated Candidate Count for varying pattern width and sequence length, with support = 10  has been evaluated for different design parameters. The Ta- ble I shows Number of Frequent Pattern(NFP), Aggregated Candidate Count(ACC) obtained from subsequence consisting 10000, 20000, 30000, 40000 and 100000 nucleotides with a support of 10. Table II shows the data obtained when experiment is repeated with support of 15. The NFP in the kth iteration is the number of patterns contained in the sequence of given length having a support value greater than or equal to  S. ACC in kth iteration is count of candidates examined till the current iteration. The table also shows that Frequent Pattern Generator accepts sequence of length 100000 nucleotides, whereas MEME limits sequence length to 60000, and another motif discovery algorithm AlignACE limits it to 50000.

A. Effects of pattern width n, support s and sequence length m  A general exhaustive search to find most frequent pattern of size n would require 4n comparison, but table I and table II shows that ACC has comparatively very low value in the Frequent Pattern Generator algorithm.

Fig. 3. Execution time required in Frequent Pattern Generator is compared with MEME  The Figure 2 shows that total number of candidates (ACC) generated with different sequences length and support values and establishes the fact that there is only linear increase in ACC when pattern width (m) is increased.

As the value assigned for support(S) increases there will be decrease in the count of pattern satisfying the criteria. The Figure 4 shows the decrease in NFP and ACC when support value is changed from 10 to 15 and sequence fixed at 10000.

Fig. 4. Number of Frequent Patterns compared with different support values, S=10, 15  The sequence length (m) has a linear influence on NFP. As the length of sequence increases there could be more repeating patterns in it, and hence NFP will also increase.

The Figure 5 shows NFP for the sequence length of 10000, 20000, 30000, 40000 and 100000 with a support of 15. Its     Fig. 5. Number of Frequent Patterns compared with different sequence length(m), support fixed at 15  behaviour is same with all sequence lengths, an increase in the initial portion as there more frequent pattern with smaller pattern width, followed by reduction in accordance with the length of pattern.



V. CONCLUSION  In genomic sequences, short repeating sequences are present in abundance and their functions in different genetic activities being identified. The algorithm we discussed in this paper is useful to find repeating patterns present in a genomic sequences. When the experiment is conducted with different sequence length, pattern width and support values, it is concluded that the algorithm converges in reasonable time.

The performance of the algorithm in terms of execution time is far better than other motif discovery algorithms.

