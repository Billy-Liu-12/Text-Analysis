Multiple-Robot Motion Planning in an Unknown and

Abstract?When a Robot finds itself in an unknown and  uncertain environment it needs to retrieve information from its  surroundings so it can perform a task in the appropriate way. A  task may demand far much more capabilities than the ones a  robot can perform by itself, a Multiple-Robot System can  accomplish lots of tasks, however, working with them implies  more uncertainty while executing actions. The desired task in this  case is to move a huge object from an initial position to a final  one. There are two main solutions to this problem, the first one is  to employ a big and expensive robot that is capable of moving the  object. The second choice is to employ a Multiple-Robot System  composed by several low-cost robots. The second one was chosen  because of its economic advantages, although it needs a more  complex way of communication between the agents. This paper  presents a novel form of deploying a coupled Multiple-Robot  System based in a Master-Slave configuration in an Unknown  and Uncertain Environment, where initially only the goal is  known, no a priori environment information is given. This way,  the Multiple-Robot System will need to retrieve data from its  sensors so it can spot itself and build a map while moving  through the space so Classic Path Planning techniques can be  used. The employed algorithms were Approximate Cell  Decomposition, A star, Kalman Filter and Particle Filter; they all  run in MATLAB 2012a. The used robots were Parallax Boe-Bots.

Keywords?multiple-robot; uncertainty; unknown; a star; cell  decomposition; kalman; particle; path planning

I. INTRODUCTION  Moving robots has been one of the biggest issues in Robotics. Lots of techniques have been developed so the Basic Problem can be solved. The Basic Problem states that a robot r must reach a goal g from an initial state i. Autonomous path planning are still one of the most relevant challenges Robotics faces. It must transform a set of tasks that were calculated in a high level language into a set of primitive and low level commands that a robot can perform. A path must be found while the current action is being executed. The development of this area has come through with several innovations such as a digital animation, industrial processes verification as well as pharmaceutical design. Some examples are CyCab?s Segway [16] and Stanford?s Stanley [17] in transportation. RHINO [18] as a Museum Tour Guide, the Mars Rover in Planetary Exploration [19], and the Da Vinci Surgical System [20] in Medicine.

All those examples have in common Robot Path Planning, which is critical for them. Whichever algorithm is employed in them, it has to be capable of finding a collision-free path, calculate all the movements and verify that they are physically performed. The path planner must consider the task that must be performed, the robot and the algorithm. [2] The task can be navigation, localization or coverage. Navigation refers to the calculation of an obstacle free trajectory from an initial point (Pi) to a final point (Pf). When a robot needs to explore all the points in the workspace the task is a coverage task whereas in a localization task the robot needs to use information provided by some sensors. The robot must also be considered along with the environment. Together they determine the number of Degrees of Freedom (DOF) of the system, the workspace and the configuration space. Finally, the chosen algorithm must satisfy certain restraints such as the computational complexity and the solution it returns. Complexity deals with memory limitations and the required time for computing the calculations. The returned solution shows how complete the algorithm is. A complete algorithm guarantees to find a free path whenever one exists and to return failure otherwise.

Approximate methods may not be complete; but, for most of them, the precision of the approximation can be tuned and made arbitrarily small so that the methods are said to be Resolution-complete. [2]  The implementation objectives are to develop a low cost Multiple Robot System capable of moving an object from an initial point Pi  to a goal location Pf; to employ a resolution- complete path planning algorithm to represent the chosen workspace; to implement an online centralized planner that uses sensor-based information; to deal with uncertainty using software solutions; to identify fixed and mobile obstacles; to obtain an optimal path, and to overcome non-holonomic robot restraints. This paper is organized in the following way: Section II presents the State of the Art. Section III gives a brief description of the employed algorithm. Section IV presents the employed robots. Section V shows how software was implemented. Section VI resumes the global algorithm. Results are shown in Section VII, while Future work and Conclusions are presented in Section VIII.



II. STATE OF THE ART  A. Path Planning  The goal of defining a basic path planning problem is to isolate some central issues and investigate them in depth before considering additional difficulties. It states that in W the robot r is the only moving object so all of its dynamic properties are ignored. This way, a physical path planning problem turns into a geometrical path planning problem [2]  The most popular path planning algorithms are Roamaps (Visibility Graph Method, Probabilistic Roadmap, Voronoi Diagram), Cell Decomposition and Potential Field.

B. Robot Formations and Communication  1) Leader ?follower ? The leader-follower scheme can be  implemented when the number of robots goes from 2 to n. A  robot must be the leader. It receives precise instructions from  a path planner of how and when to move. The follower?s talsk  is to track and to follow the leader?s movements.

2) Object Manipulation ? Certain tasks cannot be  performed by just one robot because of its size, wight or the  lack of sensor information. It is quite important to consider  that any cation will affectthe other members of the team, that  is why coordination is critical.[9] Lots of approaches have  been presented for a group of  agents manipulating an object.

One of them proposesto displace an object with multiple-  robots wielding contact forces. Theses are modelled loke non-  linear potential gradients that describe the load deformation.

They also work as implicit communication.[6]. Object  Enclosure proboeses that the transported object is caged by a  team. It creates a bounded and mobile area for transporting  and manipulating it. The robots approach the object indepently  using the Potential Field Algorithm. An optimal formation is  then computed. A robot takes the leader role while the other  gone change their position to create a formation. [7] Software  solutions have developed altorithms where some behaviours  were developed for certain situations in which a robot can spot  itself. The task complexity is evaluated, as well as looking for  a partner, checkin the object and determining if it is possible  to move it.[10] Coupled or decoupled path planning  algorithms for multiple robots are also a solution. The coupled  ones create paths for all the robots by comining the states of  the robots in a space-state. It uses a centralized architecture.

Decoupled algorithms compute the paths for each robot and its  main appeal is the decentralized architecture. Before the  movement is performed, a decision tree must be done with all  the possible robot configurations.

3) Communicatio ?  For  large teams in big, dynamic and  unknown environments where classic communication  mechanisms are not liable, it is necessary to reduce the load in  the data transmission. Several formations can be implemented  as restrictions among each robot position to maintain a certain  shape in the formation. A formation can be represented as a  set of nodes and edges in a connectivity graph. Each node  represents the localization of each agent and the edges  represent the communicaiton links amongh them. The  information flows in a separate way in slow and fast time-  scale.[4]

III. THEORETICAL FRAMEWORK  A. Approximate Cell Decomposition  This path planning approach represents the robot?s free space Qfree as a collection of cells. Cells are required to have a simple predetermined shape. They do not represent exactly the free space; instead, they approximate it in a conservative way.

A connectivity graph that represents the adjacency relationship among the cells is built and searched for a path. The rules to use a cell shape are to achieve space decomposition by iterating the same simple computation, and to be relatively insensitive to numerically approximate computations. [2]  Two cells are adjacent if and only if their intersection is a set of non-zero measure in     . The intersection is computed by taking into account that        , (      )  is identified with (     ).

A cell    is classified as: EMPTY if and only if its interior does not intersect an obstacle region       . FULL if and only if   is entirely contained in the obstacle region,     . It is MIXED otherwise. [1]  The connectivity graphs that is associated with a decomposition   of   is the non-directed graph G defined as follows: The nodes of G are the EMPTY and MIXED cells of . Two nodes of G are connected by a link if and only if the corresponding cells are adjacent. [15]  B. A* (A star)  Informed search algorithms employ problem-specific knowledge beyond the definition of itself. It finds solutions in a more efficient way than uninformed search algorithms. The general form of A* is called best-first search. A node is selected for expanding it based on an evaluation function  ( ) which is calculated as a cost estimated, so the node with the lowest evaluation is expanded first. The choice made by f will determine the whole strategy. Best-first algorithms use a heuristic function  ( ) to be included as a component of f. [13] The node evaluation system is the combination of the cost of reaching the node  ( ) and  ( ), the cost to get from the node to the goal  ( )   ( )   ( ).

( ) is the cost function of moving from the start node to a node n.  ( )  gives the estimated cost of the path with the lowest combined heuristic. By combining them, the estimated cost  ( )  is calculated. If the cheapest solution is being searched, what is usually done is to try the loes value node of g( )   ( ). [1]  C. Kalman Filter  Gaussian techniques all share the basic idea that beliefs are represented by multivariate normal distributions. The density over x is characterized by the mean ? and the covariance ?. ? is a vector that has the same dimensionality as x. ? is a quadratic matrix that is symmetric and positive-semidefinite. The dimension is the dimensionality of the state x squared. [15]  Kalman filters represent the belief bel(xt) at time t by the mean ?t and the covariance ?t.. The input of the Kalman filter is    the belief at time t-1, represented by ?t-1 and ?t-1. To update these parameters, Kalman filter requires the control ut and the measurement zt. the output is the belief at the time t represented by ?t  and ?t..

D. Particle Filter  The particle filter is a nonparametric implementation of the Bayes filter. It approximates the posterior using a finite number of parameters. It represents the posterior    (  ) by a set of random state samples taken from the posterior. Rather than representing the distribution in a parametric form ? like a normal distribution ? particle filters represent a distribution by a set of samples drawn from this distribution. This distribution is approximate and nonparametric so it can represent much better a space of distributions. Another advantage is that it can model nonlinear transformations of random variables. [14] In particle filters, the samples of a posterior distribution are called  particles. Each particle [ ]  (with      ) is a concrete representation of the state at time t. the intuition behind particle filters is to approximate the belief    (  ) by the set of particle . Ideally, the like hood for a state hypothesis    to be included in the particle set    shall be proportional to its Bayes filter posterior    (  ).



IV. HARDWARE IMPLEMENTATION  This work?s main goal is to implement several algorithms and make them interact so the task of the transporting a heavy object is achieved, but it would not be accomplished without the correct hardware.

A. Leader robot ? The leader robot needed to be equipped with a Laser Range Finder to measure the distance  between itself and an obstacle in the environment.

However, if the LRF kept still the information it could  give would be rather limited. That is why it was mounted  over a standard servo motor so it could cover the  environment in an interval [   ]. It was also equipped with a GPS at the top of the Transport Platform so it could  have a clear ?shot? to the satellites to assure liable  information. As this robot leads the other ones, it needs far  much more ?power? to move. Boe-Bots are equipped with  continuous rotation servos with a 2.5 kg-cm torque,  however, they were not enough. Instead, 13 kg-cm torque  servos were employed. Finally, a mechanical structure was  added at its back so it could carry and pull the platform.

(Figure 1 a)    B. Transmitter board ? initiall, the leader robot was equpped with all the sensors and communication devices: GPS,  LRF, Compass and Bluetooth module, but the  microcontroller had nod enough RAM to handle the  retrieved data. The Compass and the Bluetooth module  were assigned to an extra boeard. The hardware split came  up with a new need, somehow the leader and the  transmitter should communicate. A serial communication  between the leader and the transmitter was implemented.

(Figure 1 b)    C. Follower robots ? These robots were equipped with mechanical structures similar to the one in the leader.

However,  they needed a more robust structure that could  handle all the weight they would carry. It goes from the  front part, through both sides ades stops at the back. All  the structure hast the same height and its symmetrical so  the object?s weight will be evenly distributed among it.

The way the folloers will thursue the leader is with the  Line Followers. They are located at the upper front part.

This way the followers will follow the line?s path  wherever it goes, in case that there is no line it will remain  still. (Figure 1 c and d)      a)   b)    c)   d)  Fig. 1.  a)  Leader Robot, b) Transmitter Board, c) and d) Follower  Robots

V. SOFTWARE IMPLEMENTATION  The diagram shown in Figure 2 shows the overall  implementation. The arrows show the way the information  flows through the various elements of the software  implementation. Algorithm interactions are marked with a  dotted line, indirect interaction with a discontinuous line.

Hierarchy is as shown. The diagram shows a general  interaction scheme.

A. Robot Programs  All the robot programs run in a BASIC Stamp 2. It is a handy but limited microcontroller, especially when developing a large and complex implementation. As in any other microcontroller, it has internal auxiliary elements, it is cheap, it can handle several peripherals such as sensors and actuators it uses several communication protocols, but most important of all, it can work in an standalone mode, but despite all those advantages, it has a limited program memory and RAM. The code it executes hall be quite efficient. The BS2 is only in charge of acquiring data from the sensors and executing actions, no data-processing is performed in it. The reasons are simple: operations are far too much complex and valuable information could be lost.

Fig. 2.  Overall Algorithm Block Diagram  B. Planner Programs  The Planner runs in a remote computer. Its task is to compute the employed algorithms: A?, Particle Filter, Kalman Filter, and Cell Decomposition. It requires additional information from the environment, such as the robot?s location, orientation and obstacle presence. That information comes from the Leader Robot?s and the Transmitter Board?s sensors.

After the algorithm?s output is computed, it must translate it to a primitive command for the Robot to execute. The system?s intelligence is contained here; most of the calculations are done in quite large loops, which are not recommended to be implemented in any autonomous system with small memory.

Some other calculations require a more powerful processor: arctangent, float point operations, array manipulation, linear algebra or random number generation.

1) Cell Decomposition implementation ? The Cell  Decompositiion Algorithm will be used to represent a  determined location. As there is no information of where the  obstacles are located in  , the cell size must be set to a very small value  , this way almost always a path will be found. A mapping and correspondece was also implemented between  the cell size and GPS coordinates. The author?s experience in  Mobile Device programming was employed in this area.

2) A* Implementation ? Informed Search Algorithms  require knowledge that will help them find an optimal solution  to a certain problem. An optimal path between    to    shall be found in the minimum possible number of movements so  the heuristic shall penalize the number of movements. The  robot?s environment is defined in Manhattan Distance: it can  only preform vertical or horizontal movements, no diagonals  are allowed. The heuristic is generated with a paraboloid  function, this way it will greedily search for the goal and reach  it. The center of the paraboloid will be located at the goal, so it  will always converge if a path exists, else it will return failure.

3) Particle Filter implementation ? The noise constants  were defined as the bearing noise, steering noise and the  distance. Robot motion is not as exact as one could wish, that  is why these parameters shall be set according to observed  uncertainty. PF deals with Gaussian noise in sensor readings  and motions, noisy constants can be represented as    for a reading ?. Next, the number of particles shall be specified.

This number shall be proportional to the difference of the  maximum and minimun? data in which the algorithm will run.

High precision is reached by using a large set  of particles, its  disadvantage is the elapsed time between calculations.

Now the robot performs a motion. Each of the particle  moves and rotates from their own location. At this point,  distance and steering noise are critical values, they define how  much does each particle really moves. The sensor data is  acquired from the GPS and the Compass. The error  measurement stage takes. It is computed by obtaining the  difference between the physical measurements and all the  computed particles. Finally, a resample takes place. Only  particles with small error survive, the ones that have a big  error are relocated near the real robot location following a  Gaussian distribution.

C. Kalman Filter implementation  The Kalman Filter is tightly related to the LRF samples.

At first, the environment is completely sampled. If an object is  detected, five more environment samples will be taken. The  centroid of the detected object will be computed so just one x  and one y value are used.  The data is introduced to the KF to  esteem where the object will be located at t+1. An initial  sample is used as?. Samples  zt of the whole environment are  taken each 2.7 seconds. (Figure 3)   Fig. 3. Kalman Filter Output

VI. GLOBAL ALGORITHM  The whole algorithm implementation required a coupling strategy so all of the elements could employ the same (or very similar) data. The initial set of particles is thrown and plotted.

A while loop starts at this point. It will only stop if the robot is located at the goal. Particles move according to their location and orientation. After it, the GPS and Compass are read for obtaining the error between the expected and real  Particle Filter  Kalman Filter  Cell Decomposition  A*  Planner  Computer?s Bluetooth  EB500 Module  Transmitter Board  Leader Robot  Follower Robot  GPS Laser Range Finder  Compass    measurement. Particles with small error will survive; the rest of them will be re-sampled until they are located near the actual location Gaussian.

The Kalman Filter is used to map any obstacle present in the surroundings of the robot, in case it is a mobile object, its trajectory is estimated, the previously computed position is used as the initial location of the robot to run A* search for an optimal path. After it, the movement is performed and the while loop repeats until the robot completes the task.



VII. RESULTS  When the algorithm starts running, the particle filter executes with a movement vector [0 0]. The first element represents the travelled distance, the second one the rotation angle. In this special case it stays still. It now finds a path from the current location to the goal state. Each time a movement is performed, all the particles move in the same direction as the robot does. The A* path is also refreshed so it fits the actual location and orientation. As movements go by, the path gets reduced and the particles approach the goal state.

a)    b)    c)  Fig. 4. Overall implementation a) initial path b) 20th movement c) 50th movement  Figure 4 shows some the graphical representation of the particles and the computed path. The estimated location the Particle Filter is shown in the left while the path of A* is in the right. The initial location shows where the robot is at t=0. As the robot performs some movements, the location becomes uncertain because of stochastic events such as loose earth or irregular ground. Previewing these outcomes, the path is recalculated dynamically. When the robot reaches the goal location it returns success and the run is aborted.

Throughout the development of the final implementation lots of problems emerged. The main ones will be now addressed. Hardware design was the first obstacle. Some modifications had to be done to the Boe-Bot Robots so each one of them could perform its task in a better way. Several designs were proposed to assure enough load-capability to the Follower robots.

The structure design came from considering how could the weight be distributed evenly in the the robot?s chassis while having a big contact surface with the Transport Platform.

Another problem was to figure out how they would follow the leader. If a platform was going to be used above the robots, it should help and indicate them where it was moving. The low cost solution was to place a line follower sensor over the Followers and a black line beneath the platform. The only problem is the continuous calibration the sensor needs depending on the amount of light available in the environment.

After calibration takes place, the Follower robots will track the Leader?s movements and they will follow it wherever it goes.

Communication was critical between the Planner, the Board and the Leader. The Leader and the Board use a Serial protocol. The BS2 microcontroller?s pins have the capability of working as a conventional I/O pin, PWM generator or Serial TX/RX. However, it has some problems while handling multiplexed peripherals and communication elements at the same time. Separated input/output pins were used for communication. A timeout was needed between the data reception/transmission. The BT communication between the Board and the Planner presented almost no problems except for the elapsed time in which MATLAB?s buffer is filled.

Algorithm coupling was not as complicated as it was expected.

Almost all algorithms were flexible enough and could handle data with almost no problem at all. The real deal was to parameterize data. This is, some algorithms could handle float point data (Particle Filter and Kalman Filter) but A* needed fixed point to represent a location in . When all of them could work with the same data the processing time and employed resources were diminished.



VIII. FUTURE WORK AND CONCLUSIONS  The obtained results accomplished the expected objectives. An  online centralized low-cost non-holonomic object-carrier  Multiple Robot System was developed. All the employed  algorithms worked as expected, they were also modified so  they could be integrated into the project and coexist and work  together to produce a desired output. This project can grow as  much as imagination can give. Robots can be replaced for  more complexes, powerful and precise robots such as Pioneer    Robots. These Robots are capable of moving any distance (in  meters) as specified, as well as rotating in any direction. Of  course it brings a new set of uncertainties but they can also be  considered in the Particle Filter, they can be modeled as  Gaussians. They are also equipped with far much more  powerful motors, which make them capable of handling large  weights. The sensors they include are more accurate and they  cover the whole front environment. But most important of all,  they can be structurally modified with certain ease. Their main  disadvantage is the presence of a computer that manipulates  them, but due to wireless communications such as XBee, this  is a small problem.

As the implemented robot is a prototype it has several  drawbacks but lots of virtues. Among its virtues is the usage  of low cost robots that work together to perform a task. All the  employed sensors and actuators are not that expensive and  they can be found with ease. All the components are user-  friendly and they can be easily used, nonetheless it is  important to know how they work so all of their capabilities  can be exploited. An object (not quite heavy) can be moved  between two points, for now just a uniformly distributed  weight one. The communications and all of the hardware were  carefully selected so they could be robust and liable while  facing several situations. Durability is a main requirement;  robots must be able to work for a long time during different  conditions. Almost all devices wear out with usage but the  employed ones demonstrated to last long enough while  performing at least 100 tests. There are the main drawbacks:  the first one is the uncertainty that the sensor and actuators  have, for many applications, high precision data is required,  but the employed hardware does not provide it continuously:  motion is not performed as desired and sensors? measurements  may have a huge error or may not sense nothing at all.

An extension to the solved problem is the implementation  of a Multiple Robot-Team System where several teams work  together to deal with objects in the environment. With this  extension, a decentralized schema can be used. Each team will  know the global goal and will plan its actions individually.

Each team can be formed by N robots depending of the object  that is going to be moved, thus, some team members can be  equipped with a robot-arm so the object can be mounted or  dismounted from the platform.

The robot?s processor can be a mobile device such as a  tablet or an smartphone. Currently these devices are capable of  performing lots of calculations at the time, being user-friendly  with a GUI, they have a Bluetooth module and they can access  a remote server via Wi-Fi for instructions or to upload  acquired information from sensors. They are equipped with  lots of useful sensors required for navigation such as GPS,  magnetic field sensor and an altimeter. Extended Reality is  also a great choice for developing products.

Software can be improved in several ways. The path can  be computed while using Dynamic programming, this way a  faster online algorithm can be used. This will reduce the  motion uncertainty. The only disadvantage is that all actions  are computed at the time so there is a large computing-load.

The localization and mapping are done by the Particle Filter  and the Kalman Filter. They can be replaced with a modified-  SLAM algorithm. If a decentralized architecture is used the  computing load will be dramatically reduced.

