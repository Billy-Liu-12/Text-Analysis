Mining Association Rules from the Star Schema on a Parallel NCR  Teradata Database System

Abstract  The Star schema is a popular relational database schema for representing multidimensional data in data warehouses. In this paper, we propose an efficient algorithm, named Star-miner, for mining association rules on the joined result of the tables in the Star schema. The proposed algorithm is designed to be implemented directly on a relational database system by using SQL queries. It is based on the unique properties of the Star schema and does not create the join result of the tables in the schema. We implemented and evaluated the Star-miner on a parallel NCR Teradata database system. The performance of Star-miner is more efficient and scalable than other algorithms which mine the association rules from the single joined table.

1. Introduction  Mining association rules is an important data mining problem, and it is formally described in [1] as follows: Let I = {i1, i2, . . . , im} be a set of items. Let D represent a set of transactions, where each transaction T contains a set of items, such that T ? I. Each transaction is associated with a unique identifier, called transaction identifier (TID). A set of items X is said to be in transaction T if X ? T. An association rule is an implication of the form X => Y, where X ? I, Y ? I and X ??????. The rule X => Y holds in the database D with confidence c if c% of the transactions in D that contain X also contain Y. The rule X => Y has a support s if s% of the transactions in D contain X U Y.

The process of mining association rules is divided into two steps. Initially all sets of items (frequent itemsets) that have support above the user specified minimum support are discovered. Then, association rules that have minimum confidence are easily derived from the frequent itemsets, as described in [2]. In this paper, we concentrate on the computationally intensive step of finding the frequent itemsets.

There are many association rule mining algorithms proposed [1,2,3]. Association rules were first introduced on market basket data and later extended to different kinds of data. Relational databases are widely used to manage corporate data. [8] details the importance of integrating association rule mining with relational database systems. All these association rule mining algorithms assume that data is stored in a single table. Data stored in data warehouses spans across multiple tables, and one popular multidimensional data model used is the Star schema.

The Star schema is a relational database schema for representing multidimensional data. A Star schema consists of a central fact table (relationship table) and multiple dimension tables (entity tables). The fact table forms the relationships among the dimension tables which contain the attributes of entities. The fact table contains foreign keys to the dimension tables. Typical association rule mining algorithms require the join of the fact table and the dimension tables to be computed first before frequent itemsets are mined. Even though the cost of performing the join is not significant compared to the mining step, the disadvantage of such an approach is that the size of the joined result is large. The number of attributes of the joined result is equal to the sum of the number of attributes of the individual tables, and the cost of mining is proportional to the number of attributes. The data stored in the joined result is redundant since the number of times each row of the dimension table appears in the final joined table is equal to the number of occurences of its key or transaction-id in the fact table. Thus, the itemsets are counted more number of times even though they are in only few rows in the dimension tables.

Mining frequent itemsets from the Star schema is divided into two phases. In the first phase, frequent itemsets from each dimension table are mined. Since frequent itemsets are mined with respect to the final joined result, the number of occurrences of the keys of dimension tables in the fact table is used to count itemsets. This step is accomplished easily since the cardinality of the dimension tables is low compared to that of the fact table (property of the Star schema). In the next phase, frequent itemsets mined in the previous phase are used for the efficient mining of the cross-table frequent itemsets. This is based on the fact that all the subsets of a frequent itemset should be frequent  [2]. For example, cross-table candidate itemsets involving items from dimension tables A and B are generated by using the frequent itemsets whose items belong to only table A or table B. We extensively evaluated our algorithm on different datasets and the results prove that it is more efficient than mining the joined result.

2. Related Work  Mining association rules on vertically partitioned tables was first introduced in [4]. An algorithm for mining association rules on the joined result of the Star schema without performing the join operation was proposed in [6]. However, both algorithms are designed for data stored in file systems and use  0-7695-2315-3/05 $ 20.00 IEEE    specialized data structures. These algorithms require data to be loaded from the data warehouse before mining. On the other hand, our Star-miner algorithm can be implemented directly on a relational database system using SQL qureies.

3. Mining Algorithm for the Star Schema  In this paper, SQL queries used for the implementation of the proposed Star-miner are expressed in the extended relational algebraic notations listed in Table 1 [11]. Let A, B, and C represent the dimension tables of a Star schema and FT be the fact table, without the loss of generality. Let a, b, and c be the transaction-ids (or keys) of the dimension tables A, B, and C respectively. Then, the frequent itemsets on table T (T=FT A B C on FT.a=A.a AND FT.b=B.b AND FT.c=C.c) should be mined. We also assume that the attributes in the dimension tables are unique. Within each itemset, the items are ordered in the order of the dimension tables, which means items in A are followed by items in B, and items in C.

Notation Operation  R1 ? R2 UNION  ?<selection condition> (R) SELECT  ?<attribute list> (R) PROJECTION  R1 <join condition>R2 JOIN  <grouping attributes>?<function list> AGGREGATE FUNCTION  ?P(R) RENAME (table name)  ?(b1,b2, ?,bn)(R) RENAME (attributes)  Phase 1: Mining  frequent itemsets on dimension tables  The following queries are used to mine the frequent itemsets whose items belong to dimension table A, assuming table A contains n attributes excluding the transaction-id or key.

1st pass:  AI(a,i1) ?((?(?a,i1(A) ? ?a,i2(A)) ? ? ) ? ?a,in(A))  T??i1,cnt(AI a=a ?(a,cnt)(a?COUNT a(FT))) FA1(i1,cnt) ??cnt>=:minsup(?(i1,cnt)(i1?SUM cnt(T)))  RA1(a,i1)??a,i1(AI i1=i1FA1)  2nd pass:  T1??(a,i1,i2)(?P.a,P.i1,Q.i1(?P(RA1) a=a AND i1<i1?Q(RA1))) T2??(a,cnt)(a?COUNT a(FT)) FA2(i1,i2,cnt) ??cnt>=:minsup(?(i1,i2,cnt)(i1,i2?SUM cnt  (?i1,i2,cnt(T1 a=aT2)))) T??(a,i1,i2)(?P.a,P.i1,Q.i1(?P(RA1) a=a AND i1<i1?Q(RA1) )) RA2(a,i1,i2)??a,i1,i2(T i1=i1 AND i2=i2FA2))  kth pass:  T1??(a,i1,i2, ? ,ik)(?P.a,P.i1,P.i2, ? ,P.ik-1,Q.ik-1(?P(RAk-1) a=a AND i1=i1 AND ? ik-2=ik-2 AND ik-1<ik-1?Q(RAk-1)))  T2??(a,cnt)(a?COUNT a(FT)) FAk(i1,i2, . . . ,ik,cnt)??cnt>=:minsup(?(i1,i2, ? ,ik,cnt)(i1,i2, ? ,ik?SUM  cnt(?i1,i2 ? ,ik,cnt(T1 a=aT2))))  T??(a,i1,i2, ? ,ik)(?P.a,P.i1,P.i2, ? ,P.ik-1,Q.ik-1(?P(RAk-1) a=a AND i1=i1 AND ? ik-2=ik-2 AND ik-1<ik-1?Q(RAk-1)))  RAk(a,i1,i2, . . . ,ik)??a,i1,i2, ? ,ik(T i1=i1 AND ? ik=ikFAk)  In the first pass, frequent 1-itemsets are mined. Table AI is created with only 2 columns (transaction-id, item), and rows are formed by coupling each non-key attribute of table A with its key or transaction-id. The number of occurrences of each key value of table A in FT is counted, and they are joined to AI to obtain the number of occurrences of each item of table A in the joined result. Frequent 1-itemsets are found by selecting only those items that meet the minimum support constraint. Table RA1 is created to store all instances of the frequent items in dimension table A (items together with their transaction identifiers).

In the second pass, table RA1 is joined with itself to obtain all instances of the candidate 2-itemsets. The transaction-ids of the resultant table are replaced by their number of occurrences in table FT, and frequent 2-itemsets are found by selecting only  Table 1. Relational algebraic notations  A a i1 i2 i3 a0 0 4 7 a1 2 5 6 a2 1 3 6 a3 0 4 8 a4 1 3 7  FT a b c a2 b3 c2 a3 b2 c3 a0 b3 c3 a2 b2 c3 a0 b2 c3 a3 b0 c1 a1 b2 c4 a4 b2 c3 a4 b0 c2 a4 b0 c3  B b i1 i2 i3 b0 9 12 15 b1 10 12 16 b2 11 13 15 b3 11 14 17 b4 10 12 15  C c i1 i2 i3 c0 18 23 25 c1 19 21 25 c2 19 23 24 c3 20 22 25 c4 20 22 26  Figure 1. A Star Schema  0-7695-2315-3/05 $ 20.00 IEEE    those itemsets with at least the minimum support. Frequent k- itemsets are found in a similar manner.

The purpose of creating RAk table, containing all instances of the frequent k-itemsets, is to easily find frequent (k+1)-itemsets and cross-table itemsets. Usually the dimension tables are smaller in size compared to the fact tables, thus the overhead of creating RAk table is minimal in terms of the storage space and the time required.

This procedure is repeated on all the other dimension tables. At the end of this step, all the frequent itemsets whose items belong to one dimension table are found (FA1, RA1, FA2, RA2, ? , FB1, RB1, FB2, RB2, ? , FC1, RC1, FC2, RC2, ?).

Phase 2: Mining frequent itemsets across the dimension tables  (1) Mining frequent itemsets across any two dimension tables  The following queries are used to find frequent itemsets whose items belong to dimension tables A and B. AmBn denotes the set of candidate itemsets with m A items and n B items. FAmBn denotes the set of frequent itemsets with m A items and n B items.

1st pass:  T1??(a,b,cnt)(a,b?COUNT a,b(FT)) T2??(i1,b,cnt)(i1,b?SUM cnt(?i1,b,cnt(RA1 a=aT1))) T3??(i1,i2,cnt)(?P.i1,Q.i1,P.cnt(?P(T2) b=b ?Q(RB1))) FA1B1(i1,i2,cnt)??cnt>=:minsup(?(i1,i2,cnt)(i1,i2?SUM cnt(T3)))  In the first pass, frequent 2-itemsets whose first item belongs to A and second item belongs to B are found. Distinct combinations of the transaction-id of A and the transaction-id of B present in FT (T1) are derived and joined to RA1 on the transaction-id of A (a). The resultant table consists of the associations between the items of A and the transaction-id of B (b) which are grouped together (T2) and joined to RB1 on the transaction-id of B (b). Each tuple of the resultant table (T3) consists of an item of A, an item of B and the number of times they are present together in the joined result, from which frequent itemsets are found.

2nd pass:  T??(i1,i2,i3)(?P.i1,P.i2,Q.i2(?P(FA1B1) i1=i1 AND i2<i2?Q(FA1B1))) A1B2(i1,i2,i3)??i1,i2,i3(T i2=i1 AND i3=i2FB2)  T1??(a,b,cnt)(a,b?COUNT a,b(FT)) T2??(i1,b,cnt)(i1,b?SUM  cnt(?i1,b,cnt(?a,i1(RA1 i1=i1?i1(A1B2)) a=aT1))) T3??b,i1,i2(RB2 i1=i2 AND i2=i3 ?i2,i3(A1B2)) T4??(i1,i2,i3,cnt)(?P.i1,Q.i1,Q.i2,P.cnt(?P(T2) b=b?Q(T3))) FA1B2(i1,i2,i3,cnt)??cnt>=:minsup (?(i1,i2,i3,cnt)(i1,i2,i3?SUM cnt(T4)))  In the second pass, frequent 3-itemsets whose items belong to both A and B are found (FA1B2, FA2B1).  Candidate itemsets (A1B2) for FA1B2 are generated by joining two itemsets with the same prefix in FA1B1 and then pruning with FB2. To find frequent itemsets, first all instances of items of table A that are present in the candidate itemsets are derived by joining RA1 with A1B2 on an A item. This table is joined with the derived table containing distinct combinations of the transaction-ids of A and B in FT (T1) on the transaction-id of A (a), and the result is T2. All instances of 2-itemsets in B that are present in the candidate itemsets are derived by joining RB2 with A1B2 on B items, and the result is T3. These derived tables T2 and T3 are joined on the transaction-id of B (b), and the result consists of itemsets that has one item of A and two items of B and the number of times they are present together in the final joined result.

T??(i1,i2,i3)(?P.i1,P.i2,Q.i2(?P(FA2) i1=i1 AND i2<i2?Q(FA1B1))) A2B1(i1,i2,i3)??i1,i2,i3(T i2=i1 AND i3=i2FA1B1)  T1??(a,b,cnt)(a,b?COUNT a,b(FT)) T2??a,i1,i2(RA2 i1=i1 AND i2=i2 ?i1,i2(A2B1)) T3??(i1,a,cnt)(i1,a?SUM  cnt(?i1,a,cnt(?b,i1(RB1 i1=i3?i3(A2B1)) b=bT1))) T4??(i1,i2,i3,cnt)(?P.i1,P.i2,Q.i1,Q.cnt(?P(T2) a=a?Q(T3))) FA2B1(i1,i2,i3,cnt)??cnt>=:minsup (?(i1,i2,i3,cnt)(i1,i2,i3?SUM cnt(T4)))  Candidate itemsets (A2B1) for FA2B1 are generated by joining two itemsets with the same prefix in FA2 and FA1B1, and then pruning with FA1B1. The difference between the generation of FA1B2 and FA2B1, after deriving all instances of A itemsets and B itemsets, is that the derived table with fewer items is joined to FT. This is because the resultant derived table consists of associations between itemsets of one table and the transaction- id of the other table, so it can be compressed more if it has fewer items. Therefore, to generate FA2B1, all instances of B items present in the candidate itemsets are joined to FT on the transaction-id of B (b). This table (T3) is joined to the derived table which consists of all instances of 2-itemsets of table A (T2) on the transaction-id of A (a).

kth pass:  In the kth pass, frequent (k+1)-itemsets whose items belong to both A and B are found (FA1Bk, FA2Bk-1, ? , FAk-1B2, FAkB1).

Candidate (k+1)-itemsets are generated by joining two frequent k-itemsets with the same prefix, and then pruning k-1 times using the appropriate tables. Pruning is performed to check if all the k-subsets of the candidate (k+1)-itemset are frequent (i.e., subset infrequency based pruning). Assuming that candidate (k+1)-itemsets are generated for FAmBn where (m+n)=k+1, following procedure is used.

for j := 1 to j := k if j = 1 if n != 1 T1??(i1,i2, ?, ik+1)(?P.i1,P.i2, ? ,P.ik,Q.ik(?P(FAmBn-1) i1=i1 AND  ? AND ik-1=ik-1 AND ik<ik?Q(FAmBn-1))) else  0-7695-2315-3/05 $ 20.00 IEEE    T1??(i1,i2, ?, ik+1)(?P.i1,P.i2, ? ,P.ik,Q.ik(?P(FAm) i1=i1 AND ? AND ik-1=ik-1 AND ik<ik?Q(FAm-1Bn)))  else if j ??????? if j = 2                                                     // FA0Bn => FBn Tj??i1,i2 ? ,ik+1(Tj-1 i2=i1 AND ? ik=ik-1 AND ik+1=ikFAm-1Bn) else Tj??i1,i2 ? ,ik+1(Tj-1 i1=i1 AND ij-2=ij-2 AND ij=ij-1  ? ik=ik-1 AND  ik+1=ikFAm-1Bn) else Tj??i1,i2 ? ,ik+1(Tj-1 i1=i1 AND ij-2=ij-2 AND ij=ij-1  ? ik=ik-1 AND  ik+1=ikFAmBn-1)  Frequent (k+1)-itemsets are found in a similar way as explained in the second pass. All instances of the itemsets of A that are present in the candidate itemsets are derived by joining RAm with AmBn on A items. All instances of the itemsets of B that are present in the candidate itemsets are derived by joining RBn with AmBn on B items. The derived table with less number of items involved in the frequent itemset is joined on its transaction-id to the projection of FT. The resultant derived table is then joined with the other derived table, and the frequent itemsets are found.

T1??(a,b,cnt)(a,b?COUNT a,b(FT)) if m?? T2??(i1,..,im,b,cnt)(i1,..,im,b?SUM cnt(?i1,..,im,b,cnt(?a,i1,..,im(RAm i1=i1 AND  ? im=im?i1,..,im(AmBn)) a=aT1))) T3??b,i1,?,in(RBn i1=im+1 AND i2=im+2 ? AND in=im+n  ?im+1,?,im+n(AmBn)) T4??(i1,?,im+n,cnt)(?P.i1,P.i2, ? ,P.im,Q.i1,Q.i2,?,Q.in,P.cnt(?P(T2)  b=b?Q(T3))) else T2??a,i1,i2(RAm i1=i1 AND i2=i2 ? AND im=im ?i1,i2(AmBn)) T3??(i1,?,in,a,cnt)(i1,?,in,a?SUM cnt(?i1,?,in,a,cnt(?b,i1,?in(RBn i1=im+1  AND ? in=im+n?im+1,?,im+n(AmBn)) b=bT1))) T4??(i1,?,im+n,cnt)(?P.i1,P.i2, ? ,P.im,Q.i1,Q.i2, ?,Q.in,Q.cnt(?P(T2)  a=a?Q(T3)))  FAmBn(i1,i2,?,im+n,cnt)??cnt>=:minsup(?(i1,i2,?,im+n,cnt)(i1,i2,?,im+n ?SUM cnt(T4)))  The queries used are designed in such a way that the size of the derived tables involved in the join operations are reduced as much as possible. The first optimization step is that only the itemsets present in the candidate itemsets are derived by joining R tables with the candidate itemsets ((RAm ?i1,..,im(AmBn)), (RBn ?im+1,..,im+n(AmBn))). The size of FT is also reduced by selecting only the distinct combinations (including their counts) of the transaction-ids of the corresponding tables (a,b?COUNT a,b(FT)). All instances of itemsets of one table (with less number of items in the candidate itemset) is joined to the projection of FT on its transaction-id ((RAm AmBn) a=a?a,b(FT)). The resultant derived table is grouped with respect to the items of one table and the transaction-id of the other table (?i1,..,im,b((RAm AmBn) a=a?a,b(FT))). This step reduces the size of the derived table and optimizes the mining of the  frequent itemsets, especially in the initial passes. For example, in the first pass, after RA1 is joined to FT (RA1 a=a?a,b(FT)), the resultant derived table is grouped by one item of A and the transaction-id of  B (i.e., maximum number of rows in the derived table = number of items in A ? number of transactions in B). This table is joined to RB1 ((RA1 a=aFT) b=bRB1), and frequent 2-itemsets are found (i.e., maximum number of rows in the final derived table = number of items in A ? number of transactions in B ? number of non-key attributes in B).

In the later passes, the size of the derived table produced by grouping itemsets of one table and the transaction-id of the other table is not reduced much, especially when the number of items of the table with less number of items present in the candidate itemsets is more than 1 (i.e., A2B2, A2B3, A3B3, ?).

But the number of candidates generated becomes smaller, thereby the size of the derived tables is reduced. Thus, the performance of the above queries used to find frequent itemsets from two dimension tables does not entirely depend on the number of transactions in FT, whereas the performance of the algorithms that mine on a single joined table is sensitive to the number of candidates generated and the number of transactions in FT.

This procedure is repeated on all other pairs of dimension tables (AC, BC). At the end of this step, all the frequent itemsets related to any two dimension tables are found (FA1B1, FA1B2, FA2B1, FA1B3, FA2B2, FA3B1, ? , FA1C1, FA1C2, FA2C1, FA1C3, FA2C2, FA3C1, ? , FB1C1, FB1C2, FB2C1, FB1C3, FB2C2, FB3C1, ?).

(2) Mining frequent itemsets across more than two dimensional tables  The following queries are used to find frequent itemsets whose items belong to dimension tables A, B and C.

1st pass:  Candidate itemsets (A1B1C1) for FA1B1C1 are generated by joining two itemsets with the same prefix in FA1B1 and FA1C1, and then pruning with FB1C1.

Frequent itemsets are found by first deriving all instances of A and B items present in the candidate itemsets by joining tables RA1, RB1, A1B1C1 (candidate itemsets) and FT (distinct combinations of a and b). The resultant table is joined with FT (combinations of a, b and c) to obtain the associations between itemsets of A and B, and the transaction-id of C. Frequent itemsets are found by joining with all instances of C items (RC1) present in the candidate itemsets.

T??(i1,i2,i3)(?P.i1,P.i2,Q.i2(?P(FA1B1) i1=i1 AND i2<i2?Q(FA1C1))) A1B1C1(i1,i2,i3)??i1,i2,i3(T i2=i1 AND i3=i2FB1C1)  T1??a,i1,i2(RA1 i1=i1?i1,i2(A1B1C1)) T2??b,i1,a(RB1 b=b?a,b(FT)) T3??a,i1,i2,b(T1 a=a AND i2=i1 T2) T4??i1,i2,c,cnt(T3 a=a AND b=b?(a,b,c,cnt)(a,b,c?COUNT a,b,c(FT)))  0-7695-2315-3/05 $ 20.00 IEEE    T5??(i1,i2,c,cnt)(i1,i2,c?SUM cnt(T4)) T6??(i1,i2,i3,cnt)(?P.i1,P.i2,Q.i1,P.cnt(?P(T5) c=c  ?Q(?c,i1(RC1 i1=i3?i3(A1B1C1))))) FA1B1C1(i1,i2,i3,cnt)??cnt>=:minsup(?(i1,i2,i3,cnt)(i1,i2,i3?SUM cnt(T6)))  2nd pass:  Frequent 4-itemsets whose items belong to A, B and C are found. Candidate itemsets for FA2B1C1, FA1B2C1, FA1B1C2 are generated by the following queries. Frequent itemsets are found in a similar way as in the first pass using the appropriate tables.

For example, to generate FA2B1C1, RA2 and A2B1C1 are used in place of RA1 and A1B1C1.

T??(i1,i2,i3,i4)(?P.i1,P.i2,P.i3,Q.i3(?P(FA2B1) i1=i1 AND i2=i2 AND i3<i3?Q(FA2C1)))  A2B1C1(i1,i2,i3,i4)? ?i1,i2,i3,i4(?i1,i2,i3,i4(T i2=i1 AND i3=i2 AND i4=i3FA1B1C1) i1=i1 AND i3=i2 AND i4=i3FA1B1C1)  T??(i1,i2,i3,i4)(?P.i1,P.i2,P.i3,Q.i3(?P(FA1B2) i1=i1 AND i2=i2 AND i3<i3?Q(FA1B1C1)))  A1B2C1(i1,i2,i3,i4)? ?i1,i2,i3,i4(?i1,i2,i3,i4(T i2=i1 AND i3=i2 AND i4=i3FB2C1) i1=i1 AND i3=i2 AND i4=i3FA1B1C1)  T??(i1,i2,i3,i4)(?P.i1,P.i2,P.i3,Q.i3(?P(FA1B1C1) i1=i1 AND i2=i2 AND i3<i3?Q(FA1B1C1)))  A1B1C2(i1,i2,i3,i4)? ?i1,i2,i3,i4(?i1,i2,i3,i4(T i2=i1 AND i3=i2 AND i4=i3FB1C2) i1=i1 AND i3=i2 AND i4=i3FA1C2)  In the subsequent passes, all combinations of items are generated. At the end of this step, all frequent itemsets related to tables A, B and C are found. If the schema contains four dimension tables, first all itemsets whose items belong to ABC, ABD, ACD, BCD are found, and then all itemsets whose items belong to ABCD are found.

Mining the frequent itemsets across more than two dimension tables is different from mining the frequent itemsets across only two dimension tables. Assume that frequent 3-itemsets are found on tables A, B and C. All instances of 2-itemsets of both A and B that are present in the candidate itemsets are derived by joining tables RA1, RB1, A1B1C1 and FT ((RA1 i1=i1?i1,i2(A1B1C1)) a=a AND i2=i1(RB1 b=b?a,b(FT))).

The derived table is joined to FT (?a,b,c(FT)) and grouped together to obtain the associations between itemsets of A and B, and the transaction-id of C (i.e., maximum number of rows in the derived table = number of distinct 2-itemsets of A and B present in candidate itemsets ? number of transactions in C).

The size of the resultant derived table is not reduced much after grouping, like the case with the initial passes of the frequent itemset mining on two dimension tables. But, in most cases, the number of candidate itemsets generated is smaller, thereby the size of the derived tables to be joined is reduced. Frequent itemsets are obtained by joining the derived table to all occurrences of C items (i.e., maximum number of rows in the  final derived table = number of distinct 2-itemsets of A and B present in the candidate itemsets ? number of transactions in C ? number of non-key attributes in C).

Thus, the performance of the queries to find frequent 3-itemsets from three dimension tables depends on the number of cross- table frequent 2-itemsets found. In the case of having many dimension tables and a very low minimum support, the number of cross-table frequent 2-itemsets found from all the pairs of dimension tables is very high, thereby the performance of the queries would be degraded.

In the later passes, the number of candidates generated is much smaller and the frequent itemsets are found easily. The frequent itemsets whose items belong to more dimension tables are found in a similar fashion. As the number of involved dimension tables increases, the number of candidate itemsets generated would be smaller.

One minor disadvantage of our proposed algorithm is that more tables are generated since a table is created for every combination of items in subsequent passes until no more frequent itemset is found. To minimize this overhead, in the subsequent passes, candidates are not created for those combinations with at least one subset that has no frequent itemset. For example, if the number of frequent itemsets for the combination ApBqCr is 0, then in the subsequent passes, all combinations of AsBtCu where p?s, q?t and r?u are not considered for the generation of candidate itemsets.

4. Performance Analysis  We implemented our Star-miner algorithm on a NCR Teradata database system. It has two nodes, where each node consists of four Intel 700 MHz Xeon processors, 2 GB shared memory, and 36 GB disk space. The nodes are interconnected by a dual BYNET interconnection network supporting 960 Mbps of data bandwidth for each node. Moreover, nodes are connected to an external disk storage subsystem configured as a level-5 RAID (Redundant Array of Inexpensive Disks) with 288 GB disk space. SQL queries are embedded in C++ programs and submitted to Teradata RDBMS through ODBC. More details of the Teradata database system are described in [5, 9, 10].

We used synthetic datasets generated according to the procedure described in [6]. Initially all the dimension tables are generated using the parameter values in Table 2.

Parameter Value  Number of dimensions 3  Number of transactions in each dimension table 1K  Number of  attributes in each dimension table 10  Largest size of frequent itemsets 4  Largest number of transactions with a common itemset   Domain size of each attribute  20  Table 2. Parameters for the generation of dimension tables  0-7695-2315-3/05 $ 20.00 IEEE    The number of transactions in the fact table depends on three parameters: the target frequency of the rules (sup), the number of maximal potentially frequent itemsets (|L|) and the number of noise transactions (N). To generate cross-table itemsets, transaction-ids of the related dimension tables are grouped together sup times in the fact table. This process is repeated |L| times so that |L| maximally potential frequent itemsets would be formed (i.e., number of transactions in FT = (sup ? |L|) + N).

Noise transactions mean the transactions that do not contain frequent itemsets. In real-life datasets, not all the dimension tables are strongly related [7]. For example, if there are three dimension tables A, B and C, most of the cross-table frequent itemsets may consist of items from A and B, and very few from other combinations of the dimension tables (AC, BC, ABC).  In Table 3, the number of related tables is the parameter that represents this situation.

Parameter Value  Number of transactions in the Fact table 100K  Number of  related tables 2  The performance of our Star-miner is evaluated and compared with PSETM [5] and Apriori algorithms. PSETM is an SQL- based frequent itemset mining algorithm on a single table, and it is developed on the NCR Teradata database system. For PSETM, the joined result is computed and converted to (transaction-id, item) format. The Apriori algorithm is implemented on a 500 MHz Pentium III machine with 512 MB memory, running Windows 2000. For both PSETM and Apriori, the time taken to compute the joined result (of the dimension tables with the fact table) is not included in the performance results.

Star-miner is compared with PSETM and Apriori in terms of performance, even though Star-miner and PSETM are implemented on a parallel database system while Apriori is implemented on a PC. Like other SQL-based association rule mining algorithms, the performance of PSETM deteriorates with lower minimum support and a larger number of transactions [8], so it is not comparable with Star-miner and Apriori for some datasets. To demonstarte that Star-miner is efficient even though it is also SQL-based, its performance was also compared with that of Apriori.

We measured the performance of the algorithms by varying the minimum support, the number of transactions, and the number of attributes of the dimension tables. Algorithms are evaluated on two types of datasets. In the first dataset, only two of the three dimension tables are strongly related; and in the second dataset, all three dimension tables are strongly related. In Figures 2-4, Star-miner1, PSETM1, and Apriori1 represent their performance for the first dataset; and Star-miner2, PSETM2, and Apriori2 represent their performance for the second dataset.

The effect of the minimum support on the total execution times of the three algorithms is shown in Figure 2. PSETM performs well for higher minimum support values, but it performance degrades as the minimum support value decreases. The execution time of PSETM increases sharply when minimum support value is decreased from 0.50% to 0.25%. Compared to PSETM, Apriori has steady increase in its execution time.

PSETM and Apriori have almost the same execution time for both datasets because the number of frequent itemsets is nearly equal. Star-miner is efficient for all the minimum support values on both datasets. Star-miner performs better if the number of related tables is smaller because of the overhead of creating a separate table for each combination of the items from the dimension tables. For example, for second dataset, after finding all frequent itemsets whose items belong to AB, BC and AC, all the frequent itemsets whose items belong to ABC are found (i.e., FA1B1C1, FA2B1C1, FA1B2C1, FA1B1C2, ?).

1.00% 0.75% 0.50% 0.25%  Minimum Support  T im  e (s  ec )  Star-miner1  PSETM1  Apriori1  Star-miner2  PSETM2  Apriori2        100 200 300 400 500  Number of Transactions (in 1000s)  T im  e (s  ec )  Star-miner1  PSETM1  Apriori1  Star-miner2  PSETM2  Apriori2  Figure 3 shows how the performance of the three algorithms scales up as the number of transactions in the fact table increases from 100K to 500K. A minimum support value of 0.50% was used. The execution time of both PSETM and Apriori increases almost linearly as the number of transactions increases, but Apriori performs better than PSETM. As expected, the effect of increasing the number of transactions is minimal for Star-miner. The number of frequent itemsets mined for all transaction sizes does not increase much since the minimum support is constant; and the performance of Star- miner mainly depends on the number of frequent itemsets.

Table 3. Parameters for the generation of fact table  Figure 2. Effect of the Minimum Support  Figure 3. Effect of the Number of Transactions  0-7695-2315-3/05 $ 20.00 IEEE    Figure 4 shows the effect of increasing the number of attributes of each dimension table. A minimum support value of 0.50% was used. When two more attributes are added to each dimension table, six more attributes are added to the joined result. As a result, the number of frequent itemsets mined increases multifold, and the execution time increases sharply for the three algorithms. PSETM ran out of available storage space when the number of attributes becomes 14 for each dimension table. Star-miner performs better in all the cases, but its execution time increases sharply when the number of attributes is increased from 14 to 16.  Interestingly, the number of frequent itemsets mined from the first dataset is more than that from the second dataset when the number of attributes is 14 or 16.

8 10 12 14 16  Number of Attributes  T im  e (  se c)  Star-miner1  PSETM1  Apriori1  Star-miner2  PSETM2  Apriori2  5. Conclusion  In this paper, we propose an efficient algorithm, named Star- miner, for mining frequent itemsets on the joined result of the tables in the Star schema. The proposed Star-miner algorithm can be implemented directly on any relational database system by using SQL queries. We implemented the Star-miner algorithm on a parallel NCR Teradata database system, and compared its performance with that of other algorithms in various cases. The Star-miner algorithm is more efficient than other algorithms which mine the frequent itemsets from a single joined result of the tables in the Star schema. The performance of Star-miner is quite scalable in terms of the number of attributes and the number of transactions in the dataset.

