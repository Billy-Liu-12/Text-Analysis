Efficient Mining of Weighted Frequent Itemsets  Using MLWFI

Abstract?Efficient algorithms for mining weighted frequent itemsets are crucial for mining weighted association rules.

However, the use of frequent itemsets has been limited by the high computational cost. Meanwhile, the ?downward closure property? is invalid in the weighted association rule mining model. In this paper, we define a new problem of finding the weighted frequent itemsets with a maximum length (MLWFL) and present a novel algorithm to solve these problems. Our methods are scalable and efficient in discovering significant relationships in weighted settings as illustrated by experiments performed on simulated datasets.

Keywords-Weighted association rules mining; Weighted potential frequent itemsets; MLWFL

I.  INTRODUCTION Lots of weighted frequent pattern mining algorithms [1-4]  are based on the Apriori algorithm [5] which uses a candidate set generation and test mechanism. However, it has been proved that FP-tree based algorithm is more efficient than the Apriori-like algorithm. In the FP-growth (Frequent pattern growth) algorithm [6], the frequent pattern tree structure is an extended prefix-tree structure for storing compressed and crucial information about the frequent patterns. An improved algorithm WIP [7] was proposed by U. Yun et al. The main idea of WIP is to push weight confidence into the weighted frequent pattern mining algorithm based on the FP-growth approach and prune uninteresting patterns. However, the mining process may produce a large number of conditional pattern trees, which may lead to high cost of both runtime and memory space.

In this paper, we propose a novel mining algorithm using MLWFI (M-MLWFI) to resolve above mentioned problems.

M-MLWFI integrates a variety of algorithmic ideas into a practical algorithm. Here, we first define a new conception WPFI for weighted patterns mining. Secondly, we define a new problem of finding the weighted frequent itemsets with a maximum length. Indeed, maximum length itemsets can be efficiently identified in very large datasets. Also, a number of optimization techniques have been exploited to prune the search space. Finally, we conduct several experiments to compare our proposed algorithm with previous methods, and demonstrate the performance improvements of our algorithm.



II. DEFINITIONS Given a database with a set of transactions  1 2{ , ,..., }mD T T T= and a set of items 1{ ,..., }nI i i= , in which ji ( 1,2,..., )j n= , and each transaction  kT ( 1,2,..., )k m= is a subset of I. Let 1 2{ , , ..., }nW w w w= (0 1)jw? ? be a set of weights corresponding to the itemset I, and jw is the weight of the item ji . T is called a maximal frequent itemset if it has no proper superset that is frequent.

Let MLWFI denote the set of all maximum length weighted frequent itemsets.

Definition1. Weighted frequent: Given a database D and a weighted support threshold wminsup, if a pattern X satisfies:  ( )Wsupport X wminsup?                      (1)  We call this pattern X weighted frequent pattern. Meanwhile, the count of X must satisfy:    , 1  ( )  j  n  j i X j  wminsup n N support_count X  w ? =  ? ??           (2)  where N denotes the number of transactions in D, and n is the size of pattern X.

Definition2. The maximum possible weight ( mpW ): Let Y be a p-itemset, and X is a superset of Y with the k-itemset (p<k).

In the set of the remaining items (I-Y), let the items with the descending (k-p) greatest weights  1 2 , ,...,  k pr r r I I I  ? . The  maximum possible weight for any k-itemset containing Y is  defined as , 1 1  1( , ) ( ) l  j  n k n  mp j r i Y j l  W Y k w w k  ?  ? = = = + , in which the first  sum is the average weight for the p-itemset Y, and the second sum is the average weight of the (k-p) maximum remaining itemsets.

If a superset of p-itemset Y is weighted frequent, its minimum support and the minimum support count can be given by  ( , ) ( , )mp  wminsup R Y k  W Y k =                             (3)  ( , ) ( , )B Y k R Y k N= ? ,                    (4)     in which the function ( , )B Y k is an integer with an upper bound of the value. We call ( , )B Y k the k-support bound of the itemset Y.



III. M-MLWFI ALGORITHM   A. Mining MLWFI with WFP-tree To mine all the WFI (weighted frequent itemsets) in a  database, we shall first find all the maximal length weighted frequent itemsets (MLWFI) in a database. We divide mining the whole WFP-tree into mining smaller WFP-trees which include the maximum length weighted frequent itemsets (MLWFI) and the maximum length weighted infrequent itemsets (MLWII) with the single path. In the initial WFP-tree, an itemset with maximum length is a complete path from the root. For MLWII with size n, we divide it into the itemsets with size ( 1n ? ) until MLWFI is found. For MLWFI, we can easily find all the weighted frequent subsets based on the lemma1.

For the remaining weighted infrequent itemsets (WII) in MLWII, we shall mine it similar to FP-growth algorithm.

For instance, in Figure 1, there are three paths in the initial WFP-tree, in which 5 1I I and 5 4 1I I I are subsets of the longest itemset 5 4 2 1I I I I , so we obtain only a path with maximum length. According to definition2, we can judge that 5 4 2 1I I I I  is weighted infrequent, thus 5 4 2 1I I I I is a MLWII. Then we divide  5 4 2 1I I I I into three subsets with length 3 as 5 4 1I I I , 5 4 2I I I , 4 2 1I I I . The split process doesn?t stop until we find 5 4 2I I I is a  MLWFI. Subsequently, we mine the itemset 5 4 2I I I by lemma1 and mine 5 4 1I I I , 4 2 1I I I by generating conditional pattern trees similar to the FP-growth algorithm.

root  NULL  5:7I  4:6I  2:5I  1 : 2I 1:1I  NULL  NULLNULL  NULL  root  5I  4I  2I  1I  1:1I  NULLNULL  root  5I  4I  1I  T1  root  5I  4I  2I  T2  root  4I  2I  1I  : is a MLWFI  : is not  a MLWFI   Figure 1.   Subtree generating    B. The M-MLWFI algorithm Algorithm1. M-MLWFI algorithm Input: Transaction database D , represented by WFP-tree  constructed according to Algorithm 1, the threshold wminsup, the weighted potential 1-itemsets 1C , and the total number of the transactions and total number of the items  Global: MLWFIList: the set of maximum length weighted frequent itemset found so far WIIList: the set of weighted infrequent itemset found so far  Head: a list of items; Tree: the initial WFP-tree Output: The complete weighted frequent itemsets Procedure M-MLWFI (T) { (1) IF T contains a single prefix-path part of Tree; // Mining  single prefix-path WFP-tree (2) Then IF ExpectedWeight (all the items in the single  path)?sup (largest itemsets I in this path)>= wminsup (3)      THEN{ (4)           Empty MLWFIList; (5)           Insert I into MLWFIList; (6)      ELSE { (7)           Divide T into Size ( ) =Size (T) 1 (8)  IF Weights ( ) ?sup (itemsets J in with  longest length)>= wminsup (9)  Insert J into MLWFIList; (10)           Insert (I( )  J) into WIIList; } (11)  FOR EACH items i in MLWFIList DO{ (12)      Append i to Head; (13)      Construct Head?s weighted itemsets using FWS (find  weighted subsets);} (14)  FOR EACH items j in WIIList DO{ (15)      Append j to Head; (16)      Construct Head?s conditional pattern base using FP-  growth;} (17)  // end of procedure  Method FWS: Wifi: the weighted infrequent itemsets found so far Wfi: the weighted frequent itemsets found so far Procedure FWS Tree  { (1) FOR EACH weighted itemsets t in Tree; (2) THEN IF i is a subset of t (3)     THEN IF ExpectedWeights (i)>= ExpectedWeights (t-  i) (4)     Insert i to Wfi; (5) ELSE insert i to Wifi; }  Method FP-growth: Procedure FP-growth (Tree, ) { (1) this Tree contains a single prefix path   // Mining single  prefix-path WFP-tree with Wifi (2) then { (3)    let P be the single prefix-path part of Tree; (4)    for each combination (denoted as ) of the nodes in the  path P do (5)        generate pattern with support=minimum  support of nodes in (6)    let freq_pattern_set (P) be the set of patterns so  generated;    } }

IV. EXPERIMENTAL EVALUATION In this section, we present the experimental results for  our algorithm. A series of experiments have been done to show the performance of our algorithm on AMD Sempron (tm) Processor 2800+ machine with 1G of main memory,     running Microsoft Windows XP Professional operation system. All codes and interfaces are written in JAVA.

A. Comparison of M-MLWFI with MINWAL (O) and WIP We evaluate the performance of M-MLWFI and compare  it with previous mining algorithms MINWAL (O) and WIP.

Experiments are performed on the simulated datasets with different dataset sizes and parameters.

We first investigate the impact of various wminsups on the runtime. Figure 2 shows the performance results of M- MLWFI versus MINWAL (O) and WIP with varying wminsups from 0.05% to 0.30%. The datasets consists of 5,000,000 transactions. As we can see, when the wminsup increases, the runtime for the mining algorithms decreases rapidly, and M-MLWFI performs more efficiently than the other two algorithms. The improvement is more obvious when the wminsup is low. For instance, the runtime of M-MLWFI at wminsup of 0.30% is about 77% of MINWAL (O) and 88% of WIP, but it is only 53% of MINWAL (O) and 63% of WIP at wminsup of 0.05%. This is because when the wminsup is low, for MINWAL (O), it needs to deal with more candidates without any effective pruning. WIP also need to enumerate a large number of conditional pattern trees. In contrast, M- MLWFI uses the pruning technique to reduce the itemsets and uses the tree-structure to store the itemsets. On the other hand, for M-MLWFI, finding maximum length weighted itemsets can largely speed up the processing.

Figure 2.  Runtime versus wminsup.

Figure 3.   Runtime versus dataset size.

Next, we investigate the performance improvement of M- MLWFI on datasets with various sizes. In Figure 3, we make comparisons among the three algorithms with varying number of transactions form 10,000 to 100,000. The specified wminsup is set to 0.15%. The experimental results show that all algorithms scale almost linearly with dataset size. But M- MLWFI performs much better than WIP and MINWAL (O), when the number of transactions increases, the improvement of M-MLWFI becomes more dramatically. The reasons are shown as follows: Firstly, compared to MINWAL (O), M- MLWFI runs faster because it needn?t to scan the original database many times due to the tree-based structure. In addition, M-MLWFI uses new techniques to prune infrequent itemsets, thus fewer itemsets are enumerated. Secondly, although WIP works based on the FP-tree structure, it is costly to deal with conditional pattern trees of all the itemsets. In conclusion, we can say that M-MLWFI scales well with database size.



V. SUMMARIES In this paper, we introduce the problem of weighted  frequent itemsets mining and identify some definitions for the proposed problem. We propose an efficient algorithm, M- MLWFI, which is built on top of finding the maximum length weighted frequent itemsets and makes use of the WFP-tree structure. In comparison with the classical weighted mining algorithms MINWAL (O) and WIP, our experimental results show that M-MLWFI is a faster method for mining weighted frequent itemsets. M-MLWFI also exhibits a good scalability as illustrated by experiments.

