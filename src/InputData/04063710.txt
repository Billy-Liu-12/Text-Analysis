A New Algorithm for Maintaining Closed Frequent Itemsets in Data Streams

Abstract   Online mining of closed frequent itemsets over streaming  data is one of the most important issues in mining data  streams. In this paper, we propose an efficient one-pass  algorithm, NewMoment to maintain the set of closed frequent  itemsets in data streams with a transaction-sensitive sliding  window. An effective bit-sequence representation of items is  used in the proposed algorithm to reduce the time and  memory needed to slide the windows. Experiments show that  the proposed algorithm not only attain highly accurate  mining results, but also run significant faster and consume  less memory than existing algorithm Moment for mining  closed frequent itemsets over recent data streams.

1. Introduction Online mining of data streams is one of the most interesting research issues of data mining in recent years. Data streams have the unique characteristics as described below [3, 8, 10]: (1) Unbounded size of input data; (2) Usage of main memory is limited; (3) Input data can only be handled once; (4) Fast arrival rate; (5) System can not control the order data arrives; (6) Analytical results generated by algorithms should be instantly available when users request; (7) Errors of analytical results should be bounded in a range that users can tolerate.

Many previous studies contributed to the efficient mining of frequent patterns in streaming data [4, 5, 6, 7, 11, 12, 13, 14, 15, 16, 17, 18, 19]. According to the stream processing model [20], the research of mining frequent patterns over data streams can be divided into three categories: landmark windows [15, 12, 19, 11, 13], sliding windows [5, 6, 14, 16, 17, 18], and damped windows [7, 4]. Two types of sliding widow, i.e., transaction- sensitive sliding window and time- sensitive sliding window, are used in mining data streams.

The basic processing unit of window sliding of first type is an expired transaction while the basic unit of window sliding of second one is a time unit, such as a minute or an hour.

Chi et al. [6] proposed a transaction-sensitive sliding window based algorithm, called Moment, which might be the  first algorithm to find frequent closed itemsets (FCI) from online data streams with a transaction- sensitive sliding window. A summary data structure, called CET (Closed Enumeration Tree), is used in the Moment algorithm to maintain a dynamically selected set of itemsets over a transaction-sensitive sliding window. These selected itemsets consist of closed frequent itemsets and a boundary between the closed frequent itemsets and the rest of the itemsets. CET can cover all necessary information because any status changes of itemsets (e.g. from infrequent to frequent or from frequent to infrequent) must be through the boundary in CET.

Whenever a sliding occurs, it updates the counts of the related nodes in CET and modifies CET. Experiments of Moment show that the boundary in CET is stable so the update cost is little. However, Moment must maintain huge CET nodes for a closed frequent itemset. The ratio of CET nodes and closed frequent itemsets is about 30:1. If there are a large number of closed frequent itemsets, the memory usage of Moment will be inefficient.

The purpose of this work is on closed frequent itemsets mining over online data streams with a transaction-sensitive sliding window. An efficient algorithm, called NewMoment , is proposed to mine the set of closed frequent itemsets over online data streams with a transaction-sensitive sliding window. Experiments show that the proposed NewMoment algorithm not only attains highly accurate mining results, but also runs significantly faster and consumes less memory than Moment algorithm [6] for mining closed frequent itemsets over the most recent w transactions of a data stream.

The remainder of the paper is organized as follows. The problem is defined in Section 2. Section 3 presents the proposed NewMoment algorithm. Experiments are discussed in Section 4. Finally, we conclude this work in Section 5.

2. Problem Definition Let ? = {i1, i2, ?, im} be a set of items. A transaction T = (TID, x1x2?xn), xi ? ?, for 1 ? i ? n, is a set of items, while n is called the size of the transaction, and TID is the unique identifier of the transaction. An itemset is a non-empty set of items. An itemset with size k is called a k-itemset. A  0-7695-2702-7/06 $20.00  ? 2006    transaction data stream TDS = T1, T2, ?, TN is a continuous sequence of transactions, where N is the TID of latest incoming transaction TN.

A transaction-sensitive window (TransSW) in the transaction data stream is a window that slides forward for every transaction. The window at each slide has a fixed number, w, of transactions, and w is called the size of the window. Hence, the current transaction-sensitive window is TransSWN?w+1 = [TN?w+1, TN?w+2, ?, TN], where N?w+1 is the window id of current TransSW. The support of an itemset X over TransSW, denoted as sup(X), is the number of transactions in TransSW containing X as a subset.

Definition 1 (Frequent itemset) An itemset X is called a frequent itemset (FI) if sup(X) ? s?w, where s is a user- defined minimum support threshold (MST) in the range of [0, 1]. The value s?w is called the frequent threshold (FT) of TransSW.

Definition 2 (Closed frequent itemset) An itemset X is a closed frequent itemset if there exists no itemset X? such that (1) X? is a proper superset of X, and (2) every transaction containing X also contains X?.

Figure 1 is an example of transaction-sensitive window used in this paper. In Figure 1, the size of the sliding window is 4. The first transaction-sensitive widow TransSW1 consists of the transactions from T1 to T4. When the transaction with T5 comes, the transaction-sensitive window eliminates the oldest transaction (T1) from the current window and appends the incoming transaction (T5). The second window TransSW2 is the result after the first time of window sliding.

A transaction data stream is formed by transactions arriving  in series  Figure 1. Example Transaction-Sensitive Window   3. The NewMoment Algorithm In this section, we introduce the proposed NewMoment algorithm. A bit-vector based representation of items is used in the NewMoment algorithm to reduce the time and memory needed to slide the windows. A new summary data structure NewCET1 based on a prefix tree structure is developed to maintain the essential information of closed frequent itemsets in the recent w transaction of a data stream.

1 New Closed Enumeration Tree  3.1. Bit-Vector Representation of Items In the NewMoment algorithm, for each item X in the current TransSW, a bit-sequence with w bits, denoted as Bit(X), is constructed. If an item X is in the i-th transaction of current TransSW, the i-th bit of Bit(X) is set to be 1; otherwise, it is set to be 0.

For example, in Figure 1, the first window TransSW1 consists of four transactions: <T1, (abc) >, <T2, (bcd) >, <T3, (abc) > and <T4, (bc) >, but the second window TransSW2 consists of transactions: <T2, (bcd) >, <T3, (abc) >, <T4, (bc) >, and <T5, (bd) >. Because item a appears in the 1st and 3rd transactions of TransSW1, the bit-sequence of a, Bit(a), is 1010. Similarly, Bit(b) = 111, Bit(c) = 1111, and Bit(d) = 0100. The most left bit of a bit sequence represents the oldest transaction in current window and the most right bit represents the newest transaction.

3.2 Window Sliding Using Bit-Sequences The bit-sequence is efficient in window sliding process. The sliding process consists of two steps: delete the oldest transaction and append the incoming transaction.

3.2.1 Delete the Oldest Transaction In this step, the bit-sequences of items are used to left-shift one bit to delete the oldest transaction. For example, in Figure 1, the bit sequence of item a, Bit(a), is 1010 in the first window TransSW1. If transaction T1 is deleted from TransSW1, Bit(a) becomes 0100. Now the most left bit represents the transaction T2. The most right bit is meaningless and is conserved for next step.

3.2.2 Append the Incoming Transaction After deleting the oldest transaction from current transaction- sensitive window, we set the most right bit of each bit- sequence of items by checking the new incoming transaction TN. We set the most right bit of the bit-sequence of item X to 1 if TN contains X as a subset. Otherwise, we set the bit to 0.

For example, in Figure 1, the bit-sequence of item a, Bit(a), becomes 0100 after deleting the expired transaction T1. Because the incoming transaction T5 does not contain item a, we set the most right bit of Bit(a) to 0, i.e., Bit(a) changes form 1010 to 0100. Similarly, Bit(c) changes from 1111 to 1110 and Bit(d) changes from 0100 to 1001.

3.3 Counting Support using Bit-Sequences The concept of bit-sequence of item can be extended to itemset. For example, in Figure 1, the bit-sequence of 2- itemset ab, Bit(ab), in the TransSW1 is 1010. That means transactions T1 and T3 of TransSW1 contain the itemset ab.

The process of counting support of an itemset is described as follows. Assume that there are two k-itemsets X and Y and their corresponding bit-sequences Bit(X) and Bit(Y). The bit- sequence of the (k+1)-itemset Z = X  ? Y can be obtained by the bitwise AND of Bit(X) and Bit(Y). For example, the bit- sequence of 2-itemset ab, Bit(ab), in the first window TransSW1 is 1010 which can be obtained by bitwise AND the bit-sequences of items a and b, where Bit(a) = 1010 and  c d T6  b d T5  b c T4  a b cT3  b c d T2  a b cT1  Transaction TID Window size w = 4  TransSW1  TransSW2  TransSW3  0-7695-2702-7/06 $20.00  ? 2006    Bit(b) = 1111.

3.4 Building the NewCET The proposed summary data structure, called NewCET (New Closed Enumeration Tree), is an extended prefix tree structure. NewCET consists of three parts.

(1) The bit-sequences of all 1-itemsets in the current transaction-sensitive window TransSWNN?w+1.

(2) A set of closed frequent itemsets in TransSWNN?w+1.

(3) A hash table: For checking whether a frequent itemset is  closed or not, we use a hash table to store all closed frequent itemsets with their supports as keys.

Similar to a prefix tree, each node nI in the NewCET represents an itemset I. A child node, nJ, is obtained by adding a new item to I. But, NewCET only maintains a set of closed frequent itemsets, not all itemsets.

Figure 2 gives the algorithm of building NewCET. In the building algorithm, each nI has a corresponding bit-sequence, Bit(I), to store the support information in the current sliding window. Function Build is a depth-first procedure. Build visits the itemsets of the current NewCET in a lexicographical order. Function leftcheck uses the support of nI as a hash key to speed up the checking.

Figure 3 shows the NewCET in the first transaction- sensitive window TransSW1 when Build is done. The tree nodes with shadow are closed frequent itemsets. For simplicity, the hash table is not displayed in this figure.

Build (nI, N, s)  1:    if support(nI) ? s ? N then 2:        if leftcheck(nI) = false then 3:            foreach frequent sibling nK of nI do 4:                generate a new child nI K?  for nI; 5:                bitwise AND Bit(I ) and Bit(K ) to obtain Bit(I ?K); 6:            foreach child nI? of nI do 7:                Build(nI?, N, s); 8:            if a child nI? of nI such that support(nI?) = support(nI) then 9:                retain nI as a closed frequent itemset; 10:              insert nI into the hash table;  Figure 2. Algorithm of building NewCET   3.5 Deleting the Oldest Transaction Deleting the oldest transaction is the first step of window sliding. First of all, all bit-sequences of 1-itemsets are left- shifted one bit. Then, all items in the deleted transaction are kept. The process can be done by observing the most left bit before the left-shifting.

Figure 4 gives the algorithm of deleting the oldest transaction after left-shifting all the bit-sequences of 1- itemsets. In the Figure 4, the function Delete generates the prefix tree including the itemsets whose supports are s?N ? 1.

This is because the supports of a set of closed frequent  itemsets in previous window would be s?N and then becomes s?N ? 1 after the deletion.

Function Delete is a depth-first procedure. When the recursive calls of nI?s children return, Delete is performed, if nI is a closed frequent itemset, the NewCET is maintained and the hash table is updated. In the lines 19 and 23, if nI is closed frequent itemset in previous window, nI is marked as a non-closed itemset. In this case, nI will not be retained when the function Delete is done. Figure 5 shows the NewCET after deleting the oldest transaction T1.

?  (a): <1010> (b): <1111> (c): <1111> (d): <0100>  (a, b, c): 2 (b, c): 4  Figure 3. NewCET in the first window TransSW1 (tree nodes with shadow are closed frequent itemsets)   Delete (nI, N, s)  1:    if nI is not relevant to the deleted transaction then 2:        return; 3:    else if support(nI) ? (s?N ? 1) then 4:        foreach sliding nK of nI  whose support ? (s?N ? 1) do 5:          generate a new child nI K?  for nI; 6:         bitwise AND Bit(I) and Bit(K) to obtain Bit(I?K); 7:        foreach child nI? of nI do 8:            Delete(nI?, N, s); 9:        if support(nI) ? s ? N then 10:          if leftcheck(nI) = false then 11:              if nI is closed frequent itemset in previous sliding window then 12:                  update the support of nI; 13:                  update nI in the hash table; 14:              else 15:                  retain nI as a closed frequent itemset; 16:                  insert nI into the hash table; 17:          else  /* leftcheck(nI) = true */ 18:              if nI is closed frequent itemset in previous sliding window then 19:                  mark nI as a non-closed frequent itemset; 20:                  eliminate nI from the hash table; 21:      else  / * support(nI) < s?N  */ 22:          if nI is closed frequent itemset in previous sliding window then 23:              mark nI as non-closed itemset; 24:              eliminate nI from the hash table;  Figure 4. Algorithm of deleting the oldest transaction ?  (a): <0100> (b): <1110> (c): <1110> (d): <1000>  (b, c): 3  Figure 5. NewCET after deleting the transaction T1  0-7695-2702-7/06 $20.00  ? 2006    3.6 Appending a New Incoming Transaction Appending the incoming transaction is the second step of window sliding. All the bit-sequences of 1-itemsets are set their most right bit to 1 or 0 based on the incoming transaction TN. We set the most right bit of the bit-sequence of itemset X to 1 if TN contains X as a subset. Otherwise, we set the bit to 0.

Append (nI, N, s)  1:    if support(nI) ? s?N then 2:        if leftcheck(nI) = false then 3:           foreach frequent sibling nK of nI do 4:            generate a new child nI K?  for nI; 5:            bitwise AND Bit(I) and Bit(K) to obtain Bit(I?K); 6:            foreach child nI? of nI do 7:                Append(nI?, N, s); 8:            if a child nI? of nI such that support(nI?) = support(nI) then 9:                if nI is closed frequent itemset in previous sliding window then 10:                  update the support of nI; 11:                  update nI in the hash table; 12:              else 13:                   retain nI as a closed frequent itemset; 14:                   insert nI into the hash table;  Figure 6. Algorithm of appending the incoming transaction   Figure 6 gives the algorithm of appending a new incoming transaction after setting the most right bit of each bit- sequence of 1-itemsets. Function Append is almost the same as Build. Figure 7 shows the NewCET in the second window TransSW2 after appending the incoming transaction T5.

?  (a): <0100> (b): <1111> (c): <1110> (d): <1001>  (b, c): 3 (b, d): 2  Figure 7. NewCET after appending a new incoming transaction T5 in the TransSW2    4. Performance Evaluation of NewMoment In this section, the experiments are performed to compare the proposed NewMoment algorithm with the Moment algorithm [6]. The source code of Moment algorithm, denoted as MomentFP, is provided by Yun Chi [6]. All experiments are done on a 1.3GHz Intel Celeron PC with 512MB memory and running with Windows XP system. The proposed NewMoment algorithm is implemented in C++ STL and compiled with Visual C++ .NET compiler. Moreover, the synthetic data T10.I10.D200K is generated by the IBM synthetic data generator [2]. Total number of items is 1000.

The performance measurements include memory usage, the loading time of the first window, and the average time of  window sliding. Memory usage was tested by system tool to observe real memory variation. Average time of window sliding was reported over 100 consecutive sliding windows. Memory usage  0100200300 1 0.8 0.6 0.4 0.2 0.05Minsup (%)Memory (MB ) NewMoment MomentFP   Figure 8. Memory usage with different minimum supports Time of Loading the First Window  050100 1 0.8 0.6 0.4 0.2Minimum Support (%)Loading Time (seconds) NewMoment MomentFP   Figure 9. Time of loading the first window with different  minimum supports Average Time of Window Sliding00.05 1 0.8 0.6 0.4 0.2Minimum Support (%)Window Sliding Time (seconds) NewMoment MomentFP   Figure 10. Average time of window sliding with  different minimum supports  In this experiment, the minimum support threshold is  changed from 1% to 0.1%, and the size of sliding window is fixed to 100,000 (100K) transactions.

Figure 8 shows the memory usage with KB units. We can observe that memory used by Moment is more than 120MB but used by NewMoment is about 15MB. When the minimum support is down to 0.05%, the memory used by NewMoment is just 50MB but memory of Moment is out of bound (more than 512MB).

Figure 9 shows the loading time the first window. In the first window, both NewMoment and Moment need to build a prefix (lexicographic) tree. We can observe that NewMoment is a little faster than Moment. The reason is that generating candidates and counting their supports with bit-sequences is more efficient than with an independent sliding window (in  0-7695-2702-7/06 $20.00  ? 2006    MomentFP, a FP-tree [6] is used).

Figure 10 shows the average time of window sliding. In the experiment, NewMoment is a little slower than Moment because NewMoment do not use TID sum as another key to speed up left-check step. But we can observe that the difference is about 0.02 seconds. The steps of window sliding can be finished in one second for both algorithms and the difference is meaningless.

We also test NewMoment with different window size and different number of items. NewMoment is still more efficient than MomentFP in executing time and memory usage.

Because of the space limit, we do not list these experiments in the paper.

5. Conclusions In this paper, we propose an efficient single-pass algorithm NewMoment to mine the set of closed frequent itemsets over data streams with a transaction-sensitive sliding window. In New-Moment algorithm, an effective bit-sequence representation is developed to reduce the memory requirement of the online maintenance of closed frequent itemsets generated so far.

