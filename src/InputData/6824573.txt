SECloud: Binary Analyzing Using Symbolic Execution in the Cloud

Abstract?SECloud is a automatic platform to deal with the resource-intensive and laborintensive nature of high-quality software analysis. SECloud parallelizes symbolic execution in computing cloud to cope with path explosion. To our knowledge, SECloud is the first binary analyzing software that scales to large clusters of machines and  can  automatically test real-world softwares (e.g., Squirrel, Aeon, Socat, Aspell, Atphttpd) effectively. It utilizes the technology of loop elision and state merging to reduce the executing path state explosion. SECloud can also diagnose incomplete software patches by analyzing the difference pathes caused by patches. SECloud offers a flexible testing service according to the software testing task. It runs on computing clouds, like Amazon EC2, and takes advantage of  the the flexible computing resource of cloud. Our experiment results show that SECloud can achive 3 to 4 orders of magnitude speedup comparing a state-of-the-art symbolic execution engine (e.g., S2E).

Keywords?symbolic execution; software analysis; parallelize; S2E; state explosion;Amazon EC2

I.  INTRODUCTION SECloud can achieve high levels of automation through  utilizing symbolic execution technology introduced in the 1976 [1]. This method can explore all feasible execution paths in a program, thus being an ideal candidate for test automation.

However, it faces serious challenges, for example: high memory consumption and CPU-intensive constraint solving, both exponential in program's branch size. It is only feasible to test programs with a few thousand lines of code because of the limit of current computing resources.For larger programs, there are too many pathes to test, and the memory always exhausts in a short time. Thus, symbolic execution cannot be used alone in the general software industry, because real software often has millions of lines of code, rendering symbolic execution infeasible. SECloud can test large systems by using selective symbolic execution which just execute the interesting parts of systems and reducing the uninteresting pathes by heuristic methodes.

To our knowledge, SECloud is the first binary analyzing software that scales to large clusters of machines and  can automatically test real-world softwares effectively.We have analyzed softwares like, Squirrel, Aeon, Socat, Aspell, Atphttpd and can replay CVE vulnerabilities of them using SECloud. SECloud run on large shared-nothing clusters of computers, thus harnessing their aggregate memory and CPU resources. While parallelizing symbolic execution is a natural way to improve the technique?s scalability, doing so in a cluster presents significant research challenges: First, balancing execution workload among nodes and tasks becomes a complex multi-dimensional optimization problem with several unknown inputs. Second, global coordination can only be done infrequently, so new search strategies must be devised for exploring a program?s paths in parallel. Third , the merging states between nodes becomes more complex to reduce the execution state.



II. BACKGROUD Software testing is the most commonly used technique for  validating the quality of software, but it is typically a mostly manual process that accounts for a large fraction of software development and maintenance. Symbolic execution is widely used to test, debug, verify softwares. It is one of the many techniques that can be used to automate software testing by automatically generating test cases that achieve high coverage of program executions. Symbolic execution is a program analysis technique that executes programs with symbolic rather than concrete inputs and maintains a path condition that is updated whenever a branch instruction is executed, to encode the constraints on the inputs that reach that program point. Test generation is performed by solving the collected constraints using a constraint solver. Symbolic execution can also be used for bug finding, where it checks for run-time errors or assertion violations and it generates test inputs that trigger those errors.

The original approaches to symbolic execution [1,2,3] addressed simple sequential programs with a fixed number of input data of primitive type. Modern approaches, such as   DOI 10.1109/CBD.2013.31     generalized symbolic execution (GSE) [4] and jCUTE, address multi-threaded programs with complex data structures as inputs. Much of the popularity of symbolic execution applied to large programs is due to recent advances in dynamic test generation [5,19,21,22], extending prior work originating around 90s [6] where the symbolic execution is performed at run-time, along concrete program executions. We discuss these techniques in more detail in the next section.

There are many popular testing tools using symbolic execution, like: Stanford's KLEE, NASA's Java PathFinder, UC Berkeley's CREST and BitBlaze, UIUC's CUTE and jCUTE2, DSLab's S2E, etc. Symbolic execution tools are also now used in industrial practice at IBM (Apollo [7]), NASA and Fujitsu (Symbolic PathFinder), Microsoft (Pex6, SAGE [8], YOGI7 and PREfix),  and form a key part of the com- mercial testing tool suites from Parasoft and other companies [9].

Although we acknowledge that the impact of symbolic execution in software practice is still limited, we believe that the explosion of work in this area over the past years makes for an interesting story about the increasing impact of symbolic execution since it was first introduced in the 1970s.

Symbolic execution still suffers many difficulties. First, the number of  states of symbolic execution  is exponential of the number of paths that need to be analyzed. This can exhaust computing resources quickly. The complexity of the constraints is also growing accompanying the length of paths.

Second, Funcion calls between the test program and its environment is a tough question, i.e., symbolically executing a program that calls into libraries and the OS, or communicates with other systems, neither of which execute symbolically. The environment is not interesting to us, so we unnecessarily execute it symbolically.One possible approach is to simply allow the call to go through into the ?concrete? environment (e.g., to write a file); unfortunately, this causes the environment to be altered for all forked executions being explored in parallel, thus introducing inconsistency. Another approach is to replace the real environment with a symbolic model, i.e., a piece of code linked with the target program that provides the illusion of interacting with a symbolically executing environment. For instance, KLEE uses a symbolic model of the file system. Of course, real-world programs typically interact in richer ways than just file I/O: they fork processes, synchronize threads, etc.  Third, Automatically testing many drivers with symbolic exectution tools (e.g., S2E, KLEE) is difficult for three major reasons. Firstly, the process of configuring symbolic inputs is repetitive and error-prone. A single mistake means the testing software will not initialize. Secondly, developers must supply annotations. Although some tools provides developers with instructions on where to supply the annotations, it reports only one missing annotation at a time.

Consequently, if a testing software requires five annotations, developers must re-execute the same program five times in order to find all five locations. Thirdly, existing tools can only analyze one software at a time, which limits scalability.

This paper aims to address the above difficulties. The rest of the paper is organized as follows. Section 3 proposes the overview of SECloud. The details of scalable parallel symbolic execution are described in section 4. Section 5 introduces the  loop elision to reduce the amout of execution states. The method of State merging is discussed in section 6. We give the implementation of SECloud in section 7. Related work of SECloud  is showed in section 8 and we make the evaluation of SECloud's efficiency in section 9. Finally, Section 10 makes a conclusion.



III. OVERVIEW OF SECLOUD SECloud consists of multiple analyzing processors and a  task balancer. Each task coresponds one task. We can test multiple programs simutaneously. The design of it is shown in Figure 1. Each analyzing processor independently explores a subtree of the program?s execution path tree, by running a symbolic execution engine. The OS kernel and driver under test, as well as user-mode test programs, execute in a virtual machine. Before testing, the user should configure SECloud through a configure file which contains the information about programs under test (e.g., names of programs, the testing priorities of each program, assigning the initial testing resources for programs).The symbolic execution engine provides symbolic inputs and devices for the testing. The binary program under test should be translated into the form of LLVM. Our symbolic execution engine runs on LLVM language. To avoid the path's loop combination explosion, we annotate the loop the structure. SECloud  provides stubs that annotate anywhere in the program you want.

When the symbolic execution engine encounters a conditional branch in the program, it initializes a child node in the execution tree corresponding to each branch outcome. The path selecting strategy is used to decide which node in the tree to go to next (e.g., a DFS strategy would dictate always choosing the leftmost unexplored child, a directed strategy would prefer the path that can reach the target point). Once the path selecting strategy returns a choice, the  symbolic execution engine  calls upon the constraint solver to determine the feasibility of the chosen node, i.e., whether there exist values that would satisfy the conjunction of the branch predicates along the path to the chosen node. If the path is feasible, the runtime follows it and adds the corresponding branch predicate to the path?s constraints; otherwise, a new choice is requested. When symbolic execution engine runs the codes  that may cause a bug, the vulnerability checker will verify this behavior through checking the preconditon or postcondition.

A smart exploration strategy helps find sooner the paths leading to the requested goal. This is particularly relevant for symbolic execution trees of infinite size. The path selecting strategy  can choose any node on the unexplored horizon of the execution tree, not just the immediate descendants of the current node. The overall exploration is global, while SECloud path selecting strategy have visibility only into the execution trees assigned to their particular analyzing processors. Thus, worker-level strategies must be coordinated?a tightly coordinated strategy could achieve as efficient an exploration (i.e., with as little redundant work) as a single-node symbolic execution engine. It is also possible to run multiple instances of the symbolic execution engine and path selecting strategy on the same physical machine, in which case the co-located path selecting strategy  can see all subtrees on that machine. But     tight coupling limits the ability of analyzing processors to function  independently of each other, and would thus hurt scalability. In order to steer path exploration toward the global goal, SECloud employs several techniques: Two-phased load balancing that starts with an initial static split of the execution tree and adjusts it dynamically, as exploration progresses.

Replacing a single strategy with a portfolio of strategies which not only compensates for the limited local visibility, but can also better exploit SECloud?s parallelism. Finally, we employ techniques for reducing redundancy, handling worker failures, and coping with heterogeneity.

Fig. 1. SECloud's main architecture.



IV. SCALABLE PARALLEL SYMBOLIC EXECUTION Symbolic execution is a program analysis technique that  was introduced in the 1976. Symbolic execution means executing a program with symbolic rather than concrete values.

Assignment statements are represented as functions of their (symbolic) arguments, while conditional statements are expressed as constraints on symbolic values. Symbolic execution can be used for many purposes, such as bug detection, program verification, debugging, maintenance, and fault localization. One of the earliest proposals for using static analysis as a kind of symbolic program testing method was proposed by King [1]. The idea is to symbolically explore the tree of all computations the program exhibits when all possible value assignments to input parameters are considered. For each control path p which is a sequence of control locations of the program, a path constraint pc is constructed that characterizes the input assignments for which the program executes along p.

All the paths can be enumerated by a search algorithm that explores all possible branches at conditional statements. The paths p for which pc is satisfiable are feasible and are the only ones that can be executed by the actual program. The solutions to pc characterize the inputs that drive the program through p.

This characterization is exact provided symbolic execution has perfect precision. Assuming that the theorem prover used to check the satisfiability of all formulas pc is sound and  complete, this use of static analysis amounts to a kind of symbolic testing.

The operational semantics of the language for symbolic execution is given in Figure 2.  is the environment, then  , ,PC Pro?? . PC is a path constraint set. ?  maps a variable to its symbolic value or concrete value. Pro is program that is executing. FV  means a flesh symbolic value considering environment .

, , _ (.); , [ ],  , , ; , [ ],  , , ( ); , ,  , , ' ( ), ,  s FV S Input PC x get input P PC x s P  b b S Assign  PC x b P PC x b P  e e S Assert  PC assert e P PC e P  e e e TRUE S If True  PC if e then P else P PC e TRUE P  e e e  ?  ?  ?  ?  ? ?  ? ?  ? ?  ? ?  ? ?  ? ?  ? ?  ?? ?  ? ?  ?? ?  ? ? ? ?  ?? ? ??  ? ?  ?  ?  ?  ?  ? ?  ? ?  , , ' ( ), ,  FALSE S If False  PC if e then P else P PC e FALSE P? ? ? ?  ? ?? ? ??    Fig. 2. Parts of semantics of symbolic execution.

A prototype of this system allowed the programmer to be presented with feasible paths and to experiment with assertions in order to force new and perhaps unexpected paths. King noticed that assumptions, now called preconditions, also formulated in the logic could be joined to the analysis forming, at least in principle, an automated theorem prover for Floyd/Hoare?s verification method, including inductive invariants for programs that contain loops. Since then, this line of work has been developed further in various ways, leading to various strands of program verification approaches, such as verification-condition generation (e.g., [10, 11]), symbolic model checking  and bounded model checking. Symbolic execution is also a key ingredient for precise automatic code- driven test generation. While program verification aims at proving the absence of program errors, test generation aims at generating concrete test inputs that can drive the program to execute specific program statements or paths. Work on automatic code-driven test generation using symbolic execution can roughly be partitioned into two groups: static versus dynamic test generation.

SECloud employs symbolic execution, an automated testing technique that has recently shown a lot of promise. A symbolic execution engine  executes a program with unconstrained symbolic inputs.When a branch involves symbolic values, execution forks into two parallel executions, each with a corresponding clone of the program state.

Symbolic values in the clones are constrained to make the branch condition evaluate to false respectively true. Execution recursively splits into sub-executions at each subsequent branch, turning an otherwise linear execution into an execution tree. In this way, all execution paths in the program are     explored. To ensure that only feasible paths are explored, the symbolic execution engine uses a constraint solver to check the satisfiability of each branch?s predicate, and it only follows satisfiable branches. If a bug is encountered (e.g., a crash or a hang) along one of the paths, the solution to the constraints accumulated along that path yields the inputs that take the tested program to the bug?these inputs constitute a test case.

We use vulnerability checker to find bugs along the paths.

Since the size of the execution tree is exponential in the number of branches, and the complexity of constraints increases as the tree deepens, state-of-the-art symbolic execution engines can quickly bottleneck on CPU and memory even for programs with just a couple KLOC. We therefore build a parallel symbolic execution engine that runs on a commodity cluster and can take advantage of  the flexible computing resource of cloud according to the testing tasking at hand. The key design goal is to enable individual cluster nodes to explore the execution tree independently of each other. One way of doing this is to statically split the execution tree and farm off subtrees to worker nodes. The contents and shape of the execution tree are not known until the tree is actually explored, and finding a balanced partition of an unexpanded execution tree is undecidable. Besides subtree size, the amount of memory and CPU required to explore a subtree is also undecidable, yet must be taken into account when partitioning the tree. Since the methods used so far in parallel model checkers [Barnat 2007, Holzmann 2008] rely on static partitioning of a finite state space, they cannot be directly applied to the present problem. Instead, SECloud partitions the execution tree dynamically, as the tree is being explored.

SECloud consists of Analyzing Processors nodes and Taskcontroler that act as a load balancer. Analyzing Processors run independent symbolic execution engines. They explore portions of the execution tree and send statistics on their progress to the Taskcontroler, which in turn instructs, whenever necessary, pairs of Analyzing Processors to balance each other?s work load.  Encoding and transfer of work is handled directly between Analyzing Processors,  thus taking the load balancer off the critical path. The goal is to dynamically partition the execution tree such that the parts are disjoint (to avoid redundant work) and together they cover the global execution tree (for exploration to be complete). We aim to minimize the number of work transfers and associated communication overhead. A fortuitous side effect of dynamic partitioning is the transparent handling of fluctuations in resource quality, availability, and cost, which are inherent to large clusters in cloud settings. SECloud operates roughly as follows: The first component to come up is the load balancer.

When the first Analyzing Processors node P1 joins the SECloud cluster, it connects to the Taskcontroler and receives a ?seed? job to explore the entire execution tree. When the second  Analyzing Processors P2 joins and contacts the Taskcontroler, it is instructed to balance P1?s load, which causes P1 to break off some of its unexplored subtrees and send them to P2 in the form of jobs. As new Analyzing Processors join,  the Taskcontroler has them balance the load of existing Analyzing Processors. The Analyzing Processors regularly send to the Taskcontroler status updates on their load in terms of exploration jobs, along with current progress in terms of code coverage, encoded as a bit vector. Based on  Analyzing Processors? load, the Taskcontroler can issue job transfer requests to pairs of Analyzing Processors. The source node decides which particular jobs to transfer.



V. LOOP ELISION One major problem with symbolic execution was the need  to annotate some loops to reduce the path explosion, such as checksum loops, in order to permit forward progress.

Executing checksum loops is effectively impossible symbolically because it is similar to finding a set of data that hashes to a given value. In general, the problematic loops are those that generate additional paths on each iteration, and provide no usable mechanism for early termination, such as a break statement. Instead of requiring annotations for these loops, SECloud breaks out of them after one iteration.

Afterward, it stores unconstrained symbolic data in any variables written to during that iteration. SECloud  breaks from the loop after one iteration and replaces the contents of the checksum variable with unconstrained symbolic data. After the loop, there is a conditional statement that compares the unconstrained checksum tally against some constant, and if the check fails, SECloud  will immediately switch to executing the other, successful path. This approach guarantees that all such loops terminate quickly. By introducing additional symbolic data and relaxing constraints, SECloud is making an approximation in the program?s behavior because it cannot model it precisely. In doing so, SECloud is making a compromise in favor of scalability and at the expense of precision. Static analysis tools often make similar approximations. The goal of SECloud is to maintain the highest precision possible while requiring no per-driver effort.

Unfortunately, as expected, this approximation may introduce false positive bug reports. False positives may stem from relaxing constraints on the variables written in the loop, and breaking from the loop early. We have not yet observed false positives stemming from relaxed constraints. However, we have seen false positives resulting from terminating the loop early. For example, some loops that create more paths also interact with the kernel. In one case, a loop created multiple files, to export multiple entry points to the kernel, while also testing some program's input. By breaking from the loop early, the program  would create only one file. Fortunately, most loops either:  do not generate more paths,  do generate paths but do not interact with the kernel, or  provide an existing break statement that allows for early termination. We have found only a few loops that both create more paths and interact with the enviroment.



VI. STATE MERGING Another way to reduce the number of states used by  SEcloud is to merge states that correspond to different paths.

This is standard in classic static analysis, where the resulting merged state over-approximates the individual states that were involved. Several techniques, such as ESP and trace partitioning [12], reduce but do not eliminate the resulting imprecision (which can be a source of false positives) by associating separate abstract domain elements to some sets of execution paths. In symbolic execution, as a matter of principle, a merged state would have to precisely represent the     information from all execution paths without any over- approximation. Consider, for example, the program if (x<0) then x = -1; else  x = 1; with input X0 assigned to x. We denote with (pc; m) a state that is reachable for inputs obeying path condition pc and in which the symbolic store m = {v0 = c0; ... ; vn = cn} maps variable vi to expression value ci, respectively. In this case, the two states (X0  <  0; {x = -1}) and (X0  >= 0; {x = 1}), which correspond to the two feasible paths, can be merged into one state (true; {x = if(X0 < 0; -1; 1)}). Here, if(X0 < 0; -1; 1) denotes the if-then-else operator that evaluates to -1 if X0 < 0 is true, else to 1. If states were merged this way for every branch of a program, symbolic execution would become similar to verification condition generation or bounded model checking, where the entire problem instance is encoded in one monolithic formula that is passed in full to a solver. State merging effectively decreases the number of paths that have to be explored [13], but also increases the size of the symbolic expressions describing variables. Merging introduces disjunctions, which are notoriously difficult for SMT solvers, particularly for those using eager translation to SAT [14].

Merging also converts differing concrete values into symbolic expressions, as in the example above: the value of x was concrete in the two separate states, but symbolic if(X0 < 0; -1; 1) in the merged state. If x were to appear in branch conditions or array indices later in the execution, the choice of merging the states may lead to more solver invocations than without merging. This combination of larger symbolic expressions and extra solver invocations can drown out the benefit of having fewer states to analyze, leading to an actual decrease in the overall performance of symbolic execution [15]. Furthermore, state merging conflicts with important optimizations in symbolic execution: search-based symbolic execution engines, like the ones used in test case generators and bug finding tools, employ search strategies to prioritize searching of ?interesting? paths over ?less interesting? ones, e.g., with respect to maximizing line coverage given a fixed time budget. To maximize the opportunities for state merging, however, the engine would have to traverse the control flow graph in topological order, which typically contradicts the strategy?s path prioritization policy. SECloud  uses a solution to these two challenges that yields a net benefit in practice. We combine the state space reduction benefits of merged exploration with the constraint solving benefits of individual exploration, while mitigating the ensuing drawbacks.

First, we present query count estimation, a way to statically approximate the number of times each variable will appear in future solver queries after a potential merge point.We then selectively merge two states only when we expect differing variables to appear infrequently in later solver queries. Since this selective merging merely groups paths instead of pruning them, inaccuracies in the estimation do not hurt soundness or completeness.Second, we present dynamic state merging, a merging algorithm specifically designed to interact favorably with search strategies. The algorithm explores paths independently of each other and uses a similarity metric to identify on-the-fly opportunities for merging, while preserving the search strategy?s privilege of dictating exploration priorities.Experiments on the GNU Coreutils show that employing our approach in a symbolic execution engine  achieves speedups over the state of the art that are exponential in the size of symbolic input.



VII. IMPLEMENTATION SECloud consists of about 68,000 lines of C/C++ and  OCaml code. Our binary instrumentation framework was built on our own tool Binin and all the hooks for modeled system and API calls were written in C/C++. The symbolic execution engine is written solely in OCaml and consists of about 25,000 lines of code.We rely on our novel tool Bin2L to convert assembly instructions to the LLVM. We use STP as our decision procedure, for which we built direct OCaml bindings.

To allow for remote communication between the two components we implemented our own cross-platform, light- weight RPC protocol (both in C++ and OCaml).



VIII. EVALUATION For all our experiments, we used a heterogeneous cluster  environment with analyzing processors CPU frequencies between 2.3?2.6 GHz and with 4?6 GB of RAM available per core. SECloud can  automatically test real-world software (e.g., Squirrel, Aeon, Socat, Aspell, Atphttpd) effectively. The experiment result is showed in table 1.

On each analyzing processor, the path selecting strategy consists of random-path, coverage-optimized and target- directed strategies. At each step, the engine alternately selects one of these heuristics to pick the next state to explore.

Random-path traverses the execution tree starting from the root and randomly picks the next descendant node, until a candidate state is reached.

TABLE I.  REPLAYING SOME CVE VULNERABILITIES  Programs Vulnerability type CVE ID Time(s)  Squirrel Stack Overflow CVE-2004-0524 0.1  Aeon Stack Overflow CVE-2005-1019 0.2  Socat Format String CVE-2004-1484 3.6  Aspell Stack Overflow CVE-2004-0548 5.2  Atphttpd Stack Overflow CVE-2000-1816 15.7  Mbse-bbs Stack Overflow CVE-2007-0368 22.3  The coverage-optimized strategy weighs the states according to an estimated distance to an uncovered line of code, and then randomly selects the next state according to these weights. To quantify coverage, we consider both line coverage and path coverage numbers. Line coverage measures the fraction of program statements executed during a test run, while path coverage reports how many execution paths were explored during a test. Path coverage is the more relevant metric when comparing thoroughness of testing tools.

Nevertheless, we also evaluate properties related to line coverage, since this is still a de facto standard in software testing practice. Intuitively, and confirmed experimentally, path coverage in SECloud scales linearly with the number of workers.

The target-directed strategy conders the best way to reach the target points. The factors include the length from current point to the target point, the number of ways between the current point and the target point, etc.



IX. RELATED WORK To our knowledge, SECloud is the first binary analyzing  software that scales to large clusters of machines. There has been work, however, on parallel model checking. Nevertheless, there are currently no model checkers that can scale to computing cloud, mainly due to the overhead of coordinating the search across multiple machines and transferring explicit states. Cloud9[18] is a mature symbolic execution tool that parallelizes and diversifies its search strategy on a shared- memory multi-core system. However, it cannot analyze the binary codes.We cannot directly apply those techniques to shared-nothing clusters. Moreover, Cloud9 cannot be used to test the particularly target program points which we are interesting in. It also just analyze one program at a time.There have been previous efforts to scale symbolic execution that do not involve parallelization. For example, concolic testing [16] runs a program concretely, while at the same time collecting path constraints along the explored paths; the constraints are then used to find alternate inputs that would take the program along different paths. Another example is S2E [17], which improves scalability by automatically executing symbolically only those parts of a system that are of interest. In general, SECloud benefits from most all single-node improvements of symbolic execution.



X. CONCLUSION This paper presented SECloud, an automated testing  platform that employs parallelization to scale symbolic execution by harnessing the resources of commodity clusters.

SECloud can automatically test real binary systems, such as Squirrel, Aeon, that interact in complex ways with their environment. It includes a new symbolic environment that supports all major aspects of the POSIX interface, and provides a systematic interface to writing symbolic tests. In the future work, we intend to expand SECloud's application to more wide programs under test, like android, etc.

