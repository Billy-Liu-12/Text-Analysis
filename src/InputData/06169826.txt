An Efficient Incremental Mining Approach   Based on IT-tree

Abstract?The itemset-tidset-tree (IT-tree) is an efficient data structure for association-rule mining. Zaki et al. designed a mining algorithm based on the IT-tree stucture, which traversed an IT-tree in a depth-first order, generated itemsets by using the concept of equivalence classes, and computed the support values of itemsets fast by tidset intersection. It, however, needed to process all transactions in a batch way. In this paper, we propose a Pre-FUIT algorithm (Fast-Update algorithm based on the IT-tree structure and the concept of PRE-large itemsets algorithm), which does not only update the IT-tree when new transactions are inserted, but also mine all frequent itemsets easily. Experimental results show the good performance of the proposed algorithm.

Keywords?data mining; IT-tree structure; pre-large itemset; incremental mining.



I.  INTRODUCTION Many algorithms for mining association rules from  transactions were proposed, most of which were based on the Apriori algorithm [1], which generate-and-test candidates in each level. This might need scanning databases iteratively and cause high computational cost. An important data structure used in the Apriori algorithm is the hash-tree [2]. In 2003, Bodon and Ronyai [11] adopted the trie data structure to profitably substitute hash-trees. In addition to Apriori-based algorithms, some new approach were proposed as well. Han et al. [4] proposed the Frequent- Pattern-tree (FP-tree) structure for efficiently mining frequent itemsets (FIs) without candidate generation. Zaki et al. [12, 13] proposed the IT-tree structure and designed an algorithm to fast mining all FIs. Their approach used the depth-first search technique to generate itemsets and used the tidset to fast compute the support of itemsets. They showed it could have a better performance than the original Apriori algorithm.

All the Apriori, the IT-tree-based and the FP-tree-based algorithms belong to batch mining. It means that they must process all the transactions in a batch way. In real-world applications, new transactions are usually inserted into the database incrementally. The first incremental mining algorithm was the Fast-UPdated algorithm [3] (called FUP).

Although the FUP algorithm could indeed improve mining performance for incrementally growing database, the original database still need be scanned when it is necessary.

Hong et al. then proposed the concept of pre-large itemsets to further reduce the need for rescanning the original database [5]. Since rescanning the database spent much computation time, the maintenance cost could thus be reduced in the pre-large-itemset algorithm. Some algorithms based on the concept of pre-large itemsets have been developed [6, 7, 8, 10].

As mentioned above, in an IT-tree structure, the process of determining the support values of candidate itemsets can be computed fast by tidset intersection. Each node in an IT- tree consists of an itemset and its tidset. In this paper, we propose an algorithm called Pre-FUIT for handling newly inserted transactions based on the concept of pre-large itemsets and the IT-tree structure. Experimental results also show that the proposed algorithm has a good performance for incrementally handling inserted transactions.



II. REVIEW OF RELATED WORKS In this section, some related researches to the proposed  approach are briefly reviewed.

A. IT-tree structure As mentioned before, the Apriori algorithm [1] generates  and tests candidate itemsets in each level. This might need scanning a database iteratively and cause high computational cost. Zaki et al. [12, 13] then proposed the IT-tree structure and designed the ECLAT (Equivalence CLAss     Transformation) algorithm for mining FIs. The algorithm is based on equivalence classes and scans the database only once. Not like the Apriori algorithm, the ECLAT algorithm uses the vertical data format. The vertical data format consists of a list of items, each of which includes a tidset (the ID list of all the transactions containing the item). Its main idea is to use the depth-first search technique to generate itemsets and to compute the supports of the itemsets fast by the tidset intersection. The IT-tree structure is a prefix tree, and each node in an IT-tree, represented by an itemset-tidset pair of X ? t(X) is in fact a prefix-based class, where X is an item or itemset and t(X) is the list of transactions with X. All the children of a given node with X belong to its equivalence class since they share the same prefix X. The main difference between Apriori and ECLAT lies in how they traverse this prefix and how they determine the support of an itemset.

Apriori traverses the prefix tree in a breadth-first order. It first checks itemsets of size 1, then itemsets of size 2, and so on. Besdies, it determines the support of itemsets by scanning the whole database.

ECLAT, on the other hand, traverses the prefix tree in a depth-first order. That is, it extends an itemset prefix until it reaches the boundary between frequent and infrequent itemsets, and then backtracks to search on the next prefix (in the fixed order of items). ECLAT determines the support of a an itemset by computing the tidsets intersection. More details can be found in [12, 13].

B. The pre-large-itemset algorithm The pre-large-itemset algorithm was proposed by Hong  et al. [5]. It was based on a safety threshold f to reduce the need of rescanning original databases for efficiently maintaining association rules. The safety number f of inserted records was derived as follows:  ( ) ,  u l  u  S S d f  S  ? =  ?  ? ? ? ?? ?  (1)  where Su is the upper threshold, Sl is the lower threshold, and d is the number of original transactions. When the number of new transactions is smaller than f, the algorithm did not need to rescan the original database. A summary of the nine cases and their results are given in Table I.

TABLE I.  NINE CASES AND THEIR RESULTS [5]  Cases: Original ? New Results Case 1: Large ? Large Always large Case 2: Large ? Pre-large Large or pre-large, determined  from existing information Case 3: Large ? Small Large or pre-large or small,  determined from existing information  Case 4: Pre-large ? Large Pre-large or large, determined from existing information  Case 5: Pre-large ? Pre-large Always pre-large Case 6: Pre-large ? Small Pre-large or small, determined  from existing information Case 7: Small ? Large Pre-large or small, when the  number of transactions is small Case 8: Small ? Pre-large Small or pre-large Case 9: Small ? Small Always small

III. THE PRE-FUIT ALGORITHM The notation used in the proposed Pre-FUIT maintenance  algorithm is first described below.

A. Notation D the original database T   the set of new transactions U  the entire updated database, i.e.,  D ? T d   the number of transactions in D t    the number of transactions in T Sl  the lower support threshold for pre-large itemsets Su  the upper support threshold for large itemsets, Su > Sl X an item Tr a IT-tree stores the set of pre-large, and large itemsets from D TT(X) tidset of item X in T TTr(X)  tidset of item X in Tr IT the set of item in T supTr(X)   the support of  X in Tr [P] a equivalence class of node P in Tr [?] the equivalence class of the root in Tr, which is ?  B. The Pre-FUIT algorithm The main idea of the proposed algorithm is traversing an  IT-tree in a depth-first order to update the supports and tidsets of the itemsets stored in the IT-tree. The algorithm also uses the downward-closure property [2] to prune unpromising itemsets while traversing the IT-tree. FIs can thus be directly derived from the tree-traversing process.

The details of the algorithm are stated as follows, where the rescan itemsets in the IT-tree means the itemsets which are small in the original database but pre-large or large in the new transactions. When the number of newly inserted transactions exceeds the safety f, the algorithm will rescan the original database to handle the rescan itemsets.

INPUT: A lower support threshold Sl, an upper threshold Su, a IT-tree Tr storing large itemsets and pre-large itemsets derived from the original database consisting of (d+c) transactions, and a set of t new transactions.

OUTPUT: A trie Tr storing large and pre-large itemsets, and rescan itemsets from U.

BEGIN  1.

( )  u l  u  S S d f  S  ? =  ?  ? ? ? ?? ?    2. if  (t + c > f) { 3.       rescan the original database to determine whether the rescan itemsets Tr in are large or pre-large } 4.  for each item X ? IT { 5.       if (X does not exist in Tr){ //Cases 7, 8, 9 in Table I  6.     if ( )T  l  T X S  t ?  ? ? ? ? ? ?  {  7.      add X to Tr and mark X as a rescan itemset 8.      supTr(X) = |TT(X)| }//end if 9.  }//end for       10.  for each item X ? Tr { //Cases 1, 2, 3, 4, 5, 6 in Table I 11. if (X ? IT){ 12.      if  ( ) ( )Tr T  l  sup X T X S  d t c  + ?  + +  ? ? ? ? ? ?  {  13.     TTr(X) = TT(X) 14.  supTr(X) = supTr(X) + |TT(X)| 15.   else remove X from Tr  16.  }else if ( )Tr  l  sup X S  d + t + c ?  ? ? ? ? ? ?  {  17.      add X to Tr with TTr(X) = ? 18. }//end else 19.  }//end for 20. ENUMERATE_FIs (Tr, [?]) 21. if  (t + c > f) { 22.      d = d + t + c 23.      c = 0 } 24. else c = c + t END   PROCEDURE ENUMERATE_FIs(Tr, [P]) BEGIN PROCEDURE 25.  for each itemset Xi ? [P] and Xi is not a rescan itemset{ 26.       for each itemset Xj ? [P]  with j > i  and Xj is not a rescan itemset { 27.            Z = Xi ? Xj 28.            T(Z) = T(Xi) ? T(Xj) 29.            if (Z exists in Tr)  30.      if ( ) ( )Tr  l  sup Z + T Z S  d + t + c ?  ? ? ? ? ? ?    31.           Add Z to Tr with TTr(Z) = T(Z) 32.           supTr(Z) =  supTr(Z) + |TTr(Z)| 33.           [Pi] = [Pi] ? {Z ? T(Z)} 34.      else remove Z from Tr  35.  else if ( )  l  T Z S  t ?? ?? ?  ? ? {  36.              mark Z as a rescan itemset 37.              supTr(Z) = |T(Z)| } 38. }// end for 39. ENUMERATE_FIs(Tr, [Pi]) 40. }//end for END PROCEDURE  Lines 4 to 9 process the 1-itemsets which exist in IT but  is not retained in Tr (Cases 7, 8, 9 in Table I) and lines 10 to 19 process the 1-itemsets which are pre-large or large in the original database and are retained in IT (Cases 1, 2, 3, 4, 5, 6 in Table I). After line 19, the total count and the tidset of each 1-itemset in Tr have been  updated and the rescan itemsets have been found. The procedure ENUMERATE_FIs(Tr, [P]) will update the supports of the itemsets stored in IT-tree. This task is recursive. The final results include the IT-tree storing all the large and pre-large itemsets.

C. An example In this section, an example is given to illustrate the  proposed incremental data mining algorithm. Assume the initial data set includes the 8 transactions shown in Table II.

For Sl = 30% and Su = 50%, the sets of large and pre-large itemsets for the given data are showed in Tables III and IV, respectively. An IT-tree Tr storing the set of pre-large and  large itemsets in the original database is shown in Fig. 1. In fact, the tidsets of the itemsets which are mined from the original database are not retained since the algorithm does not consider them in the mining process.

TABLE II.  AN EXAMPLE OF ORIGINAL DATABASE  Original database TID Items  1 ACE 2 ABDE 3 BCDE 4 ACE 5 ACE 6 ABC 7 BDE 8 ABCE  TABLE III.  THE LARGE ITEMSETS DERIVED FROM THE ORIGINAL DATABASE  Large itemsets 1 item Count 2 items Count 3 items Count  A 6 AC 5 ACE 4 B 5 AE 5 C 6 BE 4 E 7 CE 5  TABLE IV.  THE PRE-LARGE ITEMSETS DERIVED FROM THE ORIGINAL DATABSE  Pre-large itemsets 1 item Count 2 items Count 3 items Count  D 3 AB 3 BDE 3 BC 3 BD 3 DE 3                      Figure 1.  The IT-tree Tr storing the set of pre-large and large itemsets in the original database  Assume the two new transactions shown in Table V are inserted after the IT-tree Tr is built and Table VI shows the vertical layout of the two new transactions.

{}  A(6) Tx  B(5) Tx  C(6) Tx  D(3) Tx  E(7) Tx  AB(3) Tx  AC(5) Tx  AE(5) Tx  ACE(4) Tx  BC(3) Tx  BD(3) Tx  BE(4) Tx  BDE(3) Tx  CE(5) Tx  DE(3) Tx      TABLE V.  TWO NEW TRANSACTIONS  New transactions TID Items  9 ABCD 10 CEF  TABLE VI.  THE VERTICAL DATA FORMAT OF TWO NEW TRANSACTIONS  Items Transactions containing Items A 9 B 9 C 9 10 D 9 E 10 F 10   For the above data, the Pre-FUIT algorithm proceeds as  follows. The variable c is initially set at 0.

From Line 1 of the algorithm  ( ) (0.5 0.3)8  1 1 0.5 u l  u  S S d f  S  ? ? = = =  ? ?  ? ? ? ? ? ? ? ?? ?? ?  .

In Lines 2 to 4, since t + c = 2 + 0 = 2 ? f, rescanning the original database is unnecessary, so nothing is done. Lines 4 to 19 then update the support and the tidset of each 1- itemset in Tr based on the tidsets of items in the two new transactions. In this example, item {F: 1} is a rescan itemset because {F} is small in the original database, but is pre- large in the two newly inserted transactions. The results are shown in Fig. 2.

Figure 2.  The IT-tree Tr after the 1-itemsets processed  After Line 19, the algorithm calls the procedure ENUMERATE_FIs(Tr, [?])  with [?] = {A, B, C, D, E, F}. The results after this step are shown in Fig. 3 and Fig. 4.

Figure 3.  The IT-tree Tr after  [A] processed   Figure 4.  The IT-tree Tr after [A] and [B] processed  The final IT-tree Tr are shown in Fig. 5.

Figure 5.  The final IT-tree Tr  After the called procedure ENUMERATE_FIs(Tr, [?]) is finished, Lines 21 to 24 are executed. Because t + c = 2 + 0 = 2 ?  f,  c = c + t = 2 + 0 = 2. The result of the algorithm is thus the IT-tree Tr which stores the pre-large and the large itemsets for the entire updated databases, as well as the rescan itemsets. The IT-tree Tr can then be used for processing next newly inserted transactions.

Note that the final value of c is 2 in this example and f ? c = 1. It means that one more new transaction can be added without rescanning the original database.

BCD(1) Tx9  {}  A(7) Tx9  B(6) Tx9  C(8) Tx9 10  D(4) Tx9  E(8) Tx10  AB(4) Tx9  AC(6) Tx9  AE(5) Tx  ACE(4) Tx  BC(4) Tx9  BD(4) Tx9  BE(4) Tx  BDE(3) Tx  CE(6) Tx10  DE(3) Tx  AD(1) Tx9  F(1) Tx10  ABC(1) Tx9  CD(1) Tx9  {}  A(7) Tx9  B(6) Tx9  C(8) Tx9 10  D(4) Tx9  E(8) Tx10  AB(4) Tx9  AC(6) Tx9  AE(5) Tx  ACE(4) Tx  BC(4) Tx9  BD(4) Tx9  BE(4) Tx  BDE(3) Tx  CE(5) Tx  DE(3) Tx  AD(1) Tx9  F(1) Tx10  ABC(1) Tx9  BCD(1) Tx9  {}  A(7) Tx9  B(6) Tx9  C(8) Tx9 10  D(4) Tx9  E(8) Tx10  AB(4) Tx9  AC(6) Tx9  AE(5) Tx  ACE(4) Tx  BC(3) Tx  BD(3) Tx  BE(4) Tx  BDE(3) Tx  CE(5) Tx  DE(3) Tx  AD(1) Tx9  F(1) Tx10  ABC(1) Tx9  {}  A(7) Tx9  B(6) Tx9  C(8) Tx9 10  D(4) Tx9  E(8) Tx10  AB(3) Tx  AC(5) Tx  AE(5) Tx  ACE(4) Tx  BC(3) Tx  BD(3) Tx  BE(4) Tx  BDE(3) Tx  CE(5) Tx  DE(3) Tx  F(1) Tx10

IV. EXPERIMENTAL RESULTS The PC configuration includes Intel Core 2 Duo 2.1  GHz CPU, 2GB RAM, and Windows 7 OS. The well- known T40I10D100K (with 100000 transactions) is used in the experiments.

The performance of the proposed Pre-FUIT algorithm was compared with that of the pre-large-itemset algorithm [5] which used the hash-tree data structure. The execution time for mining all FIs by the two algorithms was first compared. The first 90000 transactions were extracted from the T40I10D100K database for offline mining. Each next 1000 transactions were then sequentially used each time as new transactions for the experiments. The upper and the lower support thresholds were set at 5% and 2%, respectively. In the experiments with the T40I10D100K database, the safety number was calculated as f = 90000*(0.05-0.02)/(1-0.05) = 2842. Fig. 6 shows the execution time required by the two algorithms. It could be seen from the Fig. 6 that the Pre-FUIT maintenance algorithm ran faster than the pre-large-itemset algorithm even in the case when the number of inserted transactions exceeded the safety threshold.

Figure 6.  The comparison of the execution time for the T40I10D100K database

V. CONCLUSION This paper has proposed a new approach based on the IT- tree structure for incremental data mining. The proposed Pre-FUIT algorithm used the tree structure to help traversing tasks and update of the itemset supports. The support of candidate itemsets can be computed fast by tidset intersection. It also adopted the concept of pre-large itemsets to reduce the number of database scans. It uses two user-specified upper and lower support thresholds to avoid small items directly becoming large in the updated database when transactions are inserted. All the tasks are processed in the IT-tree structure. With these strategies, the proposed approach can thus spend less execution time than the previous pre-large-itemset algorithm which uses the hash- tree data structure.

