mRegistry: A Registry Representation for Fault Diagnosis

Abstract  Microsoft Windows uses the notion of registry to store all configuration information. The registry entries have associations and dependencies. For example, the paths to executables may be relative to some home directories.

The registry being designed with faster access as one of the objectives does not explicitly capture these relations.

In this paper, we explore a representation that captures the dependencies more explicitly using shared and unify- ing variables. This representation, called mRegistry ex- ploits the tree-structured hierarchical nature of the registry, is concept-based and obtained in multiple stages. mReg- istry captures intra-block, inter-block and ancestor-children dependencies (all leaf entries of a parent key in a registry put together as an entity constitute a block thereby making the block as the only child of the parent). In addition, it learns the generalized concepts of dependencies in the form of rules. We show that mRegistry has several applications: fault diagnosis, prediction, comparison, compression etc.

1 Introduction  The vulnerability of computers due to softwares keeps increasing in spite of all the advancements in software tech- nology. A major reason for this has been attributed to the configuration changes. In Windows operating system, the configuration data of a computer is stored in the reg- istry and changes in the registry is a major cause for prob- lems in these computers [1]. Diagnosis of computer prob- lems in general [4, 5] and diagnosis of problems due to registry in particular, is drawing attention in recent times [1, 8, 6, 3, 7] and the need of the hour is to build automated, self-managing, global-scale diagnostic services.

Change and Configuration Management (CCM) is one of the most basic and important approaches towards building robust diagnostic systems. Wang [7] defines CCM as a task of monitoring and maintaining software/hardware installa- tions and configuration changes aimed at maintaining com- puter systems in good condition. Wang [7] proposed an ap-  proach called Computer Genomics to CCM and the prin- ciples and techniques are inspired by the human genome project. (genome ? registry), (gene ? registry entry) are a few of the analogies drawn by Wang. Strider [8] tack- les CCM using state-based analysis. PeerPressure [6] uses statistics from a database of registry entries to identify the root-cause misconfigurations on a compromised machine.

The existing registry model does not capture the associa- tions and dependencies between the registry entries and the existing diagnostic approaches perform poorly over cross- machine registry databases. Some of the associations of in- terest include associations that exist between:  ? a key and its sub-keys  ? the sub-keys of the same parent key  ? keys of similar registry entries (similar applications, drivers etc.,)  In this paper, we explore a representation called mRegistry (meta-Registry) that captures these dependencies in multi- ple stages. Consider a block to be an entity wherein all the leaf entries of a parent key in a registry are put together thereby making the block as the only child of the parent. In the first stage, we capture the dependencies between entries within a block, the second stage finds dependencies across the blocks and the third stage finds dependencies between values of keys and its ancestors. In the last phase, we gen- eralize the learned dependencies and form concepts. The proposed representation provides a means for efficient com- parison, prediction and diagnosis. mRegistry also achieves compression.

The rest of the paper is organized as follows. Sec- tion 2 gives a brief description of the registry concept in Windows while section 3 motivates the need for abstrac- tion/conceptualization of the existing registry model. Sec- tion 4 describes our approach towards meeting this require- ment. Section 5 discusses the experimental setup, results and applications of the proposed approach. Finally, section 6 concludes with proposals for future directions.

2 Registries in Windows  Windows registry can be thought of as a central reposi- tory of information about all aspects of the computer (hard- ware, applications, operating system and users). The in- formation in the registry is centralized, easy to access, hi- erarchical and tree-structured. The hierarchical tree struc- ture of the registry is divided into registry hives that con- tain keys, sub-keys and items corresponding to hardware, software and system components. Sections whose names begin with HKEY_ are called root keys. Each root key con- tains sub-keys, which in turn might contain further sub- keys and so on. The lowest level keys (leaves) along a given branch are associated with values. Keys and val- ues both hold data and the data can be either binary or ASCII strings. At the leaves, the binary data are specified with the types REG_BINARY, REG_BINARY(truncated) and REG_DWORD whereas the ASCII data has as its type any one of REG_SZ, REG_MULTI_SZ and REG_EXPAND_SZ.

The keys and values can be identified by specifying its path along the branch. The registry is divided into six and five sections on Windows 9x and NT respectively. The five sections correspond to (i) HKEY_CLASSES_ROOT, (ii) HKEY_LOCAL_MACHINE (iii) HKEY_USERS (iv) HKEY_CURRENT_USER (v) HKEY_CURRENT_CONFIG Among the five mentioned above, only two root keys viz., HKEY_LOCAL_MACHINE and HKEY_USERS stand on their own and the rest are pseudonyms for other parts of the tree e.g., HKEY_CLASSES_ROOT is a pseudonym of HKEY_LOCAL_MACHINE\Software\Classes. The pseudonym root keys are not duplicates, but, provide an al- ternate view of the same information [2]. We use HKLM to represent HKEY_LOCAL_MACHINE for the rest of the paper.

3 Motivation  Almost all the proposed approaches for fault diagno- sis dealing with registries [8, 6, 7] basically rely on find- ing the differences between a previously recorded good- state snapshot of a registry with that of the current bad- state snapshot (the one captured on occurrence of a fault).

This approach though might identify accurate differences when applied on a single machine however suffers badly for cross-machine diagnosis. This is due to the inherent configuration differences between machines. Consider the following simple example. Let ? ? and ? ? be two ma- chines whose registry entries we wish to compare. Fur- ther assume that on ? ? , all the softwares has been in- stalled on drive C while on ? ? , they are installed on drive D. A naive comparison would differ even in en- tries like the HKLM\SOFTWARE\Perl\BinDir whose val- ues could be C:\Program Files\Perl\bin\perl.exe and D:\Perl\bin\perl.exe for machines ? ? and ? ? respectively. The differences in registry entries which is ex-  pected to help would now turn out to be a disaster for the diagnostic engine. This is due to the lack of intelligence in identifying the relevant differences. An intelligent diag- noser can take into consideration the semantics of the keys and values and shouldn?t report entries like the one above.

The registry entries have associations and dependencies. An abstract representation of the registry capturing these asso- ciations is required to build better diagnostic systems. Red- stone et al [4] also observe that diagnostic systems can be simpler when we have a structured representation. These factors motivate us to explore a representation mRegistry (meta-Registry) that captures dependencies more explicitly.

4 mRegistry The aim is to discover hidden (previously unknown)  knowledge and potentially useful information from reg- istry data. A few examples include extracting repeated pat- terns, unexpected patterns, associations and new rules from the data. mRegistry is a representation of registry that is concept-based and captures the dependencies among the registry entries in multiple stages. mRegistry achieves this by exploiting the hierarchical design of the registry  4.1 Pre-Processing  mRegistry requires the following preprocessing steps.

1. Block-Based Representation: Fig 1 depicts the gen- eral and block-based tree representation of the registry.

The block-based representation is just a matter of con- venience to present and explain the algorithms. The difference between the two is that, all the leaf node keys and values for a hive are combined together as an entity and is made the only leaf node of the corre- sponding parent. Let us call this entity a block. By this, we can refer to all leaf keys of a parent of the origi- nal representation as keys within the block. Also, in the modified representation, the neighboring nodes at a leaf level belong to different parents whereas it might belong either to the same parent or a different one in the general representation.

2. Discount Binary Values: We concentrate only on keys that have ASCII string values so that the dependencies learned would be valid across all the registries from different machines. We feel that the keys in the reg- istry, the values of which are binary/numeric valued and specific to a machine provide less information in identifying the dependencies/concepts that would be valid over the registries from various machines. For example, the values of hardwareID, ClassGUID etc., for a registry hive will definitely be different when we compare registries from two machines. We also ignore all branches in the registry tree that has a sub-key with a binary value. We mean a ?key with binary value? to     1 HKEY_LOCAL_MACHINE  SOFTWARE  Microsoft  Shared Tools  Graphics Filters  Import  PNG  Extensions ... Path Extensions... Path  PICT GIF  Extensions... Path  ......... JPEG  PathExtensions ...

...        ...

L?2  L?1  L   (a) General tree representation of registry hives (At leaf node: only keys are depicted without their values)   PNG PICT GIF ......... JPEG  ...        ...

L?2  L   ...

L?1  block  ... ... ......

Path  Extensions png  C:\PROGRA~1\COMMON~1\MICROS~1\GRPHFLT\PNG32.FLT Path C:\PROGRA~1\COMMON~1\MICROS~1\GRPHFLT\JPEGIM32.

Extensions jpg  HKEY_LOCAL_MACHINE  SOFTWARE  Microsoft  Shared Tools  Graphics Filters  Import  (b) Block-Based tree representation of registry hives  Figure 1. Registry representation  refer all keys whose values are represented either in pure binary notation (0 or 1) or hexa-decimal notation (with regular expression [0-9A-F]+).

3. Use of domain knowledge: The knowledge used is the DOS and Windows equivalence in rendering paths. For example, the fact that PROGRA?1 resembles Program Files is to be provided. However, this can also be learned automatically from the registry entries.

4.2 Types of Dependencies Before exploring the dependencies that might exist in  a registry, let us formalize the notion of similar blocks.

Blocks of registry hives that convey analogous infor- mation are similar. For example, the registry entries corresponding to ..\ContentFilter\Linkage and ..\ISAPISearch\Linkage are similar as both convey linkage information about different services (viz., Content- Filter and ISAPISearch). As another example, the blocks corresponding to ..\Graphics Filters\Import\JPEG and ..\Graphics Filters\Import\PNG conveying information about import graphics filters are similar.

We capture the following types of dependencies in the registry.

Type-0: intra-block dependencies This corresponds to associations that exist between the values within a block.

For example, the values for the key pairs (printerName, driverName), (ImportFilter, ExportFilter) might be closely associated.

Type-1: Type-0 dependencies across all inter-blocks Type-0 dependencies might result in capturing many irrelevant associations that hold only for a single block and not in other similar blocks (blocks that are analogous).

Type-1 looks for associations that exist between the values within a block (intra-block) and that is satisfied across all the neighboring blocks (inter-block) that are similar. The association captured is key-value subsumption of entries within a block. Derived keys ($$X, X is a variable) are created for values subsumed and the subsumed values are replaced with $key where key is the key whose value is subsumed.

Type-2: inter-block dependencies This corresponds to associations (common patterns, substrings etc.,) that ex- ist between respective keys among neighboring blocks that are similar. For example, consider a registry hive depicting fonts. In a system, all the Windows fonts might be installed in a single directory (say, C:\Windows). In a registry, for each font, say x, for the key Path, we might have the value C:\Windows\x. Here the association that all the fonts are installed in the same directory is of interest. Inter-block dependencies tries to capture such commonalities between the keys among all or some neighboring blocks that are similar.

Type-3: ancestor dependency This constitute the as- sociations between values of keys in a block and its corresponding parents and ancestors. These dependencies are captured by unification 1 and reveal some domain knowledge about the registries. Rules are generated from the learned dependencies.

As mentioned earlier, Type-0 dependencies may not reveal much about the registries and so we concentrate on the rest viz., Type-1, Type-2 and Type-3 dependencies.

These three dependencies are discovered using Algorithm 1, 2 and 3 respectively. Further in the last phase, the dependencies learnt are generalized using the notion of regular expressions. The associations are captured using pattern variables viz., derived keys $$X, subsumption keys $key and unifying variables $&X.

4.3 Discovering the dependencies  4.3.1 Type-1 Dependencies  Algorithm 1 captures these dependencies. Let us look at Algorithm 1 in detail. For any node ? in the tree representation of the registry, ? ? ? ? ? 	 ? ? gives the level of the node ? . Fig 2 depicts the application of Algorithm 1 on part of a registry. In Fig 2(a), in the leaf node  ? ? ? ? ,  1unification tries to identify two symbolic expressions by replacing cer- tain sub-expressions by other expressions (variable)     powerpnt.exeMSPUB.EXE infopath.exe MSACCESS.EXE... ... ...... cmmgr32.exe  ......

App Paths  <No Name>  <Path>= C:\Program Files\MicroSoft Office\OFFICE11\ = C:\PROGRA~1\MICROS~2\OFFICE11\MSPUB.EXE <Path>  <No Name>  = C:\WINDOWS\System32\ = C:\WINDOWS\System32\cmmgr32.exe  (a) Tree representation of part of a registry (shown is a subtree under HKLM ? Software ? Microsoft ? Windows ? CurrentVersion)  powerpnt.exeMSPUB.EXE infopath.exe MSACCESS.EXE... ... ...... cmmgr32.exe  App Paths  ... ...<No Name> <Path>  <No Name>  <Path> <No Name>  <Path>  = $$HD1 = $<Path>\INFOPATH.EXE = $$HD1  = $$HD2 = $<Path>\cmmgr32.exe  = $<Path>\MSPUB.EXE  $$HD1 = C:\Program Files\MicroSoft Office\OFFICE11\ $$HD2 = C:\WINDOWS\System32\  (b) Resultant on application of Algorithm 1  Figure 2. Output of Algorithm 1 shown as a tree  Algorithm 1 mRegistry (intra-block across inter-blocks) 1: ? ? ? ? ? ? any leaf node 2: for different keys in the leaf node ? ? ? ? ? , check if a value  for some key, ? ? , is subsumed in the value of another key ? ?  3: if there exist such a subsumption then 4: for all nodes ? ? ? ? ? , similar to ? ? ? ? ? do 5: check whether the subsumption satisfied for ? ? ? ? ?  holds good also in ? ? ? ? ? for the same set of keys.

6: end for 7: if subsumption is satisfied for all similar nodes then 8: create derived keys, say $$HD ? ? ? ? , one for  each different value of the key ? ? and assign its value to the corresponding value of ? ? . Replace the value of ? ? as $$HD ? and the ? ? valued sub- string of ? ? as ? ? ? .

9: create the derived keys $$HD ? as keys of the clos- est common ancestor of ? ? ? ? ? and nodes similar to it.

10: end if 11: end if  corresponding to the child of MSPUB.EXE, we see that the value of the key <Path> is subsumed in the value of the key <No Name>. The keys <Path> and <No Name> correspond to keys ? ? and ? ? in Algorithm 1. Now, for all the leaf nodes that are grand-children of App Paths and similar to ? ? ? ? ? , we check for the satisfaction of the value subsumption for the keys <Path> and <No Name> and it holds true. It is to be noted here that though the string val- ues of <Path> are different for the children of MSPUB.EXE and cmmgr32.exe, we are interested only in the fact that the key <No Name> subsumes the value of the key <Path> for all the grand-children of App Paths. Now, according to step 8 of algorithm 1, we create two derived keys $$HD1 and $$HD2. This choice of two is due to the existence of two different values for the key <Path> among all the nodes similar to ? ? ? ? ? . The two values correspond to C:\Program Files\Microsoft Office\OFFICE11\  and C:\WINDOWS\System32\. The derived keys created are added as keys to App Paths (which forms the closest  common ancestor for ? ? ? ? ? and nodes similar to it).

Fig. 2(b) shows the resultant registry upon application of Algorithm 1.

4.3.2 Type-2 Dependencies  Inter-block dependencies are captured using Algorithm 2.

Consider Fig 1(b). The substring kval = C:\PROGRA?1\  Algorithm 2 mRegistry (inter-block dependencies) 1: ? ? ? ? ? ? any leaf node 2: for each key value, kval within ? ? ? ? ? do 3: for each neighbor, ? ? ? ? ? similar to ? ? ? ? ? do 4: check if a common sub-string/pattern exists in kval  and the corresponding value for the same key in ? ? ? ? ?  5: end for 6: if there exist a common sub-string/pattern among all  or some neighbor nodes then 7: create derived keys, say $$HD ? ? ? ? for the  common sub-string/pattern at the closest common ancestor and replace the sub-string/pattern with $$HD ? in ? ? ? ? ? and its neighbors.

8: end if 9: end for  COMMON?1\MICROS?1\GRPHFLT\ for the key Path in the left most leaf node (say ? ? ? ? ? ) is also a sub- string in the value of the key Path in all the neighbors of ? ? ? ? ? which are similar. We create a derived key $$HD1 = C:\PROGRA?1\COMMON?1\MICROS?1\GRPHFLT\  in the grandparent node Import (which forms the closest common ancestor) and replace all the occurrences of kval in the leaf nodes with $$HD1.

4.3.3 Type-3 Dependencies  The ancestor-child dependencies are uncovered using Algorithm 3.

Let us discuss Algorithm 3 in detail. Consider the dotted box portion of the registry tree shown in Fig 3. Con- sider the left most leaf node corresponding to the branch HKLM\SYSTEM\ControlSet001\Enum\Root\LEGACY_AFD  \0000. Let the leaf node be called ? ? ? ? ? and it contain     Enum  Root  ControlSet001 CurrentControlSet  Enum  Root  LEGACY_SCHEDULE...LEGACY_DHCP...LEGACY_AFD  Class  REG_SZ=LegacyDriver Service  REG_SZ=AFD  :  :  Class  REG_SZ=LegacyDriver Service  REG_SZ=SCHEDULE  :  :  LEGACY_SCHEDULE...LEGACY_DHCP...LEGACY_AFD  Class  REG_SZ=LegacyDriver Service  REG_SZ=AFD  :  :  Class  REG_SZ=LegacyDriver Service  REG_SZ=SCHEDULE  :  : Class  REG_SZ=LegacyDriver Service  REG_SZ=SCHEDULE  :  : Class  REG_SZ=LegacyDriver Service  REG_SZ=AFD  :  :  LEGACY_SCHEDULE...LEGACY_DHCP...LEGACY_AFD  HKEY_LOCAL_MACHINE  SYSTEM  ControlSet003  Enum  Root  ...

0000 0000 0000 0000 0000 0000  ...

...

Figure 3. An example depicting ancestor-child dependencies  Algorithm 3 mRegistry (ancestor dependency) 1: ? ? ? ? ? ? any leaf node 2: ? ? ? 	 ? 	 ?  ? ? ? ? ? ? 3: for ? ? ? ? ? to ? do 4: ? ? ? ? ? ? ancestor of ? ? ? ? ? at level ? 5: for different keys in ? ? ? ? ? , determine any seman-  tic relations existing between ? ? ? ? ? and the values of the keys (e.g., maximal sub-string match between  ? ? ? ? ? and the values of the keys in ? ? ? ? ? ). Find all such matchings for all the keys in ? ? ? ? ? .

6: if there exist such a relation then 7: break 8: end if 9: end for  10: for all relations determined above do 11: for all siblings ? ? ? ? ? ? of ? ? ? ? ? and similar to  ? ? ? ? ? do 12: determine whether the relation is satisfied between  ? ? ? ? ? ? and the leaf node of ? ? ? ? ? ? .

13: end for 14: if relation is satisfied then 15: create a rule depicting the relation using unifica-  tion variables 16: end if 17: end for  the keys Class and Service apart from others. Consider the ancestor node: ? ? ? ? ? ? LEGACY_AFD. The LEGACY sub-string of ? ? ? ? ? is the maximal string that matches with the value of Class viz., LegacyDriver. Another relation exists between the key Service and ? ? ? ? ? . The Service value (AFD) is nothing but the sub-string following the _ in ? ? ? ? ? . We got two relations and we next check how many of these relations hold between the siblings of ? ? ? ? ? (LEGACY_DHCP, LEGACY_SCHEDULE etc.,) and their corresponding leaf nodes. It is to be noted that for all the siblings of ? ? ? ? ? , the two semantic relations are satisfied. Our next step is to formulate some rules out of the relations learned. The relations suggest that for any registry hive corresponding to HKLM\SYSTEM\ControlSet001\ Enum\Root\LEGACY_$&XYZ ($&XYZ is a unification variable for some string), the key Class has the value LegacyDriver and the key Service has the value held in  $&XYZ. This is an useful and important knowledge having various applications as discussed in section 5.

The last phase of mRegistry tries to generalize the de- pendencies learned using regular expressions. Let us discuss this with the following example. In Fig 3, cor- responding to the three branches of HKLM\SYSTEM, we get three sets of rules, one for each branch according to Algorithm 3. The rules resemble ?If registry hive is HKLM\SYSTEM\$&ABC\Enum\Root\LEGACY_$&XYZ, then, Class = LegacyDriver and Service = $&XYZ?. Here $&ABC is one of {ControlSet001,  ControlSet003, CurrentControlSet}. We can generalize these rules by making the antecedent part of the rule as {Current}? ControlSet### (? denotes 0 or 1 occurrences and # corresponds to a digit) in place of $&ABC. This lets us have only one rule instead of three and captures the commonalities between the three branches.

5 Experimental Details, Results and Discus-  sion We implemented the mRegistry model and tested the per-  formance over 20 snapshots of registries taken from differ- ent work stations running Windows XP operating system.

Experiments were performed only on the HKLM section of a registry. The proposed approach has various applications and are described below with the results of the experiments.

Registries are pre-processed to filter some hives based on our assumption discussed in section 4. As an example, one registry snapshot initially had 21,998 hives and filter- ing them resulted in 5,692 hives for consideration. We have implemented the ideas presented above using the awk pro- gramming language. The resultant mRegistry has 307 de- rived keys and 46 rules. The substring LegacyDriver is the most frequent pattern occurring ? 	 times under Type-2 dependency.

5.1 Applications  This section enumerates a few applications of the pro- posed mRegistry model. Consider the mRegistry represen- tation of Fig 2(b). Apart from the entries depicted in Fig 2(b), we have rules such as  HKLM SOFTWARE Microsoft Windows CurrentVersion  App Paths $&XYZ ?  No Name ? = $  Path ? $&XYZ  (1)     The rule above says that for any application $&XYZ under App Paths, the <No Name> key has the value $<Path>\$&XYZ where $<Path> corresponds to the value of the subsumed key <Path>. The use is described below.

Fault Diagnosis: Fault diagnosis of Windows systems based on registries, viz., the Change and Configuration Management (CCM) is one of the prominent applications of the proposed approach. Section 3 described a few drawbacks of the current registry model for CCM studies.

mRegistry helps in retrieving relevant differences thereby reducing the number of differences between cross-machine registry snapshots. This is evident as Algorithm 1 captures the relationships within a hive and replaces them with pattern variables. For the example described above in (1) as a rule, for registries across different machines, irrespective of the location an application is installed, the <No Name> key?s value remains the same ($Path\$&XYZ for an application $&XYZ) and so they do not differ. The location is captured in <Path> and we create derived keys for the location and have the <Path> value equal to the derived key.

Few other applications include: Conceptualization: Conceptualization is key to under- standing and refers to the process of learning meaningful concepts/explanations from data. Rule (1) above says that the <No Name> key of an application has the value equal to the application located in <Path>. This rule holds true on all the 20 registry snapshots that we explored. Many such rules have been learned using the proposed approach.

Compression: Another important application of the proposed approach considering the large size of registry databases is that of compression. Compression is achieved as follows: by the creation of derived keys at a parent node, we just substitute the derived key in the leaves. The size of the derived key being much smaller than that of the actual value results in compression. Another source of compression is conceptualization. As discussed in section 4, by forming rules and generalized descriptions (using regular expressions), we can remove those entries corresponding to the consequents of rules from the registry and use the rules instead. This results in the removal of a lot of registry entries. And while comparison between registries, we can use the rules/concepts. We can call this as semantic compression. For the 20 registry snapshots we experimented, we noticed a compression ratio between ? ?  ?  and ? ? ? .

Prediction: However large our databases may be, with users constantly installing new softwares, it might be possible that we may come across a registry hive/entry that is not present in our database. In such cases, prediction of the entries depending on the rules formulated would  provide some clue. For example, for any new legacy driver, we know that the <Class> value would be LegacyDriver and the <Service> value would be the $&XYZ for a driver keyed LEGACY_$&XYZ  6 Conclusions and Future Work  In this paper, we proposed a novel representation of registries called mRegistry that is concept-based capturing the intra-block, inter-block and ancestor-child dependencies among the registry entries. Algorithms for finding these as- sociations are presented and discussed. mRegistry depicts the dependencies using pattern variables and rules. With its compact representation, mRegistry achieves some com- pression and results in efficient comparison between cross- machine registry snapshots. mRegistry is also applicable in fault diagnosis and in the prediction of certain unforeseen entries in the registry based on the concepts learned.

mRegistry is designed considering only the ASCII string entries in the registry. It might be possible that there ex- ist meaningful semantic relationships between some binary entries. We would like to extend the current work to in- corporate the ignored entries (with complementary usage of domain knowledge) and explore new representations as fu- ture work.

