Efficient Mining of Association Rules from Wireless

Abstract ???? Wireless Sensor Networks (WSNs) produce large  scale of data in the form of streams. Recently, data mining  techniques have received a great deal of attention in extracting  knowledge from WSNs data. Mining association rules on the  sensor data provides useful information for different  applications. Even though there have been some efforts to  address this issue in WSNs, they are not suitable when multiple  database scans are the major limitation. In this paper, we  propose a new tree-based data structure called Sensor Pattern  Tree (SP-tree) to generate association rules from WSNs data  with one database scan. The SP-tree is constructed in frequency-  descending order, which facilitates an efficient mining using the  FP-growth-based [6] mining technique. The experimental results  show that SP-tree outperforms related algorithms in generating  association rules from WSNs data.

Keywords ???? Wireless sensor networks, data mining,  association rules, frequent patterns.

1. Introduction  Wireless Sensor Networks (WSNs) have been  successfully applied for detailed observation of a variety of  real-world applications, especially in battle fields, smart  buildings, the human body, and other applications that require  the fine-grain monitoring of physical environments that are  subject to critical conditions, such as fires, toxic gas leaks,  and explosions [1, 2, 3]. Most WSNs consist of a collection  of light-weight (possibly mobile) sensors with the capabilities  of sensing, computing, and transmitting. Sensors are  integrated in an ad hoc fashion to formulate a network that is  able to deliver detected events to a well equipped device,  called the Sink, in multi hop mode of transmission [4]. In  general, while transmitting the detected events to sink,  (possibly fast) streams of raw sensor readings from every  node are generated for on-line analysis in order to find  interesting patterns in the data which results in a large data  volume that has to be delivered through the network.

Therefore, the stream nature of the data, the limited resources,  and the distributed nature of WSNs bring new challenges for  the mining techniques that need to be addressed.

Recently, association rules [5] for sensors have received a  great deal of attention [7, 8] due to their importance in  capturing the temporal relations among sensor nodes in  WSNs. An example of such a rule is (s1s2? s3, 80%, ?)  which can be interpreted as follows: if we receive events from  sensors s1 and s2 then there is a 80% chance we will receive  an event from sensor s3 within ? unit of time, where 80% is  the frequency of the rule. However, generating association  rules that have a certain frequency require generating all the  patterns presented in the data that meet this frequency, i.e.,  frequent patterns. Once the frequent patterns are determined,  the process of generating the rules is therefore  straightforward. Thus, devising an efficient algorithm to mine  frequent patterns for high-speed large scale sensor data has  been the real challenge. The FP-growth mining technique  proposed in [6] has been found as one of the efficient  algorithms in mining frequent patterns. The performance gain  achieved by the FP-growth is mainly based on the highly  compact nature of the Frequent Pattern-tree (FP-tree), where  it stores only the frequent items in a frequency-descending  order. In [7] Boukerche and Samarah proposed another  prefix-tree-based [7] data structure, called Positional  Lexicographic Tree (PLT), which is able to compress the  sensor data reside in the database. However, construction of  such data structures (both FP-tree and PLT-tree) require two  database scans, which is not suitable for generating  association rules from the streams of sensor data. Moreover,  mining PLT requires an extra mapping mechanism for the  sensors to a vector.

Therefore, in this paper, we propose a novel prefix-tree  structure, called Sensor Pattern Tree (SP-tree in short) which  is able to capture the information with one scan over the  stream of sensor data and store them in a memory-efficient  highly compact manner, similar to FP-tree. The main idea of  our SP-tree is to obtain the frequency of all event-detecting  sensors? data and construct a prefix-tree based on that in any  canonical order, then reorganize the tree in a frequency-  descending order. Through the reorganization the SP-tree can  maintain the frequently event-detecting sensors? nodes at the  upper part of the tree, which, in turn, provides high  compactness in the tree structure. Once the SP-tree is  constructed, we apply the efficient FP-growth mining  technique on it. The experimental analysis shows that mining  ISBN 978-89-5519-139-4 -719- Feb. 15-18, 2009 ICACT 2009    association rules using SP-tree is highly efficient compared to  the currently available algorithms.

The rest of the paper is organized as follows: in Section 2,  we summarize the existing algorithms to solve the frequent  pattern mining problem and its efficient use in finding  association rules from WSNs. Section 3 describes the  problem definition of mining association rules in WSNs. The  construction process and corresponding mining operation of  SP-tree are discussed in Section 4. We report our  experimental results in Section 5. Finally, Section 6  concludes the paper.

2. Related Work  In this section, we review some of the works that have  been proposed for mining association rules to sensor data.

Before discussing mining association rules from WSNs we  focus on the popular techniques for mining frequent patterns.

Mining frequent patterns in static database have been  well-addressed over the last decade. The first known frequent  patterns mining algorithm is Apriori [5] which is based on  candidate-generation-and-test methodology. The candidate  generation approach enumerates the frequent patterns in a  level wise manner, with several scans of the database. In each  iteration, the patterns found to be frequent are used to  generate possible frequent patterns (the candidates) to be  counted in the next iteration. Therefore, the Apriori technique  finds the frequent patterns of length k from the set of already  generated candidate patterns of length k ? 1. The main  performance problem of Apriori-like approaches comes from  the requirement of multiple database scans and a large  number of candidate patterns, many of which are proved to be  infrequent after scanning the database. Even though a large  number of algorithms have been proposed based on Apriori  approach [12, 13, 14], none of them could successfully  address the issues related to above problems.

Han et al. [6] proposed the frequent pattern tree (FP-tree)  and the FP-growth algorithm that efficiently overcome these  problems by reducing the number of database scans by two  and eliminating the requirement of candidate generation.

With the first database scan, the FP-tree construction  algorithm finds the set of distinct items with respective  support count (i.e., frequency) in the database. Then with the  second database scan the algorithm summarizes the database  in the form of a frequency-descending tree (i.e., the FP-tree).

Each node of the tree stores an item label and a count, where  the count represents the number of transactions which contain  all the items in the path from the root node to the current  node. By ordering items in each transaction in frequency-  descending order, it achieves higher level of prefix sharing  which reduces the size of the tree. The complete set of  frequent patterns is, then, mined from the FP-tree by  recursively applying a divide-and-conquer-based pattern  growth approach, called the FP-growth algorithm, without  additional database scan.

The highly compact FP-tree structure introduced a new  wing of research in mining frequent patterns with prefix-tree  structure. However, the static nature of the FP-tree and two  database scans requirement still limit its applicability to  frequent pattern mining over a data stream.

Recently, several works have been proposed for applying  association rules on the WSNs data [10, 11, 7]. Most of these  works have targeted the data values of the sensor nodes; in  other words, the values provided by the sensors are the main  objects of the rules. In these studies, the time is divided into  intervals, and the sensors? values at that interval formulate the  context to be stored in the database. Each different value of a  sensor is regarded as a single element and it is assumed that  sensors take on a finite number of discrete states. Romer [11],  proposed an in-network data mining technique to discover  frequent patterns of events with certain spatial and temporal  properties. In [7], the authors have proposed sensor  association rules in which the sensors are the main objects of  the rules regardless of their values. To store the sensor? event-  detecting status this method uses a tree-based data structure,  called PLT, which requires scanning the database twice.

However, the two database scans requirement limits its  efficient use in handling WSNs data.

3. Association Rule Mining Problem in Wireless  Sensor Networks Let S = {s1, s2, ? , sn} be a set of sensors, in a particular  sensor network. We assume that the time space is divided into  equal sized slots {t1, t2? , tm} such that ti+1 ? ti = ?,  [ ]1, 1i m? ? and ? is the size of each time slot. A set P = {s1,  s2 ?, sk}?S is called a pattern of sensors. A sensor database, SD, is defined to be a set of epochs in which each epoch is a  couple E(Ets, X) such that X is a pattern of event-detecting  sensors that report events within the same time slot. Ets is the  epoch?s time slot. We say an epoch E(Ets, X) supports a  pattern X1 if X1?X. Frequency of the pattern X1 in SD is defined to be the number of epochs in SD that support it, i.e.,  Freq(X1, SD) = |{E(Ets, X)|X1?X}|.

Pattern X1 is said to be a frequent pattern if Freq(X1, SD)  ? min_sup, where min_sup is a user-given minimum support  threshold (i.e., frequency). Let FSD be the set of all frequent  patterns in SD for a given min_sup.

Sensors association rules are implications of the form of  X'?X" where X' ? S, X" ? S and X'?X" = ?. The frequency of the rule X'?X" is the frequency of the pattern (X' ? X").

The confidence of the rule is defined as follows:  Conf(X'?X") = Freq((X' ? X"), SD)/ Freq(X', SD).

We say a rule is interesting if its frequency and confidence  are greater than or equal to min_sup and user-given minimum  confidence, min_conf respectively. The problem of mining  sensor rules, given an SD, a min_sup, and a min_conf, is the  problem of extracting all interesting association rules present  in the SD. In this paper, we will focus on mining frequent  patterns, since it is the most crucial task in mining association  rule, as mentioned before. The network architecture is  assumed to consist of a set of sensor nodes deployed in ad  hoc fashion and report the data to the sink in multi hop  ISBN 978-89-5519-139-4 -720- Feb. 15-18, 2009 ICACT 2009    fashion. The sink is responsible for formulating the epochs  from the received events and stores them in the database.

Sensors are assumed to be synchronized at slot level.

4. SP-tree: Construction and Mining  In this section, we provide the construction process of a  Sensor Pattern Tree (SP-tree) and corresponding mining  operation.

4.1 The SP-tree Construction  Given a database of epochs, the SP-tree is constructed  from it with one scan. A tabular representation, called S-list,  is used to maintain the ranks of all sensors in the network, and  corresponding frequency in the database. Figure 1(a) shows a  database of six epochs. We use an example (in Figures 1(b) ?  (d)) to illustrate the construction process of the SP-tree for the  sensor database in Figure 1(a). To simplify the figures, we do  not show the node traversal pointers in the trees, although  they are maintained as in an FP-tree [6].

Let us consider that the initial SP-tree is constructed in  lexicographic order of sensor identifiers (i.e. s1 > s2 > ?> sn,  where n is the total number of sensors and the symbol ?>?  indicates the order of sensor ranks). The SP-tree construction  starts with a ?null? root node, as shown in Figure 1(b). The  epochs in the database of the set {s1, s2, s3, s4, s5} are then  inserted one by one into it in lexicographic order in to the SP-  tree. After scanning the full database we obtain the SP-tree  (say, SP-treelex) as in Figure 1(c) in lexicographic order of  sensor ranks. Each node in SP-tree contains the occurrence  frequency in epochs. The S-list also maintains the total  frequency of each sensor. Therefore, after the construction of  the SP-treelex we can sort the S-list (say, S) in frequency-  descending order (say, Ssort) and rearrange the tree structure  using the new sort order in S-list. Figure 1(d) shows the  structure of the final SP-tree obtained after efficient  reorganization operation. Notice that the reorganized SP-tree  is more compact than SP-treelex because of the frequency-  descending sort order, which enables it to arrange the more  frequently event detecting sensors at the upper part of the  tree. We discuss the SP-tree reorganizing technique in the  next subsection.

4.2 The SP-tree Reorganization We use an efficient tree restructuring technique, called  Path adjusting method, proposed in [9], to reorganize our SP-  tree. We refer interested readers to [9] for getting in detail  about Path adjusting method. However, we provide a rough  sketch of the method in the following discussion.

According to the Path adjusting method, the paths in a  prefix-tree are adjusted by recursively swapping the adjacent  nodes in the path unless the path completely achieves the new  sort order (Ssort). Thus, it uses bubble sort technique to  process the swapping between two nodes. According to the  basic philosophy of Path adjusting method, given SP-treelex  and its S, the first step is to find each pair of sensors in S  requires to be exchanged to get Ssort order. Then, not only all  the nodes of these two sensors in all respective paths in the  SP-treelex but also the same items in S are exchanged. During  swapping two nodes, say between a child node ?C? and a  parent node ?P? in a path, this method inserts a new node in  the tree (with the same name as ?P?) as a sibling of ?P? when  the support count of ?P? is greater than that of ?C?. In other  words, ?P? is divided into two nodes ?P1? and ?P2? of same  name; ?P1? parenting the node ?C? with same count as ?C?, and  the remaining children nodes of ?P? (if any) are assigned to  ?P2? with remaining support count value of ?P?. Then, the  swapping between ?P1? and ?C? is performed by exchanging  all of their parent and children pointes. On the other hand,  when the support counts of both ?P? and ?C? are equal, simple  exchange operation between them is enough. However, after  swapping, this method may need to repeatedly merge two  sibling nodes (and their children nodes) of new parent node  when they are found same due to the exchange operation.

Finally, frequency-descending SP-tree and Ssort are  constructed when no further pair of items in S is found to be  exchanged.

4.3 Mining with the SP-tree  Once the frequency-descending SP-tree is constructed, we  can apply the FP-growth [6] mining technique on it for  finding the frequent event-detecting sensor sets. In the  following discussions we revisit the FP-growth mining  approach.

The basic operations in the FP-growth based pattern  growth mining approach are counting the set of frequent  Figure 1. The SP-tree Construction for Sensor Networks  ISBN 978-89-5519-139-4 -721- Feb. 15-18, 2009 ICACT 2009    event-detecting sensors, constructing conditional pattern-base  for each of such sensor, and constructing new conditional tree  from each conditional pattern-base. Counting the set of  frequent event-detecting sensors is facilitated with the help of  the S-list that contains frequency of each distinct sensor. For  each frequent sensor si in the S-list, a small conditional  pattern-base is generated; each consisting of the set of  transformed prefix-paths of si from the original SP-tree. In  order to construct the conditional patter-base only the prefix  sub-paths from the root to the nodes labeled si in the SP-tree  need to be accumulated. The frequency count of every node  in the prefix-path should carry the same count as that in the  corresponding node si in the path. A small S-list consisting of  only the items in the conditional pattern-base for si is also  created. For example, Figure 2(a) shows the conditional  pattern-base constructed for s1 from the SP-tree in Figure 1(d)  for the min_sup = 50% of the corresponding SD. The mining  of the set of frequent event-detecting sensors with si is then  recursively performed by constructing the conditional tree  from the respective conditional pattern-base.

Construction of a conditional tree requires eliminating the  nodes of all infrequent sensors having count less than the  user-given min_sup from the conditional pattern-base and  their entries from respective S-list. The conditional tree for  sensor s1 as in Figure 2(b) is, therefore, constructed by  removing all infrequent nodes (e.g. s5) from the conditional  pattern-base of Figure 2(a). The frequent event-detecting  sensor patterns are generated from the conditional trees, as  shown in Figure 2(c) for s1.

The mining technique is highly efficient due to the  frequency-descending order of the SP-tree. Such ordering  among sensors ensures that the support counts of all sensors  under si in the S-list are less than or equal to that of si;  assuring no sensor under si can be frequent if si is the last  frequent sensor in the list. Therefore, the search space during  mining FSD for any value of min_sup can be started from the  bottom most sensor in the S-list having support ? min_sup to  the first sensor in upward in the list. In other word, mining  FSD can be carried out only considering si and its upper items  in the S-list. Apart from achieving a compact tree structure, in  fact, this is another important goal to reorganize the SP-tree  in frequency-descending order. Moreover, the frequency-  descending ordering guarantees that no conditional pattern-  base contains any node of global infrequent sensors (i.e.

sensors having count < min_sup in the original database). As  a result, the corresponding conditional tree can be constructed  without the additional cost of deleting global infrequent nodes  from the conditional pattern-base, which makes the mining  process faster. The experimental study discussed in the next  section also reflects this fact.

5. Experimental Results  We conducted experiments to verify the improvement in  memory consumption and runtime SP-tree achieves due to the  frequency-descending item ordering over the state-of-the-art  algorithms ([7]) proposed for mining association rules from  WSNs. The comparisons were held using the datasets  commonly used in frequent pattern mining implementations.

We considered both synthetic data (T10I4D100K) generated  from [15] and real datasets (kosarak and chess) obtained from  [16]. Among the datasets chess is dense and others are sparse.

All programs are written in Microsoft Visual C++ 6.0 and run  Figure 3. Runtime Comparison over kosarak  kosarak        8 7 6 5 4  Minimum Support(%)  T im  e (s  ) x   PLT SP-tree  chess      75 70 65 60 55  Minimum Support(%)  T im  e (s  ) x   PLT SP-tree  Figure 4. Runtime Comparison over chess  Figure 2. Mining for s1 from the SP-tree of Figure 1(d) with min_sup = 50% (i.e. 3)    ISBN 978-89-5519-139-4 -722- Feb. 15-18, 2009 ICACT 2009    with Windows XP on a 2.66 GHz CPU and 1 GB memory.

In the first experiment, we study the runtime comparison  between our SP-tree and the PLT [7] in mining frequent  sensor patterns over all of the three datasets. The results are  shown in Figures 3 to 5. The y-axes in the graphs of the  figures report the total of the tree construction time, tree  restructuring time (only for SP-tree), and the mining time. As  shown in the figures, for each type of dataset SP-tree  outperforms the PLT. The reason of such gain is two folds:  first, the PLT construction requires two database scans, while  our SP-tree constructs the tree by scanning the database only  once; second, the mining phase of SP-tree is highly efficient  due to the frequency-descending tree structure.

The kosarak is a huge dataset of 990,002 transactions with  very few frequent patterns. Therefore, even though the mining  time requirements for both PLT and SP-tree are similar, the  former needs high tree construction cost compared to the  later, as shown in Figure 3. The chess, on the other hand, is a  small (3,196 transactions) dataset with huge frequent patterns.

So, the gain in tree construction time for the SP-tree is not  much impressive over PLT. However, SP-tree achieves faster  mining phase than the PLT (Figure 4). As in Figure 5, for  T10I4D100K (with 100,000 transactions) SP-tree performs  comparatively better in both tree construction and mining.

We also study the memory requirements of SP-tree over  several datasets. The results on these experiments are shown  in Figure 6. As shown in the figure, we observe that both SP-  tree and PLT require almost same amount of memory while  constructing the tree structures for min_sup = 100% in each  case. However, even though the memory requirements are  similar, SP-tree?s overall runtime is significantly low.

Therefore, we can say that due to single scan over  database and the use of highly efficient FP-growth mining on  a frequency-descending tree structure finding frequent event-  detecting sensor patterns using SP-tree is highly efficient for  the set of sensors? epochs of different characteristics.

6. Conclusions  In this paper, we have proposed a new tree structure,  called sensor pattern tree (SP-tree) for mining association  rules for Wireless Sensor Networks data. The important  features of SP-tree are (i) it can be constructed with one scan  over the sensor epochs, which is highly crucial while the  streams of sensor data flow; (ii) it is a frequency-descending  tree structure, which enables an efficient FP-growth-based  mining technique. The experimental results reveal that finding  association rule using SP-tree outperforms other related  algorithms.

