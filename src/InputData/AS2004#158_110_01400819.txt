<html><head></head><body><pre style="word-wrap: break-word; white-space: pre-wrap;">2004 IEEE  lntemational Conference on Systems, Man and Cybemeticb

Abstract - This work is to discover all calendar-based temporal association rules that may occur over any rime interval in a temporal database. A user-given calendar schema, e.g.. yea&lt; month, and da): isfirstly adopted to spec- ifL the interesting rime intervals as calendarpattems. Then, in every time interval, the frequent 2-itemsets are discovered along with their 1-star calendar pattems. After that, infor- mation of the rest k-star calendar pattems of the frequent 2-itemsets are levelwisely aggregated from their 1-star cal- endarpattems. A minimal set of candidate calendarpattems are generated and counted in the jrs t  scan of database. To avoid multiple scans over the database, all candidate item- sets are generated from frequent 2-itemsets and the Apri- o n  downward property is utilized to reduce the number of candidate calendar patrems. Finall),, all frequent itemsets with their frequent calendar pattems are discovered in one shot. Calendar-based ternporal association rules are then obtained. Experimentol results have shown that our method is more efJicient than others.

Keywords: calendar-based temporal association rules, peri- odic association rules, temporal data mining.

1 Introduction With the explosive growth of data available from various sources, automatic discovery of useful knowledge from large databases is becoming more and more popular. Association rule mining [I] finds interesting association or correlation relationships among data items continuously being collected and stored, and many industries are becoming interested in mining association rules from their databases. Traditional mining techniques discover unordered correlations between items from a given database of transactions each of which contains a collection of items activated at a certain time [ I ,  31. However, temporal patterns which reveal ordered cor- relations between transactions are attracting more and more attention. For example, customers might look for chocolates and flowers together on February 14th in every year. This ?Supported by the National Science Council under the granls NSC- 92-2213-E-110-006 and NSC-92-2213-E-110-007.

to .7803-8~66. ?1 /~$zo .~  @ 2004 IEEE.

kind of periodic behavior may he recorded in a temporal database. Periodic temporal patterns have been expressed in terms of various forms, e.g., periodical association rules [ 2 ] , cyclic association rules [51, and calendric association rules [4, 61. While periodical and cyclic patterns are basically in terms of a single time granularity, calendar patterns are based on a framework with multiple time granularities. Human ac- tivities are usually related to time granularities, e.g., months, days, and hours. Therefore, system support and reasoning in- volving calendars with multiple granularities have been rec- ognized to he an important issue recently.

In [41, a levelwise Apriori-based algorithm named Temporal-Apriori is the first work proposed to discover all calendar-based temporal association rules. Two interleaving steps are repeated in generating candidate patterns of each level in the method. The first step generates candidate item- sets of the current level in every time interval, and the second step checks the support and confidence rates of each candi-  date itemset. If a candidate itemset passes the support and confidence rates in one time interval, it will he recorded as a frequent itemset in all candidate calendar patterns of the time interval. Frequent itemsets that hold in an enough number of time intervals covered by candidate calendar patterns will he regarded as frequent itemsets in frequent calendar pat-    he regarded as frequent itemsets in frequent calendar pat- terns. Then, calendar-based temporal association rules are obtained.

In this paper, we propose a more efficient method to dis- cover all calendar-based temporal association rules. An example of calendar-based temporal association rules is ?gloves and scarves are frequently purchased together on every day of December in every year.? Unlike levelwise Apriori-based approaches, our method scans the underly- ing database at most twice. Moreover, a 1-star aggregation mechanism is proposed to derive the minimal set of candi- date calendar patterns that need to he counted in the first scan of database. Our method can he briefly introduced as fol- lows. A user-given calendar schema [4], e.g., year, month, and day, is firstly adopted to specify the interesting time in- tervals as calendar pattems. Then, in every time interval, the frequent 2-itemsets are discovered along with their 1-star calendar patterns. After that, information of the rest k-star calendar patterns of the frequent 2-itemsets are levelwisely aggregated by the 1-star aggregation mechanism. F?utther- more , all candidate itemsets are generated from disc:overed frequent 2-itemsets and the Apriori downward property is utilized to reduce the number of their candidate calendar pat- terns. Finally, all frequent itemsets along with their frequent calendar patterns are discovered in one shot. Calende-based temporal association rules are then obtained.

The rest of the paper is organized as follows. In Section 2, we briefly describe the concept of the calendar schema. A formal description about calendar-based temporal associa- tion rules is also given. In Section 3, we describe our method in detail. Simulation results are presented in Section 4, and finally, a conclusion is given in Section 5.

2 Calendar Schema A calendar is, in general, a structured collection of time intervals. To construct a calendar, the hierarchy of time gran- ularities, e.g. day, month, and year, has to be  determined to handle descriptions of multiple time granularities.

2.1 Basic Calendars For each time granularity, a Boolean function which de- scribes the distribution of all the time intervals in the time granularity can be specified, and the Boolean description forms a basic calendar. For example, workdays of ii week can be described with a Boolean function as shown in Fig- ure 1, A basic calendar, A,  characterizes a proposition about the collection of time intervals in a time granularity U ,  de- scribed by a Boolean function 6~ where 6A : Ti + {o, 1) for every time interval Ti E U. The function value (?*(Ti) indicates whether Ti is included in .4. Some exampl,: basic calendars are shown in Figure 2. Usually, the Boolean func- tions describing time granularities are arbitrarily speci5ed by the user.

2.2 Complex Calendars In real life, complicated temporal expressions, such as the $rst day of every month, are required and it is importint for users to easily describe these temporal requirements. Given m time granularities, i.e., U1, U,, ..., U, a complex calen- dar, B, characterizes a proposition about the collection of time intervals in multiple time granularities, described by a  Boolean function 6~ where 6~ : Ti -+ { 0 , 1 } for every time interval T, E U1 x U, x ... x U,. The: func- tion value ~ B ( T , )  indicates whether Ti is included in R. For simplicity, a complex calendar pattern of m time graiiulari- ties, U,, U2, ..., U, is represented as &lt; R I ,  Rz, ..., B, &gt; where Ri, 1 5 i _&lt; m, can he either a particular integt:r or a wild card symhol ?*?. If Ri is an integer, one specific t i a e  in- terval in U, is indicated. On the other hand, a ?*? symtrol for Ri indicates all time intervals in U,. Therefore, the time in- tervals or periodic cycles can he easily described by calendar    tervals or periodic cycles can he easily described by calendar patterns with appropriate calendar schemas. For example, given a calendar schema (year : [2001, ..., 20041, month : 11, ..., 121, day : [I, ..., 31]), February 14th in every year can be represented with the calendar pattern &lt; *: 2,14 &gt;. Note that, in the calendar schema, each granule of U, is required to be uniquely contained in a granule of Ui-l, V i  For exam- ple, the hierarchy of time granularities in Figure 2 is allowed since each day is covered by a month and each month is cov- ered by a year. Furthermore, a calendar pattern with exactly k wild-card symbols is called a k-star calendar pattern while a calendar pattern without any wild-card symbol is regarded as a basic time interval under the calendar schema.

Property 1 The information of a ( k  + 1)-star calendarpat- tem, &lt; *, *, *, *, *, ..., *, R ( k + q ,  ..., R, &gt;, can be aggre- gated from the information of all k-star calendar patterns in &lt; *,*, *, *, *, ..., *, R(k+l ) ,  ..., R, &gt;, where each &amp;, for ( k  + 1) 5 i 5 m, is indicated by an inrege,: Proof Assume that there are totally T time intervals in U(k+l). By definition, all time intervals in a granularity are indicated with a ?*? symbol. There- fore, the aggregation of all k-star calendar patterns &lt; *,*;*,I, *, ..., *, R(k+l), ..., R, &gt; in U(k+l)  will be 2 &lt; *:*,*,*,*, ..., *&gt;j ,R(k+Z) ,  ...,R, &gt; (1) 3=1 =&lt; *, *, *,*&gt; *&gt; ..., *&gt; *, R ( k + 2 ) which is the (k + 1)-star calendar pattern, &lt; mation of every k-star calendar pattern is known, the information of the (k + 1)-star calendar pattern can also be derived.

*, *, *, *, *, ...) *: R(k+S) ,R ,  &gt;. Thus, if the infor- 2.3 Calendar-based Temporal Association Rules The purpose of our method is to find, from temporal databases, calendar-based temporal association rules which holds in the calendar schema specified by the user. Let Z = {il,i2, ..., zl} be a set of items. Let D be a temporal database of transactions where each transaction t is associ- ated with an identifier TID, a time information tt indicating the time when the transaction occurred, and a set of items t ,  such that t ,  C 1. Let D be  divided into a sequence of n partitions, PI,  Pz, . _  _, and P,, each Pi containing a set of transactions occurring in the corresponding time interval Ti with the duration being that of the smallest time granu- larity. Mining calendar-based temporal association rules in a database is to discover interesting patterns with calendar- based periodicity in D. That is, to discover every associa- tion rule which holds in an enough number of time intervals given by the corresponding calendar pattern. An association rule with respect to a time interval, Ti, is an implication of B zleyr dthB1BBL Figure 1: A Boolean function describing time intervals which are workdays of the week. m:ril ;-- I5  a, % /. -., 0, a &gt; . I . . . . , 1 3 1 S *  ~, - - . - d.P - I_ Figure 2: Basic calendars associated with the time granularity of (a) day, (h) month, and ( c ) year.

the form x J T d  Y (2) where X 2 I, Y C_ I ,  and X n Y = 0. Let IP;(I)l he the number of transactions containing itemset I in partition Pi.

The association rule X+?Y is said to have supports% in the partition Pi if IPi(XUY)l = IP,lxs%, (3) where lPil denotes the number of transactions in partition Pi.

For an association rule X J T * Y ,  let IPi(XUY)l/lPi(X)l =e%. (4) The rule is said to hold in Pi or 2?; with confidence c%. For a    The rule is said to hold in Pi or 2?; with confidence c%. For a given pair of  confidence and supportthresholds, e% and s%, and a given time interval Ti, association rules in Ti are those which have confidence and support greater than or equal to c% and s% in Pi, respectively.

Furthemiore, a calendar-based temporal association rule with respect to a calendar pattern, U ,  is an implication of the form x Y. (5) Assume that lul time intervals are covered by U .  ?If an asso- ciation rule holds in at least m x IuI time intervals covered by U ,  where m is a user-defined match ratio (0 &lt; m 5 l), it is said to he a calendar-based temporal association rule that holds in U .

3 OurMethod Roughly, our method for discovering all calendar-based temporal association rules can he divided into three phases, i.e., discovery of frequent 2-itemsets along with their 1-star candidate calendar patterns, generation of candidate itemsets along with all their k-star candidate calendar patterns, and discovery of frequent itemsets along with their frequent cal- endar patterns. In phase l ,  frequent 2-itemsets, Lz, in each partition are discovered with their respecting 1-star candi- date calendar patterns V?. Note that Lz is empty initially.

In partition Pi, every frequent 2-itemset in PI is computed and inserted into La.  Also, for each itemset I in La, its first I-star candidate calendar pattern U:  is kept in V? of I and its repeating count in U: is set to 1. In the rest of parti- tions, Pz, ..., P,, discovery of frequent 2-itemsets along with their 1-star candidate calendar patterns is iterated as follows.

Frequent 2-itemsets are firstly computed with three different cases. In case 1, a frequent 2-itemset, I, is not currently in Lz,  and therefore it is inserted into La. Also, U: is kept in V? of I and the repeating count in U: is set to 1. In case 2, the frequent 2-itemset, I, is already in Lz,  but a new 1-star calendar pattern, U:, with respect to the current partition is 31 24 generated. In this case, U! is inserted into V? and I?s repeat- ing count in ul is set to 1. In case 3, the frequent 2-itemset , I ,  is already in Lz ,  and the respecting 1-star calendar pat- tern, u t ,  has also been in V? of I .  We simply increase I?s repeating count in ut by 1 in this case.

In phase 2, Property 1 is firstly used to aggregate ail other k-star candidate calendar patterns of itemsets in Lz from 1- star candidate calendar patterns. For an itemset I in L2,  its repeating counts in 1-star candidate calendar pattern:;, $k, have been derived from phase I ,  and thus its repeating counts in 2-star candidate calendar patterns, $?s, can be easily ob- tained. Similarly, its repeating counts in 3-star candidate cal- endarpattems, $?s, can be aggregated from that in u,?s, and so on. Instead of directly generating all k-star candidate cal- endar patlerns in phase l ,  our method generates and scans only 1-star candidate calendar patterns in the first scan of the database. Therefore, a smaller number of candidate cal- endar patterns are generated and counted in the process of scanning database. Once all candidate calendar pattims of itemsets in LZ are derived, candidate itemsets C k ,  for k 2 3, along with their candidate calendar patterns can funher be generated. Note that two kinds of candidates are generated in this phase, i.e., the candidates of frequent itemsets (candi- date itemsets for short), and the candidates of frequent calen- dar patterns (candidate calendar pattems for short). The set of candidate k-itemsets, i.e., C k  of k &gt;= 3,  are generxted as follows: where * is the JOINT operation given in [ I ] .

Let the set of candidate calendar patterns, VI. of I he v, = U(U,21u,?,. (7) k&gt;1 Intuitively, the candidate calendar patterns of an itemset I; in C3 can be derived by intersecting the candidate calendar pat- terns of itemsets which are the subsets of I,? in L2 as shown    terns of itemsets which are the subsets of I,? in L2 as shown below: vr: = n({vr; I VI; I;}). (8) However, by utilizing I?s  repeating counts in Vr, V I  E L2, we can find the minimal set of candidate calendar patterns for each itemset in C,. From E?.@), it is clear that the repeating count of a candidate calendar pattern of an itemset I,? in C3, uI;.count, will never be larger than any u p  .count, ?JI,? c I,?. Therefore, the maximal value of uI;.count, GI:.,iount, can be obtained by (9) Furthermore, for each I:, uI: is removed if GI;.cozmt 5 (m x IvpI). Finally, the candidate calendar patterns .3f C k , k &gt;= 4, &amp;e obtained by - ur:.count = min({vp.count I VI,? c I:}).

vrL = n({v,;-. I v1j-l c I;}) ,  fori 2 4. (IO) In the final phase, to discover the frequent patterns from candidates, all candidate itemsets along with their candidate calendar patterns are counted in the database in one shot.

Note that a candidate itemset is only scanned in the time intervals covered by its candidate calendar patterns. As a result, a frequent itemset passes the match ratio of a calendar pattem can be found. Calendar-based temporal association rules are then obtained.

4 Experimental Results We compare the performance of our method with that of the ?Temporal-Apriori? algorithm proposed in [4] by run- ning them on several experiments with a PC with 2.2 GHz CPU and 1.OG memory. The technique introduced in [ I ] is used to generate four synthetic datasets, T10.14.D400K, T10.14.D600K, T10.14.D800K and T10.14.D1000K, to form input databases to the algorithms in the experiments, where T is the mean size of a transaction, I is the mean size of potential maximal large itemsets, and D is the num- her of transactions in units of K, i.e. 1000. The calendar schema (year : [2001, ..., 20041, month : [ l ,  ..., 121, day : [l, ..., 311) is used in the experiments, and the match ratio is 0.8. These four datasets are divided into, 400, 600, 800 and 1000, partitions, respectively, where each partition con- tains 1000 transactions and is corresponding to one basic time interval in the calendar schema. In the following, we firstly give one experiment to compare the performance of Temporal-Apriori and our method with different scales on data size and support threshold. Then, to demonstrate the effectiveness of our 1-star aggregation mechanism, another  experiment is given to compare the performance of generat- ing all k-star and only 1-star candidate calendar patterns of LZ in the first database scan.

4.1 Experiment 1 In experiment 1, to compare Temporal-Apriori and our method, we use both methods to discover calendar-based temporal association rules in four datasets with different sizes mentioned above on different scales of support thresh- old. In Figure 3, the execution time of Temporal-Apriori applying to different datasets with support thresholds, 0.05, 0.06,0.07,0.08,0.09 and 1 ,  respectively, are drawn in dotted lines while our method are drawn in solid lines. Moreover, in Figure 4 and Figure 5 ,  the black pillars represent the av- erage number of candidate itemsets and candidate calendar patterns generated by Temporal-Apriori in these four differ- ent databases, respectively. The gray pillars are those gen- erated by our method. As for the white ones, they indicate the average number of frequent itemsets and frequent cal- endar patterns discovered by both methods in the database.

From these three figures, we can see that though our method generates slightly more candidates than Temporal-Apriori, we have better performance with smaller support thresholds.

For smaller support thresholds, the length of maximal fre- quent itemsets will be longer. Therefore, the number of database scans in Temporal-Apriori increases when the sup-    x lo' 0.05, 0.06 0.07 0.m om 0.1 support t h m h o l d Figure 3: Performance comparison between Temporal- Apriori and our method.

port threshold decreases. Meanwhile, our method always scans the database at most twice. As a result, our method is efficient in all kinds of support thresholds, but the perfor- mance of Temporal-Apriori varies dramatically for different cases.

4.2 Experiment 2 To demonstrate the effectiveness of our 1-star aggrega- tion mechanism, we compare the difference between apply- ing and not applying the mechanism into discovering candi- date calendar patterns in the first scan of database. Figure 6 shows the average number of 1-star and all k-star calendar patterns discovered in the first database scan with four differ- ent datasets. Since 1-star calendar patterns is the subset of all k-star patterns, it is clear that the number of 1-star calendar patterns will be smaller than that of all k-star patterns. For the calendar schema used in our experiments. the number of 1-star calendar patterns is close to 90% of all k-star pattems.

But the percentage of 1-star calendar patterns will be smaller if a more complex calendar schema, e.g., a schema with more time granularities or more time intervals in one granularity, is used. Though the number of 1-star calendar patterns is ev- idently smaller than that of all k-star calendar patterns, the efficacy of the mechanism can not be directly perceived eas- ily. Thus, the execution time for discovering all candidate calendar patterns of large 2-itemsets by scanning 1-star and all star candidate calendar patterns in the database, respec- tively, are given in Figure 7. The results obtained by utilizing 1-star calendar pattern mechanism are obviously better than those obtained by not applying the mechanism.

5 Conclusion We have proposed an algorithm to discover all calendar- based temporal association rules that occur over any time 0 07 SUPP' Figure 4: Average number of candidate itemsets and frequent itemsets generated by Temporal-Apriori and our method.

om 007 008 om 0 1 suppon threshold Figure 5: Average number of candidate calendar patterns and frequent calendar patterns generated by Temporal-Apriori and our method.

31 26 , io' I I 1 star candidate calendar patterns I all 611, candtdats calendar p a t l e d  '7 n i om DO9 0 1  I .uppod threshold Figure 6: Average number of 1-star and all star carididate calendar patterns generated in the first database scan.

Figure I: Execution time for discovering candidate calendru pattems of large 2-itemsets by scanning I-star and a l l  star candidate calendar patterns in the database, respectively.

interval in a temporal database. An example of a calendar- based temporal association rule is "chocolates and flowers are frequently purchased together on February 14th in ev- ery year." A user-given calendar schema, e.g., year, month, and day, is firstly adopted to specify the interested time in- tervals as calendar pattems. Then, in every time interval, the frequent %itemsets are discovered along with their 1-star calendar patterns. After that, the information of the rest k- star calendar pattems of the frequent 2-itemsets are aggre- gated from their 1-star calendar patterns. Thus, the mini- mal number of calendar pattems are generated and counted in the database. Further, to avoid multiple scans over the database, all candidate itemsets are generated from discov- ered frequent 2-itemsets and the Apriori downward property    ered frequent 2-itemsets and the Apriori downward property is utilized to generate the minimal number of their candidate calendar patterns. Finally, all frequent itemsets and their cal- endar patterns are discovered in one shot. Calendar-based temporal association rules are then obtained. Experimental results have shown that our method is more efficient than others.

