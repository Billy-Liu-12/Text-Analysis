Data mining Algorithm of Browsing Pattern Based on Web Log

Abstract?An Web log contains a large number of user browsing information, so how to effectively mine it for user browsing pattern is an important research subject. Based on the analysis of the problems in the current mining algorithm of the user browsing pattern, and combining the characteristics of the existing fast association rules mining algorithm, this paper adds the sequential constraint and the time factor, and puts forward a browsing pattern mining algorithm TBPM which is based on the temporal constraint. It also designs incremental updating algorithm based on the temporal frequent item set algorithm TBPM. At last, it makes a comparison with the related work of the class Apriori algorithm, and the experimental results on the actual data have verified the effectiveness of this algorithm.

Keywords-Web log mining, temporal constraint, browsing pattern, incremental updating

I. INTRODUCTION With the constant development of Internet, Web log  mining has become an international emerging important research field. Web log mining is making use of the principles and ideas of data mining to expand and improve the traditional mining methods aiming to new features of Web logs, and to apply them in Web logs so as to be mined for frequent browsing patterns. The user-based browsing pattern can optimize the website structure, and improve the website performance.

Web log data is a kind of sequence composed of real- time, continuous and ordered data, which has a large amount of data, dynamicity, timeliness and other characteristics. But the existing browsing pattern mining algorithm (class Apriori[1]) needs to frequently scan the database, with the low efficiency, and considers little about the timeliness of the browsing pattern. The browsing patterns obtained from mining in fact are all assumed to be permanently valid. Based on the characteristics of transactions and sessions for users, and combining the existing fast association rules mining[2] thinking, this paper puts forward a browsing pattern mining algorithm TBPM (Time Browsing Pattern Mining) with the temporal constraint, which is suitable for Web logs. This algorithm simplifies the generating operations of the candidate pattern in the process of mining. In this algorithm, scan the database once to obtain a continuous subsequence set of each transaction, and use set and crossover operations to obtain support. This algorithm increases the effective time  domain and time-matched item sets, and merges time intervals. Compared with the class Apriori algorithm, this algorithm has less time, good scalability, and timeliness.



II. PROBLEM STATEMENT Data mining based on Web logs requires first carrying  out data pretreatment, including user identification and transaction identification. M.S Chen and others put forward the concept of MFR (Maximal Forward Reference) as the basis for division of Web transactions. To divide Web transactions based on MFR means that the path formed from the first page the user forward browses to the previous page he backspaces each time in a user session is a transaction. For example, in a user session the requested page order is A-B-A-C-D (capital letters are used in this paper to mark pages), and then the corresponding transactions are A-B and A-C-D. After pretreatment, data in Web logs is stored in the database in the from of recording each transaction at a time, and the first page access time in the path is taken as the access time for each transaction. To facilitate the discussion, there are the following definitions.

Definition 1 (Subpath) Given the path P={p1,p2, ,pn} the arbitrary P?={pi,pi+1, pi+j}(1 i,i+j n) is a subpath of P, stating that P contains P?[1].

Definition 2 (Temporal frequent browsing pattern) Ifa Web access path P={p1,p2, ,pk} satisfies the following conditions:  Then it states that the path P is the temporal frequent browsing pattern in the time interval of TE. In the formula, Smin is the pre-defined minimum support by users; sup(P) is P?s support; TE is a time interval.



III. BROWSING PATTERN MINING WITH THE TEMPORAL CONSTRAINT  A. Temporal frequent browsing pattern mining algorithm This algorithm is mainly to scan the database once, and  to obtain all item sets from each transaction in Web transaction flow which are stored in the temporary item sets (most in memory; when reaching a threshold value, they are written into the physical database in batches). Also, this algorithm sets the counting device (support) appearing in each item set, and adds two time domains to respectively    record start access time ts and end time te which support this item set. All the temporary sub-sequence sets subit1,subit2, subitmax_T in each transaction can match with each candidate item set candit1, candit2 , , canditmax_T, which are generated and stored in the candidate item set CanditSetDB of all transaction sets. Each item set comes with the time frame which supports the frequent access item set, and then this algorithm traverses candidate item sets to filter out the item set greater than the given minimum support, so as to form temporal frequent access path sets. The candidate item data sets after being reorganized can replace the original database, and thus can reduce the time to repeatedly search the database.

First, briefly describe the extension and merging technologies of time intervals[3]:  1) Extension of the time interval: Extension of the time interval refers to the outward extension of its two endpoints, in order to make the two time intervals meet or overlap, and then to combine them into the same time interval. The degree of outward extension of the time interval?s two endpoints is determined by the promoting factor f which indicates the extension degree of the time interval. The value of the promoting factor f can be automatically set by the algorithm, and can also be designated when the algorithm is called. In a word, the value of the promoting factor f should be selected empirically based on specific application areas.

2) Merging of time intervals: Supposing ],[ 111  ??? III and ],[ 222 ??? III are two time interval  variables, whose temporal merging operation is defined as[4]:  Temporal merging ? ?T? : if ?? ? 21 II or ?? ? 12 II , then ??21 II T? , otherwise ],[ 3321  ??? IIII T? , in which },min{ 213  ??? ? III , and },max{ 213 ??? ? III .

The following is an example of the algorithm implementation. Suppose there is a temporal transaction database DB as shown in Figure 1, including 4 transactions, and the support number is 2. In this algorithm, TID is the transaction identifier; Itemset is the url sequence set which users access (which has corresponded to letters); time is the access time for a transaction; the promoting factor f is 1.5.

The diagram 1 of the mining process is shown below.

Figure 1 The diagram of TBPM algorithm generating the browsing pattern  Algorithm 1: Frequent browsing pattern mining algorithm based on the temporal constraint.

Input: the Web transaction database DB in a sliding window, the minimum support Smin, the maximum transaction length max_T, and the promoting factor f.

Output: the temporal frequent item set L.

Algorithm TBPM (DB, Smin , max_T f) 1) {L=? ; 2)CanditSetDB=CanditSet(DB,f); //Generating temporal candidate item sets 3)For each canditi CanditSetDB{ 4)Li={cj canditi | cj.count ?Smin};  5) i T  i LL max_  1?? ? ;}} Among them, in order to improve the algorithm  efficiency, the comparison and matching operations between all the non-empty subsets of a transaction and the generated candidate item sets adopt sets? union, intersection, and subtraction operations. All the temporary transaction subsets formed by i items are expressed by subiti, and all the candidate item subsets formed by i items are expressed by canditi. For each item in the intersections of temporary item sets and candidate item sets, determine whether the time is matched. If so, support increases by 1, merging the effective time; otherwise, add the item to candidate sets. Add each item in the transactions of temporary item sets and candidate item sets to candidate    item sets. Set support as 1, and set the access time of the session (Start and end time are the extension time for this session). The generating operator CanditSet(DB,f) of the temporal candidate item set is shown below:  Algorithm CanditSet(DB,f)  1) { candit=?  ; 2)  for each transaction T 	DB{ 3) subit= subset(T); //By definition 1, obtain all the non-empty continuous subsequence sets of each transaction //At the same time, extend the effective time of all subsequences based on f 4)for each subiti 	subit{ 5) N_set=subiti-canditi ; //Subtraction operation is used for the ith subset and the ith candidate item set.

6) For each nj	N_set{ 7) Add the item nj to canditi //Add the item set nj to the ith candidate item set (orderly inserting) 8) nj.count=1; 9)nj.ts=T.time-(f-1)*T.time; nj.te=T.time*f; } //When the subset appears in the candidate item set for the first time //Start and end time are both the time after the transaction time extends 10) O_set=canditi subiti //Union operation is used for the ith subset and the ith candidate item set 11)for each oj	O_set 12)  for each ck	 canditi 13) if ??kTj co ? //Time not matching 14)     {Add the item oj to canditi 15)      oj.count=1; 16)      oj.ts=T.time-(f-1)*T.time; 17)      oj.te=T.time*f; } 18)    else  //Time matching, merging 19) {ck.count++; 20)       if(oj.ts< ck.ts) then ck.ts= oj.ts; 21)       if(oj.te> ck.te) then ck.te= oj.te;} 22) } } Return candit;}  B. Log incremental mining With the continuous generation of log data, it is  necessary to carry out incremental updating mining. This part designs incremental updating algorithm based on temporal browsing pattern mining algorithm in the last part.

Aiming to the continuous generation of new logs, we need to make full use of the mined results. On the basis of a known pattern, we need to mine the transaction sets which have been modified to discover a new pattern and get rid of the failure pattern, so as to get a real-time updated user browsing pattern.

1) Symbol definition in the algorithm: The frequent set of the database DB is expressed by L, and the frequent set of DB ? db is expressed by 'L ; D, d and UD respectively express the transaction number of the database DB, db, and DB? db; support counts X.supD, X.supd and

X.supUD respectively express the transaction number containing X in DB, db, and DB? db.

2) Related concepts of the incremental algorithm: In the database DB, add one more db database formed by d transactions. For the given minimum support Smin, the support of the item set X in the database DB? db is not less than Smin, namely X.sup ? Smin  (D+d), the item set X is frequent in the updated database DB? db.

The algorithm thinking: scan once the candidate item set CanditSetdb generated by db?s use of TBPM algorithm. For the item sets in CanditSetdb, there are two cases, including belonging to the initial frequent set L and not belonging to the initial frequent set L. For the item set belonging to the initial frequent set L (and time matching), recalculate the new support count and merge time. If the item set is a loser when it is less than the minimum support count of the updated database DB? db, only modify the support and merge time without other treatments. Otherwise, it is a winner. Then reserve and add it to the new frequent set 'L .

For the item set not belonging to the initial frequent set L, it is first pretreated. If the item set is less than the minimum support count of the updated database DB? db, pruning and marking are used (not transmitted to the new frequent set). Scan CanditSetDB, and add the item sets which meet the conditions of the support count to 'L . The support counts is {I1, I2,?,In}.supD+{I1, I2,?,In}.supd. At the same time, merge the item sets which are pruned and marked in CanditSetdb into CanditSetdb (if it is the same item set (time matching), then update support and merge time; if it is a new item set, then it is added into).

For example, suppose D 4 d=3 Smin=0.5 f=1.5, T1 T2 T3 and T4 are four transactions in the initial database DB, while T5 T6 T7 are three transactions in the new database db, as shown in Table 1.

Table 1 db transaction database TID Itemset time  t5 ABCDE 10 t6 ABCD 12  t7 BCD 14  Scan once the candidate item set CanditSetdb generated by db?s use of TBPM algorithm.

CanditSetdb={(A,[5,18],2),(B,[5,21],3), (C, [5,21],3),(D, [5,21],3), (E, [5,15],1), (AB,[5,18],2),(BC,[5,21],3),DE,[5,15],1),(CD,[5,21],3),(A BC,[5,18],2),(BCD,[5,21],3),(CDE,[5,15],1),(ABCD,[5,18 ],2),(BCDE,[5,15],1),(ABCDE, [5,15],1)}. Scan CanditSetdb once, and for each item determine whether it is    contained in L. {A,B,C,AB,BC,ABC} is contained in L, and time matches, so modify support and merge time in CanditSetDB. For the item {A,B,C,AB,BC,ABC} whose support is greater than 0.5*7, directly add it to 'L .

{D,ECD,DE,BCD,CDE,ABCD,BCDE,ABCDE} is not contained in L. For the item {D,CD} existing in CanditSetDB, modify the support and merge time. For the item {DE,BCD,CDE,ABCD,BCDE,ABCDE} which does not exist in CanditSetDB, add it to CanditSetDB. For the item {D,CD} whose support is greater than 0.5*7, add it directly to 'L . At last, 'L ={ A, [1,18],5), B, [1,21],6), C, [1,21],7), D,[5,21],4), CD,[5,21],4) AB, [1,18],4),  BC, [1,21],6), ABC,[1,18],4)}.

The advantage of this algorithm is that a new frequent  set 'L is generated while the initial candidate item set  CanditSetDB is updated, without scanning the huge  CanditSetDB once again to discover the frequent item 'L  till the candidate item set CanditSetDB is updated, which effectively improves the efficiency of the algorithm.



IV. ANALYSIS OF EXPERIMENTAL RESULTS The class Apriori algorithm used for mining user  browsing pattern put forward by the literature [1] comes from improvement of the Apriori algorithm[5] which discovers frequent item sets when mining association rules in the data mining field. The disadvantage of the class Apriori algorithm is its need to repeatedly scan the database, which may also generate huge candidate sets. The following is the comparison between the TBPM algorithm and the class Apriori algorithm, which indicates the speediness and effectiveness of the TBPM algorithm.

A. Comparison of algorithm efficiency  This part makes a performance comparison between the TBPM algorithm and the class Apriori algorithm when they are used for Web log transaction database mining. The following shows the comparison between the two algorithms, aiming to different Web transaction database minings. X-axis indicates the size of different Web transaction databases, and Y-axis indicates the time spent in running the algorithm. The results are shown in Figure 2:  Figure 2 The efficiency comparison between the TBPM algorithm and the class Apriori algorithm  Seen from the experimental results, as the database size increases, the TBPM algorithm uses less time than the class Apriori algorithm, which indicates that the TBPM algorithm has good adaptability in the large-scale database mining. This is because the TBPM algorithm only scans the database once, while the class Apriori algorithm belongs to the Apriori algorithm. So it is inevitable to bear the cost of the generation of a large number of candidate sets and frequently scanning the database. The generation of Lk each time requires scanning the database once. Due to the fact that the user access log database stored in the server is usually very huge, the scanning process is inevitably very time-consuming. From this point of view, the TBPM algorithm is quite better than the class Apriori algorithm in efficiency. When mining a large-scale database, the corresponding mining time becomes critical, therefore, the TBPM algorithm has good efficiency.

B. Analysis on incremental mining algorithm  This part makes a performance comparison between TBPM-based incremental updating algorithm and Apriori- based FUP algorithm[7] when they are used for Web log transaction database mining. Suppose the maximum length of the session is 8; DB is 100k; db is 1k; the minimum support sup is 2%. When the potential frequent access path takes different values, the performance ratio of the log incremental algorithm and the FUP algorithm is shown in Figure 3:  Figure 3 Performance ratios of log incremental algorithm and FUP aiming to pattern length changes  Seen from the experimental results, as the potential frequent access path length increases, the performance ratio of log incremental algorithm to the FUP algorithm also increases proportionately, which indicates that log incremental algorithm has high efficiency in long pattern mining, related with the characteristics of the TBPM algorithm. In the entire process of log incremental algorithm, there is a need to only scan DB once and db twice, unrelated with the maximum length of the frequent path. But the FUP algorithm is based on the Apriori algorithm, which requires scanning all the databases K  Potential frequent access path length  perform ance ratio  log increm ental algorithm  and FU P    times. That is, when the greater is the frequent path length, it requires scanning the database more times, which thus results in reduced efficiency of the algorithm.

C.  Comparison of mining results  The following is a comparison result between the class Apriori algorithm and the TBPM algorithm, as shown in Table 2 and Table 3, which further illustrates the effectiveness of the TBPM algorithm.

Table 2 The patterns generated by the class Apriori algorithm  No. Web browsing patterns support 1 jxky/gzzd/kyb/kxyj.htm 0.42 2 xy/xyxw.html 0.68 3 zshjy/bzhzhsh/2008/123.html 0.45 4 Jxky/jxchg/23.html 0.82 5 Jxky/kybgsh/2008/122.html 0.38  Table 3 The patterns generated by the TBPM algorithm  No. Web browsing pattern time zone support 1 jxky/gzzd/kyb/kxyj.htm April-June 0.42 2 xy/xyxw.html March-December 0.68 3 zshjy/bzhzhsh/2008/123.html May-September 0.45 4 Jxky/jxchg/23.html April-June 0.42 5 Jxky/jxchg/23.html October-December 0.40  6 Jxky/kybgsh/2008/122.html September-November 0.38  From the analysis on the two results, it shows that the No. 1 pattern discovered by the TBPM algorithm is effective only in April-June, thus, the obtained result may be changes in Website link structure. With the incremental updating, this pattern may be eliminated. The No. 3 pattern is effective only in May-September, which can result in real-time decision support. The patterns mined by the class Apriori algorithm are considered to be always effective, lacking fidelity, which indicates that the TBPM algorithm is reasonable and effective.



V. CONCLUSION Due to a large amount of Web log data constantly  updated every day, and the discovery of Web logs with  time mark from the analysis on Web log data, this paper puts forward a user browsing pattern mining algorithm, and makes a comparison between the TBPM algorithm and the class Apriori algorithm, which proves that the algorithm proposed by this paper is fast and effective, suitable for real-time Web log mining. According to the actual needs, the appropriate time quantum is selected for mining using the algorithm in this paper, and the cyclic pattern[8] can also be mined. In e-commerce, to select one-day logs for mining, you will find such rules as Milk Bread (7:00AM 9:00AM). In practice, the author has designed and implemented a prototype system of Web log mining, and proved that this algorithm is fast and effective.

