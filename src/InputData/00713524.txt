A Uniform Framework for Processing Temporal Object Queries

Abstract  This paper explores a uniform framework for processing temporal queries in the context of object-oriented databases. A temporal object data model is developed by extending the un@ed rvdel of RDBs and OODBs from UniSQLLY with a time-dimension, that forms temporal relational- llke cubes but with aggregation and inheritance hierarchies. A query algebra is thereby defined to provide an access of objects through these associations of aggregation, inheritance and time- rleference. Due to the hierarchy of the data model and reducibility of the query algebra, an txtensible approach to processing temporal object queries within the uniform query processing framework is attained. A set of transformation rules is identiped for query rewrite, that includes the known relational and object rules plus those pertaining to the time-reference. To evaluate temporal queries involved in the path, a decomposition strategy is proposed. It has been shown that temporal object queries can be processed and optimized within the uniform query processing framework.

:l Introduction  Whilst the semantic limitations of relational databases (RDBs) are widely recognised, cbject-oriented database systems (OODBs) are emerging as the most promising database tkxhnology to satisfy the needs of advanced database applications such as computer-aided tilesign (CAD), computer-aided manufacturing (CAM), computer-aided software engineering (CASE), document and multimedia preparation, office automation and scientific computing.

Many of these advanced database applications require a support for time-varying data. Management c!f temporal data becomes one of the key challenges that today?s OODBs need to address [6, 181. As lieported in [lo, 11, 13, 81, the vast majority of research on temporal databases (TDBs) has been lbcused on the incorporation of time elements into existing data models. Little work that has been clone on query processing and optimization [7, 12, 141 is in the context of RDBs. Dayal and Wuu 131 proposed a uniform approach to processing temporal queries in the context of functional object- oriented data model. But their work didn?t take account the query optimization and evaluation within a query processing framework. Also their work is based on a functional model and language, fbat would lead the functional optimization quite different from the algebraic, cost-based ciptimization techniques employed in RDBs as well as a number of OODBs [9].

~ In this paper, we investigate processing temporal object-oriented queries within a uniform ltramework. By the uniform framework, we mean that temporal queries can be processed and cbptimized within the existing object-oriented framework that is extended from the relational l/ramework, through smoothly extending the techniques developed for existing OODBs and TDBs.

Query optimization techniques are dependent upon the query modelllanguage. The query model, iln turn, is based on the data model underlying the data, as the latter defines the access primitives  28 0-8186-8551-4/98 $10.00 0 1998 IEEE  mailto:mdx.ac.uk    that are used by the query model [9]. So our work started from the development of temporal object data model. We adopt the unified model of RDB and OODB from UniSQLlx [6,2] as a snapshot object data model, and then incorporate within it with a time dimension. A temporal object query algebra is thereby defined as a query modeVlanguage to provide an access of objects. The features of the hierarchy of data model and the reducibility of query algebra provide a basis to explore or extend the techniques and strategies for processing temporal object queries within the existing query processing framework. An extensible approach to temporal query processing within the uniform framework is therefore attained.

?The remainder of this paper is organised as follows. Section 2 describes the adaptation of the unified data model of RDB and OODB with the inclusion of a time dimension. The algebra for the data model is given in Section 3. Section 4 presents an extensible approach to temporal query processing. Processing the temporal query components is discussed in Section 5. Section 6 includes conclusions and future work.

2 ?me data model  2.1 The unified model of OODB and RDB  ?The unified data model of RDB and OODB from UniSQLlx [6, 21 extends the relational data model in three important ways, each reflecting a key object-oriented concept: (1) nested predicates; (2) inheritance; (3) methods. Allowing a column of a relation to hold a tuple of another relation directly leads to a nested relation. Allowing the users to attach procedures to a relation and to have the procedures operate on the column values in each tuple achieves the combination of data with program. Allowing the users to organise all relations in the database into a hierarchy, such that between a pair of relations P and C, P is made the parent of C, if C takes (inherits) all columns and procedures defined in P (besides those defined in C), the relational model integrates the object- oriented concept of inheritance. UniSQUX actually makes one more extension to the relational model: allowing the row/column entry of a relation to have a set of values (i.e., any number of values), rather than just a single value: and further allowing the set of values to be of more than one arbitrary data type. This provides an ability to represent the many-to-many relationship between two collections. The model is an object-oriented model and it is adopted as a snapshot model to inclxporate time.

I:n addition, we preserve the basic object concepts such as ?any real-world entity is uniformly modelled as an object?, ?each object is associated with a unique identifier?, etc., so that het(5rogeneity in the time dimension and the grouped completeness of algebra can be maintained, as discussed in our previous work [ 171.

2.2 A temporal object  Let T =( ..., t@ tl, ...I be a set of times, at most countably infinite, over which is defined the linear (total) order <?, where tl <?t, means t, occurs before (earlier than) tJ For the sake of simplicity, we can assume that T is isomorphic to the set of natural numbers. Any subset of Tis  called a temporal set. A temporal set can be represented as a union of disjoint time intervals. The most basic property of temporal sets is that they are closed under finite unions, intersections, and complementation. That is, if TI and TZ are temporal sets, then so are TJuT~,  TInT2, TI-T2, and 7Tl.

If an object o, which is any real world entity, exists for a certain period of time, which is a subset of T(i.e., the temporal set), this period is called the object?s lifespan, denoted as y o )  for the object 0. If the lifespan Uo)=[t,,, tend], the duration of time is called a span: spun(o)= tpnd -tstun+l. In     . Regular experimantal eas  order to support for derived lifespans, we allow the usual set-theoretic operations over lifespans.

That is, if Ll and L2 are lifespans, then so are L p L 2 ,  LlnL2, L1&, and+,  A temporal object is defined as a time sequence (TS for short): (t, o(t)}, tgL(o)cT, denoted as <L(o), o(t)>, (or simply o(f) or o ). A temporal object <Yo), o(t)> asserts that the object o(t) is valid for its lifespan L(o) and its value changes with time. For a constant object 0, it may be represented with no timestamp where its time reference is implied as L(o). It can also be represented with the explicit time reference as a temporal object <L(o), o>. Fig. 1 gives three basic types of time-varying entity. For the step-wise constant, <yo), oft)> =( ... ; ti.], ovi.1; ti ovi; ti+l, ovjt1; ...}. The term epoch from signal processing is used to refer to the time at which the object changes its value, e.g., ti. The interval during which the value ovi persists is determined by the epoch ti and its succeeded epoch tit], i.e., [ti ti+l). If there are n elements in a TS, it is said that there are n epochs. For the discrete time event, if the value of the entity is recorded at every single time point (if it does not, it can be represented by a time series with unequal spacing in time like the step- wise constant, and the entity value at the time point between recorded time points can be assumed or determined depending on the application), we have <L(o), o(t)> =( ... ;t;.I, ovi.1; tl. ovi; ti+l,  continuous time event, it can be treated as a sampled continuous time signal, and therefore be O V ~ + ~ ;  ...I =( .... OV, .~ ,  ovi ov;+l, ... } =(ovJ, i.e., it can be represented by a discrete time series. For the  ir ment: discrete  represented by a discrete time series.

If a TS contains a value for each time  point in the lifespan duration, it is called a regular TS [5]  (e.g., the above discrete time event). If a TS contains values for only subset of time points within the lifespan, it is called an irregular TS (e.g., the step-wise constant). The complete history of an irregular TS can be reconstructed by a function, e.g., linear interpolation. As a TS is a set, so a temporal object can be represented by its sub-objects. In practice the lifespan may consist of disjoint, noncontiguous segments, as in [5] we  - Salary: Step-wise constant Entity Value t  p t i t y  Value  Atmospheric temperataure: continuous  prefer to use null values rather than defining multiple segments in the lifespan.

In OODBs, every real world entity is uniformly modelled as an object that is grouped into a class (relation) and interrelated to other objects through associations. Now we isolate a class (relation) C from its association relationship,  T i m e ..................... as shown in Table 1. The value,, is an object with  lifespan lmn The tuple, is also an object, its lifespan is  L(tm)=l,lulm2u ... ulmn The lifespan of attribute A, is  L(An)=l1,nul2,n~.- Limn  ..- : ,.. t-.?..<,! :  denoted as L(tJ We have  : ........

.........................

V a l u e s  The lifespan of relation C is Fig. 2. A 3-Dimensi~nal Class  Thus a 2-dimensional relation (class) ?table? becomes a 3-dimensional ?cube?, as shown in Fig. 2.

L(C)=L(A ~)uL(A~)u. ..uL(A,)=L(~~)uL(~~)u ... VL(t,,J  It is obvious that     &j=Uti)nUAJ This implies that there is no value for an attribute in a tuple for any moment in time outside the intersection of the life spans of the tuple and the attribute. Clearly our temporal object model can support a completely heterogeneous temporal dimension.

It is possible to refer to the components of a temporal object. For a temporal object o=<T,o>, o . ~ a n d  o.Trefer to its value and temporal set components, respectively (sometimes we omt  U, i.e., 0.2) =o, (or o.Z;rt)=o(t) ) to refer to the value of the object 0). Let A be the name of an attribute that can take a temporal object for its values, then A.u and A.T represent names for the value and temporal set components of the attribute A. Further, the same notation may be applied to class (relation) C. If C is the name of a temporal relation, then C. U and C.Trepresent names for the value and temporal set components of the class C.

If the domain of attribute A, of class C is another class C?, then implicitly, L(A,)=L(C?). If class C is a subclass of class C?, then L(C)=L(C?). Moreover, if a database consists of n classes (relations) C,, (22, ... Cm the lifespan of the database schema is L= L(C,)uL(C,)u ... uL(C,J.

Join 01 W p < Ad. Aoi > 0 2  ible 2 Summary of basic Definition 03={0 I M 0) where L ( O ~ ) = T ~ U T ~ 03={0 I SO) where L(O3)=T1 -T2  where L(@)=L(Ol)-L(oz) 03=01Up?={O ISo1VM@) where L(03)=L(Ol)uL(oz)  where L(@)=L(Ol)nL(oz)  @=01-@={0 1 M 01 A*? 07)  0 3 q m = { O  I OE @ AO?  op o=(o I 0 E 0 Ar(0,t))  W l ,  ..., Ai> 0 =[41:gl(o), ..., Ai:gi(o)> I OEO)  m(o)=L(o)  gebraic operators  O(Tl)GO, o(T 2)c 0 Notes  0, is a ColIection.

L(0i ) is the life-span of Oj .

op 0 selects the elements ?0? of set 0 such as the predicate P(o, t) holds.

For the type of objects in 01 (i.e., O E O ~ ) ,  g retums an object of type of @ ( i.e., g(o)s oz).

If gi=l  it retums the OID of the domain object of Ai unless Ai is atomic. We retain gi=l  so that project on a set of objects (relation) likes the relational project.

Essentially a @join as in relational algebra.

7he life-span of %l(O) is TlnL.(o). ?Iime-slice purely reduces the relation along the tempoid dimension. If Ti equals to time point ti,  i.e., T1=tl, then $l(O) represents an event o(t1) happened at t i .

?Shifts? a snapshot relation at ti by the number of positions specified by the offset 1.

Maps a set of objects 0 to its temporal set.

3 Queryalgebra     From the algebra point of view, a temporal OODB (TOODB) can be viewed as a collection of temporal objects, grouped together in classes (relations) and interrelated through three associations: aggregation, generalisation and time-reference. Each temporal relation can be viewed as a 3- dimensional structure (i.e., a cube).

Basically, the standard relational algebra provides a unary operator for each of its two dimensions: select for the value dimension and project for the attribute dimension. The temporal algebra supports an operation on the third dimension, i.e., the time dimension: time-slice. An object algebra allows the predicate of the select operation on a contiguous sequence of attributes along a branch of class-aggregation hierarchy. This sort of query is usually represented by a path [l] and is often referred as an implicit join. We have defined the enhanced path that extends the path with time-reference so that the select provides an access of data along associations of both aggregation hierarchy and time-reference. A complete set of algebraic operators has been defined for our temporal object data model (The detailed definitions are given [17]). Table 2 simply lists some basic algebra operators.

4 An extensible approach to processing temporal object-oriented queries  The temporal object data model and an algebra for this model presented in the previous sections provide a basis for query processing. Due to the hierarchical feature of our data model, as shown in Fig. 3, our algebra possesses the property of reducibility. That is, when time dimension is not taken into account the temporal object algebra will be reduced to the object algebra and when the object-oriented features of aggregation and inheritance are not taken into consideration, the algebra will be reduced to the relational algebra. We therefore could explore an extensible approach to processing temporal queries within the existing object query processing framework that in turn is extended from relational query processing framework.

4.1 Optimizer hierarchy  Our optimizer is of a hierarchical structure as shown in Fig. 4, where the temporal optimizer is built on the top of the object optimizer that, in turn, is on the top of the relational optimizer. The temporal object queries can be processed and optimized within the existing query processing framework through smoothly extending the existing query processing techniques  Fig. 3 Data model hierarchy  4.2 Query transformations  I  l h -  e m p o r a l  optimizer I  Fig. 4 Optimizer hierarchy  One important aspect of query optimization is the transformation of one query into an equivalent query that might be more efficient to evaluate. The size of the search space of equivalent query plans for a snapshot query is determined in part by the algebraic equivalence available in the snapshot algebra. As we represent a temporal object as a time series that can     be thought of as the equivalence of a ?blob? object, the transformation rules in object algebra can directly apply. As our object algebra is also consistently extended from relational algebra, the relational algebraic transformation rules can directly apply. Now we identify the following transformation rules.

Relational rules  techniques in RDBs. They are called relational rules.

The following set of equivalencies is derived from well-known algebraic optimization  C,UC, =c2 uc, commutative law C,n C2 = C2 n C, commutative law CiD6 Ci=cj CI U c1= c, idempotent law C , n  CI=cI  idempotent law c,-c,=0 c1 u0= c, C 1 n O = O Ci D 6 0 G 0 c, -0= e, 0-c,=0  C]* c2 =e2 * CI  CI *( c2 * C3)* CI * C2)* c3 O P I  ( C I W 2  ) = b p i  C2UOPl c,  OPI (OP2 (Cl ) )=TP2 (OPl  (cl))= CP1.4 P2 (Cl)  ClDC c2 cc2 D C  c1  CiDG( c2 D 6  C3)qclDC C2)DQ c3  n A i ( c l W 2 ) = n A i C 2 u n A i  c1  commutative law commutative law associative law associative law  It is a good heuristic to push select, project and time-slice or offset as far down the query graph as possible, esp., to perform the time-slice as early as possible.

It has been identified some transformations are incorrect in general [14]: A selection can not be pushed through an aggregate operator or offset operator.

An aggregation operator can not be pushed through an offset operator and vice versa.

Path transformation rules In OODBs, select operation allows its predicate on a contiguous sequence of attributes along a  branch of the class-aggregation hierarchy. We use the path to express this sort of predicate and the     enhanced path expression to represent the path that includes the time references. For simplicity we suppose the time-reference occurs at the end of the path (even if it is not, it will only involve the looking up storage and will not provide any difficulty to the query optimization).

Generally speaking, the attribute/domain link between a class C and domain D of one of the attributes A of C creates the join between the class C and 0, in which the attribute A of the class C and identifier OID, which is defined by the system and which can be considered as an attribute of class D, are join attributes [l]. Therefore, an object query with a path expression involving N classes is equivalent to a relational query, which requires the join in N relations corresponding to N classes [ 11. This is why select operator is usually called an implicit join. According to the definition of our algebra, when the predicate of select involving a path expression is as path op value=CI.AI.A 2....AnrM op v, the equivalence between an implicit join and an explicit join is as  (CI )  = 7C (ci D Q P  7Z ( c 2 ) D U  '... D U P  ( C n ) )  (1) A i  C I  A I  A 2  A n r M  O p  U A ( C I )  We use D d  to represent the join that is slightly different from the join defined in our algebra in that the join attributes are the attribute Ai.] of the class Ci, and identifier OID of C,, if we join Ci.1 and Ci. The project specifies the query target.

If there is a complex predicate involving a single path such as P = CI AI op V I  and CI Ai.Az op v2 ... and CI.AI Az.. A, vn = Pi and Pz.. . and P,  then we have a general form 0 (c,) = n (cP,c1 D Q '  nAZaP2(cz )  D Q  '... D Q '  a p n ( C n ) )  (2)  P(C8 A I  A i  A I C , )  where Pi is optional that can be omitted if it does not exist, P, involves both time and value dimensions, and the first project specifies the query target.

The way to visit the path introduces a path traversal operator. The Linear path traversal operator is a navigational operator N-op[Cl.A 2....A, T'] to execute the implicit join along a path. It is equivalent to a set of joins as in equation (2):  N - o p [ C i  A I  A2 . A , , " ]  = O P , C i  D U P  0 ( C ? )  D Q P . . . D 4 P  O P n ( C , , )  (3) A ?  P ?

According to the associative law in previous subsection, the above linear path traversal operator can be further rewritten into the following form:  N-op[Cl AI A1 A,!'"] =N-op[C] AI  A, - I ]  bap c (C,) =N_op[Cl.Al A2 bU c,, (4)  0 ( C , )  = z A ( C , i ( N - ~ p [ C I . A l  _ . _ _ .  A . ]  D Q  C , )  (5)  " ' - ' ]Cm-#  A=OlD(C,,)nPn  Thus  C n - i  A = o l D ( c " , n P "  P ( C I  A I  A 1  i  Fig. 5 A sample path  temporal queries  . . . . . . . . . . . . . .

.... ...-. ...

. .

Fig. 6 A operator graph  Fig. 5 is a single path with n classes. Fig. 6 gives an operator graph (OG) for equation (5 ) that involves such a single path. An OG is a labelled n-ary tree where the leaf nodes represent collection of objects, the non-leaf nodes represent operators (e.g., join, navigational operator, etc.), and the edges represent temporary collections that can be represented by support tables     [4]. A support table can be regarded as a collection of tuples of qualified object identifiers and attributes. Two support tables can be joined together if there exists a common supported collection between them. The execution of an OG follows bottom-up order.

In order to processing temporal queries, we have assumed a temporal class is at the end of a path. Therefore the evaluation of the enhanced path can be initially decomposed by dividing the path into two parts: a sub-path with time-referenced class and an ordinary sub-path (without time-stamped classes) that can be further divided into sub-paths.

The decomposition strategy for processing temporal queries can be further illustrated in Fig. 7. A complex user query with path expressions that involves time-references is first translated into a set of single path expressions. A single path is then divided into two sub-paths: a sub-path containing a time-stamped class that can be optimized by making use of the ordering information of temporal data and an ordinary sub-path that can be further decomposed and traversed using different algorithms.

The intermediate results of traversed two sub-paths are joined together to create the output query. Fig. 7 A decomposition strategy  5 Processing temporal query components  The block B in Fig. 6 consists of temporal predicate evaluation (as well as time-series processing) and a join, which can be further expressed in Fig. 8. As temporal data provide more opportunities for optimization [7, 141, temporal optimization comes into play at this stage. When optimizing such a query, the object optimizer takes charge of the outer query block, and the temporal optimizer operates on the nested query block. Each optimizer is responsible for its own query blocks.

5.1 Time-related operations and optimization  Predicate evaluation in Fig. 8 involves the time-related operation and value evaluation. Temporal operations such as time-slice, offset, aggregation can be treated as methods and its output can then participate in the value evaluation. Temporal optimizer must be sure to ?plan? the evocation of function and make use of the ordering information for optimization. Stream processing approach is a strategy for optimization utilising the ordering information of data [7, 141.

5.2 Join  Let C and D represent the supporting tables or the intermediate results of block A in Fig. 6 and B? in Fig. 8, as shown in Fig 9. There are various join algorithms to join C and D together. The advantage in representing it as an explicit join is that we can use well-known join algorithms to perform optimization. Here a temporal object stands as a ?blob? object that can be treated as an ordinary object in a snapshot OODB. Two basic types ofjoins are: forward join and reverse join.

Forward-Join (FJ) The idea of FJ can be informally presented as follows [l]. Given a pair of classes C and 13,  such that D is the domain of an attribute A of C, the values of that attribute A are identifiers of     the instances of class D. If classes C and D are in this order, in a given permutation, the join between these classes is obtained by the following operations:  F o r c i n C d o begin retrieve c.A  a. .............. B ................

OID(d)=c.A $ A  is single-valued C "  ;  / ,  ,,-:;,, i g g r z g  a l l 0  n. u p p o r t  l a b l e  f b l o c k  A retrieve d in D such that t c  ............................ OID(d)ec.A $ A  is multi-valued; evaluate the predicate on d end sub-path  Fig. 8 Further decomposition of temporal  Implementation of forward join can integrate pointer-chasing with well-known join algorithms for optimization, such as pointer-based nested loops, pointer-based sort-merge and pointer-based hybrid-hash, etc.[ 151.

If, however, the permutation involves retrieving the instances in class D before the retrieval of the instances in C, then the following reverse join schema will apply.

Reverse-Join (RJ) The idea of RJ can be informally presented as follows [ 13.

f o r d  in D do  retrieve u=OID(d); evaluate the predicate on d retrieve c in C such that c.A=u i f A  is single-valued u ~ c . A  i f A  is multi-valued; end  begin @  & Z Fig. 9 Join between block A and block B'  As there is no direct link from D collection to C, a value-based join must be used to check the OID membership condition. This algorithm is efficient when the predicate in the last collection is selective. It performs value-based comparisons of OIDs, which is generally inefficient on a CPU [4]. Again, the implementation can employ relational algorithms of nest- loop join, sort-merge join, etc.

6 Conclusions  In this paper, we present a uniform framework for processing temporal object-oriented queries.

The temporal data model presented is of a hierarchical structure: it forms the relational-like cubes but with aggregation and inheritance associations, as it is evolved from the unified model of RDB and OODB that is in tum extended from the relational model. A query algebra, that is thereby defined to provide an access of objects through these associations of aggregation, inheritance and time-reference, possesses the property of reducibility, i.e., when the time-reference is not taken into account, it will be reduced to the object algebra that in tum will be reduced the relational algebra when the hierarchies of aggregation and inheritance do not exist. The hierarchical structure of data model and the reducibility of query algebra provide a basis to extend existing query processing and evaluation techniques for temporal object query processing. Query transformation can then be carried out based on a set of algebraic transformation rules identified. A strategy of decomposition is then proposed for processing temporal queries that involve paths. That is, evaluation of an enhanced path, which is defined to refer to the path with the time-reference, is decomposed by     initially dividing the path into two sub-paths: one containing the time-stamped class that can be optimized by making use of the ordering information of temporal data and another an ordinary sub- path (with no time-stamped class) which can be further decomposed and evaluated using different algorithms. The intermediate results of traversed two sub-paths are then joined together to create the query output. It has been shown that techniques developed for relational join, pointer-based join and sequential processing can be adapted to process the decomposed temporal query components. '4 temporal object is defined as a time series which can be treated as a function of time, that avoids thie complexity of a general temporal relational join. Temporal optimizer is built on the top of object optimizer, that requires less modification of object optimizer since the techniques of object-oriented query processing and evaluation as well as sequence processing can directly apply.

Future work will involve a detailed study of execution algorithms and cost analysis.

