On the Analysis of Evolution of Software Artefacts and Programs

Abstract?The literature describes several approaches to identify the artefacts of programs that evolve together to reveal the (hidden) dependencies among these artefacts and to infer and describe their evolution trends. We propose the use of biological methods to group artefacts, to detect co- evolution among them, and to construct their phylogenic trees to express their evolution trends. First, we introduced the novel concepts of macro co-changes (MCCs), i.e., of artefacts that co-change within a large time interval and of dephase macro co-changes (DMCCs), i.e., macro co-changes that always happen with the same shifts in time. We developped an approach, Macocha, to identify these new patterns of artefacts co-evolution in large programs. Now, we are analysing the evolution of classes playing roles in design patterns and?or anti-patterns. In parallel to previous work, we are detecting what classes are in macro co-change or in dephase macro co- change with the design motifs. Results try to show that classes playing roles in design motifs have specifics evolution trends.

Finally, we are implementing an approach, Profilo, to achieve the analysis of the evolution of artefacts and versions of large object-oriented programs. Profilo creates a phylogenic tree of different versions of program that describes versions evolution and the relation among versions and programs. We will, also, evaluate the usefulness of our tools using lab and field studies.

Keywords-Software evolution; co-change; phylogenic tree; stability; change impact

I. RESEARCH CONTEXT: SOFTWARE EVOLUTION The program should be maintained to keep their func-  tionalities along with the environment changes such as organisation changes, middle ware changes and so on.

Understanding the evolution of a program and its artefacts, is important from the points of views of both practitioners and researchers. For example, knowing that two artefacts co-evolve implies the existence of (hidden) dependencies between these two classes [1]. If these dependencies are not properly maintained, developers can introduce bugs.

We present approaches to provide knowledge concern co- evolved classes (clusters of classes exhibit similar evolution profiles, due to hidden interdependencies among them, not necessarily visible when examining their relations at the logical-design level [1]) and could help practitioners to realise their maintenance tasks without introducing bugs by maintaining co-evolution among these classes [2].

Thus, we introduce two novel concepts, namely macro co-changes, i.e., of artefacts that co-change within a large time interval, and of dephase macro co-changes, i.e., macro co-changes that always happen with the same shifts in time.

We analyse software evolution for different levels of abstraction (artefacts, groups of artefacts, and programs).

For example, we create a phylogenic tree from the different versions of a program to show their similarities and diver- gences to understand the subsequent versions of the program in a cost-effective way. Thus, researchers can draw informed conclusions about the the potential trends of artefacts and programs evolutions. Theses trends can help us to describe and identify the reasons that have driven the evolution of the program to its current state.



II. THESIS  Our thesis can be stated as follows: It is possible to infer and build models of the evolution and co-evolution of artefacts, motifs and programs? We want to group the classes in programs according to their evolutionary history to recognise and to understand their co-evolution profiles and, thus, help programmers plan future changes. In fact, we are introducing several concepts and approaches to present a complete evolution view from atrefacts to programs.

We introduced the novel concepts of macro co-changes and dephase macro co-changes to describe that two files were changed by developers within same change periods, with possible shifts in time. We describe, Macocha, an approach to detect (dephase) macro co-changes using file profiles and their stability in time. We detect what classes are in macro co-change or in dephase macro co-change and play roles in patterns and anti-patterns. Thus, we detect co- evolution dependency among groups of artefacts (e.g playing roles in design patterns). We analyse different versions of a program to trace their evolutionary history by phylo- genic tree. This tree shows commonalities and divergences between versions to facilitate the choice of a version, to acknowledge the contributions of the versions relative to each other and to assess more accurately the change impact in the program.



III. RELATED WORK  We present some major work on program evolution, con- cerning artefacts and programs evolution and co-evolution.

A. Artefacts Evolution  Many approaches exist to analyse artefacts evolution based on their relative stability. Lanza et al. [3] presented     an evolution matrix to display the evolution of the classes of a program. Each column of the matrix represents a version of the program, while each row represents the different versions of the same class. The authors presented a categorisation of classes based on the visualisation of different versions of a class. While UMLDiff [1] compares and detects the differences between the contents of two object-oriented program versions. UMLDiff is a heuristic- differencing algorithm used to extract the history of the pro- gram evolution, in terms of the additions, removals, moves, renamings, and signature-changes of design entities, such as packages, classes, interfaces, and their fields and methods.

These two approaches are limited in its usability because it does not detect change propagation among artefacts and it does not use information from software repositories (CVS and SVN) to identify co-evolving artefacts. Thus, we are introducing approaches to report artefacts evolution trends by using historical information and to link co-evolution and change impact.

Kpodjedo et al. [4] proposed to identify all classes that do not change in the history of a program, using an Error Tol- erant Graph Matching algorithm. Their approach identified evolving classes that maintain a stable structure of relations (association, inheritance, and aggregation) and, thus, that likely constitute the stable backbone of program. In fact, this approach detected differences in terms of classes with the existing version, without considering any requirements of users or new features introduced in the software. However, authors did not provide any explanation to support the question - why only classes are important rather than the additional features of a program? Thus, we are introducing approaches to analyse the evolution of different artefacts (including classes, files, design patterns, etc.) of a program and hidden dependency among them.

B. Co-change  The literature describes many approaches to extract and analyse the changes undergone by software artefacts and to infer trends that describe these changes to model program evolution [5], [6]. Several of these approaches identify co- changes among artefacts, e.g., [7], [8], which represent the (often implicit) dependencies or logical couplings among artefacts that have been observed to frequently change together [9]. Ying et al. [7] and Zimmermann et al. [8] applied association rules to identify co-changing files. Their hypothesis is that past co-changed files can be used to recommend source code files potentially relevant to a change request. An association-rule algorithm extracts frequently co-changing files of a transaction into sets that are re- garded as change patterns to guide future changes. Such algorithm uses co-change history and avoids the source code dependency parsing process. However, it only computes the frequency of co-changed files in the past and omits many other cases, e.g., files that co-change with always the same  period of time between changes. In [10], we showed that theses approaches miss interesting occurrences of co-change, so called macro co-change because, by their definition, they do not integrate the analysis of artefacts that are maintained by different developers and?or with some shifts in time.

German [11] used historical information to visualize what files are changed at the same time and who are the people who tend to modify certain files. He presented SoftChange, a tool that uses a heuristic based on a sliding window algo- rithm to rebuild the Modification Record (MRs) based on file revisions. In SoftChange, a file revision is included in a given MR if all the file revisions in the MR and the candidate file revision were created by the same author. Thus, SoftChange cannot detect co-changed file maintained in the same time by different developers. In [10], we presented Macocha to detect these missed co-changes.

C. Program Evolution Barry et al. [12] used a three-dimensional measure of  volatility to capture the amplitude (size), periodicity (fre- quency), and dispersion (consistency) of program changes.

They added another dimension, time, by calculating software volatility for some time periods (e.g., months) in a program.

A chronological vector was created for each program. Each vector has n entries, one for each time period (month) in the program?s evolution lifecycle. Their approach can be used for describing, analysing, and comparing the evolution of individual software programs. However, this method compare programs changes without analysing the code and? or the the type of changes. Evolution analysis is known to be more useful when combined with static analysis and change analysis than when used in isolation, because the most important (up-to-date) source of information in software maintenance and reengineering is the source code. Thus, in parallel to this approach, we are combining change analysis and static analysis to study programs evolution.

D. Limitations In software evolution analysis, the more important ques-  tion, for researchers and practitioners, is why artefacts and versions have changed and how they will be changed in the future? Existing approaches do not answer this question for different levels of abstraction (artefacts, groups of artefacts, and programs). One limitation of existing approaches is that they cannot detect (dephase) macro co-changes among artefacts that (almost) always happen with the same shifts in time. Existing approaches do not give us a complete evolution view from atrefacts to programs. Some approaches analyse stability and co-change but they have many limita- tions (based only on file names, without code analyses and? or change analyses, etc.).



IV. RESEARCH WORK We divide our research on three levels: artefacts (files,  classes, etc.), groups of artefacts (design patterns and anti-     patterns), and programs. For each level we have two stages: first we analyse the evolution trends. Second, we analyse co-evolution trends. Table I summarises the different stages of our research.

A. Artefacts Evolution and Co-evolution  We introduced the novel concepts of macro co-changes (MCCs) and dephase macro co-changes (DMCCs), inspired from co-changes and using the concept of change periods. A MCC describes a set of files that always change together in the same periods of time (of duration much greater than 200 ms). A DMCC describes a set of files that always change together with some shift in time in their periods of change.

We proposed an approach, Macocha, to mine software repositories (CVS and SVN) and identify (dephase) macro co-changing files. First, for each program, Macocha cal- culates the number of change periods by using the KNN algorithm. Then, for each file in a repository, it creates a profile (a bit-vector) that describes if this file changed or not in each change period. Finally, it identifies and reports (dephase, given some shifts s in time) macro co-changes.

B. Motifs Evolution and Co-evolution  In our proposal, a motif can be a design pattern or an anti-pattern. We are detecting classes macro co-changing or dephase macro co-changing in patterns and anti-patterns.

Results trend to show that classes plying roles in design motifs have specifics evolution trends.

C. Programs Evolution and Co-evolution  Co-evolving artefacts exist within evolving programs, which different version with new user requirements, bug fixes, and so on. Therefore, developers are also interested in the ?bigger picture?, e.g., the evolution of programs.

Thus, we are presenting a novel approach Profilo, to create a phylogenic tree (a reconstruction of the evolutionary story of the program) that describes the evolution of different versions of a program and the relation between them.

We are drawing inspiration from phylogenetics to study the evolution of versions of one program (species in phylo- genetics) based on information deduced from the evolution of classes (gene sequences). The study of phylogeny of programs could provide developers with a simplified but accurate picture of the programs in time to facilitate program understanding and to reduce errors during its evolution.



V. STUDIES  To support our research work, we perform empirical studies. In a first study, we compared the artefacts evolution analysis of Macocha with that of UMLDiff [1] and the co-change analysis of Macocha with association rules [7], [8] on four different programs: ArgoUML, FreeBSD, SIP, and XalanC, developed with three different programming languages, C, C++, and Java. We use external information  provided by bugs reports, mailing lists, and requirement de- scriptions to validate the MCCs and DMCCs not found using association rules to show that these MCCs and DMCCs explain real evolution phenomena. Thus, results showed that Macocha improved precision and recall of association rules, and also that it is able to detect new co-changing file sets useful to ease maintenance and reduce its costs. [10].

In a second study that we are performing on three Java programs, ArgoUML, JFreeChart and XercesJ. We are studying MCCs and DMCCs among classes playing roles in design patterns and anti-patterns to detect co-evolution models of theses classes.

In a third study that we are performing on four Java pro- grams, ArgoUML, JFreeChart, Rhino, and XercesJ. For each program, we create a phylogenetic tree, showing the inferred evolutionary relationships among various versions based upon their similarities and differences. The phylogenetic tree could be used to assess more accurately the contributions of the versions relative to each other and to report the most similar versions based on their common classes [13]. We use two existing tools PHYLIP1 and Phylodendron2 to draw the phylogenetic tree of a program. Figure 1 illustrates an example of a phylogenetic tree representing the evolution of ArgoUML.

Figure 1. Phylogenetic tree of ArgoUML showing the inferred evolutionary relationships among 18 versions  At this time of our thesis, we realised the first step of our method, the second and the third steps being in progress.

Our on-going work consists on building a complete tool to report evolution model of artefacts, of groups of artefacts  1http://evolution.genetics.washington.edu/phylip.html 2http://iubio.bio.indiana.edu/treeapp/treeprint-form.html     Table I LIST OF STAGES OF OUR RESEARCH (KNN: K-NEAREST NEIGHBOR ALGORITHM, DEMIMA: THE DESIGN MOTIF IDENTIFICATION MULTILAYERED  APPROACH, DECOR: THE DEFECT DETECTION FOR CORRECTION APPROACH, ETGM: ERROR TOLERANT GRAPH MATCHING ALGORITHM)  Input Algorithms/Tools Outpout Artefacts evolution Changelog files, source code Bit-vectors, Hamming distance stable artefacts, active artefacts Artefacts co-evolution Source code, active artefacts KNN MCC, Dephase macro co-change Motifs evolution Changelog file, source code DeMIMA, DECOR Evolution trends of motifs Motifs co-evolution Source code, active motifs Exact and approximate matching Co-evolving motifs Programs evolution Abstract syntax tree, source code ETGM Parsimony matrix of evolution Programs co-evolution Source code, parsimony matrix Phylogenic analysis Phylogenic trees for programs  (specially playing roles in design patterns and anti-patterns) and of different versions of programs.



VI. CONCLUSION  We introduced the novel concepts of macro co-changes and dephase macro co-changes to describe that two files were changed by developers within same change periods, with possible shifts in time. We describe, Macocha, an approach to detect (dephase) macro co-changes using file profiles and their stability in time.

We presented also an approach, Profilo, to analyse the evolution of artefacts in object-oriented programs and to trace the evolutionary history of these programs.

The concepts of co-evolution and phylogenic tree helped us describe and identify the reasons that have driven the evolution of the program to its current state. Understanding the exact developers motive can never be accurate. However, Profilo allows developers to review and explore evolution and co-evolution among artefacts and they can draw in- formed conclusions about the maintenance task and the potential motive for the program evolution.

Work-in-progress aims at (1) replicating our studies with other programs, (2) performing a comprehensive study of the number of MCCs and DMCCs with varying values of t and s (especially dependent on the analysed programs), (3) identifying MCCs and DMCCs among design patterns and antipatterns, (4) relating MCCs and DMCCs with static analysis and external software characteristics, such as change proneness, and (5) identifying and merging different sort of phylogenic tree based on other artifacts. Future work also includes a comparative study of the different sets computed by Macocha and associations rules with different value of confidence and support other than the values reported in [8].

