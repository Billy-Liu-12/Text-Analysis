THE STUDY OF ASSOCIATION AGORITHM BGL BASED ON BINARY  SYSTEM AND ORIENTED GRAPH

Abstract: The actuality of current algorithms in mining association  rule is analyzed in this paper. A new algorithm, based on binary and graph, is put forward. The main idea and realization project of the algorithm are introduced detailed here. Then, the new algorithm having improved the efficiency of mining rules is proved by comparing the performance of all kinds of algorithms.

Keywords: Association rules;Data mining; Binary system; Graph  1 Introduction  Association rule was first introduced by R.Agrawa1 and is the important part of KDD studies?-?]. Association rule mining is one of the technologies that be most studied in data mining. Its task is to find out the association relations between properties of the objects in database. We can complete the formalization description as follows  (1) Given a transaction database D(ID,I). Where ID is the index of customers, I={il, ..., i ,,, } is the set of all the goods;  (2) The transaction T is the set of goods which customers have bought, namely, T c I. After a customer Idk has completed a transaction, database D will add a transaction Tk;  (3) For a subset X of 1, if XC T, then we call the transaction T include X;  (4) The association rule ?X 3 Y?is a implication, where X c I, Y c I, -and X n Y=@. X is precondition, Y is conclusion.

(5) Support S ( X I  =-, where X C  I, X.count is number of ID in transaction database. ID1 is the total number of ID in transaction database (the time of transaction).

S ( X n Y )  - (XnY).count (6) Confidence C(X 2 Y)= S(X) - X.count ?  whereXG1, Y c I ,  X n Y < = I ; (7) In the practical application, the association rule  X Y shows statistical knowledge, namely, if the min-support and min-confidence has been given, then S  ( X  n Y )  >= min-support, S ( X )  >= min-support, C(X 3 Y)>=min-confidence ;  The problem of association rule mining can be divided into the following two sub- question^[^"^:  (1) Among the transaction database D, to find out all itemsets which are larger than or equal to the min-support appointed by customer. The itemset which meet the min-support is called max-itemset. The support of a itemset is the number of the itemset.

(2) Using the association rule that was required by max-itemset production, for each max-itemset A, to find out all its non-empty subset a. If support(A)/support(a)>=min-confidence, then a=>(A-a).

support(A)/support(a) is the confidence of the rule a=>(A-a).

In fact, the first problem is the central problem in the whole execution course of mining association rule. After find all the maitemsets ,  the corresponding association rules will be produced easily.

Many effective association rule algorithms have been developed by now. Among these, the two algorithms Apriori and Fptree have represented two different methods of receiving the selected sets. Performance of a lot of algorithms is all standard with these two kinds of algorithms.

The last several sections of this paper have been organized like this: Section 2 analyzed the key thought of above two algorithms; section 3 provides the main idea of new algorithm, section 4 analyzes the performance of all these algorithm.

0-7803-7865-2/03/$17.00 02003 IEEE     rule  A->B  B->A D->A D->B A,D->B B,D->A D->A,B  2 The actuality of algorithm in mining rules  confidence  100%  100% 100% 100% 100% 100% 100%  Apriori is a algorithm which was put forward by R.Agrawal,etc. after they put forward the problem of mining association rules?4? ?I. Mining rules with multi-cycle method is a very famous algorithm in mining association rules currently. While Fptree (Frequent Pattern Tree) was introduced by Canadian professor Jiawei Han in 2000[6-71.

Its characteristic is to produce frequent set straightly, and does not produce selected set. These two kinds of algorithms have represented the thoughts of mining association rules in two kinds of different angles.

For Apriori, the basic idea of searching mix-itemset is as follows. The algorithm needs deal with the database for many steps. Step 1 : counting the appearing frequency of all itemsets that include one element easily, then finding out these itemsets whose support not less min-support, is calledl-dimension max-itemset. From step2, repeating disposing until having no max-itemset been produced. The circular process is: in step k, producing k-dimension candidate itemset according to (k-1)-dimension max-itemset, then searching database, getting itemset support of candidate itemset for comparing with min-support, so that achieving the k-dimension max-itemset. Using transaction databaseL7] as in table2-1, the mining process of Apriori is showed in figure2-1.

Fptree algorithm puts forward a no-candidate-itemset mining method. It takes a kind of branch tactic: compress the database which provides frequent itemset into a frequent pattem tree (FP-tree), but keeping itemset associated information still; then divide the database which has been compressed into a set of condition database (a kind of projective database with especial type), and mining each database respectively. For example, the integral  I B I  D 1 3 I-item frequent set  item  3-item fequent set  FP-tree of the transaction database based on table2- 1 produced is shown in figure2-2. At the condition of having.

been given a support threshold, we can get a simpler FP-tree such that given a support threshold 50%, K6 will be cut.

We scan the database for the first time, then we can get the support number of every item {A,B,C,D,E,K}.

Arrange them in a decreasing order by support number. The result is written L. Then we get L={A1:4, B2:4, D4:3, C3:2, E5:2, K6:1], a set of one- frequent-itemset. The concrete step of constructing FP-tree as figure2-2 is as follows: construct the root node marked with ?null?. Scan the database for the second time. Then we deal with the items of each affair set in the order of L (in a decreasing order by support number), and construct a branch for every affair.

For example, the first affair: ?T100, KADB?, including 4 items (1, 2, 4, 6) by the order in L, lead to the first branch  (1: 1) , (2: 1)  , (4: 1) ,(6: 1) ,where 1 connect with rood node, 2 connect with 1, 4 connect with 2, 6 connect with 4. Similarly, deal with other affair in the same way. We should notice that a share prefix should be use between all paths, such as ?T200,DACEB? produce a path < l ,  2 , 4 ,  3 , 5>, it should share <1,2> with the first branch, and add up the number of node.

For facilitating to pass all over the tree, we set up a node list in order to each item can point to a node in tree through node list. The tree that was gotten after scanning all the affairs in database is a FPtree. Thus, the problem of frequent pattem mining of database has been transformed into a problem of FPtree mining.

Figue2- 1 Apriori algorithm diagrammatize      Table2-1 Example transaction dataset  TID 1 Items-List TI00 I {K, A, D, B) T200 I {D, A, C, E, B} T300 T400 1 {B, A, D}  1 {C, A, B, E}  3 algorithm BGL based on binary system and oriented graph  The efficiency of above two algorithms is not high in actual mining. This because that the shortcoming of Apriori algorithm is: (1) since needing scan database many times, the consumption of time is so large. And because that the larger data source is always used, scanning database must lead to a higher requirement in time and in space. (2) The number of candidate sets maybe far greater than the nu,mber of requent sets. In spite of scanning times being decreasing greatly in Fptree algorithm which being faster than Apriori algorithm by one order of magnitude, FP-tree is a structure needing an enormous space to store. FP-tree is unpractical if database is very large. That using recursive way in the key step of the description of the algorithm must lead to an enormous consume in space at some conditions.

Using the binary method to profess transaction information and producing frequent items with the idea of oriented graph, the writer has designed a kind of high-efficient algorithm BGL (Binary Graphic Largeset) .

The main idea of BGL is: Let?s suppose I={i,, i2, &....in) is a set of transaction  database. The recorders of the database is made up of several affairs that are denoted as T={tl, tZ, t3. .... t,,,}, where ti={xlxc I}. At first, we give a define3.3.

Let the transaction code of one transaction data is: trans= (yn*2n+yn.12n-1+yn-22n-2+. . . ..+y12I} (3- 1)  where i=l . . .n.

Thus, every transaction code of transaction data can be expressed a binary number whose length is the number of projects. For example, the transaction data of project C in table2- 1 is ?01 10?.

. . .sk} is showed as sup={ the number of 1 in B, where B= y I ~ y2 A . . . A yk}. Here, A is the logical and operation of  It can be easily concluded that the support degree of transaction code sup can denote rightly the frequency of projects appearing in same time. The (k-1)-item subset of any a k-item frequent item must be frequent item. So, if we look every (k-1)-item frequent item as a path between (k-1)  if ti includs s i? 0 if ti does not includ s Yj= The support of any a itemset S={slf s2,  binary system. (3-2)      relative nodes in the graph which regards all items as nodes, k-item frequent item must be the new path which is formatted by adding an edge on the last k-1 nodes? path.

Among a itemset S={sn, s ? - ~ ,  ... sl}, the position number of any of a item si P=i.

The item graph G(S, L) of a itemset is a oriented graph which takes all items as vertex. Where S={sI, s2, ... sk}, L={a set of all edges v Iv=(u, e), if and only if u, e c  S and  (3-3)  sup(u, e)>min-support, P(u)<P(e)} (3-4) The progress of BGL algorithm is as follows: (1) Scanning database, achieving the transaction data  of every item, and cutting items according to min-support to produce I-item frequent set;  (2) Constructing the item graph of transaction dataset of that method is as follows: comparing the supports of every two items, we add an orient edge between this two nodes if their supports are not less than min-support. The current item graph shows straightly the information of 2-item frequent set;  (3) Producing the k-item frequent set according to item graph as long as (k-1)-item frequent set is not empty.

Repeating this process until k-item frequent set is not empty. The method is as follows: for any a (k-1)-item frequent set {sl, s2, . . . ~ k - ~ } ,  finding out the item whose position number is the largest. Examining that whether item graph existing edges pointing to other nodes. For all nodes which edges point to, computing their sup(s1, s2, ..&-I , s,). If they are not less than min-support, they form a k-item frequent set (SI  SZ, . . s k - 1 ,  s,).

The correctness of BGL is proved as followed: Proof 3.1: (1) Firstly, we prove the completeness of the searching  method, namely, this method can find out all k-item frequent sets without omission.

The node which is pointed to by s,, the item whose position number is the largest, is what the algorithm will examine. Let?s suppose that it exist a item s, whose position number is smaller than s, It and (k-1)-item frequent set(sl, s2 , ... s,,,} can form a k-item frequent set, {SI , s2 7  Since any subset of a frequent set must be a frequent set, we know that { s l ,  s2, ... si ... s,,,-~} must be a (k-1)-item frequent set, {sml, s,} being a 2-item frequent set. For the item s , -~ whose position number is the largest in the (k-1)-item frequent set, it must exist a oriented edge pointing to s,. So this frequent set will be get in the deriving of {si , s2, . . . S ,  . . . S,. 1 } .

(2) Secondly, we prove the correctness. That to say, only the item nodes whose position numbers are largerthari that of s,, and which exist oriented edges, can form k-item  . . .SI.. . s,} .

frequent set.

Because all the pointed nodes s, of s, are based on  b=sup(s,, sJ, sup(s,, sI, sj) I b being right for any item s, that knows from the character and operation in binary system.

So we need only consider nodes whose b meet min-support.

The description of BGL: Algorithm 3-1: BGL Input: a transaction database (D), a min-support  Output: a largest itemset (Largeset) which meet the  Algorithm: (1) Scanning the database for the first time to produce  item list and transaction data, we cumulative add a 2? for transaction data of every field of every recorder, remaining the order of an item list. At last we cut items according to support.

(2) Let?s comparing the transaction data of every two Items a and b in turn. If the number of 1 in the result of a A  b is greater than support threshold, it can produce a 2-item frequent set and an oriented edge. The direction of the oriented edge is from smaller position number object to larger one.

(3) Then we pass every the last item of every k-item frequent set. If it exists a edge pointing to other node, let?s examine whether can form a (k+l)-item frequent set after adding this node. A (k+l)-item frequent set will be produced if the condition is met.

Let?s take the transaction dataset case in table2-1 for example, too. After the first scanning database, a structure as in fig3-1 is produced.

After getting the transaction data table and the item graph in stepl, deriving frequent mode is transformed a process as follows: all the items in every (k-1)-item frequent set form a path in the graph. We select the last node on this oriented path. We know from the deriving in proof3.1 that we need only searching the nodes which this node point to. If the k-item oriented path which is formed after adding this node is still a frequent item of meeting support, a frequent item is find out.

The table 3-2 is the item graph produced after the first scanning database. It is also a 2-item frequent set because that the produce condition of each oriented edge is just the condition of 2-item frequent set. On this base, take (A1 , C3 ) for example, viewing the largest position number item C3, it exists a edge pointing to E5 only. So only (A1 , C3, E5 may be produced. Computing sup( 1 1 1 1 A 0 1 10 A 0 1 10) =sup(O110)=2. It meet support, and produce a 3-item frequent set.

(minsup)  min-support     Proceedings of the Second lnternational Conference on Machine Learning and Cybernetics, X'an, 2-5 November 2003  A1  Item list  binarv 1111 A1 B2 D4 c 3  4 1 4 2 3 3 2 4  1 Binarv transaction arry 1  t B2 1111 c 3  0110 D4 101 1 I E5 K6  000 1 E5 1 2  Figure 3-1 Item list and binary transaction data produced by Bgl algorithm scaned database   Figure3-2 Item graph produced by Bgl algorithm scanning database  K6 1 1  algorithms in mining associated rule  The analyzing and comparing of all kinds of   Apriori algorithm produces a higher frequent set by inter-combination in frequent items which have been found with transcendental knowledge. Let's suppose that the transaction number of a database is n, the largest transaction item number is m. The transactions of all items are same under an ultra circumstance. This must lead to produce (2"-2)-item rules. Subtracting 2 means taking out (D and the circumstance which all transactions are the right of rules. Under this circumstance, we must scan database for m times in order to get every frequent set. We need to  compare for c:, * n times in the ist canning database. So it's totally n2" times comparison is needed at this condition.

The complexity in time is O(n2m). Here needs much additional space to store every frequent set. The number of  the is' frequent set is c, in the worst conditions. So 2" additional space is needed. The complexity in space is O(2"'). Under the other circumstance, each of all the  i  transaction is not same. That to say, there is on the same elements in any two transaction. This lead to that any 2-item frequent sets can not be produced. Scanning database is being needed only once. The number of times of comparison is mn. So the complexity in time is O(nm).

Since it is only 1-item frequent set that is produced, we need only m additional storage space. So the complexity in space is O(m).Fptree algorithm records frequent mode with tree. Likewise, we suppose that the transaction number of a database is n, the largest transaction item number is m. The transactions of all items are same under an ultra circumstance. Fptree scans database only for twice. When achieving the support at the time of scanning database for the first time, mn times comparison is needed. Scanning database for the second time is used to create the structure of tree that needs mn times. So, it's totally 2mn times comparison is needed at this condition. .The complexity in time is O(nm). We need totally m list elements and m tree nodes to be created under this circumstance. So the complexity in space is O(m).Under the other circumstance, each of all the transaction is not same. That to say, there is on the same elements in any two transaction. Fptree scans database still for twice. 2mn times comparison is needed.

Timc complexity  Space complexity  Time complexity  Space complexity  So the complexity in time is O(nm) now. Since all the items of every recorder are not same, the storage space of m list elements and mn tree nodes is needed. Here the complexity in space is O(mn).BGL algorithm reduces successfully the times of scanning database to 1. It denotes information of items in all transactions with binary system, and denotes the relations between frequent sets with a item graph. With the increasing of the path between items, it searches frequent sets by using transcendental knowledge time after time. The using of binary system simplifies greatly the structure of representing database knowledge. BGL  Apriori Fptree Bgl  O(n2?) O ( m )  O(mn)  ?(2??) ?(m) ?(n)  O(m)  O ( m )  O(m)  O(m) O(m)  O(n)  Table3-2 Complexity compared in upwards association rule algorithms  _ _ All the Recorder Values are same  All the rccorder values are not same  algorithm is fit for the circumstance which the number of items is smaller than that of transactions.

The complexity analysis of BGL algorithm: Likewise, we suppose that the transaction number of a  database is n, the largest transaction item number is m. The transactions of all items are same under an ultra circumstance. Bgl scans database only for once, too. When achieving the support at the time of scanning database, mn times comparison is needed. So, it?s totally mn times comparison is needed at this condition. The complexity in time is O(nm). Here needs any additional space to store every frequent set. The storage space of n binary elements is needed. The complexity in space is O(n).

Under the other circumstance, each of all the transaction is not same. That to say, there is on the same elements in any two transaction. This lead to that any 2-item frequent sets can not be produced. The times of scanning database are still once. Thus, mn times comparison is needed. So now, the coniplexity in time is O(nm). Although items of each recorder are all not same, because of binary array remaining all the transaction information, it needs only the storage space of m binary number. Here the complexity in space is O(n).

We has comDared comdexitv in saace and in time of  above several algorithms. The result is shown as table3-2.

It can be concluded that Fptree algorithms has improved the time complexity to O(mn). While the new algorithms is mainly to reduce space complexity to O(n).

5 Conclusions  This paper has analyzed the status quo of associated rules in data mining and the problems and difficulty in existence emphatically. In associated rules, it is based on transcendental knowledge that is Apriori algorithm mining data. But it needs scanning database for many times, the consumption of time being large. Fptree algorithm stores information of transaction relation with tree-like structure.

It reduces the time complexity but having added the additional operation to maintain the tree structure. The author puts forward a method of using binary and graph to abstractive rules. A high eficiency algorithm BGL is given to mining data more efficient. It is be proved that the new algorithm is high efficient by analyzing the complexity.

