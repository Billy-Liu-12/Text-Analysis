Discovering Frequent Poly-Regions in DNA Sequences

Abstract  The problem of discovering arrangements of regions of high occurrence of one or more items of a given alphabet in a sequence, is studied, and two efficient algorithms are pro- posed. The first one is entropy-based and uses an existing re- cursive segmentation technique to split the input sequence into a set of homogeneous segments. The key idea of the second approach is to use a set of sliding windows over the sequence.

Each sliding window keeps a set of statistics of a sequence seg- ment that mainly includes the number of occurrences of each item in that segment. Combining these statistics efficiently yields the complete set of regions of high occurrence of the items of the given alphabet. After identifying these regions, the sequence is converted to a sequence of labeled intervals (each one corresponding to a region). An efficient algorithm for min- ing frequent arrangements of event intervals is applied to the converted sequence to discover frequently occurring arrange- ments of these regions. The proposed algorithms are tested on various DNA sequences producing results with significant biological meaning.

1 Introduction In cells, DNA forms long chains made up of four chemical  units known as nucleotides: adenine (A), guanine (G), cyto- sine (C), and thymine (T). In these DNA chains or sequences, a number of important, known functional regions, at both large and small scales, contain a high occurrence of one or more nucleotides. We will refer to these as ?poly? regions (for ex- ample, a region that is rich in nucleotide A, is called poly-A).

Such regions include: ? Isochores (multi-megabase regions of genomic sequence)  which are specically GC-rich or GC-poor. GC-rich iso- chores exhibit greater gene density.

? CpG islands (regions of several hundred nucleotides rich in the dinucleotide CpG). The level of methylation of the cystine (C) in these dinucleotide clusters has been asso- ciated with gene expression in nearby genes [12, 11, 13].

? Protein binding regions (tens of nucleotides long), where dinucleotide, or base-step composition, can contribute to  DNA flexibility, allowing the helix to change physical conformation, a common property of protein-DNA inter- actions [24, 19, 14, 18].

Despite the importance of ?poly? regions, their algorith- mic identification and study has received only limited atten- tion. One family of segmentation algorithms employ statistical methods based on: (1) the Maximum Likelihood Estimation (MLE) of the segments, which is computed for the segments, given a restriction on their minimum length [12]. A dynamic programming approach has been introduced in [3] that com- putes the global maximum, whereas [2] proposed an exten- sion where there is no restriction on the segment size, (2) the hidden Markov chain model, proposed in [8, 9] to model the segmentation of DNA sequences and predict the locations of possible segments in mitochondrial and phage genomes, (3) the walking Markov model, which is a continuously varying stochastic process. Also, [10] examined the base composition of human and E.coli genomes and analyzed the phenomenon of strand symmetry.

Simultaneously, there have been studies on similar prob- lems, called ?change-point problems?, that were applied to DNA sequence segmentation [7, 6, 5]. The basic form of the multiple change point problem assumes that there exists a set of points in a sequence where the distribution of the sequences changes. They first determine how many change-points exist in a sequence and then find their locations.

Another family of DNA segmentation algorithms includes those that work in a hierarchical manner. In particular, they employ a recursive segmentation of DNA sequences, where at each stage a split point is chosen based on a specific cri- terion, e.g. the Jensen-Shannon Divergence [13, 19]. Such algorithms have been proposed in [4, 13, 19] and their main focus was to find domains in DNA that are homogeneous in base composition or more specifically in C+G content. More- over, in [15] it is shown that there are many other applica- tions of the recursive segmentation algorithm to the analysis of DNA sequences, such as detection of isochores (large ho- mogeneous C+G domains), CpG islands (small homogeneous CG domains), etc. Last but not least, a sliding window ap- proach with fixed size window has been applied to the human genome [18, 14] to detect G+C-rich regions and CpG islands.

0-7695-2702-7/06 $20.00  ? 2006    To the best of our knowledge, most current approaches tar- get specific compositions (mainly G+C-rich or CpG islands).

Furthermore, there have been no studies on any relations that may occur between these regions. In this paper, we propose two general approaches to finding any type of ?poly?-regions in DNA, and apply an efficient mining algorithm to extract frequent patterns between those regions.

In this paper: (1) we formally define the problem of detect- ing regions of high occurrence of a literal or set of literals in a sequence, (2) we propose two efficient algorithms to solve the problem, (3) we further apply an efficient arrangement mining algorithm to extract the complete set of frequent arrangements of these regions, (4) we provide experimental evaluation of our algorithms by testing their efficiency on the dog genome.

2 Problem Formulation A sequence S = {s1, s2, ... , sm} is an ordered list of  items, where each si belongs to an alphabet ?. In the case of DNA sequence, each si corresponds to a nucleotide base and thus ? = {A, C, G, T}, where A stands for Adenine, C for Cytosine, G for Guanine and T for Thymine.

A High region or H-region is a segment of S, where there is a ?high occurrence? of one or more items of ?. Let Hd,k = {I, pstart, pend} denote an H-region of k items with density d, that starts at item spstart and ends at item spend . I is a set of items that works as a label for the H-region and is determined by the k dense items in the H-region. Also, spstart ? I and spend ? I. An H-region Hd,k has density d, if each of the k items occurs in the region with a frequency of at least d/k %.

d is the minimum % in the segment of the items in I . Given a density threshold min density, an H-region Hd,k is dense if d ? min density. Consider for example the two H-regions in Figure 1; (1) H80,1 = {{A}, 5, 14}: in this case we have a region of ?high occurrence? of nucleotide A with density 80%, (2) H80,2 = {{A, C}, 20, 29}: in this case we have a region of ?high occurrence? of nucleotides A and C, where each one has a density of 40%. Notice that the density is meaningful for small values of k. In the case of DNA, k should either be 1 or 2, i.e. if a region has a high occurrence of all four nucleotides (or of three) then the occurrences are rather random and have no particular meaning. Note that the terms ??poly?-region and H-region are synonyms and are used interchangeably in this paper.

Given two H-regions Hd,k1 = {I1, p1start, p1end}, Hd,k2 = {I2, p2start, p2end}, the merging of Hd,k1 and Hd,k2 is a new H-region Hd,k12 = {I12, p12start, p12end}, with p12start = min{p1start, p2start}, p12end = max{p1end, p2end}, and I12 = I1 = I2. Notice that merging is only allowed when I1 = I2 Also, an H-region Hd,k1 = {I1, p1start, p1end} is said to be contained in another H-region Hd,k2 = {I2, p2start, p2end}, if p2start ? p1start, p2end ? p1end, and I1 = I2. A dense H-region Hd1,k1 is maximal, if there exists no H-region H  d2,k  such that d2 ? min density and Hd1,k1 is contained in Hd2,k2 .

AACAAGAAAA AACAATCGCC  5 14 20 29  (1) (2)  Figure 1. Example of two H-regions.

Problem Statement: Given a sequence S = {s1, s2, ..., sm}, a density constraint d, a minimum window size min win, a maximum window size max win and a support thresh- old min sup, we want: (1) to discover the complete set HS of maximal H-regions in S, where each region Hd,k = {I, pstart, pend} has density of at least d and size |Hd,k| = pend ? pstart + 1 ? [min win,max win], and then (2) given HS and a support threshold min sup, extract the complete set F of frequent arrangements of H-regions in HS .

3 Extracting H-regions We present two approaches for extracting the set of H-  regions in a sequence of items that belong to a given alpha- bet. The first approach is entropy-based and uses an existing recursive segmentation technique to split the input sequence into a set of homogeneous segments applying measures of divergence (in our case the Jensen Shannon Entropy) during the segmentation, whereas the second one implements a set of sliding windows over the sequence.

3.1 Recursive Segmentation  The idea of recursive segmentation based on a measure of divergence has been used in earlier works, [4, 13, 19], and [15] describes how it can be applied to DNA for detection of G+C-rich regions and CpG islands. In this section we present an approach that applies the standard recursive segmentation algorithm used previously targeting any type of ?poly?-region.

The main difference in our approach is that the recursive seg- mentation does not use the standard s0 [4] stopping criterion; instead, the recursion stops when the size of a segment drops below max win.

The input sequence is recursively segmented, ensuring that the homogeneity difference (in our case the entropy) between the segments is maximized. To define the homogeneity differ- ence between two segments, an appropriate measure ? is used.

There is a variety of measures that can be used for the segmen- tation process, like the quadratic divergence (QD) [19], the Jensen-Shannon Divergence (JSD) [13], the Gini-Index, etc.

In this work, we use the Jensen-Shannon divergence.

The target of the segmentation is a set of regions, where, in each region, the Jensen-Shannon Entropy is maximized.

To achieve that, the input sequence is recursively segmented and each time a split point is chosen where the JSD value be- tween the two segments is maximized, i.e. the distributions of the items in the two segments have maximal JSD value from each other. The recursive segmentation stops when it reaches a segment of size from min win to max win. The final seg-  0-7695-2702-7/06 $20.00  ? 2006    mentation includes a set of regions of the desired size that are candidates for being H-regions. Through a sequential scan, each segment is checked whether it satisfies the density con- straint and it is further expanded both ways until the density constraint is violated.

To improve the efficiency of the segmentation we apply a preprocessing step, which has been proposed in [15] for the detection of isochores. When looking for H-regions of two nucleotides, say nucleotide A and G, the original sequence is transformed to a new sequence that consists of only three types of literals: those that correspond to nucleotides A and G, and those that do not (represented by literal X). For example, S = ACAAAGCGA will be converted to S? = AXAAAGXGA.

The benefit of this replacement is the following: consider a subsequence that is being split by the algorithm. If a high occurrence of two types of nucleotides occurs in one of the subsequences, its entropy will be larger than that of the other subsequences, since all nucleotides of different type (than the two frequent ones in the first sequence) are represented by one literal. Also notice that the above replacement improves the runtime of the algorithm, since the alphabet size is reduced, achieving faster entropy calculations.

3.2 Sliding Windows  The key idea behind this approach is to use a set of slid- ing windows over the input sequence. Each sliding window keeps statistics of a segment that mainly include the number of occurrences of each alphabet item in that segment. Com- bining these statistics efficiently produces the complete set of H-regions in the sequence.

More formally, our algorithm is given a sequence S, a den- sity factor d, a minimum window size min win and a max- imum window size max win. The first step is to define a set of sliding windows W . Let W = {w1, w2, , ... , wn}, where wi corresponds to sliding window i and n = |W| = max win ? min win + 1. Each sliding window wi is a triple {Ci, wistart, wiend}, where Ci is a set of statistics for wi, wistart is an index to the starting position of w  i on S and wiend is an index to the ending position of w  i on S. Ci is a set of t counters {C1, C2, ..., Ct} one for each item in ?.

The value of each counter is the number of occurrences of the corresponding item in the window. Moreover, the piece of S covered by W is stored at each time instance. Given this set- ting, at any time, we can extract the top k frequent items in each window.

The next step is to identify the set of H-regions using W .

Particularly, all the windows defined in W will be sliding si- multaneously. Conceptually, the above setting can be seen as having M = max win ? min win + 1 levels of windows, one for each size. At any time instance, we check the statistics stored under each window in W . If a set of items in a win- dow wi is found to satisfy the density constraint, then wi is reported as an H-region. In parallel, we keep a list L of the H-regions discovered so far. Each record in L corresponds to an H-region label and points to a list of all the H-regions discovered so far with this label. Upon discovery of a new  H-region we insert it into L based on its label.

Notice that at each step we do not need to check all the win-  dows. Instead we can start with the window of maximal size and prune some of the smaller windows. More specifically, the value of each counter in a large window is an upper bound for the value of the corresponding counters in the smaller win- dows in W . Let the number of items of type c in wi be N ic .

Then c is dense in wi, if N  i c  |wi| ? d. Hence, the maximum size of the window were these items (of type c) can fit and fulfill  the density constraint is N i c  d . Based on this observation, we can start with the maximum window and then apply the bound on each counter. This indicates which windows of the lower levels should be searched for a candidate H-region for each item.

The sliding window approach makes sense when the alphabet size is small, which holds for the application this paper is focused on, i.e. the DNA alphabet size is only four.

4 Discovering Frequent Arrangements of H- Regions in a DNA Sequence  Next, we apply an efficient algorithm [17] for mining fre- quent arrangements of H-regions on a single input sequence of event intervals.

4.1 Background Let E = {E1, E2, ..., Em} be an ordered set of event inter-  vals, called event interval sequence or e-sequence. As seen previously, each Ei is a triple (ei, tistart, tiend), where ei is an event label, tistart is the event start point and t  i end is the end  point. The events are ordered by the start point. If an occur- rence of ei is instantaneous, then tistart = t  i end. An e-sequence  of size k is called a k-e-sequence. If the first event interval in an e-sequence of size m starts at point t1start and the last event interval in the e-sequence ends at point tmend, then the width of the e-sequence is equal to tmend ? t1start + 1.

An arrangement A of n events is defined as A = {E , R}, where E is the set of event intervals that occur in A, with |E| = n, and R defines the pairwise relations between the event labels in E . The size of an arrangement A = {E , R} is equal to |E|. An arrangement of size k is called a k- arrangement. Given an e-sequence s, s contains an arrange- ment A = {E , R}, if all the events in A also appear in s with the same relations between them, as defined in R. Extending [17], we consider seven types of relations between two event intervals shown in Figure 2. Using these relations, general arrangements can be defined.

4.2 The Algorithm in Detail Given an e-sequence S, the algorithm uses a sliding win-  dow w of size win to scan the whole e-sequence. w is ini- tially placed at the beginning of the e-sequence and includes the first win event intervals (in our case H-regions) of S. The window keeps sliding to the right (one event interval per slide) until it reaches the end of S, i.e. its right end includes the last event interval of S, for the first time. Based on this for-  0-7695-2702-7/06 $20.00  ? 2006    A[t start  , t end  ] B[t start  , t end  ]  (a)   Meet of A and B  A[t start  , t end  ]  B[t start  , t end  ]  (d)  A[t start  , t end  ] B[t start  , t end  ]  (g)  Contain of A and B  Follow of A and B  +/- e  A[t start  , t end  ]  B[t start  , t end  ]  (e)  Left Contain of A and B  A[t start  , t end  ]  B[tstart, tend]  (f)  Right Contain of A and B  +/- e +/- e  A[t start  , t end  ]  B[t start  , t end  ]  (c) Overlap of A and B  A[tstart, tend]  B[tstart, tend]  (b) Match of A and B  +/- e+/- e  Figure 2. Basic relations between two event-intervals.

mulation, a total of W = |S| + win ? 1 windows is defined over the sequence. The frequency of an arrangement A is de- fined as the fraction of windows in which A occurs. Thus, given A and a window of size win, the frequency of A is: freq(A, win) = |{w|A occurs in w}||W| .

The algorithm uses the arrangement enumeration tree structure, introduced in [17], which is traversed in a DFS manner. The discovered arrangements are stored in a list L, along with their frequencies. In each window w, the set of arrangements contained in w is identified, and the list of active arrangements L is updated. If a new arrangement is found, it is inserted into L with support value 1. If an arrangement already exists in L, its frequency is increased by one. The complete set of frequent arrangements is determined by scanning the whole sequence and by increasing the support of each arrangement by one, for every window in which it occurs. Eventually, the complete set of frequent arrangements of H-regions in S is produced, by extracting those arrange- ments in L with support that satisfies the minimum support threshold.

5 Experimental Evaluation Our datasets were obtained from NBCI  (http://www.ncbi.nlm.nih.gov), that includes sequence records and map data generated at NCBI or used in NCBI resources. The files in this directory provide assembled sequences for the chromosomes of the reference assembly.

For our experiments, 39 chromosomes (including the X chromosome) of the organism Canis familiaris (dog) have been used. Before applying our algorithms, the input DNA sequences have been pre-processed to remove the runs of Ns. Eventually each sequence followed alphabet ? = {A, C,G, T}. The experimental evaluation is divided into two phases. In the first phase, our algorithms have been applied to 39 chromosomes and have been compared in terms of runtime and accuracy. In the second phase, we applied the mining algorithm described in Section 4 to extract frequent arrangements of H-regions on 3 chromosomes (1, 2 and 38).

A  C  A,G  T  C  G  C  T  65%  56%  69%  A  41%  A  C  A, G  T  C  G  C  T  63%  72%  66%  A  56%  C  G  T  52%  Chromosome   Chromosome   Chromosome   G  T  C,G  T 42%  A  53%  Chromosome Arrangement Arrangement Support in  %  Support in  %  Figure 4. A sample of the Extracted Set of Frequent Arrangements for Chromosomes 1, 2 and 38 of the Canis Fa- miliaris.

5.1 Extracting H-regions The following factors have been considered: (1) size of the  input sequence, (2) density of the H-regions, (3) size of the minimum and maximum windows.

Regarding runtime, the basic observation was that the slid- ing window approach outperformed the recursive segmenta- tion approach both in small and large window ranges and den- sity values. In Figure 3, we show the performance of each algorithm with regard to the density factor, which has been varied from 40% to 80%, on Chromosome 1 (approximately 127 million bases).

As far as accuracy is concerned, the sliding window ap- proach finds the complete set of H-regions because it does exhaustive search. The recursive segmentation approach had poorer performance but did not drop below 85% in accuracy.

This was expected, because the recursive segmentation, might choose split points inside some H-regions, and especially at the early segmentations when the segments are large. The accuracy of the recursive segmentation varies between 85% and 90%, performing slightly better in small sequences (Chro- mosome 38) and slightly worse in larger sequences (Chromo- somes 1 and X). We also tried the recursive segmentation without the sequence conversion described in Section 3.1 and the performance dropped by an average of 15%.

5.2 Extracting Frequent Arrangements  Finally, the mining algorithm, described in Section 4, has been applied to the extracted H-regions to detect frequent arrangements between them. Specifically, the algorithm has been applied on the extracted H-regions of Chromosomes 1, 2 and 38 of the Canis Familiaris. The size of the sliding win- dow was 1000. We managed to extract an interesting number of frequent patterns. In all three cases a great number of over- laps and contains has been detected between H-regions of C and G. These regions are in fact the G + C-rich ones, and the CpG islands. Figure 4 gives a sample of the frequent arrange- ments that have been extracted for Chromosomes 1, 2 and 38 of the Canis Familiaris.

By and large, an interesting number of arrangements was  0-7695-2702-7/06 $20.00  ? 2006             Density in %  R un  tim e  in s  ec on  ds  Chromosome 1 ? Win [8,32]  Sliding Window  Recursive Segmentation           Density in %  R un  tim e  in s  ec on  ds  Chromosome 1 ? Win [18,64]  Sliding Window  Recursive Segmentation  (a) (b)  Figure 3. Results on Runtime Comparison: (a)Runtime Performance of the Two Algorithms for Chromosome 1 of the Canis Fa- miliaris, with window range [8,32].; (b)Runtime Performance of the Two Algorithms for Chromosome 1 of the Canis Familiaris, with window range [18,64].

detected for these Chromosomes, with the minimum support threshold varying from 60% to 40%. Chromosome 38 gave the greatest number of arrangements despite the fact it was the smallest (in length) chromosome examined. The size of the extracted arrangements was limited between two and three.

Note that in the above experiments the size of H-regions was in the range [18, 64]. When the algorithm was applied to smaller H-regions (of size [8, 32]): (1) the number of arrangements increased, (2) there was a significant increase in the number of relations of type follow, which is expected, since the smaller the size of event intervals, the greater the chance of a follow to occur.

6 Future Work Some directions for future research include: (1) improve-  ment of our algorithms to be able to work efficiently for larger alphabet sizes, (2) application of our algorithms to proteins, and (3) application of the mining algorithm to multiple DNA and protein sequences aiming the detection of arrangements of H-regions that occur frequently in these sequences.

