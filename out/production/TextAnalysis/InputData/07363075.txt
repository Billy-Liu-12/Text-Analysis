An Optimization to CHARM Algorithm for Mining  Frequent Closed Itemsets

Abstract?Frequent itemsets which are quite useful in many applications always suffer from their huge number and information redundancy. Frequent closed itemsets that provide a minimal and lossless presentation of all frequent itemsets are a solution to the problem. In past years, frequent closed itemsets mining (FCIM) has been extensively studied and many effective FCIM algorithms have been proposed. CHARM as one of the most famous FCIM algorithms is easily extended and applied due to its understandable and commonly used structure. However, CHARM faces a memory-inefficient challenge since it needs to maintain all closed itemsets in the memory to check if an itemset is closed or not. In this paper, we introduce a new method of identifying nonclosed itemsets with strict proofs and propose algorithm NEWCHARM, an optimization to CHARM for mining frequent closed itemsets that is more memory efficient. Moreover, we also prune the nonclosed itemsets timely in the search process so that the search space is reduced and with some optimized operations adopted, our algorithm also runs faster. Finally, experiments are conducted to compare NEWCHARM against CHARM on six datasets from two aspects in memory usage and execution time and the results show that our algorithm outperforms CHARM.

Keywords?data mining; frequent closed itemsets; memory efficient; fast; CHARM

I.  INTRODUCTION Frequent itemsets are those sets of items that occur in at  least a user-specified number (min_sup) of transactions. They reveal associations and correlations among items in large transactional database which can help to make many business decisions. Frequent itemsets mining (FIM) is a method used to find such itemsets and it has been extensively studied since it is an important and essential problem in the field of data mining. Many FIM algorithms have been proposed in the past years, such as the basic FIM algorithm Apriori [1], FP-Growth [2] and other variations to such algorithms [3]. However, such algorithms may fail to find all frequent itemsets since the number of frequent itemsets may be huge when database has long itemsets or min_sup threshold is set low. Besides, the huge number of frequent itemsets leads to information redundancy and makes subsequent analysis difficult.

Frequent closed itemsets which provide a minimal representation of all frequent itemsets without losing their support (i.e. the number of transactions an itemset occurs in)  information are a solution to the problems described above.

An itemset is closed if there is no superset has the same support as it. Hence, we can see that frequent closed itemsets can be orders of magnitude fewer than frequent itemsets especially on dense database which has long itemsets.

Therefore, the frequent closed itemsets mining (FCIM) problem has also been extensively studied in the past years and many efficient FCIM algorithms have been proposed [4, 5, 6, 7, 8, 9].

CHARM as one of the most famous FCIM algorithms is easily extended and applied [10, 11, 12, 13] due to its understandable and commonly used structure which is also information-completed that contains both itemsets space and transactions space. For instance, classical FCIM may still generate many itemsets unrelated or uninteresting to users especially in specific applications where users have their own constraints. Constraint-based itemsets mining which pruning useless itemsets based on constraints during mining is thus wildly used and it usually adopts itemsets search space which always generated by a prefix-based tree structure to guide the search process and prune itemsets timely [14, 15, 16, 17].

Hence, it is likely to choose CHARM as a basis algorithm for constraint-based FCIM due to the IT-tree structure it uses is actually a prefix-based tree structure leave aside the tidsets.

Unfortunately, CHARM faces a memory-inefficient challenge since it needs to maintain all closed itemsets mined so far to check whether a newly found itemset is really closed or not although it utilizes diffsets optimization and it is easily run out of memory and thus leads to failure when the database is huge. In this paper, we propose an optimization to CHARM which we call NEWCHARM to solve the memory-inefficient problem, i.e. we can assure every itemset we generate is closed without keeping the whole set of closed itemsets in the memory. Moreover, with nonclosed itemsets pruned timely, our algorithm?s search space is smaller compare to CHARM and with some optimized operations, our algorithm also runs faster. Specifically, our contributions in this paper can be list as follows:  - We introduce a new theoretical method to identify all nonclosed itemsets without keeping any closed itemsets in the memory and we also provide the strict proofs.

Dependable, Autonomic and Secure Computing; Pervasive Intelligence and Computing  DOI 10.1109/CIT/IUCC/DASC/PICOM.2015.33       - We propose algorithm NEWCHARM which is an optimization to CHARM for mining frequent closed itemsets that is more memory efficient and faster. Besides, we prove our algorithm is correct and provide some optimized operations for reducing work and time.

- We evaluate our algorithm NEWCHARM with CHARM on six datasets from aspects in memory usage and execution time. Results corroborate that NEWCHARM is more memory efficient and runs faster.

The remaining paper is organized as follows. Section II introduces related work and Section III describes our new method of identifying nonclosed itemsets. Then in Section IV, we propose our algorithm in detail. Section V shows the experimental evaluation and analysis. Finally, Section VI makes conclusions.



II. RELATED WORK  A. Frequent Closed Itemsets Mining (FCIM) We denote database of transactions as D and the set of all  distinct items appearing in D as I. Each transaction is represented by a set of items and we always give the transaction a unique identifier tid. A set X ? I is called an itemset and let t(X) be the tidset of X that is the set of tids contained X and ?(X) be the support of X where ?(X) = |t(X)|.

X is frequent if ?(X) ? min_sup, the user-specified minimum support value and X is closed if there is no superset Y ? X with ?(X) = ?(Y).

FCIM always uses closure operation, generator and equivalence class concepts in the mining process. We first define i(Y) as the itemset included in all transactions belonging to the tidset Y while t(X) defined before as the tidset the itemset X occurs in. The closure of itemset X, denoted c(X), is defined as c(X) = i ? t(X) = i (t (X)). With the definition of closure operation, we can see that X is closed if and only if c(X) = X. A generator is an itemset that can determine a closed itemset, that is, an itemset Y is a generator of the closed itemset X if c(Y) = X (note that there may be more than one generator of a closed itemset). Equivalence classes are defined as that all itemsets in one equivalence class have the same closure. There are several well known FCMI algorithms.

CLOSE [4] which was proposed by Nicolas Pasquier et al.

is an Apriori-like algorithm to mine frequent closed itemsets with two steps. The first step is to identify all shortest generators using bottom-up search technique. The second step is to compute the closure of all the generators found before to get the whole frequent closed itemsets.

CLOSET [5] is an efficient FCIM algorithm proposed by J.

Pei et al. using frequent pattern tree (FP-tree) structure. FP- tree is a compressed representation of all transactions in the database. CLOSET first constructs an FP-tree in the memory and then recursively builds conditional FP-tree projections and uses a depth first search strategy for all trees to mine all frequent closed itemsets.

Another novel tree structure called IT-tree was designed by Zaki et al. to perform a new FCIM algorithm CHARM [7].

CHARM searches all frequent closed itemsets over IT-tree and uses 4 properties to skip many levels of the tree.  Finally, a fast hash-based approach is used to remove remaining nonclosed itemsets. Besides, Zaki also proposed a technique called diffsets to reduce memory usage of CHARM.

DCI_CLOSED [8] presented by Claudio Lucchese et al. is known for its fast and memory efficient features. It excludes nonclosed itemsets without the need of storing the whole set of closed itemsets. DCI_CLOSED recursively generates a new generator based on a closed itemset building before and then computes the closure of it to get a new closed itemset after the generator is checked to be not duplicated. The closed itemsets generated by DCI_CLOSED do not follow any order which authors think is an advantage for splitting the problem and solving it in parallel.

To sum up, algorithm Close suffers from high cost of the closure operation and both Closet and CHARM is not memory-efficient since they both need to store all closed itemsets in the memory. DCI_Closed algorithm is fast and memory efficient, but its disordered and unfixed search process makes it difficult to apply and extend. Therefore, we chose to optimize the algorithm CHARM since the very structure it uses is understandable and commonly used.

B. Algorithm CHARM 1) Itemset-Tidset tree (IT-tree)   D              Fig. 1. Example of a transactional database and corresponding Itemset-Tidset tree   (a) Transactional database   (b) Itemset-Tidset tree (IT-tree)       IT-tree is a complete search space defined by Zaki in [7]. It is such tree that every node on it represented by an itemset- tidset pair e.g. X ? t(X) where X is an itemset1. The whole IT- tree is constructed by all frequent itemsets with the common organization that all direct children of a node X are generated by combination of X and other nodes coming after it according to a total order and thus all children of this node share the same prefix X.

Here is an example of IT-tree shows in Fig. 1 in which (a) shows an example of a transactional database and (b) shows the corresponding IT-tree with the value of min_sup is 1.

2) Algorithm  design CHARM builds the IT-tree and searches over it. Since lots of itemsets on IT-tree are not closed, CHARM utilizes 4 properties to skip many levels of the tree so that it can compress the search space. Let Xi and Xj be any two itemsets and X = Xi ?  Xj, then the 4 properties are showed in the following and related proof can be found in [7].

? If t(Xi ) = t(Xj ), then c(Xi ) = c(Xj ) = c(X)  ? If t(Xi )?? t(Xj ), then c(Xi ) = c(X), but c(Xj )?	 c(X)  ? If t(Xi ) ? t(Xj ), then c(Xj ) = c(X), but c(Xi )?	 c(X)  ? If t(Xi ) 	 t(Xj ), then c(Xi )?	 c(Xj )?	 c(X)  In the last step, CHARM uses a fast hash-based approach to check if the remaining itemsets on the IT-tree are closed or not.

1 We also use the itemset X to denote the node for simplicity so that the itemset and the node can replace each other.

It utilizes a hash table to save all closed itemsets mined so far with the hash key of an itemset X is defined as the sum of numbers appeared in t(X). When checking a new itemset (all its children have been already checked), compute its hash key first and then retrieve all closed itemsets with the same hash key from the hash table. For each closed itemset C, check if ?(X) = ?(C). If yes, next check if X ? C. If still yes, then X is not closed and will not be added to the hash table.

Fig. 2 shows the pseudo code of CHARM algorithm and Fig. 3 shows the search process and corresponding IT-tree using CHARM on the example showed in Fig. 1 (the value of min_sup is still 1). Note that we use an increasing order of support as the total order f since it can get the best performance and the most concise IT-tree. But, not all remaining itemsets on this concise tree are certainly closed; itemsets under the dotted line in the Fig. 3 are checked to be not closed by the hash table.



III. METHOD OF IDENTIFYING NONCLOSED ITEMSETS Since CHARM is not memory-efficient due to the need of  saving all closed itemsets in the memory to check if an itemset is closed or not, we introduce a new method to identify all nonclosed itemsets in the search process and then we can prune them timely and safely so that the search space can be smaller and itemsets stayed are all closed.

An itemset is closed if there is no superset of it with the same support and on the contrary, an itemset is called nonclosed as long as there is one such superset exists.

Therefore, identifying a nonclosed itemset is to make sure there must be a superset of it with the same support. Since the IT-tree generated by CHARM (Fig. 3) has already excluded many nonclosed itemsets from the original tree (Fig.1 (b)), we will do our job based on this concise tree generated by CHARM and we will simply use IT-tree to denote it and the original IT-tree is still called original IT-tree without ambiguity in the following paper.

Theorem 1. In the IT-tree, all children of any one node are supersets of this node with supports not equal to it.

Proof. According to the constructing process of the IT-tree, all direct children of one node are generated by combination of the node and other nodes coming after it according to the total order f. Hence, that all children of any one node are its superset is obvious. Then we prove the supports of these supersets are not equal to the node by contradiction. Assume that there is a node X be a child of node Xi in the IT-tree with ?(X) = ? (Xi ). If X is a direct child of Xi , then there must be a node Xj that Xj ?f Xi and X = Xi ? Xj , since ?(X) = ?(Xi ? Xj ) = ?(Xi ), |t(Xi ? Xj)| = |t(Xi ) t(Xj )| = |t(Xi )| so that t(Xi ) ? t(Xj ) which matches property 1 or 2 and Xi will be replaced whichever is matched, that is, Xi do not exist and the hypothesis is not true. If not, we denote X?s direct parent as X? where X? is still a child of Xi and according to the former circumstance, ?(X) 	 ?(X?), besides, X? is a subset of X and a superset of Xi so that ?(X) ? ?(X?) ? ?(Xi ), that is, ?(X) ?(Xi ) and the hypothesis is not true. Overall, the theorem is proved.

Algorithm CHARM 1 procedure CHARM (D, min_sup) 2     [P] = { Xi ? t(Xi) | Xi  I and ?(Xi) ? min_sup} 3     Charm-Extend ([P], C = ?) 4     return C  // a hash table saving all closed itemsets 5 end procedure   6 function Charm-Extend ([P], C) 7     for each Xi ? t(Xi ) in [P] 8         X = Xi and [Pi] = ? 9         for each Xj ? t(Xj ) in [P] with Xj ?f Xi // f is a total order 10             X = Xi ? Xj and Y = t(Xi ) t(Xj ) 11             if (?(X) ? min_sup) then // 4 properties 12                if t(Xi) = t(Xj ) then 13                   remove Xj from [P] and replace all Xi with X 14                else if t(Xi ) ? t(Xj ) then 15                   replace all Xi with X 16                else if t(Xi )?? t(Xj ) then 17                   remove Xj from [P] 18                   add X ? Y to [Pi] with order f 19                else 20                   add X ? Y to [Pi] with order f 21             end if 22         end for 23         if ([Pi] 	 ?) then Charm-Extend ([Pi], C) end if 24         save X in C with related check 25     end for 26 end function  Fig. 2. Pseudo code of CHARM algorithm       According to Theorem 1, we can make sure there is no superset with the same support of a node in its children. So we need to find other supersets of the node somewhere else in the IT-tree. Theorem 2 gives us the direction. Before giving Theorem 2, we denote subtree X as a subtree rooted at node X and note that the order f is only defined among nodes that have a same parent or put another way, are in the same layer of the IT-tree.

Theorem 2. Given two subtrees in the IT-tree, subtree X and subtree Y with X ?f Y, then supersets of any itemset on subtree X must not exist in subtree Y, but conversely, there must be some supersets of some itemsets on subtree Y exist in subtree X if and only if the itemset X ? Y is frequent.

Proof. Consider the constructing process of the IT-tree, Y needs to combine with other nodes coming after Y to generate its children and since X ?f Y, Y will never combine with X so that X is not included in any itemsets on subtree Y. Thus, supersets of any itemsets on subtree X which must include X cannot exist in subtree Y. On the other hand, X will combine with Y to generate a child X ? Y of it and if and only if X ? Y is frequent, it will be conserved on the IT-tree, then there must be at least one itemset X ? Y on subtree X that is a superset of Y on subtree Y. Note that all nodes which Y can combine with can also be combined by X, so there may be some other supersets of other itemsets on subtree Y exist in subtree X. If X ? Y is not frequent, it will not be conserved on the IT-tree so that Y is not included in any itemsets on subtree X, with the same reason, supersets of itemsets on subtree Y cannot exist in subtree X.

Based on Theorem 2, we can know where all supersets of a node except its children must be on the IT-tree. That is what the Corollary 1 shows. In order to express clearly, we have two definitions defined before.

Definition 1. Given a node X on the IT-tree, the checkset of X is such set: for each node Xj on the path of the root of the whole IT-tree to the node X, we add Xi into the set where Xi ?f Xj and Xi ? Xj is frequent.

Definition 2. Given a node X on the IT-tree and its checkset, the checktrees of X are subtrees rooted at nodes in the checkset.

Corollary 1. Given a node X on the IT-tree and its checktrees, all supersets of X, except its children, must exist in the checktrees.

Proof. For each node Xj on the path of root to X, X must belong to subtree Xj. According to Theorem 2, X?s supersets excepts its children may exist in subtree Xi where Xi ?f  Xj and Xi ? Xj  is frequent but must not exist in subtree Xk where Xk ?f Xj or Xk ?f Xj but Xk ? Xj is not frequent. After all such Xj are enumerated, we get all such subtree Xi which all supersets of X except its children must exist in and note that all such subtree Xi are actually the checktrees of X.

Look at the IT-tree showed in Fig. 3 and consider the node BE. For each node Xj on the path ? ? B ? BE, we need to find corresponding Xi to get the checkset of BE. When Xj is ?, there is no corresponding Xi. When Xj is B, Xi can be A and when Xj is BE, Xi can be BC and BD. Then the checkset of BE is {A, BC, BD} and the checktrees of BE are subtree A, subtree BC and subtree BD, that is to say, all supersets of BE except BE?s children must exist in subtree A, subtree BC and subtree BD.

Since we just need to make sure a superset with same support of a given node exists rather than finding out the exact superset, we have no necessity to check every node on the given node?s checktrees one by one. In fact, we just need tidset of every node in the checkset to check if such superset exists or not which will be described in Theorem 3.

Theorem 3. Given a node X on the IT-tree and Xi is any node in X?s checkset, there must be a superset of X with the same support exists in subtree Xi if and only if t(X) ? t (Xi ).

Proof. If t(X) ? t (Xi ), then t (Xi ? X) = t (Xi ) ? t(X) = t(X), so ? (Xi ? X) = ?(X), that is, Xi ? X has the same support as X. Since X on the IT-tree, X is frequent and Xi ? X is also frequent. Xi ? X is a superset of Xi and we can learn from above that all supersets of Xi can exist only two places, children of Xi and checktrees of Xi . Note that checktrees of Xi locate before Xi which suggests that all nodes on the checktrees must contain some items that before all items in Xi , it is easy to know Xi ? X has no items before any items in Xi so that Xi ? X should be added to Xi ?s children. If such Xi ? X exists, then the theorem is proved. Otherwise, Xi ? X must be replaced or removed due to a property being matched in CHARM, that is, Xi ?  X may be corresponding Xi or Xj in property 1, Xi in property 2 or Xj in property 3 and whichever is matched, there must be a superset of Xi ? X with the same support that is still a superset of X exists in subtree Xi . If t(X) ? t (Xi ), then ? (Xi ? X) 	 ?(X), and even though there is a   Fig. 3. Search process and the IT-tree using CHARM       superset of X on subtree Xi , it must be Xi ? X or superset of Xi ? X which support is unequal to X.

So far we can identify a nonclosed itemsets on the IT-tree without keeping any closed itemset in memory. Moreover, we can safely prune the nonclosed itemset as far as we find it according to Theorem 4.

Theorem 4. If a node on the IT-tree is identified to be nonclosed, then all of its children must also be nonclosed.

Proof. If a node X on the IT-tree is nonclosed, then there must be a node Y which belongs to X?s checkset with t(X) ? t(Y). Let Xi be any child of X, then Xi is a superset of X so that t(Xi ) ? t(X) and note that subtrees which X belongs to are also Xi belongs to since Xi belongs to subtree X, thus, checkset of Xi must also include Y. With t (Xi ) ? t(Y), Xi is not closed either.

With Theorem 4, we can prune a nonclosed itemset timely so that all of its children will not be generated and checked which can make the IT-tree more concise and save more computational time. Someone may question that whether it will have an influence on checking another itemsets if prune nonclosed itemsets directly. The answer is no since if an itemset is not closed, there must be some supersets of it with the same support and at least one such superset is closed which can be conserved on the tree, then the nonclosed itemset can be checked by this superset.



IV. NEWCHARM: AN OPTIMIZATION TO CHARM Based on the method of identifying nonclosed itemsets  described above, we now present NEWCHARM, an optimization to CHARM for mining frequent closed itemsets that is more memory efficient and faster, with proof of its correctness, running example and some optimized operations.

A. The NEWCHARM Algroithm Fig. 4 shows the pseudo code of NEWCHARM algorithm.

From the pseudo code we can see that the whole algorithm consists of 3 parts, the first one is a simple but integral procedure called NEWCHARM which put its main functions into function newCharm-Extend (the second one), and the third one function exist-Superset is used by the function newCharm-Extend to do some checking.

Procedure NEWCHARM is simple but integral in which we just need to add all frequent items with corresponding tidsets into a set according to total order f where the set can be regarded as root ?'s all direct children, and then we call the function newCharm-Extend with parameters are the set and ? respectively to generate the whole IT-tree and write out all frequent closed itemsets.

Function newCharm-Extend is used to construct a node's all subtrees according to the total order f. After the node?s all subtrees are constructed, the subtree rooted at the node is also constructed. The function accepts two parameters, one is a set of the node?s all direct children with order f in it, the other checkSet is used to check whether or not a node is closed that can be inserted into the subtrees. For each node Xi in the set of the node?s all direct children, it combines with node Xj coming after it to generate a child X. If X is frequent, we first use 4 properties to check if or not X will replace Xi (include itemset  Xi in Xi ?s children) and even remove Xj for X is a superset of them with the same support so that they cannot be closed, if not, then we will insert X into the Xi ?s direct children after X is affirmed to have no superset with the same support in its checktrees using the function exist-Superset. After all such Xj are combined, all direct children of Xi (may be X) are generated and then recursively call the function newCharm- Extend to generate the Xi ?s (may be X?s) all subtrees. When all such Xi has been enumerated, the node?s all subtrees are constructed and the function ends.

Note that as soon as a subtree is constructed, the tidset of the subtree?s root will be added into the checkSet for checking nodes coming after the root and we do not need the root?s itemset according to Theorem 3. Besides, we just simply add all such Xi described in Definition 1 into a node?s checkSet without checking if Xi ?  Xj is frequent or not so that the checkSet in pseudo code is larger than the theoretical checkset  Algorithm NEWCHARM 1 procedure NEWCHARM (D, min_sup) 2     [P] = { Xi ? t(Xi ) | Xi  I and ?(Xi) ? min_sup} 3     newCharm-Extend ([P], ?) 4  end procedure   5 function newCharm-Extend ([P], checkSet) 6     for each Xi ? t(Xi) in [P] 7         X = Xi and [Pi] = ? 8         for each Xj ? t(Xj) in [P] with Xj ?f Xi // f is a total order 9             X = Xi ? Xj and Y = t(Xi) t(Xj) 10             if (?(X) ? min_sup) then // 4 properties 11                if t(Xi) = t(Xj) then 12                   remove Xj from [P] and replace all Xi with X 13                else if t(Xi) ? t(Xj) then 14                   replace all Xi with X 15                else if t(Xi)?? t(Xj) then 16                   remove Xj from [P] 17                   if exist-Superset (t(X), checkSet) = false then 18                       add X ? Y to [Pi] with order f 19                else 20                   if exist-Superset (t(X), checkSet) = false then 21                       add X ? Y to [Pi] with order f 22             end if 23         end for 24         write out Xi as a closed itemset 25         if ([Pi] 	 ?) then 26             newCheckSet = checkSet 27             newCharm-Extend ([Pi], newCheckSet) 28         end if 29         checkSet = checkSet ? t(Xi) 30     end for 31 end function  32 function exist-Superset (t(X), checkSet) 33     for each t(Xi) in checkSet 34        if t(X) ? t(Xi) then 35            return true 36        end if 37     end for 38     return false 39 end function  Fig. 4. Pseudo code of NEWCHARM algorithm       which can be optimized. Moreover, before recursively calling the function newCharm-Extend, it is necessary to prepare a new suitable checkSet since when recursive level is deepened, the size of checkSet monotonically increases for nodes belonging to more subtrees and when recursive call returns, the checkSet size is monotonically decreased.

There are two kinds of checking in the function newCharm-Extend, one is the 4 properties checking and the other is the checkset checking. The 4 properties checking checks a node from its children and if it is not closed, it will be replaced by its children. The checkset checking checks a node from its checktrees and it will not be inserted into the IT-tree if it is not closed. Since a node?s supersets exist in only two places, its children and its checktrees, our checking is complete so that all itemsets on the tree are closed and we write them out after the nodes are generated. Except these checking operations, the framework of the function is similar to algorithm CHARM which is always used by itemsets mining problems.

Function exist-Superset is used to make sure if there is a superset with the same support of a node in the node?s checktrees and is implemented according to Theorem 3. It accepts two parameters, one is t(X) which is the tidset of a node we need to check and the other checkSet is a set of tidsets of nodes in the node?s checkset, if t(X) is a subset of any tidset in checkSet, then the answer is true and else the answer is false.

B. Correctness of NEWCHARM In this section, we will prove the algorithm NEWCHARM  is correct. To be specific, we will prove that the IT-tree generated by our algorithm contains and only contains all frequent closed itemsets and we write out the itemsets only after the nodes are generated so that our algorithm enumerates all and only frequent closed itemsets.

Theorem 5. The IT-tree generated by algorithm NEWCHARM contains and only contains all frequent closed itemsets.

Proof. We will prove the theorem from the following two aspects and together they form a complete proof to the theorem.

1) The IT-tree generated by NEWCHARM contains all frequent closed itemsets.From above we can know that the original IT-tree is a complete search space which contains all frequent itemsets come from a given database and the IT-tree generated by NEWCHARM is different from the original IT- tree only because we prune some nodes from it. Looking at the pseudo code of NEWCHARM algorithm in Fig. 4, we prune node only at line 12, 14, 16 and we will not insert node if the condition at line 17, 20 is not satisfied. At line 12, 14 and 16, we prune node Xi or Xj since node X is a superset of it with the same support so that the pruned node is not closed. At line 17 and 20, if the condition is not satisfied, we will not insert the node X for there is a superset of X with same support in X?s checktrees so that X is not closed. Thus, all nodes pruned from the original IT-tree are not closed and put another way, the IT-  tree generated by NEWCHARM contains all frequent closed itemsets.

2) The IT-tree  generated by NEWCHARM only contains frequent closed itemsets. That is, the IT-tree generated by NEWCHARM contains no infrequent or nonclosed itemsets.

Since NEWCHARM just prune some nodes from the original IT-tree which contains all frequent itemsets, the IT-tree generated by NEWCHARM contains no infrequent itemsets.

Suppose there is a nonclosed itemset X on the IT-tree generated by NEWCHARM, it must have a superset with the same support in its children or its checktrees and wherever the superset is, it can be checked by the two kinds checking described above and then X is replaced or removed or even not inserted. Note that nodes on the first level of the IT-tree have no checkset checking since each node?s checkset checking is included in the 4 properties checkings of all nodes coming before it. Thus, the supposition is not true, the IT-tree generated by NEWCHARM contains no nonclosed itemsets.

Since we know the IT-tree generated by NEWCHARM contains and only contains frequent closed itemsets, we can get a frequent closed itemset as soon as a node is generated.

Note that a node we first insert into the tree is not fixed since it may be replaced or removed by 4 properties checking later.

Therefore, a node is generated or fixed only after it passes the 4 properties checking and we write out the itemset at the corresponding place so that we can enumerate all and only frequent closed itemsets, that is to say, our algorithm NEWCHARM is correct.

C. Runing Example We will show how NEWCHARM works by looking at the  example showed in Fig. 1 and the particular search process and corresponding IT-tree using NEWCHARM are illustrated in Fig. 5, where we still set min_sup to 1 and use an increasing order of support as the total order f for its best performance.

First of all, we find all frequent items and arrange them according to f to initialize parameter [P] as [?] = {A?1236, B?1246, C?1356, D?1457, E?1257} and then call the function newCharm-Extend with the other parameter checkSet = ? to construct all subtrees of ?, i.e. the whole IT-tree.

In the function newCharm-Extend with parameters are [?] and ?, we first process node A?1236, it will combine with other nodes coming after it in [?]. AB?126 is frequent and matches property 4 and since the checkSet is ?, it passes checkset checking and then we insert AB?126 into [A] as node A?s direct children. AC?136, AD?1 and AE?12 have the same   Fig. 5. Search process and the IT-tree using NEWCHARM       circumstance as AB, so we also insert them into [A] with order f. So far, [A] = {AD?1, AE?12, AB?126, AC?136} and node A is generated, we can write out A as a frequent closed itemset.

We then prepare newCheckSet which is a copy of current checkSet to recursively call the function newCharm-Extend with [A].

In the function newCharm-Extend with parameters are [A] and ? respectively, we still first combine AD?1 with other nodes in [A]. ADE?1 is frequent and matches property 2, so we replace all AD with ADE and then we combine ADE?1 instead AD?1 with other nodes. With the same reason, we still replace all ADE with ABDE and then replace all ABDE with ABCDE. At last, node ABCDE is generated, we write out ABCDE as a frequent closed itemset. Since [ABCDE] is ? which means that subtree ABCDE is finished, we add t(ABCDE) into checkSet. Secondly, we combine AE?1 with other nodes coming after it. ABE?12 is frequent and matches property 2, so we replace all AE with ABE. ABCE?1 is frequent and matches property 4, but it fails checkset checking since t(ABCE) ? t(ABCDE) which is in current checkSet so that we do nothing. So far, node ABE is generated and we write out it and note that [ABE] is ? which means subtree ABE is finished, so we add t(ABE) into checkSet. The remaining process of nodes AB?126 and AC?136 are then easily understood and we will not describe in detail. At last, subtree A is constructed and the function newCharm-Extend with [A] ends and returns.

We now come back to the function newCharm-Extend with [?]. Since subtree A is finished, we add t(A) into the current checkSet and then we process the remaining nodes in [?] which are similar with node A so that we will not detail them. At last, we get a whole IT-tree showed in Fig. 5 and write out all nodes on it as all frequent closed itemsets. Note that the IT-tree generated by our algorithm showed in Fig. 5 is much more concise than that generated by CHARM showed in Fig. 3.

D. Some Optimized Operations Compare to CHARM, our mainly time-consuming  operation is checkset checking. However, we have two optimizations for it to save work and reduce running time.

1) Removing useless nodes from checkSet. As mentioned above, for any node X, we simply add all such Xi described in Definition 1 into X?s checkSet without checking Xi ?  Xj is frequent or not. From Theorem 2 we know that if Xi ? Xj is not frequent, there is no superset with the same support of X in subtree Xi , that is to say, even if we add t(Xi ) into X?s  checkSet, t(X) ?  t(Xi ) so that t(Xi ) in checkSet is useless.

Moreover, all children of X still use t(Xi ) to do checkset checking which are also useless. Thus, we can remove all such Xi where Xi ? Xj is not frequent from the checkSet to save lots of work and reduce running time. It is also worth noting that the result of Xi ? Xj is frequent or not has already been get from the 4 properties checking of Xi since Xi ?f Xj so that we can reuse it.

2) Reusing results of parent inclusion check. Considering a node X on the IT-tree, X must passes the checkset checking since it is closed. That is to say, for each t(Xi ) in the X?s checkSet, t(X) ? t(Xi ) which means there must be some tids in t(X) not belong to t(Xi ). Obviously, the inclusion check can stop as soon as one such tid is found. If we do inclusion check according to an increasing order of tid, we can get a smallest such tid. Using this tid to divide the t(X) into two parts, part one is these tids that smaller than the tid so that the part one must be strictly included in t(Xi ). For each child of X, we still divide its tidset into two parts using the tid (the tid may not in its tidset), then its tidset?s part one is subset of X?s tidset?s part one since its whole tidset is subset of X?s tidset so that the child tidset?s part one is also included in t(Xi ). As we know, t(Xi ) also exits in the child?s checkSet which means that we still need to do inclusion check about the child?s tidset and t(Xi ). Since the part one of the child?s tidset is known to be included in t(Xi ), we can directly start from the tid which get from the result of its parent inclusion check rather than from the first one. Note that the deeper the node is on the IT-tree, the larger the tid that inclusion check starts from is so that we can save amounts of work and reduce much running time.



V. EXPERIMENTAL EVALUATION  A. Expriment Settings We implement our algorithm NEWCHARM in Java and  use a Windows 7 PC equipped with a 2.5GHz CPU and 3GB of RAM memory for the experiments. For performance comparison, we also code algorithm CHARM in Java. Six publicly available datasets which downloaded from http://fimi.ua.ac.be/data/  are used for the performance test.

They are chess, connect, mushroom, pumsb, pumsb_star, and T40I10D100K. The first five datasets are real datasets which were prepared by Roberto Bayardo from the UCI datasets and PUMSB and the last dataset is a synthetic database which were generated by the generator from the IBM Almaden Quest research group according to the website.

TABLE I.  CHARACTERISTICS OF ALL SIX DATASETS  Dataset #Trans  #All Items #Appeared Items Avg. Transaction length  Max. Itemset Length (min_sup) chess 3196 76 75 37 18(40%)  connect 67557 130 129 43 25(30%) mushroom 8124 120 119 23 21(0.1%)  pumsb 49046 7117 2088 74 22(60%) pumsb_star 49046 7117 2113 50 38(10%)  T40I10D100K 100000 1000 942 40 13(1%)       Table 1 displays the characteristics of all six datasets. It shows the number of transactions, the number of all distinct items, the number of distinct items appeared in the dataset, average transaction length and maximal itemset length with corresponding min_sup which is lowest in our experiments.

Obeserving last two columns of the table, we can know that the first five datasets are dense and the last one is sparse relatively.

B. Experimental Results 1) Results of memory efficiency We conduct experiments to show the memory usage of our  algorithm NEWCHARM and algorithm CHARM on the six datasets with different value of min_sup. Fig. 6 shows the results of comparison of NEWCHARM against CHARM in six plots for six different datasets respectively. As shown in Fig. 6, our algorithm NEWCHARM outperforms CHARM in                                                  Fig. 6. Memory usage of NEWCHARM and CHARM on the six datasets   (e)   (a)   (b)   (d)   (c)   (f)       aspect of memory usage whatever the dataset is and no matter how much the value of min_sup. In general, memory usage of CHARM goes up when lower the value of min_sup while memory usage of NEWCHARM is relatively stable. Therefore, when the value of min_sup is high, the memory usage of CHARM is low and the distance of two algorithms is small, but when the value of min_sup is low, the amounts of memory used by CHARM are several times of that by NEWCHARM  which means that our algorithm NEWCHARM is more memory efficient at a lower min_sup.

The reasons for these results are discussed in the following.

CHARM requires the huge number of frequent closed itemsets generated to be stored in the memory. Thus, the lower min_sup is, the more frequent closed itemsets there are so that the amounts of memory used by CHARM are increasing.

Besides, there are also some data structures need to be kept in                                                  Fig. 7. Execution time of NEWCHARM and CHARM on the six datasets   (a)   (c)   (e)   (b)   (d)   (f)       the memory to run the algorithm. Conversely, the memory usage of our algorithm NEWCHARM is independent of the number of frequent closed itemsets. Compare to the CHARM, the additional memory used by NEWCHARM is checkSet which is used to do the checkset checking. CheckSet is actually a set of nodes? tidsets and the size of the set is much smaller than the number of closed itemsets. Therefore, as long as we compress the storage of tidset, the memory usage of NEWCHARM is small and in fact, we use bitset to do that.

2) Results of time efficiency Experiments are also conducted to compare the execution  time of our algorithm NEWCHARM against algorithm CHARM on the six datasets with different min_sup which the results are showed in six plots of Fig. 7 respectively. From Fig.

7, we can see that on dataset chess, connect, pumsb, and pumsb_star, our algorithm NEWCHARM obviously outperforms algorithm CHARM for the execution time of CHARM rapidly grow when the value of min_sup is decreased although execution time of two algorithms are almost equal at a higher min_sup. On dataset mushroom, execution time of two algorithms are very close, but NEWCHARM is still slightly better. Dataset T40I10D100K is an exception for NEWCHARM since NEWCHARM performs better than CHARM at low min_sup but become slower at high min_sup.

We also explain the results described above in the following.

For dense datasets, the number of frequent closed itemsets can be orders of magnitude fewer than all frequent itemsets. This means many nonclosed itemsets can be pruned. Compared to CHARM, our algorithm NEWCHARM prunes nonclosed itemsets timely so that can save lots of work of generating other nonclosed itemsets and then pruning them again, thus, our algorithm runs faster. However, for sparse datasets, most itemsets can be conserved as closed itemsets, that is to say, in our algorithm, most itemsets need to do checkset checking but only few of them can be pruned. Thus, our algorithm does lots of useless work which is relatively expensive, that is why the NEWCHARM runs slower on the sparse data T40I10D100K.



VI. CONCLUSIONS In this paper, we studied algorithm CHARM and pointed  out its deficiency in memory consumption since it needs to keep all closed itemsets in the memory to check if an itemset is closed or not. We introduced a new method of identifying nonclosed itemsets with strict proofs and proposed our algorithm NEWCHARM for mining frequent closed itemsets that is more memory efficient. Moreover, since we pruned nonclosed itemsets timely, we reduced the search space. And with some optimized operations that reduce work and time, our algorithm also runs faster. The two enhancements of memory and time efficiency are corroborated by the experiments conducted on the six datasets from two aspects in  memory usage and execution time and we showed and analyzed them in the last part of the paper.

