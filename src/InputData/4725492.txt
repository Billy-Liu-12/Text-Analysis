Intelligent Structuring of Association Rules in Data Structure

Abstract  With the rapid development of society, more and more universities are applying Intelligence Tutor System (ITS). As we know that the discovery of associate rules plays a very important role in a ITS. In the paper, we present a method for structuring associate rules among knowledge points in Data Structure, which is based on Formal Concept Anal- ysis (FCA) considered an important Artificial Intelligence (AI) theory. A teacher (together with his/her students) first translates some related knowledge in Data Structure into a (binary) context, and then the procedure can automatically generate a corresponding concept lattice from which many interesting associate rules with 100% confidence can be ex- tracted. The concept lattice and the associate rules provide the students with a vivid knowledge view, which can make the students more easily understand the inherent connec- tions among knowledge. By using the method, we obtained a well teaching quality.

1. Introduction  Intelligence Tutor System(ITS) is one of successful ap- plications of Artificial intelligence. Nowadays, more and more universities are applying the ITS to the teaching ac- tivities of some courses such as Data Structure. Data Struc- ture is of fundamental important in the field of computer science, as every area in computer science depends heavily on some kinds of methods for processing all kinds of data types. Therefore, most of colleges related to computer sci- ence are instructing this course. One of the core tasks of teaching activities is to make the students more easily un- derstand the knowledge and to improve the teaching quality.

Rules among knowledge points are exactly a valid tool for this task, as they can provide the students with a research environment[1,2]. In addition, the discovery of associate rules plays a very important role in a ITS. In the paper, we present a method for structuring associate rules among knowledge points in Data Structure, which is based on the  theory of FCA. FCA is a valid formal tool for data analysis, and has already been applied to various fields such as In- telligent Tutor System(ITS)[3],knowledge interconnection [4], rules acquisition [5].

In order to take advantage of the theory of FCA in the teaching activities, we firstly must redescribe the knowl- edge in books in terms of the language of FCA. There- fore, our method mainly consists of two steps. In the first step, we translate the knowledge into a (binary) context. In the second step, we obtain the corresponding concept lat- tice from which many associate rules with 100% confidence can be extracted. In the paper, we focus on the second step, as the associate rules unfold some inherent connec- tions among knowledge points. For example, the current rule (?x)(Act(Reverse, x)? Act(S ize, x)) means that if any instance x of some data type can be described by ?Reverse? the same must be true for ?S ize?.

The remainder of this paper is as follows. Section 2 briefly introduces the notions of FCA. Section 3 discusses how to intelligently extract associate rules in detail.

2. Basic notions of formal concept analysis  The following is a brief presentation of the theory of for- mal concept analysis (FCA). Details may be found in the Wille?s book, which provides an extensive introduction to FCA [6].

A binary context R is a triple (G,M, I), where G and M are sets and I is a binary relation. The elements of G and M are called the objects and the attributes, respectively. For an object g and an attribute a, (g, a)?I means that g has the attribute a. A small context can be easily represented by a cross table(see figure 1), i.e, by a rectangular table the rows of which are headed by the object names and the columns headed by the attribute names. A cross in row g and column m means that the object g has the attribute m. A formal con- cept of such a context is a pair consisting of a set of objects (the extent) and a set of attributes (the intent) such that the intent consists of exactly those attributes that the objects in the extent have in common, and the extent consists of ex- actly those objects that share all the attributes in the intent.

2008 International Symposium on Computational Intelligence and Design  DOI 10.1109/ISCID.2008.137   2008 International Symposium on Computational Intelligence and Design  DOI 10.1109/ISCID.2008.137     Formally, a formal concept of a context (G,M, I) is defined as a pair (X,Y) with X ? G and Y ? M such that (X,Y) is maximal with the X ? Y ? I, namely, ?(X) = Y and ?(Y) = X, where ?(X) = {a ? M : ?r ? X((r, a) ? I} and ?(Y) = {r ? G : ?a ? Y((r, a) ? I)}. The hierarchical order of the concepts is formalized by (X1,Y1) ? (X2,Y2) : X1 ? X2(? Y2 ? Y1). The set of all concepts of a context R to- gether with the order ? is always a complete lattice, called the concept lattice of R and denoted by L(R).

Table 1. A simple binary context  st ud  en t  m al  e  fe m  al e  ev en  ag e  od da  ge  ta ll  de di  um  sh or  t r1 + + + r2 + + + r3 + + + r4 + + +  Table 1 consists of four student as its objects described by seven attributes such as male, evenage and short. The symbol ?+? in row r1 and column male means that the stu- dent r1 is male.

h HHHHHHHH  ????????h hh hh  h hh h  h?? ??  ?? ??  HH HH  HH HH  J J  JJ  ? ?  ??  ? ?  ??  J J  JJ  ?? ??  ?? ??  ?? ?  HH HH  HH HH  HH H  l l  l l  ll  , ,  , ,  ,,  ? ? ? ? ?  T T  T T  T  r1 r3 r4 r2  male shortoddage evenage female  tall medium  Figure 1. The concept lattice of Table 1  Figure 1 visualizes the concept lattice of Table 1 by a line diagram. In the line diagram of its concept lattice the name of an object g is always attached to the circle representing the smallest concept with g in its extent; dually the name of an attribute a is always attached to the circle representing the largest concept with a in its intent. This allows us to read the map I from the diagram because an object g has an attribute a if and only if there is an ascending path from the circle labeled by g to the circle labeled by a. The extent of a concept consists of all objects whose labels are below in the diagram and the intent consists of all attributes attached to concepts above in the hierarchy. For example, the con- cept labeled by the attribute male has {r1, r3} as extent, and {male} as intent; the concept labeled by the student r4 has {r4} as extent, and {female,evenage,short} as intent.

3. Intelligent structuring of association rules  In this section, we present a method for extracting as- sociate rules from knowledge points in detail. Our method consists of two steps. The firs is to translate some relevant knowledge points in Data Structure into a binary context, and the second is to obtain the corresponding concept lat- tice and extract associate rules from the concept lattice.

We mainly discuss the second step. Firstly, we present two concept lattice construction algorithms [6]. For a small context (G,M, I), we can use the first algorithm to generate the corresponding concept lattice.

Algorithm 1 Input: a small context R=(G,M,I), where M={m1, . . . ,mN} Output: the all concepts L(R) of R (1) T? G/?T is a set of extents ? / (2) For i=1 to n DO (3) For any T in T (4) T ? T ? ?(mi) (5) L(R)? {(T, ?(T )) : T? T }  The algorithm for the determination of concepts de- scribed above becomes awkward for larger contexts. There- fore, we can use the following theorem 1, namely, algorithm 2. For simplicity, we replace the finite set G consisting of n objects by the {1, 2, . . . , n}.

Theorem 1: The small concept extent larger than a given set X ? G is X ? i, where i is the largest element of G with X ?i X ? i and X ? i := ??((X ?{1, 2, . . . , i ? 1}) ?{i}), and X ?i X ? i ? i ? (X ? i ? X) and X ?{1, 2, . . . , i ? 1} = (X ? i) ?{1, 2, . . . , i ? 1}.

By using the above algorithms, we can obtain a corre- sponding concept lattice L(R) of a context R = (G,M, I).

From the concept lattice, we can extract some inter- esting rules. The basic idea is as follows: In L(R), if there is an ascending path from the circle labeled by a1 to the circle labeled by a2, then we can know that if an object g has the attribute a1 the same is true for the attribute a2, denoted by the following rule: ?g?G((g, a1)?I?(g, a2)?I). In order to avoid the redun- dance, we only consider such ascending paths with no other circles in them. Because the ? is transitive. For exam- ple, if there are the two rules ?g?G((g, a1)?I?(g, a2)?I) and ?g?G((g, a2)?I?(g, a3)?I), then we can obtain the rule ?g?G((g, a1)?I?(g, a3)?I). In addition, we can extract such rules with existential quantifier. For instance, if there does not exist an ascending path from the circle labeled by a1 to the circle labeled by a2, then we can know that there must exist an object g which has the attribute a1 but does not have the attribute a2, denoted by the following rule: ?g?G((g, a1)?I ? (g, a2)<I).

In order to illustrate our idea, we take the following     knowledge points in Data Structure into account. We redescribe an example described in the paper [7]. Specif- ically, we regard the six kinds of data types and the ten actions/operations as objects and attributes, respectively, that is, G={Set, List, Bag, Map, Tree, and Relation} and M={Reverse, Size, MemberOf, Head, Tail, ElementAt, NumOfOccur, RemoveDups, Root,and Leaves}, and define the binary I as a predicate Act(g, a), which is said to be true if and only if the action m?M applies to the instances of type g?G, and then we get a context, as shown in Table 2.

The corresponding concept lattice is shown in Figure 2.

Table 2. A context about data types  R ev  er se  Si ze  M em  be rO  f  H ea  d  Ta il  E le  m en  tA t  N um  O fO  cc ur  R em  ov eD  up s  R oo  t  L ea  ve s  Set + + List + + + + + + + + Bag + + + + Map + + Tree + + + + +  Relation + +  h  h h  h hh h  h?? ??  ?? ??  HH HH  HH HH  J J  JJ  ? ?  ??  ? ?  ? ? ?  J J  J J  J  ? ?  ? ? ?  J J  J J  J  J J  J J  J J  J J  J JJ  , ,  , ,  ,,  Bag List Tree S et,Map Relation  Size MemberOf  NumOfOccur RemoveDups Reverse  Head Tail  ElementAt  Root Leaves  Figure 2. The concept lattice of Table 2  From the concept lattice in Figure 2, we can extract the following rules, which either contains universal quantifier or contain existential quantifier.

The rules with universal quantifier are listed as follows:  (1) ?x(Act(RemoveDups, x)? Act(S ize, x)) (2) ?x(Act(RemoveDups, x)? Act(MemberO f , x)) (3) ?x(Act(NumO f Occur, x)? Act(S ize, x)) (4) ?x(Act(NumO f Occur, x)? Act(MemberO f , x)) (5) ?x(Act(Reverse, x)? Act(S ize, x)) (6) ?x(Act(Reverse, x)? Act(MemberO f , x)) (7) ?x(Act(ElementAt, x)? Act(Reverse, x)) (8) ?x(Act(ElementAt, x)? Act(NumO f Occur, x))  (9) ?x(Act(ElementAt, x)? Act(RemoveDups, x)) (10) ?x(Act(Tail, x)? Act(NumO f Occur, x)) (11) ?x(Act(Tail, x)? Act(RemoveDups, x)) (12) ?x(Act(Tail, x)? Act(Reverse, x)) (13) ?x(Act(Head, x)? Act(NumO f Occur, x)) (14) ?x(Act(Head, x)? Act(RemoveDups, x)) (15) ?x(Act(Head, x)? Act(Reverse, x)) (16) ?x(Act(Leaves, x)? Act(Reverse, x)) (17) ?x(Act(Root, x)? Act(Reverse, x))  These rules unfold the inherent connections among knowledge points in a fixed context. For instance, rule 1 means that if the action RemoveDups can be applied to any instance x of a data type the same is true for the action S ize.

These rules can be generalized the following rules:  (1) ?x((Act(NumO f Occur, x)?App(RemoveDups, x)) ?Act(S ize, x)?Act(MemberO f , x))  (2) ?x(Act(Reverse, x)?Act(MemberO f , x)?Act(S ize, x)) (3) ?x((Act(ElementAt, x)?Act(Tail, x)?Act(Head, x))  ?(Act(NumO f Occur, x)?Act(RemoveDups, x)? Act(Reverse, x)))  (4) ?x((Act(Leaves, x)?Act(Root, x))?Act(Reverse, x))  The rules containing the ? are listed as follows: (1) ?x(Act(Head, x) ? Act(Tail, x)) (2) ?x(Act(Root, x) ? Act(Leaves, x)) (3) ?x(Act(NumO f Occur, x) ? Act(RemoveDups, x)) (4) ?x(Act(ElementAt, x) ? Act(Tail, x)) (5) ?x(Act(S ize, x) ? Act(MemberO f , x))  The rules with existential quantifier are listed as follows:  (1) ?x(Act(S ize, x) ? ?Act(NumO f Occur, x)) (2) ?x(Act(MemberO f , x) ? ?Act(NumO f Occur, x)) (3) ?x(Act(S ize, x) ? ?Act(RemoveDups, x)) (4) ?x(Act(MemberO f , x) ? ?Act(RemoveDups, x)) (5) ?x(Act(S ize, x) ? ?Act(Reverse, x)) (6) ?x(Act(MemberO f , x) ? ?Act(Reverse, x)) (7) ?x(Act(NumO f Occur, x) ? ?Act(ElementAt, x)) (8) ?x(Act(NumO f Occur, x) ? ?Act(Tail, x)) (9) ?x(Act(NumO f Occur, x) ? ?Act(Head, x)) (10) ?x(Act(NumO f Occur, x) ? ?Act(Leaves, x)) (11) ?x(Act(NumO f Occur, x) ? ?Act(Root, x)) (12) ?x(Act(RemoveDups, x) ? ?Act(ElementAt, x)) (13) ?x(Act(RemoveDups, x) ? ?Act(Tail, x)) (14) ?x(Act(RemoveDups, x) ? ?Act(Head, x)) (15) ?x(Act(RemoveDups, x) ? ?Act(Leaves, x)) (16) ?x(Act(RemoveDups, x) ? ?Act(Root, x)) (17) ?x(Act(Reverse, x) ? ?Act(ElementAt, x)) (18) ?x(Act(Reverse, x) ? ?Act(Tail, x)) (19) ?x(Act(Reverse, x) ? ?Act(Head, x)) (20) ?x(Act(Reverse, x) ? ?Act(Leaves, x)) (21) ?x(Act(Reverse, x) ? ?Act(Root, x))     (22) ?x(Act(Reverse, x) ? ?Act(NumO f Occur, x)) (23) ?x(Act(Reverse, x) ? ?Act(RemoveDups, x)) (24) ?x(Act(Leaves, x) ? ?Act(ElementAt, x)) (25) ?x(Act(Leaves, x) ? ?Act(Tail, x)) (26) ?x(Act(Leaves, x) ? ?Act(Head, x)) The above rules explicitly represent the interesting con-  nections among some revelent knowledge points in Data Structure. When learning the course Data Structure, the stu- dents can make full use of these rules. Thus, they can more easily understand the knowledge.

4. Teaching quality analysis  In order to verify the method, we have preformed sev- eral experiments on three classes in College of Computer and Science. In each class, we arbitrarily chose the scores of fifty students and computed their average score on each knowledge point. Thus, we can obtain the corresponding score rate on each knowledge point. By contracting to the history analysis results, we can find that we obtained a more well teaching quality, as shown in Table 3.

Table 3. Teaching Quality Analysis(Partly)  knowledge mass knowledge point score rate lined list stacks 96%  queues 95% sort algorithm selection sort 98%  insertion sort 96% bottom-up merge sorting 97%  merge sort 96% quick sort 89%  graph depth-first search 96% backtracking 94%  breadth-first search 97% Dijkstra algorithm 86% Floyed algorithm 82%  tree binary tree 98% rooted tree 96%  Kruskai?s algorithm 94% Prim?s algorithm 91%  5. Conclusion  In this paper, we mainly discuss how to apply the theory of FCA to our teaching schemes for instructing the course Data Structure. Our idea is as follows: we firstly translate some related knowledge points into a binary context, and then extract the corresponding concept lattice of this con- text, and last extract some interesting rules either with ? or with ?, which can be used by the students to help them more  easily understand the tuitionary knowledge in class. These rules extracted from concept lattice have 100% confidence.

By using the method, a teacher or (together with his/her students) should firstly accurately translate the related knowledge points into a binary context, and rules acqui- sition can be automatically accomplish. Therefore, our method has nicer maneuverability. Currently, we have apply the theory of FCA to two courses such as Artificial Intelli- gence and Data Structure. Contract to traditional teaching methods, the method has a more well teaching quality.

Acknowledgement This work is supported by Foun- dation of Teaching Reformation of Higher Education (No.B05042) of ShanDong Province.

