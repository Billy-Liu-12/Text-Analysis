The Optimization and Improvement of the Apriori Algorithm

Abstract   Through the study of Apriori algorithm we discover two aspects that affect the efficiency of the algorithm. One is the frequent scanning database, the other is large scale of the candidate itemsets. Therefore, IApriori algorithm is proposed that can reduce the times of scanning database, optimize the join procedure of frequent itemsets generated in order to reduce the size of the candidate itemsets. The results show that the algorithm is better than Apriori algorithm.

1. Introduction   Data mining also known as the knowledge discovery in database, it is a forecasting method to extract the hidden knowledge from the large-scale database or the data warehouse [1]. Its main methods include: classification, clustering, association analysis and so on [2]. Mining association rules is one of the main contents of data mining research at present and emphasis particularly is finding the relation of different items in database. Apriori [3, 4] is the most famous and basic method in mining association rules. The principle of Apriori algorithm is to find the valuable association rules whose support and confidence must satisfy the minimum support and confidence confirmed by user aforehand.

2. Apriori algorithm description   Apriori algorithm is the most effective method that candidate k+1-itemsets may be generated from frequent k-itemsets according to the nature of Apriori algorithm that any subset of frequent itemsets are all frequent itemsets. The classical Apriori algorithm:   L1 = {large 1-itemsets}; for (k=2; Lk-1 ? ? ;k++) do begin Ck=apriori-gen(Lk-1); //new candidate itemsets generated for all transactions t?D do begin Ct=subset(Ck,t); //transaction t contains in the candidate itemsets  for all candidates c?Ct do c.count++;  end Lk={c?Ck |c.count ? minsup}  end Answer=?kLk;  First, find the frequent 1-itemsets L1.L2 is generated  from L1 and so on, until no more frequent k-itemsets can be found and then algorithm ceases. In the algorithm each Lk generated must scan database one time [5-7].Second, Ck is generated from Lk-1.Every itemset in Ck is tested whether its all k-1 subsets constitute a large k-1 itemset or not. Therefore, scanning large database many times and generating so many useless candidate itemsets are the bottleneck of the Apriori algorithm.

3. Problem description   Apriori algorithm has three shortcomings below [8].

First, because there are lots of transactions in the database, computing the frequencies of candidate itemsets must scan database frequently and spend much more time.

Second, Ck is generated by joining two frequent itemsets that belong to Lk-1. If we can reduce the operating frequencies, we can improve the efficiency of Apriori algorithm. Third, the expending in time and space for frequent itemsets is too much. For example, if we have 104 frequent 1-itemsets, we can get 107 frequent 2- itemsets. So reducing the scale of Ck can improve the efficiency of the Apriori algorithm greatly.

Therefore, it is necessary to delete the useless transactions in the database in order to reduce the scale of database and reduce itemsets generated from Ck by the join procedure. This paper presents an improved Apriori algorithm called IApriori algorithm according to the analysis of   Apriori algorithm above.

4. Improved apriori algorithm   Improved Apriori algorithm related in [9] scans database to compute the frequencies of candidate itemsets at the same time to mark the deleting tag if the size of  2008 International Workshop on Education Technology and Training & 2008 International Workshop on Geoscience and Remote Sensing  DOI 10.1109/ETTandGRS.2008.390   2008 International Workshop on Education Technology and Training & 2008 International Workshop on Geoscience and Remote Sensing  DOI 10.1109/ETTandGRS.2008.390     transaction t is less than k. In [10, 11], transaction t does not contain any element of candidate itemsets Ck, the algorithm determines to mark the deleting tag on t, so we can skip over the record in next database scanning. The method that reduces the operating frequencies generating Ck by joining two frequent itemsets that belong to Lk-1 is proposed in [12].The improvement in [13] limits the scale (m+n ) of  Ck in advance according to the numbers of rules that contain the total items which are respectively m and n.

Due to the generalization of algorithm, IApriori algorithm proposed in this paper does not input more thresholds to improve efficiency, only has improved from some aspects.

(1) Improvement method of optimizing the join procedure to reduce the size of candidate itemsets. When Ck+1 is generated from Lk ? Lk, each item of the first Lk is joining with every item in the second Lk in classical Apriori algorithm. Since the kth item of the first Lk is the same as the kth item of the second one, the kth item of the first Lk is joining with the k+1th item of the second one, when Ck+1 is generated from Lk ? Lk. Only in this way can we spend less time than before.

For example: L1= {I1, I2, I3, I4}, Apriori algorithm needs computing 16(4*4) times but it only needs 6(3+2+1) times in IApriori algorithm.

(2) Improvement method of reducing the scale of database. Through the process obtaining Ck+1 from Lk if the size of transaction t is less than k, we can say that it is useless for generating Ck+1; if transaction t does not contain any subset of candidate itemsets Ck, mark the transaction t the deleting tag.

IApriori algorithm reduces the scale of database and optimizes the join procedure, so it improves the efficiency of algorithm greatly.

Moreover, the scale of L1 must be small as soon as possible to reduce the scale of C2, C3 and so on. Make sure the proper minsupport; also we can choose interested items for the frequent itemsets generated.

IApriori algorithm is described as follows.

1) L1 = {large 1-itemsets}; 2) for (k=2; Lk-1 ? ? ; k++) 3) { 4)       Ck=apriori-gen(Lk-1);  //generate new candidate itemsets 5)      for all transactions t?D  and  t.delete=0 6)     { 7)            if  t.count<k  then  // if the size of transaction t is less than k, t is useless for Ck generated  8)            t.delete=1 //mark t the deleting tag to skip over the record  in next database scanning 9)            else 10)           {  11)                   Ct=subset(Ck,t); //candidate itemsets contained in transcaion t  12)                   if  Ct = ?   then // if t does not contain any subset of candidate  itemsets Ck, mark the deleting tag 13)                   t.delete=1; 14)                   else 15)                  { 16)                           for all candidates c?Ct 17)                           c.count++; 18)                   } 19)            } 20)      } 21) Lk={c?Ck |c.count ? minsup} 22) } 23) Answer=?kLk;   To implement the improvement, IApriori algorithm is  described as follow steps: (1) Scan the database to get C1, make sure the proper  minsupport to get frequent itemset L1(k=1).

(2) Generate Ck+1 though joining two frequent itemsets  that belong to Lk. The mth item in the first Lk should join with the m+1th item of the second Lk.

(3) If the size of transaction t is less than k, we give transaction t to mark the deleting tag; if not, compute Ct that contains subsets of candidate itemsets Ck in transaction t.

(4) Judge whether t comprises any subset of Ck; if not, compute the frequencies of Ck. Otherwise, mark t the deleting tag.

(5) Add item of Ck to Lk+1 if the support of the item is greater than minsupport.

(6) If Lk+1= ? , the algorithm ceases. Otherwise, k=k+1, continue to the second step in circle until Lk+1= ? .

5. IApriori algorithm performance test   To analyse the relative performance of the IApriori and  Apriori algorithms, we use a small part data from real store database stored 10000 transactions. Figure 1 demonstrates the relative performance of these algorithms. Five experiments are carried out accomplished using the same database with different minimum support factors. The experiment is in WindowsXP Professional operating system, CPU with Intel (R) 2.93GHz, memory with 512MB, the algorithm language used in C #.

Experiments results show that the time needed IApriori algorithm is less than Apriori algorithm under the same support condition. So we can have the conclusion that the proposed algorithm outperforms the Apriori algorithm in computational time.

Figure 1  Relative performance under different minsupport   6. Conclusions   In this paper we discuss the problems exist in scanning  database frequently and the large scale of candidate itemsets in Apriori algorithm, present an improved algorithm IApriori algorithm. It not only decrease the times of scanning database but also optimize the process that generates candidate itemsets. Experiments results show that the proposed algorithm outperforms the Apriori algorithm in computational time.

Acknowledgement   This research was supported by Natural Science  Foundation of China (No.60473115, No.60773084, No.

60603023) and Doctoral Fund of Ministry of Education of China (No. 20070151009).

