A Novel Simulation Platform for Robot-soccer Games

Abstract  In order to promote the development of multi-agent  technology, a novel simulation platform is established according to the present rules in the present FIRA(Federation of International Robot-soccer Association) Large League SimuroSot(Simulation Robot Soccer), in which advanced physic simulation engine, graphic render engine, auto referee and network communication technology are all used. Experiments and test events show that it is a flawless and nice benchmark for the research of the Robot-soccer.

1. Introduction  Robot-soccer Games is a process that the multi-agent needs to process the real time information in a dynamic environment. Robot-soccer Games have become a new branch of research of artificial intelligence for its dynamical and prompt properties [1]. The research on Robot-soccer Games is relevant to a classical problem of multi-agent system and it also provides an ideal platform for the research of distributing artificial intelligence. The harmonic and the cooperative problems are the key points in the research of multi-agent system rather than the research on a single intelligent entity. It is a complex research direction because the traditional half independent Robot-soccer Games require the relevant research on computer vision, intelligent control, multi-agent system and other pop problems. In a word, Robot-soccer Games is a technical combat on a small platform [2, 3, 4].

The research on the real half independent Robot-soccer Games ,for the restriction on many negative factors such as manpower, money, place, time, along with the bothersome debugging of the strategy program, is hard to implement[5] ,thus only a few universities or research centers are able to perform.

Considering all these disadvantages, the Robot-soccer Simulation Games provides a convenient way for the researches of the algorithm of artificial intelligence by simulating the process of the real half independent Robot-soccer Games based on the technology of virtual reality, thus, only one computer is required for the research. At first, the paper particularized the flaws existed in the present FIRA Large League SimuroSot Robot-soccer Games simulation platform. Then, the  detailed design ideal and the relevant technologies of the finished novel simulation platform are discussed according the flaws.

Several flaws are existed in the present simulation platform. For example, the physical simulation effect is not so lively, the match process is not fluently enough, the auto referee is not accurately enough, etc. Aimed at these disadvantages, the new system introduced an advanced physical engine to simulate the match process more lively, a up-to-date three dimensions graphic render engine to display the match promptly, a reconstructed auto referee model to make the match fairly and fluently.

2. Physical engine   The physical environment is realized by an advanced  commercial physical engine, different from simulating the simple objects? movement under two dimensions physical environment utilized by the present platform, the new system use three dimensions as its basic physical environment. The physical modeling in the new system is designed exactly referenced to the real half independent Robot-soccer Games which include the shapes and the sizes of the objects as well as the simulation about the joint between the wheel and the robot body. Other parameters like static friction, dynamic friction, gravity, velocities are all assigned according to reality. The physical environment of the match includes the shape information (the vertex array, surfaces and the normal of each surface), the physical information (friction, surface flexibility, velocity, object frame work used for collision detection, etc) of each object, the physical parameters of the match field (air resistance, gravity, etc). All these information above are encapsulated in a class named NxScence in the physical engine.

A physical simulation thread is required in order to perform the match; the main pseudocode is listed below:  void simulationThread( NxScence* gScene ){ gScene->simulate( 1.0/60.0 ); gScene->flushStream( );  !gScene->fetchResults(NX_RIGID_BODY_FINISHE D, false) }  Only a few lines of code in the function are able to  2008 IEEE Pacific-Asia Workshop on Computational Intelligence and Industrial Application  DOI 10.1109/PACIIA.2008.393   2008 IEEE Pacific-Asia Workshop on Computational Intelligence and Industrial Application  DOI 10.1109/PACIIA.2008.393   2008 IEEE Pacific-Asia Workshop on Computational Intelligence and Industrial Application  DOI 10.1109/PACIIA.2008.393     perform the simulation of one frame, the result of the simulation is reflected by the changes of the parameter?s members of this function. (gScene, the object of NxScence).

3. Graphic Render Engine   The display of the match is realized by OGRE (Open Graphic Render Engine), an excellent open source graphic render engine which provides simple APIs and encapsulated the APIs of OpenGL and DirectX. OGRE provided an easy way for the beginners to do graphic programming for it is able to read graphic information from the data file produced by 3Dmax and other three dimensions design software. Different from the two dimensions display model in the present simulation platform, the three dimensions display model along with the powerful physical engine in the new simulation platform provided a much lively and handsome vision effect about the motion details: the speed and the direction a wheel rolled can be displayed harmony with the speed and direction the robot moved, the slight quiver effect after the collision is also viewable.

4. Auto referee model   Two main functions are included in the auto referee  model: the auto referee function and the auto reposition  function. The auto referee model is used by the server of the platform as a form of dynamic linked library. The auto referee function is used by the physical simulation thread in the sever once a frame in order to check whether a foul is committed and make judgment about the type of the foul according to the match time, the directions and the positions of each objects and the collision information. When a foul is detected in Robot-soccer Games, the robots in both sides must be replaced to certain locations according to the rules of the game and the type of the foul in order to continue the match. However, in the present simulation platform, the reposition process is implemented by human hands, a bothersome method which makes the match discontinuous and boring. Aimed at this flaw, the auto reposition function in the new system is designed to replace each robot back to the certain place automatically after a foul is confirmed and thus solved the problem mentioned above. In another aspect, the reposition information is assigned by the strategy of each team that also makes the design of the strategy more interesting and the difficult.

5. Structure of the software   The basic structure of the simulation system is  illustrated in figure 1.

Figure 1  The structure of the simulation platform   The software can be divided into five parts: physical  environment, auto referee model, strategy client, and display client and communication model. The physical environment together with the communication model and the auto referee model are assembled in the server.

When a match is about to start, the referee should load the strategy (as a form of dynamic linked library) into  the strategy client and then connect the strategy client to the server in order to perform a match. When the match is under way, the server must receive the velocities of each wheels of the robots sending from the strategy clients in order to perform the physical calculation in one frame and then send the calculation result (positions and directions of the movable objects along with the  Strategy client of  the red team  Strategy client of  the blue team  Simulation thread  Environment parameters  Server  Display client 1 ??  Monitor1 Monitor 2 Monitor n  Auto referee model  Display client 2 Display client n  Physical environm ent     information about fouls and match time) back to strategy clients as the basic data for the strategy to analyse, multi display monitors can be used for the real time displaying.

(1) The physical environment which included the factors used for physical simulation is constructed by the physical engine. These factors are the physical modeling of robots, ball and playground, parameters of the environment (air resistance, ground friction, gravity, etc) as well as the physical simulation thread. The physical environment is encapsulated in an object which provided several interfaces for the physical simulation thread and the auto referee model.

(2) The auto referee model is designed for the real time judgment about fouls and for the reposition process after a foul is confirmed. The interfaces of the referee model are used by the server at each simulation frame in the physical simulation thread. After continuous testing and improvement, rarely a foul might escape from the detection or a mistaken judgment is made by the auto referee model.

(3) The network communication model whose responsibility is to receive and transmit certain data is the control center of the server. It receives the data sending from the strategy client and then modify the environment variables if necessary and at last, send the relevant data back to different destinations according to the environment variables.

(4) The strategy client is used to load strategy DLLs and communicate with the server through network when the match is processing. The strategy client must receive the data from the server in order to make decisions by strategy and then send the velocities of robot wheels back to the server for physical simulation.

(5) The display client is used to view the match by  the data received from the server, human referee can also make his/her own judgment according to the match displayed by the display client. Save and review functions are also provided by the display client.

6. The system realization and the effect   The environment variables are maintained by the  physical simulation thread, the network communication model and the auto referee model. The environment variables include the information about the positions and the directions of robots, the position of the ball, the network communication status, the judgment of fouls and other crucial data. The environment variables are continuous modified and read by the server. In a word, the environment variables symbolized the status of a match at a certain time. When the match is processing, the physical simulation thread read the data of the velocities of the wheels in order to perform the physical simulation. The simulation thread also read information about the judgment made by auto referee model: if a foul is detected, the information about the fouls are listed and the simulation thread is paused by server until the foul is judged by human referee. After a foul is verified, auto reposition function is utilized to replace the robots back to certain places automatically. The wheel velocities along with the reposition information are modified at every frame by the data sending from the strategy clients. The position and collusion information in the environment variables is also used by the auto referee model at every frame as a reference to check if a foul is committed. The figure 2 illustrated the data structure of the environment variables.

Figure 2  The data structure of the environment variables   In the server, the physical calculation is performed by  the simulation thread. The thread is the heart of the system which performed at an interval of 20 ms. the performance of auto referee and auto reposition, the timing function, the data transmission between the server and clients and the refreshing of the interface of the server are all executed in this thread. Firstly, the communication model will read the velocity information sending from the strategy client and revise the environment variables stored in the server.

Secondly, the physical simulation thread has to check the environment variables shows in figure 2, and then the thread is performed according to three different situations.

(1) The match is processing and no foul or abnormity is detected: the server perform the physical simulation for one frame according to the wheel velocities recorded in the environment variables. Then the auto referee function is implemented in order to check whether a  foul is commited according to the information in the environment variables. If a foul is detected, the relevant information in the environment variables would be revised and the relevant changes would be expressed at the next frame by the checking of the environment variables.

(2) The server is paused automatically after a foul is detected or it is paused by human: the timing function is shut down and the velocities of each movable objects are saved. If the match is continued, the server would restore the velocities of each object in order to go on the match.

(3) The robots are about to replaced to the certain positions after the confirmation of a foul: the auto referee model would move the objects directly to the appointed places (The array named posit in the environment variables) which are included in the environment variables rather than manipulated by the physical simulation process. The auto referee model  Environment_Serv   BallPose2D ball2D;    Robot2D robot[2][11];  RoboPose2D posit[2][11];  StatusInfo_Serv status;  StatusInfo_Serv (Server status information)  unsigned char match_state; //match status  unsigned char placement_info; //placement  //information  unsigned char yelow_ballot;  unsigned char blue_ballot;  unsigned char score[2]; //scores  float time; //Left time in a match  SIDE which_posit; //Who pose now after a foul  SIDE which_posit_first; // Who pose now after a  //foul  Team_Info  team_info; //information of teams  Bool is_posit_done; //reposition done  BallPose2D (Coordinate of the ball)    Float x; // abscissa of the ball Float y; // ordinate of the ball  Robot2D (Robot control data)  RoboPose2D pose; //Coordinates and  //directions of robots  float motor_value_l; // left wheel velocity  float motor_value_r; // right wheel velocity  RoboPose2D  float x; // abscissa of the robot  float y; // ordinate of the robot  float ang; //angle of the robot     have to check the rationality of the reposition information sending from the strategy client (The positions send from the strategy client might out of the range of the field or overlapped) and modify the reposition information to a relevant reasonable data automatically.

At last, when the physical simulation in the thread is finished, the environment variables are modified according to the simulation results ( positions and directions of movable objects ), corresponding data extracted from the environment variables are send to the display client and the strategy client through network.

The pseudocode of the server?s simulation thread is listed below (for one frame): Void SimulationThread (EnvironmentVariables&  env,PhysicalEnvironment& pe) { Receive velocities and reposition data sending  from strategy clients and then revise corresponding information in env;  if(!exit) { switch(env.status.match_state) { case NORMAL: /* Perform physical simulation for one frame  and write the simulationresults back to env */ pe.simulateOneFrame(env); /*If any foul is detected, set the placement  information in the environment variables and set the server state flag to pause */  RunAutoReferee(env); break; case PAUSE: save objects? velocities;  break; case RESUME: env.status. match_state = NORMAL; /* restore saved velocities */ ps.restoreVelocities(?);  break; default: /* Any foul confirmed and it is time to  perform reposition function */ RunAutoReposition(env); break; } refreshServerInterface(env); Extract relevant data from environment variables  and send them to strategy client and display client.

} } void RunAutoReposition (Environment_Serv& env) { if( env. Status. is_posit_done ) env. status.match_state = NORMAL; switch(env.status.placement_info) { Judge the rationality about the reposition information in env and replace objects to the appointed position for one frame distance according to the type of foul detected.

} if( reposition finished ) env. Status. is_posit_done = true; }  The effect of the simulation platform is illustrated in figure 3, figure 4 and figure 5.

Figure 3  The interface of server        Figure 4  The interface of display client     Figure 5 The interface of strategy client   7. Conclusion   A lively Robot-soccer Games simulation platform is  important for the research of the algorithms of artificial intelligence, especially the research on the theory about the cooperation of multi-agent. Several disadvantages, for example, the match is not fluently enough, the system is not so stable and the physical simulation is not so lively, are existed in the present FIRA Large League SimuroSot simulation platform. This paper introduced a novel simulation platform and discussed the structure of the software as well as how flaws existed in the present simulation platform be solved in the new simulation platform.

