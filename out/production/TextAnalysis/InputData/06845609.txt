Parallel Spatial Nearest Neighbour Query Based on Grid Index

Abstract?In recent years, with the mobile device starting to carry sensors, the spatial data grows rapidly in the cloud. How to effectively store and query big spatial data to improve the ability of spatial data processing becomes a core problem of the big data era. This paper proposed a version of improving indexing mechanism, the parallelization grid index, by doing research on several kinds of traditional spatial data index, and we designed spatial RNN data query algorithm basing on it.

Extensive experiments using both real and synthetic datasets demonstrated that our proposed methods outperform the state-of-the-art algorithms in spatial RNN queries.

Keywords-spatial index, grid index, parallel calculation, RkNN

I.  INTRODUCTION Location based service (LBS) is more and more important in mobile and social life. It provides users with the location related information services which are required. With the development of spatial positioning technology and geographic information systems (GIS) [1], LBS is used more and more widely. Mobile data is the core of LBS, it is stored and managed by the spatial database.

Compared to the traditional relational database systems, storage and objects processing of spatial database are the spatial targets with special property. Spatial targets often have irregular shapes and relationship between the targets are complex (e.g., intersection, adjacency, inclusion, etc.),, which demands more storage. Moreover, focusing on the spatial operations of spatial target, such as intersection, join and inclusion, is more complicated than the traditional choice and connects function, and is need more calculation process because of the irregular shapes of the spatial object.

Finally, the spatial sequence of the spatial target is difficult to define, and it could not use the common sequencing technology.

Analyzing and processing the big amount of Data is the major operating of spatial database. The most common application is tantamount to query the spatial objects from the massive spatial data. One of the key issues to solve the problem of spatial query is spatial indexing techniques [3, 4], the establishment of appropriate spatial data index could greatly improve the query efficiency.

Recently, the nearest neighbor query in the spatial and spatial data processing field have received extensive attentions and appeared many research results [9-11]. As a   * Changqing Ji is corresponding author.

typical NN, RNN query retrieves the objects whose nearest neighbors include the query point q which is a typical spatial query algorithm. It is popular in intelligent navigation, modern communications and other areas. According to the difference of the spatial index mechanism, some different spatial nearest neighbor query algorithm which is based on the Rtree spatial index is more common, and  those based on grid spatial data index is relatively less, Cheema [12], proposed a method based on grid spatial index k neighbor query in 2007, he first put forward a novel spatial grid access algorithm (CircularTrip), and then established a continuous on the basis of k neighbor query algorithm and proved its efficiency.

With the rapid development of mobile Internet, high- efficient processing of mobile data is widely concerned by service providers and research scholars. Mobile data is one of spatial data, thus research and experiment about spatial data in this paper all applies to mobile data processing. Our contributions are as follows: We proposed an improved version of the index mechanism-parallel grid index, and designed index based on parallel computing of kNN and RkNN spatial data query.



II. PARALLEL GRID INDEX  A. Grid index structure Over a long-term research and develop home and abroad spatial of database index technology, the researchers have proposed a lot of different spatial data index methods, such as Rtree [2] and its deformation [5], regional quad tree [6], grid spatial index [7] and spatial index which based on the Voronoi diagram [8], etc. At present, quadtree and R-tree space index mechanism adopt spatial index ted by most of the spatial database. However, Rtree is not suitable for parallelization. it needs to rebuild additional query point positioning and local index based on voronoi index.

A grid index is a kind of partition that divides an n- dimensional space into many grid units. Spatial area was divided, when the query need spatial objects (including point, line and interfacial, etc.) to find out their own cells first, and then to find out the object in the cell. In practical applications, using a grid index file to store items of per cell, each cell records a spatial object of the actual location for storage.

B. Parallel grid index structure Inverted index derives from the fact that it is required to look for the object on the basis of the attribute value in actual applications. In contrast, to ensure the attribute value on the   2014 IEEE Workshop on Electronics, Computer and Applications     basis of the object, it is named inverted index or reverse index. Inverted index is widely used in document processing [14], it saves the extra time compared to the full-text index.

As a result of a great extent, it improves the text retrieval efficiency.

Grid index mechanism is a regional division method. it divides a multidimensional spatial area into many same size regular grid unit and the spatial objects fall in these small cell. There is a mapping function for a point x in the spatial, the index (x) to determine the cell that contains the point.

And every cell provides to the spatial object with a connection, like previously presented main storage-based grid index mechanism. [13] Thus, this index manages and maintains spatial object position information which the difference among the index is disk-based. Without loss of generality, assuming pending spatial area is a regular square shape, the spatial area can be divided into multiple ? ? ? grid unit, using data structure C (row, column) to show cell index. As the Figure 2.1 shown, Parallel grid index stores the list of objects contained within every cell spatial. During spatial query, first, determine the position of the grid cell, and then you can find all mobile objects contained within the unit. Figure 2.1 shows 4?4 grid index examples, cell C1 point to a data list which contains its object (P1, P2, P3).

Figure2.1: Grid Index Structure  C. Parallel to establish Grid index According to the nature of the grid index, we can use  parallel computing to build the index quickly. According to the computer at the beginning of the central processor nuclear number to establish thread pool, to input data judgment, if it is but a single file data set, according to the computer CPU nuclear number to establish thread pool, main program every read n (according to the CPU processing power dynamic design) of the record is assigned a thread pool of the idle thread; If multiple file input, main program every read a file is assigned a thread pool of the idle thread, if not the idle thread is waiting for the main program. Set the global hashtable HashMap < Key, Value >, Key assignment for Cell line numerical (i, j), Value for falling into the grid point set on disk index. Single thread used to establish local grid index, to input the data records in the first test is legal, for legal spatial data p will fall in grid C[?p.x/??,?p.y/??], if HashMap already exist with the same Key Value, it was written after the way of p all information update to file Value, otherwise in the hash statements add a Key Value and on disk to establish corresponding Value index. So will the  index and the data portion of the isolated, makes data processing only based on partial attributes, so as to reduce data big minor high query efficiency as shown in Algorithm 2.1 and 2.2.

Input?files: Dataset files Output: HashMap:a cell id, Index of files that points int the same cell 1.Static HashMap; 2.threadPool=new ThreadPool(Countcpu); 3.if files.count==1 then 4. File=files[0]; 5. threadPool.add(new BuildGridIndex (read(File,nLine,HashMap))); 6.end if 7.else if files.count>1 then 8.   for i=0;i<files.count;i++ do 9.    threadPool.add(new BuildGridIndex ( read(files[i]) )); 10. end for 11.end if 12.writeToDisk :HashMap  Algorithm 2.1: Main function pseudocode  Input?Ds: Dataset points Output: file: the points of a same cell 1. b=new Buffer[]; 2 .while readLine(Ds,b)!=0 do 3. p=new Point(b); 4. if HashMap.contain(C[?p.x/??,?p.y/??]) then 5.  Synchronized (refresh (HashMap)); 6. end if 7. Synchronized(writeToDisk(p)); 8. end while  Algorithm 2.2: BuildGridIndex function pseudo code

III. SPATIAL DATA QUERY  A. Nearest neighbor query spatial data The basic idea of Parallel KNN algorithm is the grid cells around the parallel access query point q, namely several wheels execute independently and parallel, to change the original algorithm of performing a wheel ergodic at one time into executing several wheels at the same time. Parallel algorithm is realized by the multiple wire or multicore process mechanism, the algorithm classify the wheels which execute at the same time into a group. Each wheel process record the query point set and the number of the points. The algorithm collect the result set and the number of the results of each wheel?s process and according to the number of the result set to judge if the algorithm is finished. In order to make use of the ability of multicore parallel computing nodes better, we adopt a multicore multithreaded way to run wheel algorithm. Assuming that the maximum number of running thread that the CPU support is Ucor, in order to better activate CPU all threads adequately running, this algorithm Ucor set a CircularTrip [12] parallel operations. CircleTrip   2014 IEEE Workshop on Electronics, Computer and Applications    pseudo code shows in Algorithm 3.1, CircularTrip show in figure 3.1.

Figure 3.1 CircularTrip[12]  Input?Query point q, Parallel Grid index G , Number k Output: S 1.Si=? ;S=? ;m=0;r0=maxdist (cq, q);?=GridRadius; 2.while true do 3. T[ucor] =new Trip(); 4. r0=m*?; m+=ucor ; 5. for i=0 to  ucor 6.  T[i].run(G,q,r0+i*?) ; 7. end for 8. for i=0 to ucor 9.  Si=CircularTrip(G, q, r); 10.  S.add (Si) ; 11.  if  | Si|?k   then 12.   break; 13.  end if 14. end for 15.end while 16.if  | S |?k   then 17.  Si1 = CircularTrip(G, q, ri+1); 18.  S.add (Si1); 19.end if  Algorithm 3.1: Pseudocode of CircleTrip algorithm  B. Spatial data reverse nearest neighbor query If the nearest neighbor query inquires the distance known point q recent space target, reverse nearest neighbor inquires the known point q is what space target around the nearest neighbor. RkNN algorithm pseudo code shows in Algorithm 3.2.

Input ? Query point q, Parallel Grid index G, query number of NN k Output: S 1.Si=? ;S=? 2.while true do 3. S.add(CircularTrip(G, q, r)); 4. r+=?; 5. if S.size>1 then 6.  break; 7. end if 8. end while  9. while !closure(S) do 10. S.add(ArcTrip(G,q,r)); 11. r+=?; 12. end while 13. Verification(G,q,S);  Algorithm 3.2:  Pseudo code of  RkNN algorithm  This algorithm first found out q point the candidate set S, and then to verify the candidate set. The choice of candidate set first find q of the nearest neighbor S, and then to the nearest neighbor do and q point of attachment midperpendicular, plane area is divided into two parts, away from the q point area must not exist to meet the requirements of point as shown in figure 3.2. If the last all the plane division finish can form a closure area which contains q point, closure area shown in Figure 3.3.

Figure 3.2: half-space pruning Otherwise, continuing the search continuity that will  cycle through the rest of the area and getting the result sets by using ArcTrip [12] algorithm. According to the result data of the front stage, a new round of pruning will be started by an iterative process. Repeat the above steps until plane form closure area. Finally, recall that verification performs candidate verification using the refinement set S from the filter step returns the RkNN results.

Figure 3.3: Illustration of closure

IV. EXPERIMENTAL STUDY In this section, we evaluate proposed Parallel Grid index with parallel computing by a series of experiments. The experiment is made in the PC which has a Dual Core AMD Opteron 2212 2.00GHz CPU, 73GB of SCSI hard drive, 2GB memory and Ubuntu10.10 server OS. We mainly evaluate tow aspects in following: (1) The response time of   2014 IEEE Workshop on Electronics, Computer and Applications    kNN query when the k is set different values. (2) The size of the experimental data on the influence of the kNN query efficiency   Figure 4.1 Effect of dataset size on response time of kNN  From the Figure 4.1 we can know that, with the increase in the amount of data, kNN query time linear growth, but movements are not great.

Figure 4.2: Effect of k value on response time of kNN  The Figure 4.2 shows that, when the value of k changes in the small range, the size of the value of k had relatively little effect on the whole query time. We can see that k value from 10 to 100, the kNN query response time increases unobvious. This also benefits from multithreaded round.



V. CONCLUSION We did test with experiments on real Spatial Data and simulated space, simulation results show that, the more amount of data, the more obvious advantage we can find out from the parallel spatial query of grid index. In the same situation spatial data of higher R-tree index is 2 to 3 times than the parallel spatial query of grid index Generally grid index is one-time formation, and once the index was built although there are new target comes, no change on the original index structure. Our spatial grid index can be built flexibly in order to makes spatial retrieval more flexible.

However, it still has shortcoming, such as uneven distribution of spatial target, will cause the grid index directory loose, and waste the storage space. Another thing is where to build the grid index construction, need many times disk-reading and operating. Therefore, improving the speed of arithmetic the main point of how to partition data files and reduce the disk-reading and operating. Distributed file system (Hadoop) is a good entry point of dividing the data-inputting. And the model of distributed parallel calculation (MapReduce) is worthy of study with spatial  query.

