An Algorithm of Double Search Association Rules Mining Based on Digital  Complementary Set

Abstract?In order to reduce redundant candidate itemsets and repeated computing existing in these presented double search mining algorithms, this paper proposes an algorithm of double search association rules mining based on digital complementary sets, which adopts two methods of forming candidate itemsets to fast execute double searching, the way of generating subsets of non frequent itemsets is used to down searching, the way of computing their digital complementary sets is used to up searching. The algorithm deletes reduplicate k-candidate itemsets generated by (k+1)-non frequent itemsets via locating order of their subsets, and also improves speed of generating candidate itemsets by computing digital complementary set of their subsets. Finally, the result of experiment indicates that the algorithm is faster and more efficient than presented algorithms of double search mining association rules.

Keywords-association rules; double search; locating order; digital complementary set; mining algorithm

I.  INTRODUCTION To reduce the number of candidate itemsets and the times  of scanning database, people propose some mining algorithms, such as, Max-Miner [1], DMFIA [2] and IDMFIA [3]. To easily generate candidate itemsets and fleetly compute support, some binary mining algorithms were presented, such as reference [4, 5, and 6]. B-Apriori [4] is faster than Apriori for binary logic operation, and B- ARDSM [6] is also faster than IDMFIA when double mining. But there are still redundant candidate itemsets and repeated computing. Such as, B-Apriori repeatedly combines candidate itemsets, it also has repeated computing to delete reduplicate candidate itemsets, and B-Apriori isn?t suitable for mining long frequent itemsets. Although B-ARDSM is suitable for mining general frequent itemsets, B-ARDSM has not only same shortcoming of B-Apriori up searching, but also some redundant itemsets down searching and repeated computing to delete these itemsets. And so, this paper proposes an algorithm of double search association rules mining based on digital complementary sets, denoted by MARDCS, which is suitable for mining any long frequent itemsets.



II. BASE NOTIONS AND PROPERTIES Let I= {i1, i2?im} be a set of items, suppose each ik has  been changed into Boolean quantity from multiattribute.

Definition 1 Binary Transaction (BT), a transaction T is expressed as binary (b1 b2?bm), bk? [0, 1], k=1?m, if ik?T, and then bk=1, otherwise bk=0.

Example, let I= {1, 2, 3, 4, 5, 6} be a set of items, if a transaction is expressed as Ti= {2, 4, 6}, and then BTi= (010101).

Definition 2 Digital Transaction (DT), which is an integer, its value would be obtained by turning binary transaction into algorism.

Example, if BT= (011010), and then DT=26.

Definition 3 Digital Item (DI), which is an integer, it is  the most simple digital transaction which only expresses an item.

Example, let I={i1, i2?im}, and then DI1=1, DI2 =2? DIm=2m-1.

Definition 4 Digital Transaction Length (DTL), which is an integer, the value equal to the number of ?1? contained by BT of DT.

Definition 5 Suppose digital transaction of a transaction T1 is denoted by DT1, digital transaction of a transaction T2 is denoted by DT2. If T1 ? T2, and then DT1 ? DT2, DT1 is regarded as subset of DT2, which is regarded as superset of DT1.

Definition 6 Digital Transaction Closed Set (DTCS), which is an integer; it is also a digital transaction which expresses a transaction including all items.

Example, let I= {1, 2, 3, 4, 5, 6} be a set of items, and then DTCS=63.

Definition 7 Digital Complementary Set (DCS), which is an integer, its value would be obtained by binary logic operation. Aiming to a Digital Transaction Closed Set (DTCS), DCS of DT is expressed as DTCS & (~ DT).

Example, if DTCS=63, DT=23, DCS=63 & (~23) =40.

Property 1 Let p and q be binary transactions with m  bits, let Tp be transaction about p, let Tq be transaction about q, then Tp ? Tq ?p & q=p.

Property 2 Let p and q be binary transactions with m bits, let Tp be transaction about p, let Tq be transaction about q, and p & q=p, let F be frequent itemsets.

?If Tq ? F, then Tp ?F.

?If Tp ?F, then Tq ?F.

Property 3 Let I= {i1, i2?im}, if DTLp= DTLq =k-1, and  then if and only if DTL (DTp | DTq) =k, the number of same items is (k-1) between DTp and DTq.

DOI 10.1109/FSKD.2009.141    DOI 10.1109/FSKD.2009.141

III. THE MINING ALGORITHM BASED ON DIGITAL COMPLEMENTARY SET  A. Data Structure and the Principle of Locating Order Data structure used by algorithm is expressed as follows: Public Struct Candidate { Int value; // saving digital transaction Int length; //saving length of the transaction Int serialNo; // saving serial number of locating order Int [] location=new int[m]; //saving the location of item } CSet, NSet According to Property 3, the principle of location  order is expressed as follows: Principle Each (k-1)-subset of k-non frequent itemsets  is located only once when it is firstly generated in the course from k-non frequent itemsets to (k-1)-subset, i.e. locating order of subset is only one when it is saved in CSet.serialNo.

Example, here are two transactions 5-{61, 55}, DT=53 is not only 4-subset of 61, but also 4-subset of 55, obviously, it is the third time that 61 generates 53 when 61 generates its all 4-subset, it is the second time that 55 generates 53 when 55 generates its all 4-subset, and so, locating order of 53 is not 2 but 3 because 55 won?t generate 53 and needn?t judge according to these principles of generating subset in chapter B.

B. Two Key Techniques of Generating Candidate Itemsets Used by Algorithm 1. The method of generating (l-1)-candidate itemsets by  locating order of subset is used to down search frequent itemsets.

The method includes three parts: (1) How to delete some an item of l-non frequent itemsets? (2)How to delete repeated (l-1)-candidate itemsets of l-non frequent itemsets?

(3)How to delete redundant (l-1)-candidate itemsets which are subset of frequent itemsets or superset of non-frequent itemsets? The algorithm uses Property 2 to solve the third problem. The algorithm uses the feature of serial number of locating order to solve the rest problems, i.e. it can automatically delete an item of l-non frequent itemsets to generate (l-1)-candidate itemsets, and then uses the relation between length and order of subset to delete repeated (l-1)- candidate itemsets.

Let I= {i1, i2?im} be a set of items, and let ISet save digital item (DI), namely ISet[t] =2t (t=0?m-1). Suppose there are N l-non frequent itemsets, let NSet save them, and let CSet save (l-1)-subset. Aiming to each NSet[i] which saves i the first l-non frequent itemsets, these principles of generating subset are expressed as follows:  Principle 1 aiming to each l-non frequent itemsets, namely NSet[i], if the sum of (l-1)-subset generated by NSet[i] is denoted by Sum =NSet[i].length- NSet[i].serialNo.

Principle 2 when NSet[i] generates j the first (l-1)- subset, if location identifier deleted by NSet[i] is denoted by ID, and ID= NSet[i].serialNo + (j-1).

Principle 3 when NSet[i] generates j the first (l-1)- subset, which is saved by CSet[j], and then value of its domain are expressed as follows:  CSet[j].value= NSet[i].value & (~ ISet [NSet[i].location [ID]]); CSet[j].length= NSet[i].length-1; CSet[j].serialNo = NSet[i].serialNo + (j-1), namely ID; CSet[j].location [0... (CSet[j].length-1)]=NSet[i].location[0?ID-1,ID+1?  (NSet[i].length-1)].

Aiming to DTCS, its information of data structure is  expressed as follows: DTCS.value=2m-1, DTCS.length=m, DTCS.serialNo=0; DTCS.location [0] = 0? DTCS.location [m-1] = m-1.

The algorithm of generating (l-1)-candidate itemsets is  expressed as follows: Input: there are N l-non frequent itemsets, and let NSet  save them.

Output: there are C (l-1)-subsets, and let CSet save them.

Generate-Candidate(NSet,CSet) (1) FOR(i=1; i?N; i++) (2){ (3)   FOR(j=1;j?NSet[i].length-NSet[i].serialNo);j++) (4)     { (5)        ID = NSet[i].serialNo + (j-1); (6)        CSet[++Count].value=NSet[i].value& (~ISet [NSet[i].location [ID]]); (7)    CSet[Count].length = NSet[i].length - 1; (8)    CSet[Count].serialNo = NSet[i].serialNo +(j-1); (9)    FOR(k=0;k<ID;k++)//Delteing ID the first item (10)   { (11)    CSet[Count].location[M++] =NSet[i].location[k]; (12)   } (13)   FOR(k=ID+1; k<NSet[i].length; k++) (14)   { (15)    CSet[Count].location[M++] = NSet[i].location[k]; (16)   } (17)   M = 0; (18)  } (19) } 2. The method of computing complementary sets of  subset of l-non frequent itemsets is used to up search frequent itemsets  Aiming to each CSet[i], the algorithm uses logic operation to compute its digital complementary sets via Definition 7, namely, DCS[i] = DTCS & (~CSet[i]).

C. The Process of Double Search Association Rules About the Algorithm DTCS: digital transaction closed set.

FSet: saving frequent itemsets (FI).

FSetu: saving FI of searching up.

FSetd: saving FI of searching down.

NFSet: saving non frequent itemsets (NFI) of searching  up.

NSet: saving NFI of searching down same length.

CSet: saving candidate frequent itemsets of searching  down same length.

Step1: Transformation transaction, namely, traditional  database is turned into D on descending by digital transaction according to definition 1 and 2.

Step2: Computing support of DTCS, if it is frequent itemsets, and then it will be written to FSet, then algorithm goes to Step6. Otherwise, it will be written to NSet.

Step3: Generating frequent itemsets, there are three parties as follows:  (1)Using the function of Generate-Candidate(NSet, CSet) to generate (l-1)-subsets of l-non frequent itemsets.

(2)Up searching frequent itemsets, using the way of computing complementary sets to generate complementary set of (l-1)-subset. If it is neither subset of FSetd nor superset of NFSet, then frequent complementary set is written to FSetu after deleting its subsets in the FSetu, and non frequent itemsets is written to NFSet.

(3)Down searching frequent itemsets, if each (l-1)- subsets is neither subset of FSetd nor superset of NFSet, then frequent (l-1)-subset is written to FSetd after deleting its subsets in the FSetu, and non frequent itemsets is written to NSet.

Step4: Repeating doing Step3 until frequent itemsets isn?t generated by algorithm.

Step5: Writing FSetd and FSetu to FSet.

Step6: Mining association rules according to confidence  from frequent itemsets.

Step7: Digital association rules are changed into normal  association rules.

D. The Algorithm of Double Search Frequent Itemsets Support (int DT): computing support of DT. Min-support  is denoted by support.

Generate-Frequent (Output FSet) (1)  IF (Support (DTCS) ? support) (2)    { (3)        Write DTCS to FSet ; (4)    } (5)  ELSE (6)  { (7)    Write DTCS to NSet and Length = m; (8)    WHILE ((Nset??) || (Length ?|m/2|)) (9)     { (10)      Generate-Candidate(NSet,CSet); (11)      FOR (all NF?CSet) (12)      { (13)         DCS = DTCS & (~NF); (14)         IF((DCS?FSetd)&&(NFSet?DCS)) (15)         { (16)            IF (Support (DCS) ? support) (17)            { (18)           Write DCS to FSetu and delete its subset of  FSetu ; (19)             } (20)            ELSE (21)              Write DCS to NFSet; (22)        } (23)       }//computing digital complementary sets (24)   FOR (all C?CSet) (25)   { (26)     IF((C?FSetd)&&(NFSet?C)) (27)     { (28)      IF (Support (C) ? support) (29)      { (30)        Write C to FSetd and delete its subset of FSetu ; (31)       }  (32)     ELSE (33)        Write C to NSet; (34)      } (35)   } (36)   Length--; (37)  } (38)   Write FSetu and FSetd to FSet ; (39)  }

IV. COMPARING THE CAPABILITY OF ALGORITHMS According to the content of reference [6], we knew that  B-ARDSM is more efficient than B-Apriori. Hence, here we only compare MARDCS with B-ARDSM.

A. Analyzing the Capability of Algorithms B-ARDSM: Firstly, the algorithm up generates l-  candidate itemsets by combining l-superset of (l-1)-frequent itemsets, and then down generates (k-1)-candidate itemsets by forming (k-1)-subset of k-non frequent itemsets.

Secondly, calculated amount (CA) of generating a round frequent itemsets.

Cu: the number of (l-1)-frequent itemsets up generated; Nu: the number of non frequent itemsets (NFI) up  generated; Fu: the number of frequent itemsets (FI) up generated; O (Nu): CA of deleting superset of NFI up generated; O (Fu): CA of deleting subset of FI up generated; Cd: the number of k- NFI down generated; Fd: the number of FI down generated; O (Fd): denotes CA of deleting subset of FI down  generated.

CA=Cu?(Cu-1)/2+[O(Nu)+O(Fu)]?m!/[l!(m-l)!]+Cd?  m+[O(Nu)+O(Fu)+O(Fd)] ?m! / [(k-1)!(m-k+1)!].

MARDCS: Firstly, the algorithm down generates (k-1)-  candidate itemsets by locating order of subset, and then generates complementary sets of (k-1)-subsets. Finally, the algorithm executes double searching according to chapter C.

Secondly, CA of generating a round frequent itemsets is expressed as follows:  CA=k?(k+1)/2+[O(Nu)+O(Fu)+O(Fd)]?m!/[(k-1)!(m-k+ 1)!] + [O(Nu)+O(Fu) +1]?Cd.

B. Comparing the Experiment of Algorithms Now we use result of experiment to testify above analysis.

Above two kinds of mining association rules algorithms are used to generate frequent itemsets from these digital transactions, which are expresses as digital transactions from 3 to 8191, they don?t include any single items, and so m=13, N=8178.

Our experimental circumstances are expressed as follow: Intel(R) Celeron(R) M CPU 420 ?  1.60 GHz, 512MB, language of the procedure is Visual C# 2005.NET, OS is Windows XP Professional. The result of comparing runtime with B-ARDSM and MARDCS is expressed as figure 1 as support of itemsets change. The result of comparing runtime with B-ARDSM and MARDCS is expressed as figure 2 as length of itemsets change.

24 12 6 2.4 1.2 0.6 0.24 0.12 0.06  minsupport(%)  R u nt  i m e ( Mi  l l i s ec  o n d )  B-ARDSM  MARDCS   Figure 1.  the result of comparing runtime as support of itemsets change        2 3 4 5 6 7 8 9 10  Length  Ru n ti  m e(  Mi l li  se c on  d )  B-ARDSM  MARDCS   Figure 2.  the result of comparing runtime as length of itemsets change

V. CONCLUSION This paper proposes an algorithm of double search  association rules mining based on digital complementary sets, which is suitable for mining any long frequent itemsets.

The algorithm reduces redundant candidate itemsets and repeated computing existing in presented double search mining algorithms. It is faster and more efficient than these presented algorithms of double search association rules mining.

