

Abstract-Several algorithms have been proposed to solve the problem of mining frequent inter-transaction itemset. However, the low efficiency of support calculation for inter-transaction itemsets is still a challenging problem that eliminates the performance of mining algorithms. This paper provides inter- transaction association rule mining algorithm using effective technique for support calculations. The proposed technique is based on cross correlation and bitwise operations. The experimental results show a significant improvement of performance up to several orders of magnitude compared to First Intra Then Inter (FITI) algorithm.

Keywords -  Data Mining, Inter-Transaction Association Rule Mining, Cross Correlation.



I. INTRODUCTION   Association rule mining (ARM) is considered one of the  most critical data mining components. This is not only because it discovers frequently occurring patterns in databases, but also the associations between these patterns' attributes.

Based on the terminology [1], the ARM is briefly described as follows: I={i1 , i2 , ?.., in} is a set of n binary literals called items. A transaction Ti is a set of items in I such that Ti ?  I. A database D is a set of transactions. A transaction Ti is said to contain a certain set of items (itemset) C, iff C ?  Ti. Itemset that consists of K items is called K-itemset. The support of an itemset C, denoted ?(c), is the percentage of transactions that contain C. An itemset is considered frequent, if its support is greater than or equals to user defined value minimum support (min_sup). The maximal frequent itemset is defined as the frequent itemset that is not a subset of any other frequent itemset. The association rule is presented in the form  A ? B ( read: A implies B), where A and B are two itemsets and  A ? B = ?. The association rule support is the support of an itemset C where C  = A U B . The rule is frequent iff itemset C is frequent. The rules in this form provide the relations between itemsets in the same transaction and called intra- transaction association rules. The other type of association rules that provides the relations between itemsets in different transactions called inter-transaction association rules. The difference between the two types could be cleared through the following example. Taking stock data as an example, intra-transactional mining, can find rules like, ?If stock A goes up, and stock B goes up, then stock C will go up on the same day (support = 5%, confidence = 80%)?, while inter- transactional mining can find rules like ?If stock A goes up on the first day, and stock B goes up on the second day, then stock C will go up on the third day (support = 5%, confidence = 80%)? [2].

In inter-transaction ARM, the relations between itemsets are discovered for specific domain. This domain may be time as above example or location or any other domain based on natural of examined database. In case of continuous domain as time it can be divided into equal intervals as hours, days, weeks.  Every transaction in database is associated with a dimensional attribute, which is value in the database domain.

The transactions are stored in form T = (Td ,Ti) where Ti is the set of items in T and Td is the dimensional attribute of the transaction. For time as domain and interval is a day, T = (Td ,Ti) represents  that set of items Ti that happened in day Td .

Another important concept in inter-transaction ARM is maxspan, which is user defined value that represents the maximum interval size in domain, where inter-transaction association rules consider interested. For example maxspan = 5 days, user is interested only in association rules that contain relations between itemsets in time interval less than or equals to 5 days, and rule like ?If stock A goes up on the first day and stock B goes up on the second day then stock C will go up on after seven days (support = 5%, confidence = 80%)?, is uninteresting rule since the time interval within the rule is more than the user defined maxspan. The first stage in inter- transaction ARM algorithms is to discover frequent inter- itemsets that are set of extended items in form ii(d) where ii is an intra-transaction item and d  is the relative position of the item in the interval of  inter-itemset contains that item.

For example inter-itemset   E = {a(0),c(2),b(5)} represents the pattern: if item a is found in a transaction has dimensional attribute d , item  c will be found in the transaction with d+2 , and item b will be found in transaction with d+5 . The inter- itemset E can be represented in form (a , 0 , c , 0 , 0 , b).

Lu et al. [3] proposed the concept of inter-transaction and  provided EH-Apriori algorithm to discover frequent inter- transaction patterns; later Tung et al proposed more efficient algorithm, FITI [2] (first intratransaction then intertransaction). The FITI algorithm is based on the concept; a frequent inter-itemset contains only the frequent intra- itemsets. Based on that concept, FITI algorithm discovers first the frequent intra-itemsets then discovers inter-itemsets.

The FITI algorithm is composed of 3 phases; that are abridged as follows:  Phase 1: Frequent intra- itsemsets are mined during this phase by using the Apriori algorithm [4], or any other enhanced algorithm [5,6,7,8]. After that, the itemsets are stored in a data structure, called Frequent-Itemsets Linked Table (FILT). The FILT data structure is composed of an itemset Hash Table, with nodes linked by several kinds of links.  These links are  Lookup Links, Generator and Extension Links, Subset Links, and Descendant Links.

Phase 2, Database Transformation: After completing the formation of the data structure FILT, the next step is to  CROSS CORRELATION BASED INTER-TRANSACTION ASSOCIATION RULE MINING TECHNIQUE   A. M. Ghanem2, B. Tawfik1, and M. I. Owis1  1Biomedical Engineering Department, Cairo University, Giza, Egypt 2Faculty of Information Systems, Suez Canal University, Ismailia, Egypt  e-mail: ahmed@optimal-sys.com     transform the database into a set of encoded Frequent-Itemset Tables, called FIT tables. Number of tables is equal to the length of the longest frequent intra-itemset that has been discovered in the first phase. Each table Fk will be in the form {di, IDseti}, where di  is the value of the dimensional attribute and IDset i  is the IDs  of frequent k-intra-itemsets that are found in the transaction.

Phase 3, Mining Frequent Inter-Itemsets: In this phase, the mining algorithm follows the Apriori basics to perform level- wise mining. So, it uses frequent k-inter-itemsets (for k>2) to form candidate (k+1)-inter-itemsets.

The performance of FITI is sensitive for the increasing in  the number or average size of frequent intra-itemsets in examined database.

FITI algorithm requires complicated data structure to store the frequent Intra- itemsets in phase one. In case of low minimum support, number of frequent itemsets will be increased and more memory space will be required to store them. In phase two, FITI transform the database in set of encode files. The number of these files is equal to the length of longest frequent intra-itemset, which increased as minimum support reduced. The number of transaction in the encoded files is the number of transaction in the original database file. Number of encoded files and required space to store them can increase dramatically in case of large database with long average frequent itemsets size. Moreover, FITI in phase three, uses complicated support calculation method based on encoded files in phase two, and concept of mega- transaction which contains all transaction in sliding window.

In this work, we propose an inter-transaction ARM algorithm provides more efficient support calculations.



II. METHODOLOGY  The proposed inter-transaction association rule mining algorithm called CC-BIT which based on cross correlation and bitwise operations. In CC-BIT, first an intra-transaction ARM algorithm is applied to discover all frequent intra- itemsets. The resulting frequent itemsets are stored in hash tree. Second, bit vector for every frequent item is generated.

Then cross correlation between every two vector is calculated and frequent 2-inter-itemsets are discovered. Finally, inter- transaction candidate generation method is applied on the resulting frequent inter-itemsets to generate the next candidate inter-itemsets. The support of candidate inter- itemsets is calculated using cross correlation, and bits counting then the frequent inter-itemsets are discovered. The candidate inter-itemsets generation, and support calculation and evaluation processes are repeated until all frequent itemsets are discovered and non candidate itemset can be generated.

A. Bit vectors encoding  In second step of CC-BIT, bit vector for every frequent item is generated. Every bit represents the existence of an item in a transaction in the DB, so the number of ones in the bit vector for item i is the support count of i. Figure 2, shows the bit vectors of five items in database in Figure 1.  Bit  vector for intra-itemset is generated by applying bitwise AND operation between the bit vectors of items in this intra- itemset. In CC-BIT, to reduce processing time and required memory space, not all frequent intra- itemsets have bit vector representation only that are represented in at least one candidate inter-itemset.

TID  Items  1  a,b,e,g,j  4 c,f,j  6  a,e,d,h  9  a,c,e,h  10  b,c,f  Fig. 1: Example dataset  Fig. 2: Bit vector representation for five items in database in Figure 1    B. Support calculation  Support calculation of inter-itemset is a time consuming process. Moreover, it is frequently applied after every candidate generation process to evaluate candidate inter- itemsets. For that reason, reducing the execution time of support calculation increases the performance of mining process dramatically. CC-BIT uses the concept of cross correlation to increase the performance of support calculation process. The cross correlation is a measure of similarity of two functions. For discrete functions, cross correlation is defined as: ?                                             (1)  Where f and g are two discrete functions, r is cross correlation between f and g, and k is time delay. In case of, f and g are two bit vectors.   can be generated by bitwise shift k  times and multiplication in can be replaced by bitwise AND operation. Finally, summation can be calculated by counting ones in the bit vector. Cross correlation value at k = 3, 3  represents the number of cases where f[n] equal one and g[n+3] equal one.

If f and g are the bit vectors for items a and c respectively, then r[3] will be the support count of inter-itemset (a,0,0,c,0).

Day Items  a  b  c  d  e 1 a,b,e,g,j  1  1  0  0  1 2   0  0  0  0  0 3   0  0  0  0  0 4 c,f,j  0  0  1  0  0 5   0  0  0  0  0 6 a,e,d,h  1  0  0  1  1 7   0  0  0  0  0 8   0  0  0  0  0 9 a,c,e,h  1  0  1  0  1 10 b,c,f  0  1  1  0  0 11   0  0  0  0  0 12   0  0  0  0  0 13   0  0  0  0  0      Equation 1 can be calculating into two steps as (1.a) ?           (1.b)  In first step, equation 1.a, shifting and bitwise AND operation are applied. In second step, number of ones in resulting bit vector is calculated. Figure 3 shows the first step of calculating cross correlation for inter-itemset (a,0,0,c,0).

Inter-itemsets as (a,0,0,c,0) contain only two individual items. So that the cross correlation can be applied directly for supports calculations. While inter-itemsets as (a d,0,0,b c,0) that contain one or more intra-itemsets, the bit vectors for intra-itemsets must be calculated first before applying cross correlation. Another form of inter-itemsets contain more than two items or intra-itemsets  as  (d,0,c,0,a ). For this form we define multi cross correlation as ?                         (2)  Equation 2 can be calculating into tree steps as (2.a) (2.b) ?         (2.c)  For inter-itemset (b,0,c,0,a),  f, g, and q are the bit vectors for items b, c, and a respectively while k =2 and l =4 . In first step, equation 2.a, bit vector of item c is shifted by 2 where k=2. Then bitwise AND is applied between the shifted bit vector and bit vector for item b. In step 2, equation 2.b, bit vector of item a is shifted by 4 where l=4. Then AND operation is applied for shifted bit vector and resulting bit vector from step one. In step 3, equation 2.c, number of ones in resulting bit vector from step two is calculated. The result of last step is the support count of inter-itemset (b,0,c,0,a).

For inter-itemsets have more than three intra-itemsets, Step 2 is repeated for all extra intra-itemset. Then ones in the resulting bit victor are counted to get the support count. This technique for calculating support count required less execution time and storage space compared to FITI .



III. PERFORMANCE EVALUATION   The performance of the CC-BIT algorithm is compared to the FITI performance with different two datasets. Datasets are generated using the same method as [2,9].Table 1 Summarize the generated datasets parameters.

The FITI and CC-BIT algorithms are coded in java, and all the experiments are performed on a Core 2 Duo processor with 2 GB main memory running under Open Suse 11.0 Linux operating system. In implementing the algorithms, Apriori algorithm is used for frequent intra-itemsets discovering. The results in Figure 4 show execution time versus minimum support. Minimum support varies from .002 - .008. For dataset 1, the execution time of CC-BIT is 8 times smaller than FITI at minimum support .002, and this ratio is  reduced to 2 times at minimum support .007.  While in dataset2, the ratio varies between 12 and 1 in the two dataset FITI, execution time is more sensitive for reducing minimum support. That is because, reducing minimum support affects the performance of the three phases of FITI. In phase one, reducing minimum support increases the execution time    Fig. 3: Example on first step proposed technique for inter-itemset support  count calculations    TABLE I  Datasets parameters   Parameter Meaning Dataset 1 Dataset 2 D Number of transactions 20k 100k T Average size of  transactions 6 10  MT Maximum size of the transactions  8 12  L Number of the potentially frequent itemsets  1000 1000  I Average size of the potentially frequent itemsets  2 6  MI Maximum size of the potentially frequent itemsets  6 8  N  Number of items 1000 1000 MS Maximum span 4 8   required to discover frequent intra-itemsets. Moreover, it increases both the number and the size of generated frequent intra-itemsets. Increasing the number of frequent intra- itemsets increases the time for building the hash tables and different links. In phase two, increasing size of frequent intra- itemsets increases number of FIT files. While in phase three, reducing minimum support increases number of candidate inter-itemsets and required database scans.



IV. CONCLUSION   We introduced the concept of using cross correlation in calculating support for inter-transaction itemsets, and  a  c  {a,0,0,0,0}  {0,0,0,c,0}  {a,0,0,c,0} 1  0  1  1  1 0  0  0  0  0 0  0  0  0  0 0  1  0  0  0 0  0  0  0  0 1  0  1  1  1 0  0  0  1  0 0  0  0  0  0 1  1  1  0  0 0  1  0  0  0 0  0  0  0  0 0  0  0  0  0 0  0  0  0  0     provided technique for inter-transaction ARM. The proposed technique is based one bit vectors, bitwise operations, and cross correlation. Using bit vector, reduces the required memory space compared to FITI algorithm. While using bitwise operations and concept of cross correlation, reduces the required execution time for support calculations, which implies that increasing in the proposed algorithm performance up to several orders of magnitude compared to FITI in most cases.

Fig. 4: Change in execution time with different minimum support for FITI, and CC-BIT algorithms.

