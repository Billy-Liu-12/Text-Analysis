Energy efficient handling of big data in embedded, wireless sensor networks

Abstract?The development of wireless sensor networks has reached a point where each individual node of a network may store and deliver a massive amount of (sensor-based) informa- tion at once or over time. In the future, massively connected, highly dynamic wireless sensor networks such as vehicle-2-vehicle communication scenarios may hold an even greater information potential. This is mostly due to the increase in node complexity.

Consequently, data volumes will become a problem for traditional data aggregation strategies traffic-wise as well as with regard to energy efficiency. Therefore, in this paper we suggest to call such scenarios big data scenarios as they pose similar questions and problems as traditional big data scenarios. Although the latter focus mostly on business intelligence problems. We then propose an aggregation strategy tied to technological prerequisites which enables the efficient use of energy and the handling of large data volumes. Furthermore, we demonstrate the energy conservation potential based on experiments with actual sensor platforms.



I. INTRODUCTION  The total amount of user data (data payload) to be stored or processed doubles every two years [1]. This fact raises several problems regarding data management and time-critical data processing tasks. In order to handle these issues, researchers all over the world are concentrating their work under the topic ?big data?. If we talk about big data research, we consider novel approaches for the processing of huge amounts of data from different, heterogeneous sources. Key problems include search strategies, data dissemination, automated analysis as well as the visualization and post processing [2].

Big data environments in a traditional manner deal with massive, centralized computing resources, e.g. high perfor- mance computing centers and high-speed storage systems.

Typical scenarios focus on data mining scenarios, financial computing (fraud detection) and scientific data evaluation [3] as well as pattern recognition. The majority of research and development activities in this field focus on existing informa- tion in larger volumes than the amount of data usually handled with relational database systems [1].

Today, the actual research focus changes rapidly. Several big data projects deal with huge amounts of multi-dimensional data in embedded, distributed systems. Accordingly, a different application context requires different strategies. For example, if we consider next generation driver assistance systems, Vehicle-2-Vehicle (V2V) or Vehicle-2-Roadside concepts, a large amount of sensor data is generated and needs to be fused  and evaluated [4]. Additionally, such tasks require local pre- processing techniques for distributed scenarios, for instance the evaluation and classification of data received by imaging systems [5]. Besides automotive applications, further scenarios address advanced sensor and monitoring systems as well as smart metering approaches [5], which are operating in a highly integrated and connected environment.



II. RELATED WORK  Related research work for big data in distributed, embed- ded systems correlates with delay tolerant network strategies (DTN) [6] and adapted concepts of data aggregation or data fusion [7]. In contrast to traditional big data infrastructures, our goal is to shrink the relevant data payload directly at the source (or in-network) instead of transmitting the entire raw data to the sink for long-term storage. Usually, the key challenge here is not the amount of the locally measured sensor data, but rather the large number of distributed subsystems (nodes) and the changing communication infrastructure between these nodes.

In the automotive context, energy resources as well as buffer storages are not as strictly limited as in other mobile em- bedded sensor platforms. Nonetheless, specific data processing approaches have to use the given resources efficiently. Here, key parameters are the communication time, latency behavior as well as the communication range and the high level of mobility [8]. Furthermore, vehicles as network nodes offer more possibilities for sensor usage and ultimately information they are able to deliver.

In [9], the key elements of big data are identified through the ?3V model?: volume, velocity and variety. These points can also be transferred to future embedded, wireless sensor networks, as follows:  ? Volume: high node density and/or nodes having a high information potential  ? Velocity: Today, there is already a high velocity of changing information in WSN in many application contexts  ? Variety: Supporting designedly heterogeneous WSN is a main goal of many data aggregation strategies (meaning a multitude of different network nodes)     Sometimes veracity is also included but then the focus is more on acquired business data than on actually measured information. Because of that, it does not fit WSN very well.

Therefore, we are going to focus on the three points above.

Consequently, the term big data for embedded, sensor net- works in this paper shall embrace wireless, embedded sensor networks with data volumes (on individual node-level as well as on network level) larger than in traditional embedded con- texts. Furthermore, networks with a high number of embedded nodes or high node density shall be included.

Since resources, such as processing power, time and energy are limited in WSN, the goal of big data applications in this context should not be collecting as much information as possible. The collection of as little data as possible and still satisfying the user?s need for information is required instead.

So the focus does not lie on data mining in large, existing databases but rather on deciding which readily available in- formation from a network or cluster should be sent in which form to the client.



III. CONCEPT  In general, sensor data collected within a sensor network may have different validity periods. Single sensor values mea- sured at a given point in time have a rather short validity period and are considered as one-shot (or even real-time) data. In con- trast to this, sensor values which are fused over time may lead to higher level conclusions or implications that are of longer validity. Usually, the more local (meaning near to a single node of the network) an information is, the shorter its validity period is, whereas the more global an information the longer its validity. Therefore, we can distinguish between short-term and long-term sensor data or more general information. For instance, consider a VANET (Vehicular ad hoc network) where each vehicle on a street is a sensor node. The middle of the road is congested, so the cars which are part of the congestion may report congested to neighboring cars or a centralized institution (local information as seen by the individual node).

The cars, which have not reached the congestion yet and those which have already left it, do report not congested on a local level. Nevertheless, the global perception of the street remains congested, although the values of the (moving) nodes change over time. With ever increasing node numbers in embedded, wireless sensor networks there is a need to retrieve local information and fuse it to global information as efficiently as possible. The rising data volumes held in local node stor- ages make in-network processing mandatory. From our point of view, traditional proactive or schedule-based aggregation methods in embedded, wireless sensor networks will reach their limits with the applications targeted by future sensor networks. These limits occur mostly with regards to energy efficiency and data volume. In traditional big data scenarios relational databases have to be succeeded by more apt concepts (such as NoSQL databases). In contrast, this very concept can come to the rescue in embedded, wireless sensor networks where traditional aggregation strategies do not fit the problems well anymore. Although the data collected by single nodes in future sensor networks increases, in most use cases the user (or client) does not need to extract single values from the sensor network. Instead, they demand a combination of values such as average of an area, highest value etc. [10]. Collecting and storing every available dataset in an archive for later inspection  often serves for node tracking and is therefore not within the scope of our research. Instead, we focus on the aggregation of combined value sets of node subsets within a sensor network for immediate or short-term usage (such as regulating actor actions based on sensor measurements). In addition, there may be data collected by nodes which is irrelevant to the current application. Being able to filter this from the view on the net- work (by queries) allows to effectively reduce network traffic and storage requirements. Therefore, in order to handle data volumes which are larger than the information stored in current embedded, sensor networks, we propose or rather reintroduce the concept of database-oriented data aggregation. The basic concept of database-oriented approaches in wireless sensor networks is viewing or modeling the network as a virtual database table, where each sensor node corresponds to a row.

An example is given in Figure 1, where each node of the sensor network has sensors (and therefore data) for temperature and pressure. Consequently, each sensor of a node is represented by a column in this virtual table (which shall be called a node attribute). There is no requirement that each node has to have the same sensors, so for some nodes there may not exist values for specific columns. Attributes may be simple sensor readings (such as pressure, temperature etc.) or higher level, abstracted information (such as ?moving slowly? or ?road ahead blocked? for V2V applications). Additionally, in the static routing case, each node knows its parent node established by a chosen routing strategy. When using a dynamic routing, the route to take for a query may be determined during query execution.

Database-oriented systems for sensor networks already in existence are TinyDB and COUGAR. TinyDB runs on top of TinyOS, which is an operating system for sensor nodes based on the C dialect nesC. Furthermore, it only supports specific hardware platforms since an extended toolchain is needed.

TinyDB?s (publicly visible) development ceased at version 0.2 in 2003 [11]. COUGAR is limited to x86-architecture sensor nodes or dedicated, proprietary ones. Furthermore the last activity regarding COUGAR is dated 2005 [12] and the project currently seems to be on halt [12]. As far as we know, the code which has to be run by the sensor nodes (QueryProxy) has never been made publicly available.

Fig. 1. View on a sensor network as virtual table

IV. THE PROPOSED STRATEGY  We think that the database-oriented approach fits the issues produced by big data in embedded, wireless sensor networks very well. Furthermore, since from our point of view the systems in existence lack several functionalities needed for future networks, we propose the system developed at our faculty: PLANetary. PLANetary is a light-weight, database- oriented data aggregation system which is platform indepen- dent and focuses on energy efficiency. In this paper, we want to focus on the data aggregation strategies and therefore the    used routing strategy is predefined and arbitrary. PLANetary does not enforce a single routing strategy but can support in finding optimal routes through the sensor network. Self- organized, tree-based routing strategies for embedded, wireless sensor networks have been proposed as part of the nanett (nano system integration network of excellence) project [13].

In general, the database-oriented approach consists of two phases, similar to those in relational database systems [14]:  ? Query compilation / optimization  ? Query execution / runtime  In our approach we call these two phases query propaga- tion and aggregation, since the query has to be delivered to all concerned network nodes after its statement. After that, information at the nodes has to be aggregated and fused in- network and the results need to be sent back to the client. This process is shown in figure 2. It should be noted that query propagation and aggregation may be executed in parallel. If a query reaches a leaf node the results are immediately sent back if the query conditions are met. Also the propagation (as well as aggregation) itself is parallel since the query (or its results) are transferred into the sensor network similar to a breadth- first search. During the query propagation we try to select as few nodes as possible to send the query to. A node may be needed to execute a query when one or both of the following two statements are true for it:  ? The query conditions may be satisfied by this node and need to be evaluated  ? The node is needed to forward results from the subtree whose parent it is  As it can be seen easily, intermediate nodes are only needed if their subtree contains at least one node where the conditions have to be evaluated. Therefore, all nodes for which the second case is true are implied by the ones for which the first one is true. In consequence, we only have to determine all nodes for which the conditions may be satisfiable. After that, all intermediate nodes which are needed to transfer the results to the sink become clear. In order to select a node subset, we have to pre-evaluate the conditions of a query before its propagation to determine nodes where the conditions are impossible to satisfy. There are different possibilities how we can determine this unsatisfiability. Each node in the network may have attributes which can be queried but are constant. For instance this could be the node id or the floor of a building the node has been deployed to. These static attributes are marked as such and are propagated to the sink during network exploration. In a first step, we may now extract all parts of the given query conditions that only contain static attributes and remove the nodes for which these are false from the query tree.

In the next step, we can remove nodes which do not possess the required sensors to evaluate the query. Since we support heterogeneous network structures there may be nodes which for example do not have a temperature sensor equipped. These nodes can be omitted from queries which select temperature values or pose conditions on temperature readings, since the evaluation result would be undefined. This static evaluation may be repeated by each node which receives the query during propagation. Within specific constraints, the static condition  (a) Query propagation (b) Result aggregation  Fig. 2. The two phases of query execution in sensor networks  evaluation is also available for dynamic attributes (such as actual sensor readings). For example, different nodes may be equipped with diverse temperature sensors having different measurement ranges. If such information is made accessible to the system, the query may be further optimized by detecting that condition checks are beyond the measurement range for a given node and sensor. The corresponding node can then be omitted from the query.

After deriving a restricted node subset, we may now construct the final query tree by adding the intermediate nodes of the multi-hop architecture for the static routing case. In the dynamic routing case, we may now construct a minimum spanning tree within the restricted node set (costs for instance based on node distances) to find the final query routing tree.

Naturally, in order to send a query into the network, the user needs a way of formulating it. With relational databases, queries are usually stated by database client software or manually by users using the SQL language. Database-oriented systems pursue a similar approach where data can be queried using a declarative, SQL-like query language enriched with syntax constructs useful for sensor networks. For the sake of simplicity and to emphasize its origin, we modeled the query language for PLANetary closer to the SQL dialect than that of COUGAR. In contrast to TinyDB, we replaced the SQL keywords SELECT and FROM with SENSE and AT, respectively. Through this, we want to highlight the area of application for the query language. Ssupport for (basic) actor control has also been added where queries can state actions which shall be executed when the query?s conditions are met. This is a similar concept as TinyDB?s triggers but more versatile since each action command can have an arbitrary amount of parameters instead of just one as with TinyDB.

These actuator commands have to be defined by the user and registered with the PLANetary core system on each sensor node.

PLANetary supports conjunctional and disjunctional links between condition statements as well as nested conditions (cur- rently up to a depth of 2). This is an important improvement compared to TinyDB and COUGAR since these solely support non-nested, conjunctional links. Therefore, PLANetary allows to state more complex conditions to restrict the required node subset. Most certainly, this also may feel more natural for the experienced SQL user. This allows the combination of aggre- gation requests that require multiple queries in TinyDB into a single query with PLANetaryQL. This leads to improvements    (a) Two queries in TinyDB  (b) One query in PLAN- etary  Fig. 3. Comparison of retrieving an average temperature value for two different floors in a building  Fig. 4. A query in PLANetaryQL with more complex conditions  with regards to network traffic, energy consumption and the time needed for query propagation. A sample is given in Figure 3. The possibility for nested queries to be stated allows for even more complex scenarios which may result in multiple queries with TinyDB or would be very hard to state at all. An example of a more complex, nested query is given in Figure 4.

After the query has reached a leaf node of the query tree during propagation, the aggregation phase starts for this node. During this phase, the results are collected and fused in-network in such a way, that aggregate functions (such as sum, average, maximum etc.) are applied in place and only the required values are sent back to a parent node of the corresponding subtree (e.g. the maximum value of a sub tree).

This enables us to reduce the network traffic depending on the user query and the requested values. It is similar to the approaches of TinyDB and COUGAR as well.

The shown optimizations are especially important with regards to the energy efficiency of the overall system. Nodes which are not required to answer any of the running queries or forward query results should consume as less power as possi- ble. Therefore, we incorporated support for wake-up receiving technology into PLANetary. Wake-Up-Receiver modules are ultra low-power wireless communication modules which wait for just one signal, the so-called wake-up signal [15]. In practice, they accompany standard wireless communication modules (such as WiFi, XBee, Bluetooth) which require much more energy during idle mode [16]. If there is no data transmission running, the sensor node may now deactivate the standard communication module. Depending on the usage case even its main processing unit can be deactivated while waiting for the wake-up signal. The energy conservation potential of such a technology is enormous, albeit the actual conservation depends on the wake-up frequency. This is due to the fact that the wake-up process is often costly energy-wise and time-wise [15]. Nonetheless, wake-up technology fits asynchronous data aggregation strategies such as database-oriented approaches very well, since (user-defined) queries have a relatively low frequency and their occurrence cannot be predicted reliably.

Here, a time-based scheduling would be very prone to energy  Fig. 5. Dropping of unsatisfiable condition parts in-network  waste. Since it either would wake the nodes too often when no new queries need to be received or too seldom so that there is a noticeable delay between the query statement by the user and the arrival of results. So in order to achieve the best results from the wake-up technology, the node set which is required to answer a query has to be restricted as much as possible.

Since PLANetary supports conjunctional as well as dis- junctional links in conditions the queries can be further optimized during the propagation step. As some parts of conditions may be unsatisfiable in subtrees, we may drop them beforehand. A simple scenario is shown in Figure 5.

This shows that the nodes of a subtree, which has dropped conditions, do not have to evaluate condition parts which can never be satisfied. With this, nodes which are further down in the subtree do not have to evaluate unsatisfiable conditions and therefore energy can be conserved as well as time (depending on the subtree size). Consequently, this only works with static attributes or properties which have to be part of the routing table. Furthermore, this optimization needs additional resources on the nodes which have to check the conditions for unsatisfiability before forwarding the queries.

Therefore this optimization should be restricted to some, more capable nodes. Naturally, this process is not suited well for highly dynamic networks where the available node set changes very rapidly. Here, the static attributes of new nodes which are needed for the optimization would need to be synchronized often, supposedly wasting more energy than is conserved by query optimization.

In contrast to TinyDB, where the virtual table must always be named sensors [11] and has no actual effect on the query processing (in fact it is entirely optional), PLANetary allows to define an arbitrary number of other virtual tables. Such a table definition consists of a table name and a predefined condition set which selects a subset of nodes in the network.

There are two main advantages of virtual tables defined in this way. Foremost, query text becomes shorter since conditions to restrict the query to a specific node subset (e.g. a specific floor of a building) are implied by the virtual table. Nevertheless, a query on a virtual table can also be further refined by using additional conditions. The second advantage is that definitions of predefined query sets can support the exploration and routing process by clustering nodes together which belong to the same or overlapping virtual table definitions. Depending on the chosen routing strategy, this may not be usable or suitable for all application scenarios but definitely supports more or less static networks, such as building automation sensor networks.

This concept can furthermore be enhanced to local node tables where queries collect data on a single node or a given cluster in their own virtual table, assigning a timestamp to each entry.

These virtual tables may then later be queried themselves    Fig. 6. The network topology used for the evaluation  creating a historic query since the user evaluates past data.

This can also further reduce the traffic in the network.

As with TinyDB, queries may be marked as continuous and given a repetition interval. These queries will be propagated once and saved on the nodes to be re-evaluated on a timely base. This allows to cut the energy cost for queries, which are static and frequently executed.



V. EVALUATION  We tested our approach with a sensor network of nine nodes (where one node represented the data sink) of the PLANet type which is a platform developed at our faculty [17]. It supports a multitude of communication standards such as WiFi, XBee, Bluetooth. The tests were done as a proof of concept to show the energy conservation potential of the combination of database-oriented aggregation and wake-up technology. The network topology we used is shown in Figure 6 and represents a simple use case for home automation scenarios. Each node communicates by means of an XBee module and offers temperature sensor readings as well as the floor and room it was deployed to.

We wanted to compare timely scheduled data aggregation with the database-oriented approach. So on the one hand, we used a time-scheduled aggregation approach where each node sent its data during a given point in time (the demanded data would be collected and extracted at the sink). On the other hand, we used queries with increasing distinctiveness where no further data processing and filtering was required at the sink. The queries range from selecting all values available (Q1) over getting the average temperature by floor (Q4) to selecting a single temperature value from a specific node (Q6).

The energy consumption for each of these actions is given in Figure 7. For controlling the sensor network, starting and stopping the aggregation and checking the received results, we used the GREASE framework. GREASE is a generic sensor data aggregation and evaluation framework, which has been developed by us, and has been demonstrated in [18] and [19].

We saw a general dependency of data volume (network traffic) on query distinctiveness. The more distinct a query is, the more restricted is the node subset on which it is executed and the less values need to be gathered. Therefore, usually the data volume decreases with increasing query distinctiveness as shown in Figure 8. Of course, the data volume required to execute a query can never fall under a certain point where the whole data transmitted is protocol data (marked as protocol overhead in Figure 8).

In the tested scenario, the energy needed to send a wake- up signal was negligible compared to the energy of the actual  Fig. 7. Energy consumption for proactively sending all values (P) and the execution of more and more distinctive queries (only communication costs)  Fig. 8. General relationship between data volume to transfer and query distinctiveness  communication module. The energy consumed by the WuRx component was almost a thousandth of the energy of the actual communication module. The averaged energy consumption of the whole network for all queries we posed is given in Figure 9. The usage of wake-up technology lead to a massive conservation of energy in the given scenario (energy consumed is less than 30 percent). Naturally, the energy conservation depends on query distinctiveness (i.e. number of nodes to wake) and query frequency. But even with our test queries which were of widely different types (many values to single value) we observed a drastic energy conservation effect.

Fig. 9. Energy consumption of the whole sensor network during testing without and with using Wake-Up technology

VI. CONCLUSION  In this paper, we introduced two cases where we see data aggregation in embedded, wireless networks as big data applications. The first case represents sensor networks with a high node density so that the combination of the sensor data collected by each node is enormous. The second case deals with networks with high node complexity (such as vehicles) where each individual node holds a multitude of sensor data and deductions. Within such networks, traditional aggregation approaches reach their limits with respect to energy-efficiency.

With further developments, such as vehicle-to-vehicle com- munication networks and the smartdust vision, the efficient handling of big data volumes in embedded, wireless sensor networks is growing more and more important. Therefore, if we speak about more than thousand (probably energy self-sufficient) network nodes, self organization and energy efficiency are the main points to consider and optimize. There have to be flexible and robust ways of self-organization for such networks as well as a dynamic way to extract data from them.

The combination of database-orientation and wake-up tech- nology yields a great potential in increasing the energy ef- ficiency of wireless, embedded sensor networks and enables the efficient handling of big data applications. Additionally, the proposed system may be applied on top of existing event- driven data aggregation strategies. This would allow for a more detailed and flexible data acquisition for applications-specific events. The basic concept is also not restricted to WSN and can be used to stream data from computer clusters or any network like structure. However, the main focus of PLANetary lies on energy efficiency, its light-weight architecture, and easy incorporability into existing networks and hardware platforms.

Regarding the database-oriented approach, one goal and at the same time a challenge - as with real database systems - is to pose queries which are as distinctive as possible but still deliver results with the needed accuracy. Additionally, there are more query optimization techniques to be considered.

Next steps are the simulation of highly dynamic networks with hundreds or thousands of nodes and the deployment of a demonstrator network with a higher number of nodes than shown in this paper. The limits of wake-up technology in such systems do also need to be defined. This includes finding the best compromise between longest possible sleep times with regard to query frequency and wake-up costs. The PLANetary core source code shall be made publicly available in the future.

