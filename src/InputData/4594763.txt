Towards a Software Diagnosis Method Based on Rough Set Reasoning

Abstract  Software diagnosis for finding faults based on the test results is one of the most time-consuming and labor- intensive activities in large scale software development.

Revealing the potential knowledge hidden in the test results or program constructs to assist this activity is a rational solution. In this paper, we propose two kinds of debugging applications based on rough set reasoning.

One is to select key input parameters which will affect program?s behaviors to facilitate diagnosis. The other is to extract association rules between program input and its behaviors. The inputs of the above two rough reasoning applications are all the test results of functional testing. Our work is the first attempt to utilize functional testing information to help software debugging.

The feasibility and effectiveness of our approach is validated by some examples and experiments. In addition, some on-going research issues are also addressed.

1. Introduction  Since the execution scenarios and code structure are usually very complicated, and the number of test cases (or test results [1]) is also not small, the debugging for finding faults based on the test results is one of the most time-consuming and labor-intensive activities in the large scale software development. Recently, work on precisely and effectively diagnosing (or debugging) has received a lot of attention and there are a number of methods dedicated to this field.

Up to now, there has been some interesting work on software diagnosis. Here, we classify them into three aspects: (1) Slicing-based methods [2,3]. According to the specific slicing criterion, this technique can produce a portion of code to which the debugger should pay more attention. Recently, some researchers combine it with other techniques, such as Bayes analysis [4] and hypothesis test [5], to reduce the search range. (2) Execution history-based methods [6,7,8]. For the sake of automatic debugging, some probes are pre-placed to  record the trace trajectories and then perform actions such as visualization, classification and clustering on them to precisely locate the faults. (3) Association-based methods [9,10]. Debuggers use the mapping relations between program input and its behaviors to detect defects.

These three kinds of methods are mainly targeted for the case of structural testing based on the assumption that execution profiles have the evident statistical character. In the paper, we propose a software diagnosis (debugging) method according to the test results produced by functional (or black-box) testing. To the best of our knowledge, this is the first attempt of using black-box testing information in intelligent software diagnosis.

2. Modeling for test results  2.1. Motivation  In recent years, applying data mining techniques and intelligent information process techniques to the domain of software engineering has become a hot research topic.

The ultimate purpose is to adopt statistical technology and data mining method to explore the potential knowledge, rules and patterns to improve the quality of software product or increase the efficiency of software development.

In general, software testing can be divided into two kinds, i.e., structural (white-box) testing and functional testing [1]. So test results may contain internal construct information or not. Unfortunately, the existing debugging methods combined with data mining techniques merely handle the former case. How to perform effective debugging for the test results generated by black-box testing?

In the functional testing, the software under test (a.k.a., SUT) is viewed as a black box, and its functions as the mapping relations between inputs and outputs (see Figure 1). Due to lack of the necessary internal construct information, the testers or debuggers are hard to find faults in that SUT. It?s clear that the essential cause of the debugging trouble lies in lack of information. Therefore, the unique settlement for this problem is to make a full     use of the information on hand. Here, the main idea of our contribution is to utilize the refined input and output information to construct a decision table, and then employ reasoning on this table to generate rules for debugging.

SUT  Equivalence Class 1 Equivalence Class 2  ??  Equivalence Class m  Input  Non-failures  Failure Type 1  Failure Type 2 ??  Failure Type n  Figure 1.  The input and output refine for SUT  2.2. Classifications of input and output  In the functional testing of software, there are quite a few methods for generating test cases, such as boundary value, equivalence partition, cause-effect diagram and decision table. The test data (input) produced by the above methods can be easily classified into several equivalence classes, because the methods such as cause- effect diagram and decision table can be easily converted into the form of equivalence partition. On the contrary, if the test cases are generated via some structural testing methods, they should be classified by the man-made rules.

The rule can be the coverage of a specific branch, path, and so on.

While the output of software is taken into consideration, there are two standard classes: non-failure and failure. For the second case, the classification of output is mainly based on software?s behaviors such as memory drop, irresponsive, and any other types of exceptions.

Based on the classifications of input and output, a decision table (DT) can be achieved by converting test cases into rules. Since some test cases can merely map into a rule in the DT, the number of rules in DT must be less than that of test cases. Furthermore, the records about non-failure are reserved in DT to keep the test execution information to assist diagnosis activities. Of course, these records could be tailored on basis of real condition.

The derived DT is an important part of knowledge expression system in rough set reasoning. To make the paper self-content, we first review the basis about rough set [11].

Definition 1 A knowledge expression system can be denote as ( ,  ,  ,  )S U C D V f , where 1 2{ , , , }nS X X X is the set of objects, A C D is the set of attributes, which can be divided into conditional attribute set ( C ) and decision attribute set ( D ). These two subsets hold restrictions such as C D A  and C D . (V  ,  )a A aU V  is the set of attribute?s value, and aV  is the  range of value of attribute a . :f U A V  is an inform- ation function, which assigns a value to each attribute of each object, i.e., ,  ,a A x U  get ( , ) af x a V .

Due to the arbitrariness of classification, the objects achieved via above method may contain inconsistent items. In this paper, we will address the debugging method based on consistent DT, and then propose the treatment for the other case.

3. Diagnosis with rough set reasoning  3.1. Running example  In order to clearly address the principle and steps of our method, we take a simple application as example. The running example is a Java application, which is used for calculating date. It has four input parameters: the former three are year, month, and date, and the last one is a flag. 1 means the judgment of leap year, 2 is to get previous day and 3 is to get next day. The parameter year can be classified into three types: Type-I, it can be divided exactly by 100 but not 400, Type-II, it can be divided by 400, and the third is a normal year. Similarly, month can be divided into three sets, such as {1,3,5,7,8,10,12}, {2}, and {4,6,9,11}. In the same way, the date can be partitioned into date<=28, 29<=date<=30, and date=31. These three types in all parameters are expressed as 1, 2 and 3 in Table 1, separately.

Here, we only performed testing on that application with fifteen test cases. Eight out of them are running without failure, so we denote their output as 0 (see Table 1). However, the remaining seven threw two kinds of exceptions, which are marked with 1 and 2, respectively.

Table 1. Decision table for the example application  Conditional Attributes ( C ) DecisionAtt. ( D )U IP1 IP2 IP3 IP4 Output  x1 2 1 1 3 0 x2 2 3 3 2 0 x3 2 3 1 1 0 x4 3 1 2 1 0 x5 3 3 3 1 0 x6 2 1 3 2 0 x7 3 1 2 3 0 x8 3 2 3 3 0 x9 1 2 1 2 1 x10 1 1 2 2 1 x11 1 3 3 1 1 x12 2 2 1 2 2 x13 2 2 2 3 2 x14 3 2 2 2 2 x15 3 2 2 3 2     As we can see, rough set theory, proposed by Z.

Pawlak in 1982 [11], is a formal method used to tackle incomplete and undetermined knowledge. Under the direction of such theory, a few operations can be performed on the decision table, and the results can be applied in many fields. Among so many applications, the knowledge dependency analysis and attribute significance analysis are two key topics, which can also be utilized in the direction of software diagnosis.

3.2. Significance analysis for input parameters  In the program debugging activities, it is important for maintainers to know which input parameter is very important to the program?s behaviors. With such parameter, debuggers can calculate the static slice according to it. The slicing result is the sensitive part so that they should pay more attention to those statements.

Definition 2 Given an information system ( ,  S U C ,  ,  )D V f , and suppose the corresponding classification  of attribute subset C  is D . Once attribute a  is removed from C  the classification must be changed. Therefore, the significance of attribute a  is defined as:  ( ( ))( ) 1 ( ( ))  C a C a  C  Card Pos DSig D Card Pos D  (1)  Where ( )CPos D is called the positive domain of set D , and ( )Card X  is the cardinal number of set X .

According to formula (1), the significance of each attribute  (1 )ia i C , i.e., ( )iC aSig D  can be calculated.

In order to facilitate the comparison between attributes, we must normalize them:   ( )  ( )  i i  j  C a a n  C a j  Sig DW Sig D  (2)  For the example application, the significances of input parameter IP1, IP2, IP3 and IP4 can be calculated as below:  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15/ {( , , , , , , , ), ( , , ), ( , , , )}U D x x x x x x x x x x x x x x x , ( IP1) 1 2 3 4 6 7 8 10 13 14 15( ) { , , , , , , , , , , }CPos D x x x x x x x x x x x , ( IP2) 1 2 3 4 5 6 8 9 10 11 12 13 14( ) { , , , , , , , , , , , , }CPos D x x x x x x x x x x x x x , ( IP3) 1 2 3 4 5 6 7 9 10 11 12 13 14( ) { , , , , , , , , , , , , }CPos D x x x x x x x x x x x x x , ( IP4) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15( ) { , , , , , , , , , , , , , , }CPos D x x x x x x x x x x x x x x x  ,  IP1  4 115= 4 2 2 20 15 15 15  W , IP2 2 115= 4 2 2 40  15 15 15  W ,  IP3  2 115= 4 2 2 40 15 15 15  W , and IP4 0= 04 2 2 0 15 15 15  W .

According to these results, we can find that the attribute IP1 is the most important factor to determine program?s  behaviors, so debugger should carefully inspect the statements of static slice [2] of that input variable.

3.3. Rule-based program diagnosis  Generally speaking, software system is viewed as a black box during functional testing. The relation between program?s input and output is the typical cause-effect mapping rule. For software debuggers, the chief task is to find the reason causing software failure. In the other perspective, the problem can be induced into the process of mining rule such as ?reason failure type?.

Extracting rules from information system is the main task in the field of data mining or knowledge reasoning.

In general, four kinds of rules can be mined from data, i.e., characteristic rule, association rule, discriminant rule, and classification rule. Here, we mainly use rough set-based reasoning to mine association rules from test results, and then employ these rules to program debugging.

Definition 3 Given an information system ( ,  S U C ,  ,  )D V f , and G  and H  are subset of conditional  attributes and subset of decision attributes respectively.

g h  means a decision rule, where g  denotes the pre- condition of rule, and  h  denotes post-condition of rule.

Definition 4 For any two objects y x , if the condition | | | |x y x yd C d C d D d D  is satisfied, then we call xd  is consistent, otherwise not. Here, xd  is a rule in system S , |xd C  is the pre-condition of rule, and |xd D  is the post-condition.

In this section, we mainly discuss the situation of consistent rules mining. The latter case will be discussed in the next section. In this paper, we adopt the algorithm RICCR (Rule Induction based on Classification Consistency Rate) [12] to mine the debugging-purposed rule.

(1) Mining rules based on algorithm RICCR For the running example (i.e., Table 1), we can gain  the following classifications through considering the values of conditional and decision attributes:  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15/ {( , , , , , , , ), ( , , ), ( , , , )}U D x x x x x x x x x x x x x x x ; 1 2 3 6 12 13 9 10 11 4 5 7 8 14/ (IP1) {( , , , , , ), ( , , ), ( , , , , ,U Ind x x x x x x x x x x x x x x  15)}x ; 1 4 7 10 2 3 5 11 6 8 9 12 13 14/ (IP2) {( , , , ), ( , , , ), ( , , , , , ,U Ind x x x x x x x x x x x x x x  15)}x ; 1 3 9 12 2 5 6 8 11 4 7 10 13 14/ (IP3) {( , , , ), ( , , , , ), ( , , , , ,U Ind x x x x x x x x x x x x x x  15)}x ; 1 7 8 13 14 15 2 6 9 10 12 3 4 5/ (IP4) {( , , , , , ), ( , , , , ), ( , , ,U Ind x x x x x x x x x x x x x x  11)}x ; IP1 9 10 11( ) { , , }Pos D x x x ; IP2( )Pos D ; IP3( )Pos D ; IP4( )Pos D .

Compared with attribute IP2, IP3 and IP4, the positive domain of attribute IP1 isn?t null, i.e., IP1( )Pos D .

Therefore, we choose IP1 as the gist for getting decision rules. In case of considering the objects 9 10 11( , , )x x x  in  IP1( )Pos D , the following rule can be achieved.

IP1 1  1D From above rule, we can conclude that the type 1  failure must be attributed to the first input parameter.

Subsequently, a new decision table can be produced after removing the objects in IP1( )Pos D . Based on the new DT, we can further explore the potential rules in information system.

Table 2. New DT after removing objects in IP1( )Pos D  Conditional Attributes ( C ) DecisionAtt. ( D )U IP1 IP2 IP3 IP4 Output  x1 2 1 1 3 0 x2 2 3 3 2 0 x3 2 3 1 1 0 x4 3 1 2 1 0 x5 3 3 3 1 0 x6 2 1 3 2 0 x7 3 1 2 3 0 x8 3 2 3 3 0 x12 2 2 1 2 2 x13 2 2 2 3 2 x14 3 2 2 2 2 x15 3 2 2 3 2 Similarly, we can achieve the following results  according to the first two steps in algorithm RICCR: 1 2 3 4 5 6 7 8 13 14 15/ {( , , , , , , , ), ( , , )}U D x x x x x x x x x x x ;  1 6 2 3 4 7 5 12 13 8 14/ (IP1, IP2) {( , ), ( , ), ( , ), ( ), ( , ), ( , ,U Ind x x x x x x x x x x x 15)}x ; ??; (here some results are omitted for space reason)  ( IP1,IP2) 1 2 3 4 5 6 7 12 13( ) { , , , , , , , , }Pos D x x x x x x x x x ; ( IP1,IP3) 2 5 6 8 13( ) { , , , , }Pos D x x x x x ; ( IP1,IP4) 3 4 5 14( ) { , , , }Pos D x x x x  Since cardinal number of ( IP1,IP2)( )Pos D  is the biggest, we deduce following rules according to it.

IP1 2 IP2 1  0D ; IP1 2 IP2 3  0D ; IP1 3 IP2 2  0D ; IP1 3 IP2 3  0D ; IP1 2 IP2 2  2D .

Then the objects 1 2 3 4 5 6 7 12 13( , , , , , , , , )x x x x x x x x x  are  removed from the decision table, we can deeply deduce rules as below based on the new generated DT.

IP1 3 IP2 2 IP3 3  0D ; IP1 3 IP2 2 IP3 2  2D .

Finally, we can ignore the unconcerned rules whose  decision attribute equals to 0. For the concerned rule subset, the third step of algorithm RICCR (i.e., simplification step) is performed on it to produce the final rules as below.

IP1 1  1D                                                      (R1) IP1 2 IP2 2  2D                                       (R2) IP1 3 IP2 2 IP3 2  2D                          (R3)  During the above calculating procedure, it?s should note that we should choose the attribute (among x  and y ) with lower conditional entropy when ( , )( ( ))a xcard Pos D  ( , )( ( ))a ycard Pos D , that is, if ( / ) ( / )H D x H D y , we should generate rules according to objects in ( , )( )a xPos D .

(2) Debugging based on the rules After getting the above mentioned rules, software  debugger should diagnose the SUT based on the knowledge of each rule. Taking the rule R1 as an example, the debugger should perform dynamic slicing [2] according to slice criterion (IP1, ,  1)line  to locate the bugs in program. In the slice criterion, IP1  is the variable name, the second parameter is the start statement during dynamic slicing, and the last parameter is the specific value of that variable in the statement line . For the purpose of debugging, the line  is set as line number of input statement of the corresponding variable. In general, the size of dynamic slice is greatly smaller than that of the whole program. Therefore, program debuggers can reduce the search scope with the help of slicing results.

In most situations, the rules generated by rough set reasoning are not so simple as R1, they usually have more than one logical clause in the conditional part, such as R2 and R3. Without loss of generality, we select R2 as an example to demonstrate how to handle this case.

For the rule IP1 2 IP2 2  2D , debuggers should compute the dynamic slicing results for variable IP1 and IP2, separately. Here, assume the dynamic slice of logical clause IP1 2  is (IP1, , 2)iDynSlice l , where il  is the input statement of variable IP1, and similarly  (IP2, , 2)jDynSlice l  to IP2 2 . Then, the union set of these two dynamic slices can be calculated as below.

(IP1 2 IP2 2  2)Debug D (IP1, , 2) (IP2, , 2)i jDynSlice l DynSlice l                   (3)  It is obvious that, debuggers can locate bugs rapidly and precisely, which may result in external failure behaviors, under the direction of rules generated by rough set reasoning.

3.4. Treatment for inconsistent case  As stated in the previous sections, the decision table may contains inconsistent objects (or rules) due to arbitrariness of equivalence partition. For an instance, there are two test cases 1 (year=2000,  month=2,  datetc =27,  flag=3;  Output - )non failure  and 2 (year=2000,  tc month=2,  date=28,  flag=3;  Output )failure . Their input can be classified into the same class (IP1 2,  IP2 2, IP2 1,  IP2 3) , but their output are not identical. So  these two test cases will bring inconsistent objects into DT if the classification method in running example is adopted.

To handle the inconsistency in DT, Reference [12] also proposed an algorithm (i.e., LEM2) to extract rules from that table. Its main idea can be described as below: At first, it compute the super proximity ( *( )R X ) and inferior ( *( )R X ) for each attribute classification X . Then we can generate deterministic rules from *( )R X  and probabilistic rules from *( )R X . The final output rules are the sum of these two kinds of rules.

When the decision table constructed by the test results contains inconsistent records, debuggers can adopt algorithm LEM2 to tackle such harassment. The whole process is similar to treatment skeleton mentioned in Section 3.3. The main difference lies in a step for determining variable?s importance via classification consistency when adding it into attribute class.

4. Discussion  4.1. Framework for rough set-based diagnosis  In the previous sections, we have addressed the program debugging methods based on rough set reasoning. As a whole, the basic process of knowledge- based software diagnosis can be summarized in Figure 2.

The input of the diagnosis activity, i.e., test results, can be divided into two kinds. One is produced via classification-like methods, such as equivalence partition, decision table, and cause-effect diagram. This kind of results can be directly transformed into rough information system. The other kind of results is generally produced by functional testing methods without classification property such as random testing, so debuggers should classify them first, and then construct DT for reasoning.

Ro ug  h Se  t-b as  ed D  ia gn  os is  Figure 2.  The complete framework for rough set-based software diagnosis  There are two different software diagnosis modes based on the decision information system. The first one is to find the key part of program for its external execution behaviors through analyzing the significance input parameters of whole program (the detailed discussion refers to Section 3.2). In this debugging style, the static slicing technique is used to determine which statements are responsible for a specific program failure behavior. In the other software diagnosis mode (see Section 3.3), software debuggers can first make use of algorithm  RICCR or LEM2 to deduce association rule between input parameters and failure behaviors. Then they can perform the dynamic slicing on the SUT for each association rule to achieve the statements related to the failure in the rule?s post-condition. Finally, they can employ union operation on the above statement sets to get the part of program which they should pay more attention to.

For the second debugging style, there is a potential threat that should be validated, that is, decision information may deduce many association rules. In some cases, the number of generated rules is much greater than the objects in DT. Since the number of rules is too large, rough set reasoning-based program debugging maybe unpractical in the real software maintenance activities.

However, we can utilize the background knowledge to solve this issue. The na?ve solution is to compute weight for each rule, prioritize such rule with the descendant order, and then select the former part of rules to direct software diagnosis. The number of selected rules can be set as a proportion (e.g., 10%) of test cases or association rules. On the other hand, many methods are explored to reduce the size of rules in the research field of rough set.

We can refer such methods to tackle debugging problem according to the real need. In a word, the threat resulting from the character of rough reasoning can be flexibly settled in the real applications.

4.2. Related work  Here, we mainly address two aspects closely related to this paper, i.e., defect (or bug) localization and rough set application in software engineering.

Program slicing is a traditional technique for localizing defects, which has been studied for more than 20 years [2,3]. Since the slicing (especially static slicing) results are still very huge, a practical solution is to apply Bayes analysis [4] and hypothesis test [5] on them to reduce search range. Another famous execution record-based method is proposed by Jones et al. [7], who recorded program execution profiles and visualized them to reveal the relations between failure and statement set.

In order to avoid repetition of debugging activities, Dickinson and Podgurski initially employed clustering analysis on failure executions, and sampled several records from each cluster to assist debugging [6]. Li and Zhou adopted another data mining technique, i.e., frequent item-set mining, to mine usage patterns among the execution records of program elements [10]. Despite preferable preciseness, the above methods are all based on the test results of structural testing, and to instrument probes in program code is an inevitable step. Different from them, our main contribution is to give a rational solution for debugging program based on the functional testing results.

Since rough set is suitable to treat small sample and uncertain data, and it can tackle some complicated cases such as inconsistency, data absence etc., it has been applied in many fields such as finance, manufacturing industry and so on. However, its applications in software engineering are not so extensive until today. Tang et al.

[13] introduced a new approach with dominance-based rough set to obtain knowledge from past applications of services to deal with three difficult problems in the field of service retrieval. Lu et al. [14] introduced rough set theory to calculate combination weights of project risk factors, assisting managers to make correct decision on software project management. On the other hand, Ramanna et al. introduced rough set reasoning to software defect classification [15]. As compared with their method, we mainly apply rough set reasoning to achieve association rules between input variables and failure behaviors. To our best of knowledge, it is the first time to utilize rough set and functional testing results to direct software debugging.

5. Concluding remarks  How to diagnose software effectively according to large numbers of test results is a baptism in software maintenance, so software debugging becomes a time- consuming task, too. During software diagnosis, introducing the potential knowledge explored from test results or program constructs is a rational solution. In the paper, the key input parameters and association rules between program input and its behaviors are achieved through rough set reasoning. According to each key input parameter, we can compute static slicing to point out statements closely related to some exceptional behavior.

For each one of the deduced association rules, debugger can calculate dynamic slicing for each input variable and then work out their intersection to direct defect localization. As shown via the running example, the software debugging based on rough set reasoning is a feasible and effective way to improve its quality and reliability.

While our research is at an early stage??that is, there are still some open issues that need to be further explored. For example, (1) how to reduce the size of rule set, (2) how to rank the priority of each generated rule, and (3) how to apply other fuzzy information process techniques to assist software diagnosis are all worth deeply studying.

6. Acknowledgments  This work was supported in part by China Postdoctoral Science Foundation under Grant No.20070410946, the Postdoctoral Science Foundation of HUST, the Science  Foundation of Jiangxi Educational Committee under Grant No.GJJZ-2007-267, and the Youth Foundation of Jiangxi University of Finance and Economics.

7. References  [1] B. Beizer, Software Testing Techniques (2nd edition), International Thomson Publishing, 1990.

[2] F. Tip, ?A Survey of Program Slicing Techniques?, Programming Languages, Vol.3, No. 3, 1995, pp. 121- 189.

[3] S. Kusumoto, A. Nishimatsu, K. Nishie, and K. Inoue, ?Experimental Evaluation of Program Slicing for Fault Localization?, Empirical Software Engineering, Vol. 7, No.1, March 2002, pp. 49-76.

[4] C. Liu, Z. Lian, and J. Han, ?How Bayesians Debug?, Proc. of ICSM?06, 2006, pp. 382-293.

[5] C. Liu, L. Fei, X, Yan, and et al., ?Statistical Debugging - A Hypothesis Testing-based Approach?, IEEE Trans. on Soft. Eng., Vol. 32, No.10, 2006, pp. 831- 848.

[6] W. Dickinson, D. Leon, and A. Podgurski, ?Finding Failures by Cluster Analysis of Execution Profiles?, Proc.

of ICSE?01, 2001, pp. 339-348.

[7] J. Jones, M. J. Harrold, and J. Stasko, ?Visualization of Test Information to Assist Fault Localization?, Proc. of ICSE?02, 2002, pp. 467-477.

[8] M. Renieris, and S. P. Reiss, ?Fault Localization with Nearest Neighbor Queries?, Proc. of ASE?03, 2003, pp.

30-39.

[9] B. Liblit, A. Aiken, A. X. Zheng, and et al., ?Bug Isolation via Remote Program Sampling?, ACM SIGPLAN Notices, Vol. 38, No. 5, 2003, pp. 141-154.

[10] Z. Li, and Y. Zhou, ?PRMiner: Automatically Extracting Implicit Programming Rules and Detecting Violations in Large Software Code?, Proc. of ESEC/FSE?05, 2005, pp. 306-315.

[11] Z. Pawlak, ?Rough Set?, Int?l Journal of Information and Computer Science, Vol. 11, 1982, pp. 341-356.

[12] Jianhua Dai, Research on Rough Set Theory and Its Applications in Knowledge Discovery (Ph. D.

Dissertation), Library of Wuhan University, 2003, pp. 97- 104. (in Chinese) [13] B. Tang, L. Qian, R. Xu, and et al., ?A Service Retrieval Model with Enhanced Dominance-Based Rough Sets?, Proc. of CIT?06, 2006, pp. 249-254.

[14] X. Lu, J. Zhang, and G. Cong, ?The Combination of Multiple Risk Factor in IT Projects Based on Rough Set?, Chinese Journal of Management, Vol.2, No.5, 2005, pp.

527-531. (in Chinese) [15] S. Ramanna, R. Bhatt, and P. Biernot, ?Software Defect Classification: A Comparative Study with Rough Hybrid Approaches?, Proc. of RSEISP?07, 2007, pp. 630- 638.

