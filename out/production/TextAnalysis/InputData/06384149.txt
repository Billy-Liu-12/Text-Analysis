A Data-Centric Executable Modeling Approach for  System-of-Systems Architecture

Abstract - A data-centric executable modeling approach is proposed for system-of-Systems (SoS) architecture by taking full advantage of the Department of Defense Architecture Framework (DoDAF) Meta-model (DM2), which provides more flexibility and adaptability to the automated construction of executable models directly from the architectural data. Firstly, the architectural data meta- model is established to guide architectural data modeling of core data elements and associations in DM2 as the common and consistent data dictionary for architecture modeling, and the executable formalism meta-model is designed to formally define executable models. Then, the mapping rules between both meta-models are defined as the common transformation specification regardless of what modeling language or methodology is employed in developing architectural descriptions. Finally, XML (eXtensible Markup Language) technologies are discussed to facilitate the automated transformation of executable models from architectural instance data. Colored Petri Net (CPN) is used as an illustrative executable formalism in the discussion of the proposed approach.

Keywords: System-of-systems architecture, data-centric, meta-models, architectural data elements, executable formalisms.

1 Introduction Recently, the paradigm of system-of-systems (SoS) has emerged as a popular choice for being an economic and strategic approach for enhancing existing system capabilities to address challenging systems engineering and management problems in the military, academia, industry, and elsewhere [1]-[3]. However, the development of an SoS is evolutionary over time and challenged by its characteristics of increasing complexity, emergent behavior, and uncertainty in requirements and context; thus, there is increasing integration of its evolutionary components and functions with demands for more interoperability to fulfill desired effects as a whole [4], [5]. Model Based Systems Engineering, which focuses on the system models as the leading artifacts of the systems engineering process, can help address these significant challenges [6]; while systems architecture is the conceptual model that characterizes the structure of the component systems, their relationships and  behavior, and provides the principles and guidelines governing their design and evolution over time [4], [7].

Architecture based capability engineering in particular addresses the complexity and uncertainty early in the SoS design process, and therefore conceptualizes the capabilities expected to be achieved by the entire SoS via the development and continuous evolution of its systems architecture to accommodate more possibilities and unpredictable operating environments [1], [4]. Over the past few decades, many studies on architecture modeling and analysis, such as architecture frameworks and design methodologies, have served well in the development and analysis of architectural descriptions for traditional systems that meet a set of fixed requirements. However, the products of an architectural description, being static models of architectural elements in nature, fail to support dynamic analysis, validation and verification of whether all elements combined together behave as expected and the overall architecture as modeled achieves the desired capabilities [4], [7], [8]. Consequently, executable modeling has become increasingly important as executable models are still strongly needed to enable the time-dependent dynamic simulations to allow a more complete examination and early exploration of the logical and behavioral characteristics, and to provide cost-benefit analysis of the capabilities as modeled in the architecture against the capability requirements.

Currently, the most popular approach for executable modeling has been concerned with the construction of executable models from static architectural models, which in essence is the model transformations using the principles of model driven architecture (MDA) at the model level [6], [8], [9]. The latest Department of Defense Architecture Framework (DoDAF 2.0) [7] establishes the DoDAF Meta- model (DM2) along with a new ?data-centric? approach to developing architectural descriptions in a semantically consistent and interoperable fashion. However, current studies of executable modeling usually rely heavily on static models specified with different modeling languages, without taking full advantage of DM2 and the ?data- centric? approach. Since the inconsistent representation for the same semantic content in various modeling languages, the target executable models transformed from static    models are very diverse even for the same architecture.

Furthermore, any changes detected or any errors found in the creation of the executable model and subsequent detailed analysis must be reflected back to guide revisions in the static models of source architectural description [9], while the iterative architecture refinements (e.g., modifying an architecture design or correcting errors in the design) are needed to better support the SoS evolution and accommodate its changing requirements and context. As most of current executable modeling studies are still a manual model transformation process with weak model consistency checking due to semi-formal semantics in modeling languages [8], [10], it connotes that they may require more significant effort to preserve the complete bi- directional traceability and consistency between all elements of static and executable models.

A data-centric executable modeling approach is proposed for SoS architecture by taking full advantage of DM2 and the ?data-centric? approach while addressing the collective weaknesses of current studies to provide more flexibility and adaptability to the automated construction of executable models directly from architectural data. The remainder of this paper is organized as follows. Related work leading to executable modeling is reviewed in Section 2 with the outline of weaknesses. The proposed data-centric executable modeling approach is discussed in Section 3, including the meta-models of architectural data and executable formalism, mapping rules between them, and model transformation to generate executable models.

Appropriate conclusions are finally provided in Section 4.

2 Related Work Since Unified Modeling Language (UML) dominates the modeling language for developing object-oriented architectural descriptions, several variants of UML have been created to make it executable, including executable UML (XUML) and executable and translatable UML (XTUML). Systems Modeling Language (SysML) has recently evolved as an extension of UML for systems engineering applications. However, being weak in formal execution semantics, both these variants of UML and SysML still do not support the formal specification, validation and verification of executable models [8], [10].

Currently, an alternative approach for executable modeling is the conversion of static architectural models specified by different modeling languages to executable models based on various executable formalisms. Levis et al.

[4], [9] described a framework for architecture design and evaluation, in which the DoDAF compliant complete architectural description, produced by either Structured Analysis or Object-Oriented Methodology based on UML, can be transformed into Colored Petri Net (CPN) executable models. Liles [9] has created mapping rules to enable the automated transformation to a CPN executable  model from the UML-like architectural description, where a UML activity diagram with swim lanes is used to capture the complete static behavioral description. Wang et al. [8] proposed an executable system architecting paradigm with a SysML-based MDA design process for discrete-event system modeling and analysis, in which a new conversion procedure is developed for converting SysML models into CPN models. Huynh et al. [11] proposed a systems engineering methodology for performing SoS architecture analysis, involving process modeling with SysML, and the conversion of the resulting SysML models into an executable model via Extend (renamed ExtendSim in the latest version). Ring et al. [12] employed the Activity- Based Methodology to generate integrated static DoDAF models, and then to facilitate the transition from these models to executable process models in Bonapart, which is an object-oriented business process modeling tool based on a CPN simulation engine. Other target executable formalisms include Agent-Based Simulation [13] and DEVS (Discrete Event System Specification) [14].

Overall, the aforementioned current executable modeling studies in essence are the model transformations using the principles of MDA [6], [8], [9]. They firstly describe the system context and requirements with computation independent models (CIMs); CIMs are then refined to static architectural models (platform independent models (PIMs)) specified by different modeling languages to define system functionality and behavior; and PIMs can be further transformed into executable models (platform specific models (PSMs)) with more implementation details based on various executable formalisms of any desired dynamic simulation platforms.

Clearly, the primary advantage of current studies is the ability to permit the same concept to be realized with different modeling tools (e.g., modeling languages and executable formalisms) to draw on the strengths of each tool. There also exist, however, the following collective weaknesses due to the model transformation process that relies heavily on the static models of architectural descriptions, without taking advantage of DM2 and a ?data-centric? approach in the executable modeling.

? Current studies are grounded on the premise that the  information collectively contained in static models must be sufficient and consistent to fully specify the executable models [4], [8]. Either design methodology can produce all the information needed, however, semi-formal semantics in modeling languages make them weak at model consistency checking [10], and maintaining concordance among static models (still manually in many cases) is difficult, especially for a ?product-centric? architectural description.

? Different modeling languages have different symbols (vocabulary), semantics, and syntax [4], which lead to inconsistent representation for the same semantic content in static models. Therefore, the model    transformation process based on the mappings between elements of static and executable models is methodology-dependent and diverse even for the same architecture and same target executable formalism, and needs someone to be familiar with both the original modeling languages and target executable formalisms. It is difficult to be commonly understood and compared across multiple instances.

? The model transformation, usually a manual process, should keep the complete bi-directional traceability between both static and executable models [9]. Due to the lack of a common foundation and specification, current studies offer weak flexibility and adaptability to guide traceable and consistent revisions in the architectural description and executable modeling for an SoS, which needs iterative architecture refinements to better support its evolution and accommodate any changing requirements and context.

3 Proposed Approach In response to the collective weaknesses of current studies, a data-centric executable modeling approach is proposed for SoS architecture by taking full advantage of DM2 and the ?data-centric? approach to provide more flexibility and adaptability to the construction of executable models, as shown in Figure 1. More specifically, several processes are needed to be addressed: a process for establishing the meta-models of architectural data and executable formalism to guide the architectural data modeling and define the executable models, respectively; a process for defining the mapping rules between both meta- models as a common specification at a higher level for the model transformation regardless of the modeling languages; and a process for performing an automated model transformation conforming to established mapping rules and with the support of XML (eXtensible Markup Language) technologies.

Meta-model of Executable Formalism  (Expressed as XML Schema)  Meta-model of Architectural Data  (Expressed as XML Schema)  Mapping Rules between  Meta-models  Executable Model Instance (Expressed in XML or other formats)  Architectural Instance Data (Expressed as XML Document)  Model Transformation  Instance of Instance ofConforms to  XML Technologies e.g., Xpath, XSLT  Based on   Figure 1. Executable modeling overview  3.1 Meta-models for Executable Modeling According to the MDA with MOF (Meta Object Facility) designed by OMG (Object Management Group) [15], architectural models can also be organized within a four-layered architecture. At the top layer, the level M3 is the self-defined meta-meta-model and allows defining meta-models at level M2. A model conforming to its meta-  model is defined at level M1, and represents a real system at the bottom level M0. A meta-model (model of model, or model of metadata) typically defines the abstract syntax of models and the interrelationships between model elements [15]. That is, it is usually defined as a set of concepts or model elements of a language (or within a certain domain), as well as the constraints and rules of how they may be arranged and related to build models without necessarily providing the concrete syntax of the language. Accordingly, the creation of a model populated with instance data can be equivalent to define the model elements in its meta-model with specific attributes of an instance.

DoDAF 2.0 [7] presents DM2, which is an entirely new data meta-model used to organize semantically related data concepts or elements into common taxonomies (terminology having common definitions) of data types and define their associations and attributes based on several important properties of a formal, higher-order, four- dimensionalism ontology called IDEAS (International Defence Enterprise Architecture Specification). The new ?data-centric? approach along with DM2 places greater emphasis on architectural data as the necessary ingredient for architecture development, and then enables static models or views (DoDAF-described Models populated with instance data) and other user-defined views of a subset of architectural data to be built ?Fit-for-Purpose? and in a semantically consistent and interoperable fashion.

By providing the standard terminology and formal/ well-defined semantics, which allow machines to interpret in an automated manner, DM2 can also be used to provide more flexibility and adaptability for executable modeling.

It is a fundamental architecture principle that architectural data elements should be grouped into the six semantically complete interrogatives (i.e., WHO, WHERE, WHAT, WHEN, WHY, and HOW (5W1H)) as data taxonomies at the highest level to ensure consistency in the meaning of each data element [7], [12]. Moreover, DM2 is still undergoing a major evolution, and some of its broad and diverse data types and associations probably would be redundant, while an executable model can be defined as an integrated dynamic model of sequenced Activities (HOW) performed by Performers (WHO) to produce and consume Resources (WHAT) in Locations (WHERE) under specified Rules and Conditions (WHY) [12]. Thus, it is necessary and advantageous for architecture modeling to capture core elements around 5W1H in DM2 for the collection of architectural instance data, which is only needed to be sufficient enough to fully specify the executable models, while not necessarily providing all of the required details demanded by the specific scope of an architecture. In this respect, a simplified meta-model mainly based on the Capability and Activity meta-models of DM2 is established to formally describe core data elements around 5W1H and their associations at the high- level, as depicted in Figure 2. This architectural data meta-    model is also the basis for model concordance; thus, architectural instance data, which conforms to the meta- model with standard terminology and formal semantics, can be collected, maintained, and shared among various stakeholders as a common, consistent and comprehensive data dictionary to increase the potential for application interoperability and reuse, and provide more flexibility and adaptability for executable modeling regardless of what modeling language or methodology is employed to develop architectural descriptions.

PERFORMER (WHO)  Person, Organization, Service, System  CAPABILITY (HOW)  ACTIVITY (HOW)  Operational Activity,  Service Function, System Function  ActivityPartOfCapability  ActivityPerformedByPerformer  ActivityProducesResources  ActivityPartOfActivity  MEASURE  RESOURCE (WHAT)  Information, Data, Material  RULE (WHY)  CONDITION (WHY)  ActivityConsumesResources  LOCATION (WHERE)  ResourceInLocation  RuleConstrainsActivity  ActivityPerformableUnderCondition   Figure 2. Meta-model of high-level data elements  The capability based architectural data modeling process conforming to the aforementioned meta-model can be executed to collect architectural instance data regarding these core elements and associations for executable modeling. Supposing the capability requirements of SoS have been derived via the requirements analysis process, the sequences of Activities (ActivityPartOfActivity) with required resource flows can be identified to achieve the desired Capabilities (ActivityPartOfCapability). Then, system or service based solutions which satisfy the resource flows and support the capabilities are finally obtained by answering a set of questions consistent with the meta-model, as to whether these Activities are performed by Performers (ActivityPerformedByPerformer) to produce and consume Resources (ActivityProducesReso- urce, ActivityConsumesResource) in Locations (ResourceI- nLocation) under specified Rules and Conditions (RuleCo- nstrainsActivity, ActivityPerformedUnderCondition) from both operational and solution-related perspectives. The reader is referred to the literature of DoDAF 2.0 [7] for a detailed exposition on these core elements and associations of DM2 (denoted by italics in this paragraph).

Executable models, which are built based on different executable formalisms, have different interests and involve various abstraction levels. CPN models are well-suited for information systems that consist of a number of communication and synchronous processes, while the others based on ExtendSim are better for performing key performance indicator oriented, data and rule driven simulations for complex systems. Similarly, a meta-model can also be established to formally define the model elements and their relationships of the executable formalism selected to create ?Fit-for-Purpose? executable  models. Wagenhals et al. [9] have established such a meta- model for CPN, as illustrated in Figure 3. CPN will hereafter be used as an illustrative executable formalism in the discussion of the proposed approach.

Figure 3. CPN Meta-model [9]  3.2 Mapping Rules between Meta-models Each static model focuses on particular aspects of the architecture; on the contrary, an executable model defines the time-dependent dynamic behavior around the core elements and associations from holistic 5W1H. Therefore, one can take full advantage of DM2 and the ?data-centric? approach in the model transformation process to construct an executable model automatically by directly pulling related instance data of core data elements and associations collected in the previous data modeling process. This in essence extracts all the architectural instance data needed to populate the executable formalism meta-model.

In order to provide a common transformation specification for executable modeling to be effective on a family of model transformations using same target executable formalism, the mapping rules should be defined at the higher meta-model level, rather than between the elements of static and executable models as is done in current studies. Accordingly, the proposed approach establishes the mapping rules between the meta-models of architectural data and executable formalism as the common transformation specification regardless of what modeling language or methodology is employed in developing architectural descriptions. That is, it requires an understanding of concepts or model elements, semantics, and syntax of the executable formalism, and then assigns its formal execution semantics to the core data elements and their associations of DM2. One needs to compare the meta-models of architectural data and executable formalism, and establish the mapping rules between the elements of both meta-models with semantic consistency and complete bi-directional traceability. That is, the concepts captured in the architectural data meta-model and conveyed by the target executable formalism must be consistent; those expressing the same concept should have the same semantics; and all of the elements in the target    executable formalism must have a mapping from a source architectural data element. Table 1 gives some key mappings from the core architectural data elements (see Figure 2) to the model elements of CPN.

Table 1. Mappings between core data elements and CPN  Core Data Elements CPN CAPABILITY Transition ACTIVITY PERFORMER Place RESOURCE  MEASURE Color Sets, Intital Markings ActivityPartOfCapability Substitution  Transition & Subpage ActivityPartOfActivity  ActivityPerformedByPerformer Place-Arc-Transition  ActivityProducesResource Transition-Arc-Place  ActivityConsumesResource Place-Arc-Transition RuleConstrainsActivity Arc Inscriptions,  Guard Functions, Code Segments ActivityPerformedUnderCondition  3.3 Model Transformation After the mapping rules between both meta-models are defined, model transformation is a process of converting the architectural instance data conforming to architectural data meta-model to the executable model conforming to the executable formalism meta-model. That is, the mapping rules can be seen as a series of operations to construct an executable model by extracting and transforming all the related information from the architectural data meta-model populated with architectural instance data to populate the target executable formalism meta-model. According to the key mappings given in Table 1, the procedure for the model transformation to construct a CPN executable model from architectural data can be defined, as shown in Table 2.

XML is ?a markup language produced by the W3C that defines a set of rules for encoding documents in a format that is both human-readable and machine-readable?, and nowadays a dominant representation format of arbitrary data structures used in many areas [16]. It has become the default format for many office-productivity tools and the common use for the interchange and sharing of data that can occur in a toolset-agnostic, methodology- agnostic environment [7], [16]. Many established XML technologies or specifications can also provide new possibilities for expressing the key mapping rules and the procedure for model transformation in code to enable the automated creation of executable models.

Table 2. Procedure for model transformation  1. Construct the declarations and define the color sets in the index using the attributes of the Measures.

2. Create a substitution transition for each Activity (or Capability) having Sub-Activities, or create a transition for each leaf Activity according to the ActivityPartOfC- apability or ActivityPartOfActivity.

3. Create a place for each Performer or Resource, and assign the appropriate color set.

4. Create arcs to connect transitions and places based on the associations specified in ActivityPerformedByP- erformer, ActivityProducesResource, and ActivityCons- umesResource.

5. Use Rules and Conditions associated with each Activity based on RuleConstrainsActivity and Activity- PerformedUnderCondition to add arc inscriptions, guard functions, or code segments.

6. Create a subpage for each substitution transition.

6.1. Follow steps 2 to 5 to create all the related transitions, places, and arcs.

6.2. Assign places to the appropriate Input, Output, and I/O ports.

7. Specify initial markings for each related place that represents the Performers or Resources.

Thus, the architectural instance data and executable models can be expressed as an XML document conforming to an XML schema, such as XSD (XML Schema Definition) or DTD (Document Type Definition). Since such XML schema languages typically check and formally describe XML documents for validity by constraining the set of elements, their attributes, and the logical structure of an XML document [16], the meta-models of architectural data and executable formalism can also be expressed as XML schemas by mapping every element in each meta- model to appropriate constructs available in the corresponding XML schema. Actually, the meta-models of architectural data in DoDAF 2.0 are expressed in the XSD conforming to the DM2 Physical Exchange Specification; and the model files of executable formalism, such as the CPN in CPN Tools, are XML documents with a DTD/XSD as the model template. Since architectural instance data, as well as some executable models, can be expressed in an XML document with an XML schema, the mapping rules can be expressed in code using the specifications of XSL (eXtensible Stylesheet Language) to automatically produce an executable model. XPath (XML Path Language) defines XPath expressions to select nodes from the XML document of architectural instance data to extract all the information needed for the construction of executable models; and XSLT (XSL Transformation) can be employed for defining the transformation from the XML document of architectural instance data to the document of executable models in XML or other formats according to the procedure for model transformation (see Table 2).

Consequently, during each of the iterative architecture refinements for an SoS architecture, one does not need to    develop the architectural models from scratch, but only to execute actions such as creation of new elements, update of existing elements and deletion of elements in appropriate XML documents.

4 Conclusions In this paper, a data-centric executable modeling approach for SoS architecture is proposed by taking full advantage of DM2 and the ?data-centric? approach to provide more flexibility and adaptability to the construction of executable models. The meta-model of architectural data is firstly defined to guide the architectural data modeling to collect architectural instance data of core data elements and their associations in DM2, which can act as a common, consistent and comprehensive data dictionary for architecture modeling; and the executable formalism meta- model is designed to formally define ?Fit-for-Purpose? executable models. Then, the mapping rules are established at the higher meta-model level as the common transformation specification for executable modeling to be effective on a family of model transformations, no matter what modeling language or methodology is employed in developing architectural descriptions. Finally, XML technologies are discussed to facilitate the automated transformation of executable models from architectural instance data.

Acknowledgements This research was supported in part by the State Scholarship Fund of China under Grant No. 2011611075, and the National Natural Science Foundation of China under Grant Nos. 70971131, 71001104, and 70901074.

