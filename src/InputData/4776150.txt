Research on Algorithms for Association Rules Mining Based on FP-tree

Abstract- Technology of frequent pattern tree is presented in the paper. This paper analyzes the defect and limitation of algorithm based on classic frequent pattern of association rules.

Then based on KDD* model this article implement an association rules algorithms based on IFP-tree. The middle results and finally frequent patterns of the algorithm are stored on database. The algorithm in build IFP-tree and speed of mining frequent patterns has certain improvement. Finally, the experiments reports in the paper confirmed that IFP-tree algorithm if effective and reliable for mining association rules.

Keywords Data mining, Association rules, frequent patterns

I. INTRODUCTION  Since 1993, Agrawal[l] [3] proposed the concept of association rules, the mining of association rules quickly get the attention of data mining experts. The object of mining association rules is the TD (Transactional Database). Mining Association Rules was widely used in catalog design, sale analysis, network detection, biological sequence detection and so on.

Han proposed a new frequent pattern of growth algorithm based on the so-called FP-tree, FP-growth (frequent pattern growth) for short. FP-growth algorithm adopt a new divide and conquer strategy: the algorithm will compresses frequent sets oftransaction database to a database frequent pattern tree (referred to as FP-tree), and still retains itemset related information; Then, such a compressed database is divided into a group of conditions database (also known as conditional pattern base), get a frequent association of each item and each ofthe respective conditional pattern base.

This paper's main work is as follows:  1. Through our research of association rules mining and KDD* model, we found that the classic FP-tree algorithm in the actual process have some problem, such as the low efficiency and the difficulty of secondary development. Because ofFP-tree's defects and limitations of the classic mining algorithms, we propose an IFP-tree improvement algorithm and its intermediate results and FP-tree establish by algorithm have been storied by database. And we have a certain improvement of the time space of built FP-tree.

2. This paper achieves a system of IFP-tree mining algorithm, analysis the time consumption comparison   of changes the building process and the mInIng frequent patterns process when the parameters change. Then we found IFP-tree structure has greatly enhanced the mining rate.



II. BASED ON FP-TREE ASSOCIAnON RULES MINING ALGORITHM  Algorithm FP-tree is described as follows[I][3]: Algorithm: FP-growth. Mine frequent patterns using an  FP-tree by pattern fragment growth.

Input: A transaction database, D; minimum support  threshold, min_sup.

Output: The complete set of frequent patterns.

Method: The FP-tree is constructed in the following steps.

Scan the transaction database D once. Collect the set of  frequent items F and their supports. Sort F in support descending order as L, the list of frequent items.

Create the root of an FP-tree, and label it an "null". For each transaction Trans in D do the following.

Select and sort the frequent items in Trans according to the order of L. Let the sorted frequent item list in Trans be[p,P],where p is the first element and P is the remaining list.

Call insert_tree([p,P],T),which is performed as follows. If T has a child N such that N.item-name=p.item-name, then increment N's count by 1; else create a new node N, and let ites count be 1, its parent link be linked to T, and its node-link to the nodes with the same item-name via the node-link structure. IfP is nonempty, call insert_tree(P,N) recursively.

Mining of an FP-tree is performed by calling FP~rowth(FP_tree,null), which is implemented as follows.

Procedure FP-growth(Tree, a) IfTree contains a single path P then For each combination (denoted as f3) of the nodes in the  pathP Generate pattern PUa with supports=minimum support  ofnodes in f3  Else for each aj in the header of Tree{  Generate pattern f3 = aj Ua with support= aj .support; Construct f3 ,s conditional pattern base and then P 's  conditional FP_tree Treep ;  if Treep =1= 0 then    call FP-growth (Tree? ? ? );} Example: Transaction database TID is showed as Table 1,  and the minimum support is two(min_sup=2/9 22%) ? Table 1 Transaction TID  Transaction TID Item list of transaction  A,B,E  2 B,D  3 B,C  4 A,B,D  5 A,C  6 B,C  7 A,C  8 A,B,C,E  9 A,B,C  The frequent patterns generated by algorithm 2-1 and showed in Table 2, whose consume is showed in Table 3 as follows.

Table 2 frequent patterns generated  item Conditional pattern base  conditional FP-tree  frequent patterns generated  E {(BA:1), (BAC:1)}  <B:2,A:2> BE:2 AE:2  BAE:2 D {(BA:1),(B:1)} <B:2> BD:2 C {(BA:2),  (B:2), (A:2)}  <B:4,A:2>, <A:2>  BC:4 AC:4  BAC:  2 A {(B:4)} <B:4> BA:4   Table 3 consume of mining  item support consume(seek node's left brother)  B 7 7  A 6 8  C 6 12  D 2 3  E 2 3

III. KDD* MODEL  In the KDD* process model[7], the heuristic coordinator and the maintaining coordinator are the most essential mechanisms. The heuristic coordinator simulates the ?intention creation? in cognitive psychology, so that the shortage of knowledge could be found. In the classical KDD process, the focus depends on user?s interest, consequently much useful knowledge would be neglected. So the heuristic coordinator could help the system of KDD obtain hidden useful knowledge, and work more actively, that the human experts? confinement would be counterbalanced.

The maintaining coordinator simulates the ?psychological information renovation?, a feature in cognitive psychology, so that the real-time maintenance of knowledgebase is realized. Because of the maintaining coordinator?s  introduction, under the correct definitions of repetition, contradiction and redundancy, the repeated, contradicted and redundant knowledge could be processed in real time by super graph theory. As a result, only the hypothesis of knowledge which is possible to be new know ledges, needs to be processed, and furthest diminish the workload. In the practical expert system, the new knowledge is usually much less than the hypothesis of knowledge, hence maintaining coordinator would improve the efficiency of the system. (As shown in Figure 1).

Heuristic coordinator  Focus  Obtain hypothetic rules  Preprocess Real database  Split sub-databases  Form data subclass structure according to sub-databases, construct mining database  Directional mining process  Move the rules obtained into  knowledge database  According to  user?s demand,  interests.

Maintaining coordinator  Basic knowledgebase  Assess  Derivative knowledge database  Split sub-knowledgebases  Separate knowledge nodes according to attributes, form conclusion arcs, construct mining knowledgebase.

Search disconnected status from knowledge nodes in mining database, discover knowledge shortage.

(Directional searching)  (Directional mining)   Figure 1 KDD* process model  The kernel technologies of the 2 coordinators (algorithms) shown above, are ?directional searching? and ?directional mining?, our paper[7] proposed the mechanism double bases cooperation, meanwhile constructed the equivalent relations between database and knowledgebase under their specific conformations.

Lemma 1 (conformation mapping theorem) [7]: There is an equivalent relations between the inferential category of universe X, Cr(?) and complete data substructure reachable category C?<???c(?)>.(Proof is abbreviated)  This theorem establishes the one-to-one correspondence between knowledge single node and ?data substructure? in database (As shown in Figure 2).Double bases cooperation mechanism resolves fundamentally the problem of ?directional searching? and ?directional mining?.

Sub-Database(For universe X) Sub-Knowledgebase(For universe X)   Figure 2 Knowledge single, compound node and their relations in  Knowledgebase  Algorithm 1 Maradbcm[7]: Input: Rule strength threshold Min_Intensity, support threshold  Min_Sup, confidence threshold Min_Con;  To Sj?s certain layer  To Si?s certain layer  Knowledge single node Pi Si  To Sk?s certain layer  Sj  Sk  Knowledge single node  Pj  decompound  K now  ledge com  pound node  Knowledge single node  Pk    Output: Association rule base KD.

1. Data preprocess; 2. When ?shortage of knowledge? is detected 3.  Create K2;//Km denotes the shortage knowledge whose length  is m, namely Km={r| Len(r)=m}.

4.    m = 2; 5.    Create hypothesis of knowledge Km; // Directional mining the  shortage of knowledge ri in Km.

6.    Repeat 7.        For every ri in Km 8.    If (ri is conformed with present knowledgebase && the  measure of ri is qualified) 9.        move ri into KD, update reachable matrix; 10.   Else 11.       delete ri; 12.   Endfor; 13.       m = m+1; 14.   Until Km=?; 15. EndWhen; Based on KDD* process model, our paper[7] designed an  association analysis algorithm, Maradbcm.

Relative to KDD, KDD* fuses the KDD and double bases  cooperation mechanism, so that it is a novel knowledge discovery process model, and there are several features of it:  1) KDD* organically integrates and fuses the new knowledge mined by KDD* and the inhere knowledge in basic knowledgebase;  2) In the process of KDD, KDD* relieves the complexity of data accumulation, meanwhile provides the prior condition for the fusion of new, inhere knowledge;  3) Double bases cooperation mechanism, in itself, is capable of evolving as the structure?s changing;  4) KDD* changes and optimizes the process and mechanism of knowledge discovery, realizes ?multi-origin? focus, and diminishes the workload of assessment;  5) From the aspect of cognitive science, KDD* enhances and upgrades the intelligence of KDD, and improves its ability of cognitive activeness;  6) Double bases cooperation mechanism, reveals the relations between the sub knowledgebase and data substructure, under certain principle of construction of bases;  7) Double bases cooperation mechanism and KDD* model that is induced from former, derives a novel algorithm, Maradbcm, which is more expansible and effective relatively to prevailing algorithms.



IV.  BASE ON IFP-TREE ASSOCIATION RULES ALGORITHM  We based on KDD* model analyzed FP-tree structure, then found out that they have some deficiencies as following: (1) through root note procedure recursive search FP-tree, when tree structure has become a huge size, efficiency of recursive procedure will become very low, (2) all the path generated from algorithm to aim at the minimum support, need to do adjusted from the path below the minimum support of node to delete, and this means an additional burden.

Therefore, we propose an improved prefix FP-tree IFP-tree based on FP-tree.

Aim to the minimum support threshold min supDB  which is set by user, it statics frequent items of transaction database  DB. According to the frequency of frequent item sort the item of dataset by descending. The item subset before any item in the sorting of some itemset is called prefix item. Especially, the prefix item of root node is null. The back item of item subset is called suffix item.

Property 4.1 Nods which is point to same father node in the prefix table has the same prefix item.

Property 4.2 Depth of prefix table is the maximum length of corresponding transaction database DB?s frequent itemset.

Property 4.3 Candidate frequent itemset of each transaction in transaction database conclude in one path in prefix table.

Property 4.4 Two nodes , iX , (jY iX  is indicated node X in  the i-the layer of FP-tree, and  is corresponding indicated  node Y in the j-th layer of FP-tree)in one path of prefix table, if i<j(means node X is up to node Y, node X is the prefix node  of Y),then .

jY  . .i jX count Y count> Prove: From the constructing process of FP-tree, it is  obviously that the node?s prefix item count in prefix table is definitely no less than count of suffix item.

Through property 4.4, we get the deduction 4.4.1, 4.4.2 of property 4.4.

Deduction 4.4.1 When one path in prefix table  exists iX ,  and i <j, thenjY mX ,  node in the other path satisfied m<n.

nY  Prove: If it is not satisfied, then one path in prefix table  exists iX ,  and i <j, there be existjY mX ,  in the other path satisfied m>n. It?s conflict with property 3.4.

nY  Definition 4.1 From node link and tail link generated all X?s node link in prefix table, is called node link base on head  table X, recorded as 1 2  1 2 ~ k  k i i iX X X  In  which  1 2  1 2. . . .

k  k i i iX count X count X count X count+ + + = .

Figure 3 Deduction 4.4.2 Deduction 4.4.2 Two node X,Y?s node link in prefix table  are 1 2  1 2 ~ k  k i i iX X X , , if exists a path which  contain ,then node X,Y in the other  path must satisfied . The node link of  X,Y  1 2  1 2 ~ k  m j j jY Y Y  . .i jX count Y count>  . .i jX count Y count>  1 2  1 2 ~ k  k i i iX X X ?  cannot be intersect, t 1 2  1 2 ~ k  m j j jY Y Y  iX  jY  nY  mX    there is no exist such X,Y node which is satisfied  . .

j  m n iX count Y count> and  . .

s  p q rX count Y count< (shown in Figure 3).

Deduction 4.4.2 means node links connect with node link in  head item table and same node in node tree each cannot be intersect. This deduction is an important property for the following data mining job.

We analyzed FP-tree structure, then found out that they have some deficiencies as following: (1) through root note procedure recursive search FP-tree, when tree structure has become a huge size, efficiency of recursive procedure will become very low, (2) all the path generated from algorithm to aim at the minimum support, need to do adjusted from the path below the minimum support of node to delete, and this means an additional burden.

Improvement of the IFP-tree structure can solve these two problems, it increase the father nodes? information in node information, so that change the entire mining algorithms from argument, not to use recursive structure, and mining from bottom to up, meet the minimum support of the smallest node, the bottom-up search for frequent pattern, storage to frequent pattern table, and then corresponding mining the frequent pattern. In this way, we can effectively avoid lower efficiency of the recurring operating process and the path consumption of the generated path.

The improved FP-tree algorithm is based on SQL-Server databases, the mining data save in the temporary data table.

The classical establishment FP-tree steps as follows: scan DB once to get the frequency of itemset, which is save into the item head table, and sort with the frequency descending. Then read each data in the transaction from temporary data table, according to sorting of item head table?s order (for generate the size of FP-tree as small as possible). From "null" node as the beginning of insertion, inert the sorted transaction data to FP-tree. If the same node is existed, plus one to the node of count domain; if not the same node there, and then insert a new node, set the node?s count domain one. Read the node information in the item head table, if there is first time, and then connect it to the corresponding node link in item head table; if node link in item head table is no null, then through node link find out the last node, and link to the back of the node. In the mining process of IFP-tree, we add a tail domain in item head table to record the last node, so in the process of the insert node, it can quickly target to the last node, directly connect the node and enhance the efficiency of the constructing FP-tree.

The structure of IFP-tree has also added the link of sub-node point at the parent node and stored in the node information, so that change the classic FP-tree?s one-way link structure and increase the link of the sub-node connected to parent node reversely. That makes the mining process significantly speed up.

An example of transaction data sets is Table 1, and the minimum support is 3. The process of construction is as same as the previous FP-tree tree construction; the different is the update methods to information of node link in item head table.

IFP-tree?s new way is find out last node directly from the node?s tail link information, add the new node to the back of last node, then update the tail link information to the new node.

Table 4   compare with IFP-tree and FP-tree?s consume  item support consume(IFP-tree) consume(FP-tree)  B 7 7 7  A 6 6 8  C 6 6 12  D 2 2 3  E 2 2 3  Through table 4 we can clearly see that the new IFP-tree have a great advantage to the original FP-tree in the search of left items, so the whole time will be able to sharply cut down.

And we save the middle result of mining to database. The middle result contains nodes, item head table information, generated frequent patterns. It can facilitate secondary treatment of mining and incremental mining. The database as stored data can use the available tools provided by the database to facilitate the massive data operation, increase the using of disk space and I/O speed, because the results generated by mining are relatively small, in this way it is also effective for storage due to the reduction of the disk fragment.



V. EXPERIMENT ANALYSIS  For test of the improved association rules mining algorithm, we choose the standard test database (mushroom database) which is recorded 23 attributes details of mushroom, in total 8124 records. From mushroom database we randomly sample 100, 200, 300, 500, 1000 records to make up mushroom_100, mushroom_200, mushroom_300, mushroom_500, mushroom_1000 as test data.

From the entire data mining process, the time consumption compose of four main parts, the first part is open mining files, import data mining files into the temporary tables; second part is static the frequency of the transaction data, and generate item head table; third part is construction of FP-tree, sort original transaction data by the item frequency in item head table, then insert to the FP-tree and update node?s ritem_no domain; the last part is mining frequent pattern and association rules based on the minimum support and store to the database.

As showed in figure 4, we can see that consume of mining time and the number of transaction in dataset is linear, that keep when the number of transaction in database increase linearly the total time complexity is no become exponential increase.

4.08375 6.9485  11.39625  16.11625  26.0035         100 200 300 500 1000  the number of transaction in mining file  s e c o n d   Figure 4 relationship of transaction?s number and time consume of construct  FP-tree          950 800 600 400 200 100  FP-tree  IFP-tree   Figure 5 comparison of FP-tree and IFP-tree(mushroom_1000)  In Figure 5, it shows the different time consumes of FP-tree and IFP-tree whose minimum support is 100, 200, 600, 800 and 950. It?s clearly that the IFP-tree is superior to the FP-tree in frequent pattern mining. From our experiment , base on the IFP-tree association rules algorithm is effective and reliable.

VI CONCLUSION  In this paper, we discuss the association rules mining algorithm based on frequent pattern tree, find out the problem of classic algorithm, and propose an improved association rules algorithm base on IFP-tree. The experiment illustrate the IFP-tree has something improvement in construction of frequent pattern trees. Forward we will improve the frequent pattern tree algorithm in the web application of data mining, privacy protection and information security field.

