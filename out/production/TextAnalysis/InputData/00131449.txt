An Association Algebra  For Processing Object-Oriented Databases t

Abstract: This paper presents an association algebra (A- algebra) for manipulating 0-0 databases which is analogous to the relational algebra for relational databases. In this algebra, objects and their associations in an 0-0 database are uniform- ly represented by association pattems and are manipulated by a number of operators. These operators are defined to operate on association pattems of both heterogeneous and homogene- ous structures. Very complex structures (e.g., network struc- tures of object associations across several classes) can be directly manipulated by these operators. Therefore, the associ- ation algebra has greater expressive power than the relational algebra which manipulates on relations of compatible struc- tures. Some mathematical propezties of these operators are described in this paper together with their application in query decomposition and optimization. The algebra has been used as the basis for the design and implementation of an 0-0 query language called OQL and a knowledge rule specification language.

1. Related Work and Motivations Object-Oriented (0-0) and semantic data models  [HAM81, BAT84, KIN84, DAD86, MAI86, MAN86, SU86, ZDO86, BAN87, FIS87, KIM87, ROW87, ZD087, CAR88.

CHR88, COL89, SU89] offer more powerful constructs for modeling the structural and behavioral properties of objects found in advanced applications such as CAD/CAM, CASE, and decision support. For these models to be truly useful, they must provide some object manipulation languages, which can take advantage of the expressive power of the models and provide the users with simple and powerful querying facilities.

Recently, several query languages such as DAPLAX [SHIIl],  EL [ROW87], EXCESS [CAR88], and others reported in [DAD86, MAN86, BAN87, FIS87, BAN88, COL89, SHAW] have been proposed. These languages were developed based on different paradigms. For example, DAPLAX and the query language of w 8 6 ]  are based on the functional paradigm.

The query language of PAN881 is based on the message pass- ing paradigm. Other query languages are based on the rela- tional paradigm: an extension of Q U E  wOW87, CAR881; an extension of SQL [DAD86]; and an extension of the relational algebra [COL89]. The query language of m 8 7 ]  is based on both functional and relational paradigms, allowing functions to be used in Object-oriented SQL (OSQL) constructs.

The above languages have 0-0 flavor and have taken significant s t e p s  towards the development of a powerful 0-0 query language. Query languages such as DAPLAX [SHI81], GEM [ZAN83], ARIEL [MACS], and the object-oriented t 'lxs research IS supported by the National Science Foundation (DMC-8814989) and t k  National Institute of Standard and Technol- ogy (60KANB4W017). The development effort is supported by the Florida High Technology and Industrial Council (UPN88092237).

GEM [ZAN83], ARIEL [MAC85], FAD PAN871, POSTQU-  query language described in [BAN881 are based on an object- oriented view of a database defined in terms of objects, object classes, and their associations. A query in these languages is formulated by speclfying a class (usually a nonprimitive-class, whose instances are real world objects) in the schema as a central class with some path expressions. Each path expres- sion starts from the central class and ends at another class (usually a primitiveclass, whose instances are of basic data types sucn as integer, string, set, and etc.). A restriction con- dition can be specified on the class referenced at the end of a path expression. This class can also be specified in the list of attributes to be retrieved. The result of a query is a set of tu- ples, each of which corresponds to a single instance of the central class and contains values related to that instance which are collected from classes specified in the list.

A major drawback of these query languages is that they do not maintain the closure property [ALA89]. In these languages, the input to a query has an 0-0 representation (i.e., a network of objects, classes, and their associations) whereas its output is a relation which does not have the same structural and behavioral properties as the original objects. Consequent- ly, the result of a query cannot be further processed by the same set of language operators.

The query languages proposed in [DAD86, MAN86.

BAN87, ROW87, CAR88, COL891 use nested relations as their logical views of 0-0 databases. Although these languages are closed, i.e., operators in these languages operate on nested relations and produce nested relations, the nested relations, in our view, is not a proper logical representation for an 0-0 database which is basically a network structure of ob- ject associations. Mapping from a network representation to nested relations is an extra process. Furthermore, the relation- ships among objects in 0-0 databases are not restricted to plane graphs. It can be as complicated as a surface graph. In order to use a nested relation to represent these complex struc- tures, a large amount of data has to be replicated in the representation.

A query algebra [SHAW] was proposed recently based on the 0-0 model ENCORE [ELM89]. Although ENCORE models applications as networks of objects, object types, and their associations, the domain of the algebra is defined as sets of objects of the Tuple type, which is essentially the nested re- lation representation since it allows the nesting of tuples.

Therefore, the mapping problem addressed above still remains.

In this algebra, two identical queries or two identical opera- tions in a single query do not give the same response, since each result collection is a newly identified object in the data- base. To eliminate duplicated copies of the same newly creat- ed object, the algebra introduces operations named DupElim- inate and Coalesce, which would not be necessary if the alge- bra were to directly support the network structured processing of 0-0 databases. We further observe that the union operation + this algebra may produce a collection of objects having the  CH2968-6/0000/0023$01 .OO 0 1991 IEEE    same data type but with different structures (e.g., the union of two collections of objects of the Tuple type with different ari- ties). Nevertheless, the other operators introduced in this alge- bra are not defined to operate on collections of objects with heterogeneous structures.

A common limitation of many existing query languages is that they cannot express "non-association" relationship between objects easily, i.e.. identify objects in two classes that are not associated with each other while their classes are. For example, in an 0-0 database, Suppliers s l  and s2 supply Parts p l  and p2, respectively. GEM, FQSTQUEL, and several other query languages provide the "dot" construct (Suppliers.Parts) and ARIEL provides the "of" construct (Parts of Suppliers) to navigate from class Suppliers to class Parts to produce object pairs (s1,pl) and ( ~ 2 . ~ 2 ) .  However, they do not have a language construct for specifying the semantics that s l  does not supply p2 and s2 does not supply pl .  Similarly, in func- tional languages, only the function Parts(Suppliers) is provided to specify the associations of ( s l q l )  and ( ~ 2 . ~ 2 )  but not the non-association of these suppliers and parts.

To conclude our survey of the related works, we would like to stress the importance of using graphs as the logical representation of an 0-0 database at both intensional and ex- tensional levels as exemplified by 0 2  [LEC88], FAD [BAN87], and OSAM* [SU89]. The query language and its underlying algebra should provide constructs to directly pro- cess graphs with different degree of complexity. They should also support the spitication of non-associations and the pro- cessing of heterogeneous s t~ctures .  Furthermore. the closure property should be maintained.

In this paper, we propose an Association Algebra (A- algebra), which uses graph as the representation of 0-0 data- bases and operates on the graph. Analogous to the develop- ment of the relational algebra for relational databases, the development of the A-algebra provides the formal foundation for query processing and optimization in 0-0 databases and for designing 0-0 query languages. Unlike the record(tup1e)- based relational algebra [COD70 and COD721 and the query algebra [SHA90], the A-algebra is association-based, i.e., the domain oftfie algebra is sets of association pattems (e.g., linear structures, trees, lattices, networks, etc.) and processing an 0-0 database is based on the matching and manipulation of heterogeneous or homogeneous pattems of object associations.

Operators of the A-algebra can be used to navigate along the path of interest to construct a pattem with a complicated struc- ture from those with simple structures, or to decompose a complicated one. Nine operators have been defined: two unary operators [A-Select (a) and A-Project (n)]  and seven binary operators [Associate (a), A-Complement (\), A-Union (+). A-Difference (-), A-Divide (+), NonAssociate (!), and A-Intersect (o)], where. the prefix A- stands for "Association".

Although, many of these operators correspond to the relational algebra operators, they are different from them in that they operate on complicated heterogeneous s t ~ c t u r e ~ .  In this respect, the A-algebra is more general than the relational alge- bra.

Based on the A-algebra, an 0-0 Query Language (OQL) [ALA89a, ALA89bI and a knowledge rule specification language [ALA901 for the 0-0 semantic data model OSAM* [SU89] have been developed and implemented [SU88, LAM89, PAN89, CHU90, SI"].

The rest of this paper is organized as follows. Some basic concepts in association-based query formulation are described in Section 2 with the help of examples. In Section 3, after giving the formal definitions of Schema Graph (SG), Ob- ject Graph (OG), and association pattem, the formal definitions of the association operators are presented. Simple mathematical properties are given after the definition of each  operator. The A-algebra expressions for some example queries are given to demonstrate the utility of the algebra. In Section 4, additional properties of the association operators are presented. Fiially, the conclusion is given in Section 5.

2. Association-based Query Formulation 0-0 semantic data models provide a conceptual basis for  defining 0-0 databases. Although each model has some unique constructs, there are several common structural and behavioral properties based on which an algebra can be developed and used to suppolt these models. First, an object is assigned a system-wide unique object identifier (OD) so that it can be unambiguously distinguished and referenced.

Second, objects having the same structural and behavioral pro- pedes are grouped together to form an object class. Third (and very important), object classes and their objects are inter-related (i.e.. associated) with other classes and their ob- jects in the database. Different 0-0 models recognize different types of associations. For example, two of the most commonly recognized associations are aggregation and gen- eralization. Aggregation captures the semantics of is-part-of, is-composed-of, or has-properties-of. It allows an object class (and its objects) to be defined in terms of other object classes (and their objects). Generalization captures the seman- tics of is-a or is-a-kind-of relationship. Objects in a sub- class inherit the structural and behavioral propedes of its su- pelrlasses.

The semantics of these and other association types can be expressed in texms of constraints governing the data mani- pulation and retrieval operations on objects of the associated classes. They are either implemented in the 0-0 DBMS or declared by rules which are then processed by a rule process- ing component of an 0-0 DBMS. An underlying algebra does not have to distinguish these association types since they are explicitly d e h e d  in a schema and their semantics are im- plemented in an 0-0 DBMS. For this reason, the algebra in- troduced for manipulating an 0-0 database does not have to incorporate the semantics of association types. This is particu- larly important if the algebra is to be used as a general algebra for supporting a variety of 0-0 models.

Thus, from the algebra point of view, an 0-0 semantic database can be viewed as a collection of objects, grouped to- gether in classes, and inter-related among each other through some type-less associations. At the intensional (i.e., schema) level, we can view an 0-0 database uniformly as a collection of object classes inter-related through type-less associations.

For example, a schema for a university database is graphical- ly illustrated in Figure 1. Each rectangle denotes a nonprimitive-class which represents a class containing objects of interest in an application, such as a class of person objects or a class of department objects. Objects in a nonprimitive- class are assigned with system-wide unique object identifiers (or ODs). Each circle denotes a primitiveclass which represents a class of primitive objects which serve as a domain for defining or describing other objects, e.g., a class of names or a class of age values. Associations among object classes are denoted by the edges between the classes in the schema graph. All edges are bi-directional. Query processing in- volves the traversal of object classes along these edges.

At the extensional (i.e., instance) level, a database can be viewed as a collection of objects, grouped together in classes, and inter-related through type-less associations. For example, an object graph corresponding to a part of the university schema graph is shown in Figure 2. In this exam- ple, the Course object c2 is associated with two Section ob- jects, representing the fact that two sections of the course c2 are offered. The Section object sc2 is taught by Teacher t2 and is taken by Student s l ,  s2, and s3. Finally, each Student object is associated with a GPA object.

GPA Student  Figure 1 Schema Graph of a University Database  Based on the extensional view of a database, the user can query the database by specifying pattems of object associ- ations as the search condition to select some objects for further processing by either system-defined operations such as re- trieval, display, update, insert, delete, etc., or user-&fined operations such as rotate a design object, purchase a part, hire a faculty member, etc. For example, the following two queries can be issued against the university database illustrated in Figures 1 and 2.

Query 1: Get the social security numbers of the teaching assistants.

It is clear that objects associated in the following pattem  T A 4 r a d 4 3  tudentPerso&S#  Here, the lines connecting the classes represent the traversal path. They will be replaced by the association opera- tors to be defined later. It should be noted that since the A- algebra is at a level lower than the high-level query languages provided to the user, it provides a way to describe and imple- ment this retrieval by specifying the pattem using some primi- tive operators rather than including the inheritance concept in the algebra. An association-based high-level language, how- ever, can specify the pattem T A S S #  for this query based on the inheritance concept and the query interpreter will translate it into the corresponding A-algebra expression based on the schema definition.

We further note that this and other examples given in this paper assume that objects of a subclass (e.g., TA) are also members of its superclasses (e.g., Student and Person).

Instances are the representations of objects in different classes.

Thus, "dynamic inheritance" is assumed in this paper which is different from the "static inheritance" of attributes used in SMALLTALK-like 0-0 models [GOLSl]. The A-algebra is applicable to both inheritance methods.

Query 2: For a l l  sections of courses offered by the CIS department, get the specialties of faculty members who are teaching them. Also, get the earned credits and the GPAs of those students who are taking sections of these courses.

To satisfy the query, the following operations are required in the algebra level:  (1) Get the Specialty of the Faculty objects who satisfy the following association pattem,  Specialty-Faculty-Teacher-Section-Course Name[ CIS ]-Department I  which represents the specialties of faculty members who are teachers who teaches sections of courses offered by the CIS department.

(2) Get the GPAs and Earned-Credits of the Student objects  who satisfy the following association pattem,  Flgure 2 Object Graph  G P ~ t u d e n t S e c t i o ~ o u ~ - D e p a r t m e n t - " e [ ~ ~ ~ l Earned-Crkdit  According to the stated query, the GPAs and Eamed Credits of students who are taking sections of CIS couseswhich do not have teachers with specialties should be included in the result. Similarly, the specialties of teachers who are teaching sections of CIS courses which do not have students with GPAs and Earned Credits should also be included. This means that there iZ a logical OR condition between two subpattems merged at Section as shown in Fig- ure 3. In this figure, the single arc at Section represents the "OR" condition and the double arc at Student represents the "AND" condition which requires that a student object be asso- ciated with both GPA and Earned-Credit.

It should be clear to the reader that this association- based query formulation is quite different from the record- based query formulation in the existing relational query languages which matches key attributes with foreign keys in different relations. A complex pattem of object associations may contain branches with logical AND and OR conditions and complex network structures. Such pattems, which can be specified in an association-based language in a rather straight- forward manner, can only be specified in a relational query using complex nested query blocks or multiple queries [ALA89a]. The association algebra to be described below provides the operators and the mathematical basis for process- ing heterogeneous as well as homogeneous pattems of object associations.

3. Association Algebra (A-algebra) 3.1 Definitions  First, we formally define an 0-0 database at both schema and object levels.

Schema Graph (the intensional database): The schema graph of an 0-0 database is defined as SG(C,A), where C=( C,) is a set of vertices representing object classes; A is a set of edges, each of which, A, (k), represents association between classes C, and C,, where .k is a number for distinguishing the edges from one another when there is more than one edge between two vertices.

Object Graph (the extensional database): The object graph of an 0-0 database is defined as OG(0.E). where 0=(01,,} is a set of vertices representin object instances (jth object instance in class Cl); and E={Ol,,&,,,,,] is a set of edges represent- ing the associations among object instances. When an instance is connected with another in the object graph, a regular-edge (so$d line) is drawn between the corresponding vertices as O,,-O,, which specifies that jth instance in class C1 is related to nth instance in class C ,  through the kth association of classes CI and C,. If two object instances 01, and O,,,, are not connected in the object graph but their classes CI and C, in the corresponding SG are directly connected, a complementedge (dotted line) is drawn between them and is denoted by O,k.O,,.

- -~     NannlClSl Dapanmnl COV- seciton  T.2.C.ch.r  Faculty  SI"d.nl  Ea"dcr.6,1 Figure 7 3 Query by Pattern Sp.clalw  In this 0-0 paradigm, an object may participate in several classes (in a generalization hierarchyfiattice). Its representation in a class is called an object instance.

The reason for explicitly introducing complement-edges into the OG is to d o w  the A-algebra to manipulate both asso- ciation and non-association between object instances of two adjacent classes. In an 0-0 database, it is not necessary to explicitly store the complement-edges. Figure 4 illustrates the regular-edges and complement-edges among the object instances of three object classes. For example, we see that sec- tion scl is taken by students s2 and s3 (regular-edges) and not taken by students sl and s4 (complement-edges).

To d e h e  "association pattern", we first extend the con- cept of connected graphs in graph theory by Creating complement-edges as edges, i.e., a connected graph is a graph in which there exists at least one path between any two ver- tices and each path may contain regularedges, complement- edges, or a combination of the two. We shall, from now on, use an upper-case letter to denote a class and the correspond- ing lower-case letter with a subscript to denote an object instance in that class. We shall assume that there is only one edge between any two vertices in SG unless otherwise specified so as not to complicate the notation.

Association Pattern: A connected subgraph of an OG is an association pattem (or pattem for short).

By this definition, a single vertex is an association pat- tem. We call it an Inner-association-pattem (Inner-pattem for short). It is algebraically represented as (a,) for a vertex of class A. A regular-edge together with two vertices (i.e., two Inner-pattems) it connects is c d e d  an Inter-association-pattem (Inter-pattem) which is represented as (albJ). This pattem states that object instances a, and bJ are associated with each other in OG. A complement-edge together with the two Inner-pattems it connects is called a Complement-associatkn-  attem (Complement-pattern) and is represented as (albj).

k s  pattem states that a , and b, are not associated with each other in OG. An 0-0 data contains only Inter-pattems.

Complement-patterns are derived during query processing to manipulate object instances that are not associated with one another. If a path consists of only regular-edges between non-adjacent vertices a, and bJ, it is represented by a Derived- inter-association-pattem @-Inter-pattem). denoted by (a;b); otherwise, it can be represented by a Derivedcomplement- association-pattern (D-Complement-pattem), denoted (a;bl ). When a path is represented by a derived pattem,$ simply means that two vertices are indirectly (or directly) associated or non-associated but how they are interrelated (the actual path) is of no importance. A D-Inter-pattem is treated as an Inter-pattem and a D-Complement-pattem is treated as a Complement-pattem in the algebraic operations.

The above five types of pattems are the primitive pat- terns the latter four being binary pattems. Their graphical and algebraic representations a~ illustrated in Figure 5a All other connected subgraphs are called complex pattems. For exam- ple, the complex pattem shown in Figure 5bl  contains three primitive pattems: twoAter-patterns (albl) and (bid,), and a Complement-pattem (blcl). It can be uniquely defined by its algebraic representation as a set of primitive pattems, i.e., (a,bl,b!d,,blcl). More examples of complex pattems are shown m Figure 5b.

Figure 4 Regular-edges and Complement-edges  The definitions of OG and association pattern imply that a pattern is a non-directional graph, i.e., (albj) = (bj.3,). and that the sequence of primitive pattems in the algebraic repsentation of acomplex pattern is not important, hence  Based on the above definition and notion of association pattern, we view an OG as an Association Graph (AG) and all the association pattems in AG form the domain of the A- algebra, denoted as A.

(qbJ. bJcd = (qbJ* bbJ)*  ,.#rZ:r%,m re;!%%t,o"  0 la11  a1 b1 c1 bl C I  dl  Figure 5 (a) primitive panerns  Examples 01 Association Patterns (b) complex patterns  3.2 Relationship Between Two Association Pattems The operators of the A-algebra are defined based on the  possible relationships between two pattems in A, so that they can be used either to construct complex pattems using simpler pattems or to decompose a complex pattern into several pat- tems of simpler structures. There are four possible relation- ships between two pattems p' and p': non-overlap, overlap, contain, and equal.

(1) Non-overlap: Two pattems are said to be non-overlap,  denoted by p'~>cp*. if they have no common Inner- pattern.

(2) Overlap: Two patterns are said to be overlapped, denoted by P'PP', if they have at least one common Inner-pattern.

(3) Contain: Contain is a special case of (2) when all the primitive pattems of a pattem (p') are contained in another (p'). We say that pl is a subpattern of p2 and denote this relationship by PI-'.

(4) Equal: This is a special case of (3) when a pattem con- tams all the primitive pattems of another, and vise versa. It is denoted by p'=p2.

Before defining the nine association operators, we give the definition of "Association-set" -- the operand of the associ- ation operators.

Association-set: An association-set, denoted by a Greek letter a (or p,y, ...), is a set of association pattems without duplicates. If a superscript a' designates the ith pattem in a, then ai#aJ (i#]). An empty set is also an association-set, denoted by +.

-     A B C D A special type of association-set is called homogeneous association-set, which is important to the A-algebra, since some of the mathematical properties hold only when operands are homogeneous association-sets.

HomogeneousAssociation-set: An association-set is homo- geneous, if (1) all patterns are formed by Inner-pattems from the same set  (2) all patterns have the same number of Inner-patterns from  (3) all pattems have the same topology and their comspond-  Otherwise, it is a heterogeneous association-set.

of object classes; and  each class in the set; and  ing primitive pattems are of the same type.

Figure 6 depicts three example association-sets: a is homogeneous, whereas $ is not since pattem $' has only one Inner-pattem of class C instead of two as in $' and $'. 7 is not homogeneous because contains a Complement-pattem which is different from 7' and y.

a Y  Figure 6 Examples of Assoclation Sets  - 3.3 Association Operators Nine association operators are formally defined in this  section: two unary operators [A-Project (ll) and A-Select (o)] and seven binary operators [Association (*), A-Complement (I), A-Union (+), A-Difference (-), A-Divide (+), NonAssoci- ate (!), and A-Intersect (e)]. The examples used to explain these operators will make use of the domain a shown in Fig- ure 7. To keep the graph simple, the Complement-pattems are not shown in the figure. The mathematical properties such as commutativity, associativity, and idempotency satisfied by the operators are given after each definition.

3.3.1 Notations  as follows: A, B....,K Denote classes.

CLI [R(CLl,CL2)]  ai  -~ Notations that will be used in the subsequent sections are  Denotes variable for a class.

Denotes the association between classes CLI  Denotes the ith Inner-pattern of class A.

Denotes an Inner-pattern variable.

Denotes an Inter-pattern between two classes A and B.

Denotes a Complement-pattem between two classes A and B.

(a&, Denotes a Derived-pattem from class A to class C.

a $, 7.-. Denote association-sets.

ai Denotes ith pattem of association-set a.

( W ) , { X ) , ( Y ) ,  ... Denote sets of classes. Hence, alx)  represents a which has Inner-pattem(s) from the classes in (XI.

It should be noted that an Inner-pattem (Le., an object instance) is represented by an instance identifier (m)), which is a system-assigned object identifier (OD)  prefixed by its class identification so that the object instances of an object in multiple classes can be unambiguously distinguished and the fact that these object instances are of the same object can easily be recognized.

and CL2.

@, (albJ)  (albJ)  Figure 7 A Sample Database Association Graph ,The C-prrtcrn. *r. nor ,bo"",  3.3.2 Operators (1) Associate (*): -  The Associate operator is a binary operator which con- structs an association-set of complex pattems by concatenating the pattems of two operand association-sets. Since a pattem may have Inner-pattems from many classes and an object class may have more than one association with another class, it is necessary to specify through which association the concatena- tion of two pattems is intended. The Associate operation on association-sets a and $ over the association R between classes A and B is defined as follows:  a * [R(A,B)I P = I y I ?=(a',@.a,b.): [R(AB)I A a m e a t  A bnE Bl 1 The result of an Associate operation is an association-set  containing no duplicates. Each of its pattern is the concatena- tion of two pattems (one from each operand association-set).

More specifically, if the Inner-pattern (or object instance a,,,) of A in a' is associated with the Inner-pattem (or object instance b,) of B in @ in the domain of the algebra A, then ai and are concatenated via the primitive pattern (a,bn).

An example of the Associate operation is shown in Fig- ure 8a. For clarity, we use graphical notation in the figures.

In the example, a' is concatenated with $' and $', respec- tively, due to the existence of (blcl) and (blc2) in A as shown in Figure 7. a' is dropped simply because it does not have an Inner-pattern of class B. a3 is dropped because (b2 IS not  be concatenated through (c4) with any pattems in a because no pattern in a has an Inner-pattem of B that is associated with (c4) in 2. For the same reason p' is dropped.

associated with any Inner-pattem of class C in 2. $ 2 '  cannot  Figure 8a Example of Associate Operation  For the Associate operator, [R(A,B)] can be omitted if the following conditions hold (1) both a and $ are A-algebra expressions, (2) the Associate operates on the last class in a linear expression a and the first class in a linear expression $.

and (3) there is a unique association between these two classes. For example, A *[R(AB)] B can be written as A*B, if class A is associated with class B through the attribute [R(A,B)] of A. It should be pointed out that A-algebra allows an attnbute have a computed value (or object). For instance, B=f(A). The implementations of the function and the pro- cedure are invisible to the algebra. However, they should not have side effects, i.e., the computed result must be of the same data type as B.

The Associate operator is commutative and conditionally associative as defined below:  (commutativity)  (associativity) a *[R(A,B)I $ = $ *[R(B,A)I a  ( q x )  *[R(AB)I Ply)) *[R(CD)I rlz)     The associativity holds true when a and 7 do not have Inner-patterns of classes C and B. respectively. Otherwise, the associativity does not hold. For example, if W a l b l , b l ~ ) .

Be(blcl), and y=(d,) and A shown in Figure 7 is the Qmam of the algebra, then  ( a  *CR(AB)I B) *[R(CP)l7  ==(aibibi~i.bi~2.czdi) a *[R(AB)I (8 *[R(CP)lr) = $  (2) A-Complement (I): The A-Complement operator is a binary operator which  concatenates the pattems of two operand association-sets over Complement-pattems. It is used to identify the object instances in two classes which are not associated with each other in A of Figure 7. The A-Complement operator is defined as follows:  a I [R(A,B)I B = t 7 I f+a'.BJ.amb,): ( a x ) ?  [R(AB)I A a,? a'Ab,+ BJ  or : 3 (m)(amEa') A (H V (n)(b,EB)) or f=B' : 3 (n)(bnE B') A (e$ V ("am? a) )  1  The result of an A-Complement operation is an association-set. Each of its patterns is formed by concatenat- ing two patterns (one from each operand association-set) via a Complement-pattem (ax,) ,  where a, and b, be% to a' and c. respectively, and the Complement-pattem (a,b,) is in A .

In the special case when a(or B) is an empty association-set or does not have Inner-pattems of A(or B), then all pattems of B<or a )  that have Inner-patterns of A(or B) are retained in the resulting association-set.

An example of the A-Complement operation is shown in Figure 8b. It operates over the association between classes B and C. a' does not appear in the resultant association-set because it contains no Inner- attems of B. a' cannot be A- Com lemented with B' and 8 because it is connected with and i2 by Inter-pattems (blcl) and (blcl) in a. respectively. P  a B Y  (b) FFb) IP(B.C)l (ci@---edl> C 2  U 62 [si-: e - -e - -e- -4 dl a4 b3 52 az e--*--- C3.

a4 b3 c3 *----e---.

a4 @---@ b3  Figure 8b Example of A-Complement Operation  Under the same conditions as given in the Associate operator, [R(A,B)] need not be specified with the A- Complement operator unless there is an ambiguity. The A- Complement operator is commutative and associative. For the similar reason described for the Associate operator, the associ- ativity holds true conditionally.

a I [R(A,B)I B = B I [R(BA)I a (commutativity) (a,x) I [R(A,B)I Ply)) I [R(C.D)I 7(z) (associativity)  = a ( x )  I [R(AB)I (Ply) I [R(CP)I Y(Z,) (if c e t x )  A B W I )  (3) A-Select (6) The A-Select is a unary operator, which operates on the  association-set a to produce a subset of pattems that satisfy a specified predicate P. A pattem in the operand association-set is retained iff the predicate is evaluated true for that pattern.

o(a)[P] = 1 7 I 9 = a1 : P(a')=true ) where a is defined by an algebraic expression, and P = TlelT202 - * &T,. Each term. Tl(i=1,2 ,... a), is a  comparison between two expressions and @(i=1,2, ..., a-1) is a Boolean operator ( or v ). P(a')=true represents that a pat- tern is evaluated true for that predicate.

The expressions on the left- and right-hand sides of a comparison operation may contain constants, functions and/or operations on object instances, but cannot both be constants.

The comparison tenns are type sensitive, i.e., the results of the two expressions in a term must be data of the same type for primitiveclasses or both IIDs for nonprimitiveclasses.

=,>,<>,I, and # are the legitimate comparisons for numerical types; = and # for character, string, and m> =,c,z).E,~. and # for set types. The comparison OK: is performed by comparing their ODD portions, since m>s are the concatenation of the class identifiers and Oms. A single valued object or a single III) can be treated either as its own data type in numerical, string, or JJD comparison, or as a set type containing one element in set comparison.

As an example of A-Select, we assume that there are two associated classes: S for stack and Q for queue. To select associated stack and queue object pairs in which the object on the top of the stack is located in the front or the tail of the queue, the algebraic expression can be written as  o(S*Q)[top(S) c ( f ioNQ) U WQ))I where U is a set-union operation. For the top equals the front and the bottom equals the tail. we have  o(S*Q) [( top(S)=fiont(Q)) /r (bottom(S)=tail( Q))] (4) A-Project (n):  Similar to the projection operation in the relational alge- bra, an A-Project operation projects a given pattem over some subpattem( s). However, in relational algebra, the relationship among the projected attributes is not important. Whereas in A-algebra, the associations among the projected subpattems must be maintained so that the associations among the object instances in these subpattems will be retained. The A-Project operator is defined as follows:  Wa)F.; TI where a is an association-set defined by an A-algebra expres- sion; w e l ,  eh . . . , e,) is a set of expressions which specify subpattems to be projected; and T=(tlrt2, . . . , t,) is a set of ordered sets of classes. Each ordered set, tl, defines a path for connecting two projected subpatterns specified by the E expressions. It contains a minimal number of classes along the path which can uniquely identify that path.

The result of an A-Project is an association-set which contains object association pattems corresponding to the pro- jected subexpressions specified in E. Each pair of subpattems is connected by either a D-inter-pattern or a Dcomplement- pattem depending on whether the path connecting these two subpattems contains all Inter-patterns or not. The function of D-inter-pattem and Derived-complement-pattern is to retain the original associations among object instances before the projec- tion operation.

Figure 8c shows an example of A-Project from a pattern a over A*B and D. For al. the subpattems (a,b,) and (d,) satisfy A*B and D, respectively. Therefore, they are kept in the result. Accordingto the path specification, a D- Complement-pattern (bydl is a&& to the result, thus y'==(albl. dl, bid, ), .i.e., $=(albl, bid, ). is produced for the same reason. Since a does not have a subpattem satisfy- ing A*B, only (d3) is retained.

Figure Bc Example of A-Project Operation     (5) NonAssociate (!): The NonAssociate operator is a binary operator used to  identify the association pattems in one operand association-set that are not associated (over a specilied association) with any pattem in the other association-set, and vise versa, based on the pattems in A. The NonAssociate operator is defined as follows:  The result of a NonAssociation operation is an association-set. Each of its pattems is formed by concatenat- ing two pattems a' and via a Complement-pattem (a,bn) under the condition that a' is not associated with any and vice versa. Furthermore, in the special case where the pattems of a(or @) have Inner-pattems of A(or B) and cannot be con- catenated with any pattems of B(or a), then these pattems of Mor B) will be retained in the result if one of the following three conditions holds: (1) P(or a) is an empty association-set, (2) all pattems of mor a) do not have Inner-pattems of B(or A), or (3) all pattems of mor a) that have Inner- attems of B(or A) can be concatenated with pattems of Mor 8.

An example of the NonAssociate operation is shown in Figure 8d. In the example, a' and P' are dropped due to the existence of (blcz) in Figure 7. a2 is dro ped because it does not contain an Inner-pattem of class B. 8: is dropped because it does not contain an Inner-pattem of class C.  7' is in the resultant association-set because (b2) is not associated with (c in a shown in Fi ure 7 and none other pattem in a is associ- ated with (cq). .$ exists because (b2) is not associated with (c3) in a.

4)  a Y  Figure 8d Example of NonAssoclate Operation  Note that the NonAssociate operator produces a resultant association-set which is a subset of that produced by the A- Complement operator. NonAssociate is not a primitive opera- tor since it can be expressed by other operators. However, it is very useful for query formulation and is therefore included in the set of A-algebra operators.

Under the same conditions as given in the Associate operator, [R(A,B)] need not be specified unless there is an ambiguity. The NonAssociate operator is commutative but not associative.

a ! [R(A,B)I P = B ! [R(B.A)I a (commutativity) (6) A-Intersect (0):  The A-Intersect operation is convenient for constructing a pattem with a branch, a lattice, or a network structure, since a pattem in such a structure can be viewed as the intersection of two pattems. Conceptually, the A-Intersect operator is equivalent to the JOIN operator in the relational algebra. It operates on two operand association-sets over a set of specilied classes. Two pattems, one from each association-set, are combined into one if they contain the same set of Inner- pattems for each specified class.

q x )  4 W l  P , Y )  = ( y I r* = (a'.B'): V (CLnE ( W I )  Y (@ECLn,a')(@EBI) AV (CL,? IWI) tf (@ECLn,P')(@Ea') I  Figure 8e shows an example of the A-Intersect operation over classes B and C. The resultant association-set contains four attems, which are the intersection of a'np', a1nS2, a%$, and aznP2, respectively, since they all have Inner- pattems (b,) and (cz), Other pattems (a3, a', P3, 8') fail to produce new pattems because they either have no Inner-pattem in both classes B and C or have no common Inner-pattem of class C.

a B I  (e) (+)o[B,c] CCI [g:q - - [;Tl "2 dl c. *  a1 b l  cZ 63  Figure 8e Example of A-Intersect Operation  The set of classes (W) can be omitted when the A- Intersect operation is performed on all  the common classes of its operands, i.e., ( W}=( X)n( Y 1 is implied.

Since a network structured pattem can be transformed into a set of other simple pattems, an A-Intersect operation for building a complex pattem can be replaced by an Associate operation followed by an A-Select operation. The A-Intersect operator is commutative, conditionally associative and idempo- tent.

a o ( W )  P = P o { W ]  a (commutativity) (associativity) ( a l x )  dW1 I Ply)) 4 W z )  712)  (if ( ( W i t - ( W ~ l ) n  ( Z I = +  A ( ( W z I - ( W i I ) n  ( X I = @ ) a o a = a  (idempotency) (if a is a homogeneous association-set)  = a l x )  ( W ,  t (Ply, 4w21 7IZl)  The associativity is not always true because there are cases in which a pattem of P that fails to intersect with any pattems of y, may succeed by first intersecting with a pattem of a in the operation (4 W 1  1) and then intersecting with a pat- tem of y in the operation (4 W 2 ] ) .

Now we define three set operators, which are different from the corresponding set operators in relational algebra, since they operate on heterogeneous structures rather than union-compatible relations.

(7) A-Union(+): Similar to the UNION operation of the relational alge-  bra, A-Union combines two association-sets into one. How- ever, these two association-sets may contain heterogeneous association structures. It is important for A-algebra to be able to operate on heterogeneous structures because some prior operations may produce heterogeneous association-sets and may need to be further processed over the object instances of a common class against other pattems of associations. Unlike the relational algebra and other 0-0 query languages, union- compatibility is not a restriction in A-algebra. For this reason, A-algebra has more expressive power. Any query thaf can be expressed by a single expression in other languages c m  be expressed as a single A-algebra expression but not vise versa.

The A-Union operation is defined as follows:    a+B=(  71 Y E ~ V Y ~ E B  1 The A-Union operator is commutative,  idempotent:  a + f l = p + a  (a + B) + 7 = Q + (B + 7) a + a = a (8) A-Difference (-):  associative, and  (commutativity)  (associativity)  (idempotenc y )  The A-Difference implements the same concept as the DIFFERENCE operator in relational algebra but with two differences. First, its operands do not have to be union- compatible. Secondly, a pattem in the minuend is retained if it does not contain any of the pattems in the subtrahend.

The example depicted in Figure 8f shows that a' and a3 are dropped since they both contain p'.

a B 1  Figure Bf Example of A-Difference Operation  (9) A-Divide (+) The A-Divide operator implements the concept that a  group of pattems with certain common features contains another set of pattems.

a + l w l B = (  rI?=s': +t WB'EG) where a, is a subset of pattems of a, which have common Inner-pattems for all classes of ( W). If ( W 1 is not specified, the A-Divide operation retains all the pattems of a, each of which contain at least one pattem of g and they together con- tain all pattems of B.

Figure 8g shows an example of a being divided by B with respect to class B. The A-Divide operation retains a', a2 ,and a since they all contain Inner-pattem (b,) of B and together contain all pattems of p.

U B 7 - .  (2)  Figure 89 Example of A-Divide Operation  3.3.3 Precedence - The precedence relationships of the above operators are  as follows. Unary operators have higher precedence than binary operators. The precedence of the seven binary associa- tion operators is given in the following order: I, 1, !, 0, /, -, and +. Parentheses can be used to alter the precedence rela- tionships.

- 3.3.4 Querv Examples  W e  have formally defined nine association operators and given their simple mathematical properties. Before exploring other properties, we give some examples to illustrate how these operators are used to express queries for processing an 0-0 database. There can be many alternative expressions for the same query. Choosing the best one for execution is the task of a query optimizer. The mathematical properties of these operators can be used for that purpose.

It is straightfoxward to write an algebraic expression for a subgraph with a linear stmcture. The expression for Query 1 given in Section 2 can be fomiulated as follows by navigat- ing the schema graph (Figure 1) from class TA up to class SS#.

ll(TA*GRAD*Student*Person*SS#)[SS#]  Shown below is the expression for Query 2 (Section 2).

The expression for this query can be easily constructed by specifymg the a expression (defining the operand association- set of A-Project) first, and then attaching the [E, T] clause.

ll (o(Name)[Name="CIS"]*Department*Course*(Section *Teacher*Faculty*Spciality+Section*(Student*GPA.Student +Earned Credit))) [Section,,Specialty,GPA,Eamed Credit: Section:!$xialty,Sec tion:GPA,Section :Eamed-Cr&t]  To write this expression, the user may first trace the Schema Graph to specify a graph as shown in Figure 3. Then label each edge of the graph with an operator *, 1, or !

depending on the semantics of the query. For this query, every edge is labeled by an *. Since the query does not require that Student and Teacher relate to the same Section of a Course, the two branches should be A-Unioned for further processme. The A-Select operation ensures that only the (7Is department is under consideration. The result of this expres- sion will contain two types of pattems: Section-Specialty and GPASection-Earned Credit as specifies by the [E, TI clause of the A-Project%peration. Note that this query cannot be phrased in a single relational algebraic expression, since the union of heterogeneous structures is involved.

Some other query examples are given below. Their corresponding pattems are depicted in Figure 9. The interpre- tations of these queries are left to the reader.

Query 3: List the names of students who teach in the same departments as their major departments.

n(Student*Person*Name8tudent*~p~ent .Student*Grad*TA*Teacher*Department) mame]  Query 4 List the section# of those sections which have not been assigned a m m  or a teacher.

ll(Section#*(Section!Room#+Section!Teacher))[Section#]  Query 5: List the names of students who take courses 6010 and 6020.

ll(Name*Person*S tudent*Enrollment*Course*Course# +ptudat] O(Course#)[Course#=6010 or Course#=6020])[Name]  Again, we stress that the above association pattem expressions represent the intemal algebraic operations that need to be performed if the dynamic inheritance mothod is used. The highlevel query statements that the user uses can be much simpler due to the inheritance of attributes in the gen- eralization hierarchy or lattice.

Query 4 Teacher  Ouery 3 M y  pe;m"sEynl -  section# * A H %d-, R"  Te?&er Grad TA  = 13 Course#-6010 Query 5 Enrollmen1 Courrs  Figure 9 Patterns for Query 3, 4. 5      4. Additional Properties of the Operators  In Section 3.3, we have shown some properties of the individual operators. Many other properties have been stu- died. These properties are important for query decomposition and query optimization. Due to space limitation, we shall only give the distributivity properties of some operators with respect to other operators.

a) distributive property of * with respect to +: a *[R(A.B)I (B + y) = a *[R(A,B)I P + a *IR(A,B)I y  a 1 [R(A.B)I (B + y) = a 1 [R(A,B)I B + a I [R(A,B)I 7  a 4 X )  ( P + r ) = a o l x l  B + a o l X l y  b) distributive property of 1 with respect to +:  c) distributive property of 0 with respect to + :  These three properties hold true for the same reasons.

First, the A-Union operation simply lumps together pattems of two association-sets without modifying them. Second, for operation *, 1, or 0, the decision whether a new pattem is pro- duced or not is determined only based on the structure of the two pattems being operated on and is independent of the other pattems in the operand association-sets.

d) distributive property of * with respect to E "(XI *[R(CLI.CLZ)I (Ply) 4 W l  Y{Z,) = a l x )  *[R(CLI,CLdl Ply) 4 W u X l  q x )  *[R(CLI,CLZ)I ylz)  a Ix )  I [R(CL,,CLdI (Ply) 4 W l  ylzt) e) distributive property of I with respect to E  = six) I [R(CLi,CLdI P,y) 4 W u X J  a(,) I [R(CLi.CLz)I Y ~ Z , f )  distributive property of ! with respect to 0:  a l x t  !IR(CL,.CLJI (&Yt 4 W )  Y ( z J ~ )  = a l x t  ![R(CLI,CLZ)I Ply) 4 W u X l  a l x )  ![R(CLI.CLdI ylzt  Distributive properties d), e), and f) hold true under the following three conditions:  i) CL,EW, and ii) X n Y = X n Z = + . a n d  iii) a is a homogeneous association-set.

The first condition ensures that the *, I, and ! operations  are performed on the intersection of @' and $; othenvise, it does not make sense to have an operation between a and 7.

The second condition states that patterns of a are non- overlapping with pattems of P and 7. The third condition states that, on the right-hand side of the expression, only the pattems having the same pattems of a as their subpattems will succeed in the A-Intersect operation.

The above mathematical properties are the basis for query optimization since they provide ways for transforming a query expression into alternative expressions which produce the same result but with different performances. For example, the associativity holds true for the two Associate operations in the expression A * B * C. Thus, either order of evaluation will produce the same result. Similar to the optimization of consecutive JOIN operations in relational databases, the order of their execution should depend on their selectivities (similar to the selectivity of a JOIN operation).

As a second example, the following expression defines a complex pattem as shown in Figure loa.

expr = A * (B*E*F + B * (C*D*H 0 C*C))  By applying the distributivity of the operators, it can be writ- ten as below:  expr = A * (B*E*F + B*C*D*H 0 B*C*G) = A*B*E*F + A*(B*C*D*H 0 B*C*G) = A*B*E*F + A*B*C*D*H A*B*C*G  The final expression and the intermediate expressions are the altematives for evaluation. Among them, the final expression is particularly suitable for a parallel system, since it is an A- Union of two sub-expressions. each of which can be evaluated independently and produces a homogeneous association-set with simpler structure (see Figure lob). Its processing will be more efficient than the processing over heterogeneous association-set. 'The second subexpression can be further optimized using other properties of its operators.

A B E F  - E F  (a) (b)  Figure 10 Example of Query Optimization  5. Conclusion  The mathematical foundation of the relational model, namely the relational algebra and the relational calculus, has contributed to the success and popularity of the relational model and relational database management systems. Although the recently introduced 0-0 DBMSs and their underlying models exhibit several desirable features that are suitable for modeling and processing complex objects found in more advanced database applications, they still do not have a solid mathematical foundation. Such a foundation is imponant for the efficient manipulation of 0-0 databases and for the design of high-level query languages to ease the user's task in access- ing and manipulating 0-0 databases.

In this paper, we have presented an algebra for 0-0 database processing. In this algebra, objects (object instances) and their associations in an 0-0 database are uniformly represented by association pattems. Nine algebraic operators have been introduced for manipulating pattems of heterogene- ous and homogeneous structures. The result of performing an A-algebra expression is an association-set. The closure pro- p e q  of the algebra allows the result of an algebraic expres- sion to be further processed by the algebra  Several mathematical properties of the A-algebra opera- tors have been described. The A-algebra is complete in the sense that all possible subdatabases that are derivable from an 0-0 database can be expressed in terms of A-algebra expres- sions. The proof of completeness is done by induction on the number of classes in SG. More mathematical properties. their proofs, and the completeness issue are presented in a forth- coming paper [SUW].

