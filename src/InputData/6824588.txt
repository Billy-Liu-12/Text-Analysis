A Configurable Simulation System Illustrated by the Case of Futures Trading

Abstract?It is well known that speculative behavior may do harm to the financial system and the market order. So, it is essential for us to make a research on how speculative behavior affects the market. And for this purpose, we developed a futures trading simulation system. We designed a configurable client to simulate traders and users can define trade strategies using different programming languages. We designed a lightweight server to handle the large scale and high concurrency access requests from clients. We chose HBase as our database to grantee the high scalability of our system. And, we also developed multi-row and multi-table transaction support to improve the data consistency for HBase. The experiment indicates that our system shows high efficiency in the face of the large scale and high concurrency access request, and the read/write performance loss of HBase introduced by the transaction support mechanisms is also acceptable.

Keywords-futures trading simulation; high concurrency; transaction management

I. INTRODUCTION The futures market is one of the essential investment  instruments in the modern world. It functions for the most part as price finding and risk avoiding. However, futures trading, as a part of the financial system, could not rule out the risk which it inherits unavoidably. In the futures trading process, individuals would suffer tremendous loss caused by excessive speculation or rogue-trading activities. This might further harden the situation of the futures market, initiate a series of chain reaction, and even evolve to a catastrophe to the whole economic system. As a pricey mistake, so-called fat finger trading error made recently by Everbright Securities Company Limited caused wild swings in China?s stock market. China?s main stock index was up approximately at 5% in one minute and soon swiftly slid back down. It was triggered by Everbright Securities? sending through billions of incorrect purchase orders for shares as its trading system had a problem [1]. Not only did this incident cause serious damage to the brokerage itself and a lot of investors, but injured the market order badly. It is precisely these emerging problems which suggest that Multi agent-based simulation should play a more significant role.

The development of a detailed simulation platform representing the agents, the markets, and the market trading mechanisms, together with reinforcement machine learning to facilitate profit-seeking behavior performed by the agents,  can provide a computational frame work to overcome the limitations of the analytical approaches.

In a word, it is essential that we conduct a study on how individual speculative behavior produces an effect on the futures market. And for this purpose, we developed a futures trading simulation system. In this paper, we are more concerned about the technology being used in the simulation system, rather than the analysis of the behavior of financial markets based on the simulation system.

The futures trading simulation system is divided into two parts, client side and server side. The client is responsible for simulating the traders? behavior, while the transaction, matching orders, is dealt by the server. In order to make this scenario more realistic, the traders are classified and segmented into different types of the requirements of themselves. And then each type of traders will behave distinctly according to their strategy. In actual operation, the client will simulate a large quantity of traders concurrently purchasing and selling chunks of futures and the server will have to respond the requests by executing the corresponding business logic efficiently. A large quantity of traders with high concurrency means that a large quantity of data needs to be saved in a database, such as the purchasing or selling request, the matching orders, the real time and historical data of stock index futures trading.

The above analysis shows that the database of our system should meet the demand of high concurrent read and write, huge storage and high scalability. Relational databases don?t work easily in a distributed manner because joining their tables across a distributed system is difficult [2]. In contrast to relational database management systems, most NoSQL databases are designed to scale well in the horizontal direction and not rely on highly available hardware [3]. The ?shared nothing? horizontal scaling allows them to support a large number of simple read/write operations per second [4].

However, NoSQL database makes a composition on the scalability. Take BigTable for example, it only supports single-row transaction, which means that if the operations in a transaction are not in a single row, the atomicity of the transaction cannot be guaranteed [5]. Not providing consistency enables better performance and scalability but is a problem for certain types of applications and transactions, such as those involved in banking as well as our system [2].

So in conclusion, there are two major obstacles, large scale and high concurrent access requests as well as the large scale data storage and processing, concerning the futures   DOI 10.1109/CBD.2013.2     trading simulation system. The difficulties of the whole system are listed as follows. High efficiency has to be met while dealing with large and high concurrent access requests, as well as the strong consistency should also be satisfied while handling large scale data storage and processing.



II. RELATED WORK The basic economic structure of the market draws  heavily on existing market setups such as those of Bray [6] and Grossma and Stiglitz [7]. However in recent years, agent-based simulations of market have been developing rapidly and gaining more and more acceptance. The agent simulates the investors who interact with each other in the actual financial market. Among the numerous agent-based simulations, the Santa Fe Institute Artificial Stock Market Model is one of the most well-know and classic masterpiece.

Santa Fe Institute Artificial Stock Market, one of the first agent-based models of a financial market, is developed by Brian Arthur, John Holland, Blake Le Baron, Richard Palmer, Paul Tayler, and Brandon Taylor. The model is inhabited by a population of myopic, imperfectly rational, heterogeneous agents who make investment decisions by forecasting the future status of the market, and who also learn from their experience over time. The model illustrates how simple interactions among such agents may lead to the appearance of the realistic structure itself.

Researchers at Santa Fe Institute construct a widely used multi-agent software platform for the simulation of financial trading systems named Swarm later. Swarm is a free and open source toolkit with both Objective-C and Java bindings [8].  Swarm was originally developed as a software toolkit for the creation of simulation models in the field of Artificial Life. It provides modelers with a flexible, nested approach to modeling interactions. While discussing their design, Minar states that agent-based modeling toolkits or libraries are important in that they save scientists from wasting time on repetitive and error-prone programming [8]. Object orientation is also useful because of its close association with agents.

Other agent-based simulation platforms are listed as follows. Repast 3 is a family of three free and open source agent-based modeling libraries [9]. The three libraries are Java-based Repast J, C#-based Repast .NET, and NQP (Not Quite Python) -based Repast by StarLogo is a library and environment that uses a Java interpreter and interface [10].

NetLogo is a free and open source agent-based simulation environment that uses a modified version of the Logo programming language [11].

As mentioned above, all of the gent-based simulation platforms are bound directly to specific programming languages. And it?s common that people from business and financial communities are lack of coding proficiency.

Therefore, it?s of vital importance to keep high scalable ability of the Futures trading platform which means that the platform has to support several different languages implementing the trading algorithm.

Based on platforms discussed above, researchers have built a lot of simulation systems for financial trading and have made abundant achievement. Multi-agent automated  intelligent shopping system (MAISS) is a distributed system, where human users (buyers and sellers) are able to delegate their tasks to agents, which will then do the shopping job on their behalf and present them the results [12]. Buyer users (customers) and the seller users (suppliers) can be organizations, companies or individuals. JADE based multi agent system for mobile computing for cellular networks [13], by S. Mundle, as Multi Agent resource provisioning problem, where agents interact with each other to find the optimal threshold for call admission using Distributed Service Architectures. It evaluates connection level performance characteristics of Dynamic and Mobility based call admission control schemes using agents. The Multi Agent architecture is designed and simulated using open source Java Agent DEvelopment Framework (JADE).

Implementing a multi-agent system for the real-time coordination of a typical supply chain based on the JADE technology by A. Shemshadi [14]. Their paper is framed to address the preliminary approach towards process-oriented collaborative inventory management in supply chains, taking advantage of multi-agent technology in terms of modeling and simulation.

Almost all of the simulating softwares mentioned above are using relational databases. However Futures trading simulation system needs to face the challenge of the large scale and high concurrent access requests which means that a NoSQL database is a better choice. However, it?s well known that almost all NoSQL databases cannot fully provide complete support for complicated transaction which leads to failure in keeping the strong consistency of the data. And that?s an indispensable key technology in our system.

An open source project named omid provides transactional support for HBase. Omid uses a central server named the transaction oracle to manage transactions. Users can use the API in transaction clients. Transaction clients are in charge of connecting to the transaction oracle and perform the required operations in data-stores. The transaction oracle replicates transactional information to the transaction clients which just contact the transaction oracle when they want to start a transaction or commit it [15]. Besides, HBASE-5229, one of HBase?s updating issues, mentioned that it provides basic building blocks for "multi-row" local transactions, however afterward it also says this feature is by design and is not available to the client via the HTable API [16].

For Bigtable, Goolge proposed a technique called percolator [5]. Percolator chooses to use a column of itself to provide lock service and implements a two phase commit protocol to guarantee the synchronism of multi-row and multi-table. We implemented the multi-row and multi-table transactional mechanism based on HBase referencing percolator. Furthermore, we extended the multi-row and multi-table transactional mechanism, such as providing multi-level isolation level.



III. FRAMEWORK AND FLOW Fig. 1 shows the architecture of the futures trading simulation system. Trading strategies of all kinds of traders are stored in client backend. Each client frontend stimulates     a certain amount of traders and communicates with client backend. Trading requests generated according to corresponding strategies will be sent to the server side using FIX (Financial Information Exchange) protocol. FIX is a communication and messaging protocol widely deployed in conducting securities transactions produced by FIX Protocol Ltd. After trading requests being received, they will be processed by the business logic adopting distributed computation methods. HBase, which is used as the database of our system, only supports single-row transaction.

Therefore, we add a transaction support layer to deal with the multi-row and multi-table transaction. The detailed architecture of client and server will be discussed in the next section.

Fig. 2 is a specific description of a simulated trading process. The process involves the interaction between the three modules such as client frontend, client backend (CSPI) and server. Client frontend is in charge of generating and transmitting trading requests; client backend stores all trading strategies used by traders; server is responsible for managing and matching the trading requests. Firstly, one of the traders that client frontend simulates communicates with the corresponding trading strategies stored in client backend to decide what kind of data it needs, like the real time and historical data of stock index futures. And then client frontend collects the required information from the server and sends the information back to client backend. After client backend gets the data, trading orders are generated by running relevant strategy and then orders are sent to the server. At last, the server processes the orders and sends feedback, that the order is successfully matched or failed, to client frontend.

Figure 1. Architecture of the futures trading simulation system.

Figure 2. A specific description of a simulated trading process.



IV. KEY TECHNIQUES  A. Configurable Client In order to simulate the real complex futures trading,  simulated traders depend on well-defined trading strategies and apply the data they get from the simulated market to make predictions and generate trading orders accordingly.

There are three different kinds of traders which are hedger, speculator and arbitrager. Each kind of trader has been granted to different trading strategies. The client is split into client frontend module and client backend module. Client frontend communicates mutually with a server while client backend provides the trading strategy for client frontend.

One thing to note here is that, the detailed realization of the trading strategy is not our top priority. Most often, it is realized by financial professionals. The strategies in the client backend can be implemented using advanced programming language such as Java, C++, C#, and even Matlab. Also the uniform interface is provided to support different strategies, adopting the design pattern of adapter.

The scalability and usability of the system are improved by using the configuration settings to initialize the client frontend and client backend. The configuration settings for client frontend contain the port number, the FIX protocol version, the server?s IP address and port number, the client backend?s IP address and port number, the interaction protocol with client backend, the number of simulated traders, the percentage of each kind of simulated traders and the interface of trading strategy. The configuration settings for client backend contain the port number, the interaction protocol with client frontend, the implementation of the adapter and the interface of trading strategy. All configuration settings exist as cfg files which can be edited by text and graphic. The system also provides several different default configuration settings to provide default initialization.

Fig. 3 shows the structure of the client. There are several client frontend modules deployed in a cluster of nodes, and each of them runs a certain amount of simulated traders.

Client backend is deployed in a single node, and it communicates with all client frontends. Multiply ways can be used in the interaction between client frontend and client backend including RMI, Web Service, etc. The interaction between client frontend and server relies on FIX protocol.

Message formats and mechanisms for sending and receiving     message are defined in FIX protocol, and FIX protocol also includes the content of session layer management, application layer messages, data dictionary and so on. All FIX protocol versions and most part of the functions are implemented in FIX server module and FIX client module.

User Behavior Algorithm  Backend Interface  User Behavior Controller  Configur ation  Settings FIX Client  Frontend Interface  FIX Server   Figure 3. Structure of client.

B. Lightweight Server  Fig. 4 shows the structure of the server. As soon as the FIX server receives the trade requests from clients, it transmits them to the nodes deployed in the cluster. Each node in the cluster will run two processes: data process and transaction support. The data processing module handles the trade requests according to the business logic and transaction support module provides multi-row and multi-table transaction support for HBase. Similar to client, server also uses the configuration settings which can configure the port number of the FIX server, the FIX protocol version and the port number and IP address of the node in the cluster.

Figure 4. Structure of server.

In order to improve the performance of the system, we designed a lightweight server. Firstly, every module in the server is lightweight, especially for FIX server, it only concerns the transmitting of the trade request. And also, we implement the business logic of other modules in the cluster to be as simple as possible. Secondly, according to the actual operation condition, we implement different transaction isolation levels and use the level will be as low as possible to decrease the responding time of the database. For example, for the operation in the table of the trade request, we set the isolation level as read committed to guarantee the strong consistency. For the operation in table of the real time data of the market, we set the isolation level as read uncommitted to improve the read performance. For the operation in table of the historical data of the market, we set no isolation level because it is a read-only table. At last, the server is stateless.

The state of orders and traders is transmitted by messages and this enhances the scalability of our system.

C. Non-relational Database Supporting Strong Consistency HBase is deployed as the database of our system. Similar  to BigTable, HBase supports only single-row transaction.

Considering the situation that trader A transmits a purchasing order to a server, and trader B sends an order selling the same futures at the same time. Afterwards, the requests are considered matching successfully and two trade records are generated by the server. And then, the two records have to be written into the database, and we should ensure the atomicity as they would both succeed or both fail. But this operation involves two different rows and the above requirement couldn?t be satisfied by HBase. Therefore, a similar technique as percolator is used to support multi-row and multi-table transaction in our system. Beyond percolator, we also implement three different transaction isolation levels for HBase, and they are read-uncommitted, read-committed and repeatable-read.

Consider the requirements for the lock needed by transaction operation in HBase: lock itself must be persistent; lock service has to provide high throughput and low latency.

HBase runs on top of HDFS, which provides storage backup capability for HBase, so as to be persistent. As a kind of distributed database, HBase naturally has the ability of high throughput. While HBase can do load balancing itself, low latency is also met. In conclusion, HBase could provide lock service to itself, so an extra column is added into the table to illustrate the locks.

The atomicity of multi-row and multi-table transaction in HBase is guaranteed by two phase commit protocol which involves coordinator and participator. The coordinator can be viewed as both the initiator and a participator of the transaction. Each row contained in the transaction corresponds to a participator. The detailed two phase commit protocol includes the following steps, pre-commit and actual- commit. In the phase of pre-commit, coordinator informs all participators to be prepared for committing or cancelling the transaction. And then the coordinator is notified of the decision made by the participators. While in the phase of actual-commit, coordinator will make the decision depending on the result of the voting in the previous phase. If and only     class ReadUncommitted { public Result read(ReadOperation r) {  return readInDBAndCache(r); } public void write(WriteOperation w) {  //add to the list and execute when calling commit operationList.add(w);  } public void delete(DeleteOperation d) {  //add to the list and execute when calling commit operationList.add(d);  } //the commit is divided into preCommit and actualCommit public boolean commit() {  for (int i = 0; i < operationList.size(); i++) { if (!preCommit(operationList.get(i))) return false;  } for (int i = 0; i < operationList.size(); i++) {  if (!actualCommit(operationList.get(i))) return false; }  } // Lock the row of op, return false while encountering conflict public boolean preCommit(Operation op) {  if (existsVLock(op) || existsSLock(op)) { rollback();  return false; }  writeVLock(op); return true;  } // Clean up the lock and do the actual write or delete.

protected boolean actualCommit(Operation op) { boolean flag;  if (op instanceof WriteOperation) flag =  commitWriteOpeartion(op);  else flag = commitDeleteOpeartion(op);  if(flag) deleteVLock(op); return flag;  } }  class ReadCommited extends ReadUncommitted { public Result read(ReadOperation r) {  while (true) { if (existsVLock(r))  return null; writeSLock(r); Result tmp = readInDBAndCache(r); deleteSLock(r); return tmp;  } }  }  if all participators agree on committing the transaction, all participators will be informed to commit the transaction.

Otherwise, the transaction will be cancelled. An example is given below, in the example Bob wants to transfer 5 dollars to Alice, which is a typical case of transaction. The five tables give a short description of the process.

TABLE I.  ALICE?S ACCOUNT CONTAINS $0 DOLLARS, BOB?S $10  rowkey bal: data bal: lock  BOB T0: 10 ALICE T0: 0  TABLE II.  THE TRANSACTION BEGINS. BOB IS THE COORDINATOR, AND DOES THE PRE-COMMIT: WRITE THE COORDINATOR LOCK.

rowkey bal: data bal: lock  BOB T0: 10 T1:coordinator ALICE T0: 0  TABLE III.  ALICE IS THE PARTICIPATOR, AND DOES THE PRE-COMMIT: : WRITE THE LOCK.

rowkey bal: data bal: lock  BOB T0: 10 T1:coordinator  ALICE T0: 0 T1:@BOB  TABLE IV.  BOB DOES THE ACTUAL-COMMIT INCLUDING WRITING THE DATA AND CLEANING THE LOCK.

rowkey bal:data bal:lock  BOB T1: 5 T0: 10  ALICE T1: 5 T0: 0 T1:@BOB    TABLE V.  ALICE DOES THE ACTUAL-COMMIT INCLUDING WRITING THE DATA AND CLEANING THE LOCK.

rowkey bal:data  bal:lock  BOB T1: 5 T0: 10  ALICE T1: 5 T0: 0   We implement three kinds of isolation level: read  uncommitted, read committed and repeatable reads. The pseudocodes for the three kinds of isolation level are shown below as fig. 5, fig. 6 and fig. 7.

Figure 5. Pseudocode for read uncommitted  Figure 6. Pseudocode for read committed                           Figure 7. Pseudocode for repeatable read  Also we use the snapshot isolation provided by HBase to reduce the happening of conflict and improve concurrency.

Each transaction will get two timestamps from a timestamp server: one is at the beginning time of transaction and the other is at the committing time of transaction. The beginning timestamp of a transaction determines the data it can read and the committing timestamp determines the data other transactions can read.

Considering the problem that during a transaction process, the node which is processing the transaction might crash and the transaction can?t be committed properly, a lock would be left behind. It?s still not efficient to do an auto- detect of the left-behind locks, so a lazy way of cleaning up the left-behind locks is adopted. When the transaction is blocked due to a lock, the system will detect whether the lock is a left-behind lock by measuring whether the node, which the transaction is belonged to, has crashed. And then the transaction will choose to roll forward or roll back according to the state of the coordinator key. If the coordinator lock doesn?t exist which means that the transaction is partly actually committed, we should complete the remaining process in the transaction. And if the coordinator lock still exists which means that no part of the transaction has been actually committed, we should clean up the locks and recover the database to the state before the transaction. Fig. 8 shows the detailed process.



V. EXPERIMENT AND RESULT  A. Load Test This sector will focus on the performance of our system  in the face of the large and high concurrent access requests.

As clients and the process part of server are both deployed in a distributed way, the FIX server is most likely to be the system?s bottleneck. We run a load test to measure the performance of FIX server. We simulated 100 traders, and  by modifying the request frequency of each trader, we have seven results. Fig. 9 describes the response time of FIX server and the horizontal axis of both fig. 9 and fig. 10 represents the number of concurrent request per second. In fig. 9, we can find that when the concurrent number is below 500, the response time stayed at a low level, and when the concurrent number grows to 1000, we can see a significant increase. However this problem can be solved by a larger HBase cluster.

Figure 8. The process of the cleaning up of the left-behind lock.

Figure 9. The response time of FIX server.

Fig. 10 describes the CPU utilization of FIX server. In figure 10, we can find that the CPU utilization rate always stayed at a low level. This is because the FIX Server handles a very small amount of calculation.

Figure 10. The CPU utilization of FIX server.

class RepeatableRead extends ReadCommitted { public Result read(ReadOperation r) {  //add to the list and execute when calling commit operationList.add(r);  } // Lock the row of op, return false while encountering conflict public boolean preCommit(Operation op){  boolean flag; if (op instanceof WriteOperation)  flag =  commitWriteOpeartion(op); else if(op instanceof DeleteOperation)  flag = commitDeleteOpeartion(op); else  flag = commitReadOpeartion(op); if(flag) deleteVLock(op); return flag;  } }     B. The Influence caused by strong consistensy As mentioned, we provide multi-row and multi-table  transaction support for HBase, and this section will focus on the influence on the read/write performance of HBase caused by this. We designed four experiments: random write 5M rows in HBase; random read 5M rows in HBase; random write 5M transactions in HBase; random read 5M transactions in HBase. In the last two experiments, each transaction only includes one write or read operation and this represents the worst case of the transaction. And also in the last two experiments, the transaction isolation level is set to be read-committed to represents most commonly used scenes. Table 6 shows the result.

TABLE VI.  THE RANDOM READ/WRITE PERFORMANCE BETWEEN ORIGINAL HBASE AND ENHANCED HBASE  Original HBase  Enhanced HBase  Relative  Read/s 2271 771 0.339 Write/s 4052 1170 0.289  As expected, after providing multi-row and multi-table transaction support, the random read/write about HBase performance has declined. To random read, the performance declined from 2271 to 771. This is because in a transaction, each read operation will have an additional detect of the ?v lock?, and an additional write of ?s lock?, so the performance will drop by about one third. To random write, it shows a more significant decline, which is from 4052 to 1170, as there will be an additional detect of ?v lock? and ?s lock? and an additional write of the ?v lock?. So the performance will approximately decline to about two seventh. And also, there will be other additional operations in a transaction, like getting a timestamp, and this can explain why the actual relative is a little smaller than the relative in theory.



VI. CONCLUSION AND FUTURE WORK We have designed and implemented the futures trading  simulation system and the system has been used by financial professionals to conduct a study on how individual speculative behavior produces an effect on the futures market. The experiment shows that the system performs high efficiency in the face of the large scale and high concurrency access request, high scalability and strong consistency in the face of the large scale data storage and processing. The experiment also shows that the read/write performance loss of HBase introduced by the transaction support mechanisms is acceptable. We plan to deploy our system to a much bigger cluster and test the system more full-scale. Also in reality, the futures market and the spot market are influenced by each other. In order to make the study of how individual speculative behavior produces an effect on futures market more precise, we should concern the spot market. So implementing the spot market simulating system will be our future work.

