A Fast Algorithm for Association Rules Mining Based  on Binary Search

Abstract?To mine the frequent item sets from database conveniently and rapidly, a novel approach for association rules mining is proposed in this paper. In our approach, a vector subspace is build from database and the problem of searching frequent sets in database is transformed into that of searching vectors in vector subspace based binary search. Studies show that our approach is not only simple because it scans the database only once, but also has the virtues of reducing the size of vector subspace and accelerating the searching process.

Keywords: association rules; binary search; frequent item set

I. INTRODUCTIO With the help of the latest achievements in the study of  association rules mining, decision-makers could find out potential associations between items in large database easily and quickly.

Recently, association rules mining has become one of the most heated problems in the fields of knowledge-discovery. However, among so many algorithms for association rules mining submitted in recently years, the Apriori algorithm is still the most fundamental and well-known one, whose essence is that it?s a recurrence method based on the theory of frequency collection, with aiming to excavate the association rules whose support and confidence are both not lower than the minimum support threshold and the minimum confidence threshold from the database. The shortage of the Apriori algorithm for mining frequent item set is that it has to scan the database repeatedly so that the number of candidate items is so large and memory utilization is ineffective and it leads to low efficiency of the algorithm. At present, in view of the Apriori algorithm?s insufficiency, a lot of improved methods and expansion algorithm are proposed, such as, DHP[2] PARTITION[3] frequent closed item sets algorithm[4] FP-Growth algorithm[5] closed item set lattices[6] Hash algorithm[7]. Generally speaking, however, these algorithms are still complex and low-efficiency, particularly in the case of high dimensional items. So the key of evaluating an algorithm good or bad is that whether it can excavated frequent item sets or association rules from databases conveniently, fast and effectively.

In order to mine the frequent item sets from database conveniently and rapidly, this paper starts from the process of finding frequent item set with Apriori algorithm and proposes a novel approach to mine association rules based on binary search.

Firstly, according to the idea of the Apriori algorithm that the biggest frequent item set must be the subset of item sets in database, the vector subspaces are constructed correspondingly based on the number of item sets contained by non-empty subsets; then map the vector subspaces into Boolean matrix according to the database; lastly the vector subset, in which the biggest frequent item set exists is found out through binary search and inner product of vectors, so that the pointed frequent item set is discovered.



II. SUMMARY OF THE APRIORI LGORITHM The Apriori algorithm can be divided into two steps:  Firstly,  it produce frequent item sets based on support;  Then, it produce strong association rules based on confidence. However, the core is frequent item sets which are generated by , in other words, it discovers all the item sets whose supports are not less than the given  . The basic principle of this algorithm is that using an  iteration method, that is using - set of item to explore  supmin  k )1( ?k - set of item.

Suppose that },,,{ 21 mIIII ?? is a set composed by  different items of the database  m  D  and every item i I  mi ,,2,1 ?? is equal to one kind of commodity.

is a set represented a group of business, every  business  },,,{ 21 nTTTW ??  iT ni ,,2,1 ?? is a group of commodities, .

Every business has unique identifier TID. The number of the item set is called its dimension or length, if the length of the item set is , which can be called  ITi ?  k ?k item set. For the given database D , the  process of producing frequent item set can be described [8] as follows:  1) Calculate all 1-item sets first, recorded as . Find out all commonly used 1-item sets which are bigger than or equal to the  , marked as ;  1C  supmin 1L  2) Determine the candidate 2- item sets according to the  commonly used 1- item sets and record which as . Find out all  commonly used 2-items set from  which are bigger than or equal  to the , marked as .

2C  2C  supmin 2L  3) Determine the candidate 3- item sets according to the  commonly used 2- item sets, and record as . Find out all  commonly used 3-items sets from  which are bigger than or  equal to , and record as . Repeat until no frequent item set with higher dimension is found.

3C  3C  supmin 3L  Obviously, the Apriori algorithm needs to scan the database repeatedly. As a result, too much candidate items are produced.

Particularly, when there are too many candidate items, the complexity of the algorithm will grow exponentially and it will affect efficiency seriously.



III. Construction of vector subspace From the result of Apriori algorithm for searching frequent item  sets, it is not difficult to find that the frequent item set produced in the database D  must be the elements of power set corresponded  to . In other words, the power set  is the solution space of the frequent item sets in database. Let?s denote m-dimensional vector as follows:  I2 },,,{ 21 mIIII ?? I2  )0,0,1,0,,0( ???ie , mi ,,2,1 ??  The ith element of vector is set to 1 and the rest are 0s.

According to the number of items contained by the elements, which are not empty sets in solution space of power set ,  -dimensional vector subspaces are built as follows:  ie  I2 m m  ? ? ? ?  ?  ?? ? ?  ?    ????   ?????????   ????? ??  }{  },,,;1|{  },;1|{ },,2,1|{        mm  kkiiik  ii  i  eeeW  ZiiimiiieeeW  ZiimiieeW mieW  k  ?  ??  ???  ??  ?  (1)  Obviously, according to the idea of finding frequent item sets using Apriori algorithm, we can see that the -dimensional vector, corresponding to the largest frequent item set in the database  m D ,  must exist in some constructed vector subspace ,  .

kW  mk ,,2,1 ??

IV. BOOLEAN MATRIX EXPRESSION Suppose that D  is the given database, make  RDf :  In which  mnijrDfR ??? )()(  Here  ??  ? ?   ?    ?  ij  ij ij TI  TI r  ,0  ,1  ,  ni ,,2,1 ?? ; mj ,,2,1 ??  So, when the database is scanned once, it can be mapped into  Boolean matrixR  by . For example, the transaction database f D in ref. [9], as shown in [Fig.1], can be mapped into Boolean matrixR , as shown in [Fig 2].

Figure 1. transaction database  Figure 2. Boolean matrix expression of transaction database  It is easy to know that any database only needs to be scanned once and a corresponding Boolean matrix would be produced accordingly. Therefore, the problem of mining frequent sets from database is transformed into that of analyzing the corresponding Boolean matrix.



V. BINARY SEARCH WAY FOR FINDING FREQUENT ITEM SETS  Suppose that },,,{ 21 mIIII ?? is the set containing m different items of database D , R  is the corresponding Boolean  matrix of database D . Denote R = , in which T  denotes the transpose operator of matrix and  T n ),,2,1( ??? ?  i?  are -dimensional real row vector of m R , .ni ,,2,1 ??  When a subset  is the largest frequent item set of IpT ? ?k  D , -dimensional row m ?  that  corresponds to is certainly  satisfied with  ,  while   ,  pT  k W ? j  W??  },,1,1,,2,1{ mkkj ?? ?? . Therefore, in order to find out  subspace  in which the largest frequent item set exists quickly, binary search way can be used in the following steps:  k W ?k  Scan database D  and establish the corresponding Boolean  matrix , and give out the smallest support level  that the user expects;  T nR ),,,( 21 ??? ??  supmin  According to - the number of items in databasem D , construct m m-dimensional vector subspaces according to the formation  [Eq.(1)]. Set the initial value of  as 1; 0k  Calculate )   int( 00 ??  ?? km  kk ;  Make the inner product ?? ikj ?? ,  , with each  vector  ni ,,2,1 ??  kj?  in the vector subspace  and all row vectors k W  i?  of  Boolean matrix , and statistic the number of T  nR ),,,( 21 ??? ?? ?? ikj ?? , = ask )( kjsum ? . If all vectors kj?  of vector subspace  ,  , satisfies with condition k W k  mCj ,,2,1 ?? )( kjsum ? supmin? ,    then the frequent item sets should be searched from to by  binary search, at the same time give up searching from to .

then go to the step 6);  k W  1?k W  k W  m W  If for vector subspace , there are some s satisfying k W  kj?  )( kjsum ? supmin? ,  , we should give up  searching from to , and make . Then go to Step 7)  and search the largest frequent item set in new to  by binary search way;  k mCj ,,2,1 ??  k  W 1?k  W kk ?0  k  W m  W  If  , as soon as some vectors have been  existed in the vector subspace , the item set composed by nonzero-bit items, which the vector support number in  correspond to, is the largest frequent item sets  we will find. If  , make , then go to Step 3) to search repeatedly the vector subspace that the frequent item sets exist;  10 ?? kk  supmin? 1?kW  1?k W supmin?  10 ?? kk 1?? km  If  and the support number all vectors  counted in the vector subspace , the project set that nonzero-bit component composed , which the vector support number  in vector subspace  corresponded, is the largest  frequent item sets we find. If  10 ?? km  supmin? mW  k W supmin?  10 ?? km , make 1?? km , then go to Step 3) searching the vector subspace that the frequent item sets existed once more;  Here, is the inner product of vectors ?? ikj  ?? , kj? and i? .

Clearly, the algorithm above has some advantages in searching the largest frequent item set from database D :  As simple vector inner product employed, the algorithm is not only simple, but also can solve problem well when the dimension of item sets is relatively large.

Database is just scanned only once, and there aren?t candidate sets during searching the frequent item sets.

Because the solution space of searching frequent item sets has been divided into several vector subspaces according to the number of items, employing binary search way can reduce the number of the vector subspace quickly when searching the frequent item sets, whose purpose is to accelerate the searching process.



VI. EXAMPLES Here, let?s take the transaction database in Figure 1 again as an  example to describe our algorithm. Firstly, database D  is mapped  into Boolean matrix R  with sequencing , shown as Figure 2. Suppose the smallest support , mark  . then according to the number of items in the business database, constructs the following vector subspaces with formation [Eq.(1)]:  54321 ,,,, IIIII 2supmin ?  TR ),,,( 921 ??? ??  )}1,0,0,0,0(),0,1,0,0,0(),0,0,1,0,0(),0,0,0,1,0(),0,0,0,0,1({ 15141312111 ?????? ?????W  ),0,0,1,1,0(),1,0,0,0,1(),0,1,0,0,1(),0,0,1,0,1(),0,0,0,1,1({ 25242322212? ? ? ?? ?? ? ? ? ?W  )}1,1,0,0,0(),1,0,1,0,0(),0,1,1,0,0(),1,0,0,1,0(),0,1,0,1,0( 21029282726 ????? ?????  ),1,0,1,0,1(),0,1,1,0,1(),1,0,0,1,1(),0,1,0,1,1(),0,0,1,1,1({ 35343332313 ?????? ?????W  )}1,1,1,0,0(),1,1,0,1,0(),1,0,1,1,0(),0,1,1,1,0(),1,1,0,0,1( 31039383736 ????? ?????  )}1,1,1,1,0(),1,1,0,1,1(),1,1,1,0,1(),1,0,1,1,1(),0,1,1,1,1({ 45444342414 ?????? ?????W  )}1,1,1,1,1({ 515 ?? ?W  Thus, the entire searching process is:  Step 1: make 10 ?k , calculate 3)  115int(0 ? ??  ?? kk ;  Step 2: make inner product ?? ij ?? ,3 , 9,,2,1 ??i with each vector j3?  of  vector subspace 3W  and all row vectors i?  of Boolean matrix , and calculate the number  of  TR ),,,( 921 ??? ?? ?? ij ?? ,3 =3, 10,,2,1 ??j , marked as )( 3 jsum ? . Then get  them as follows:  2)( 31 ??sum 1)( 32 ??sum  2)( 33 ??sum 0)( 34 ??sum  1)( 35 ??sum 0)( 36 ??sum  0)( 37 ??sum 1)( 38 ??sum  0)( 39 ??sum 0)( 310 ??sum  Obviously, in  the support of vector  and vector 3W 31?  33? 2supmin ?? . So discards the searching of frequent item set in and . Then, makes , transfers to , 41W 2W 30 ?k 3W W  and 5W to search the largest frequent item sets;  Step 3: Calculate the new position 4)  135int(0 ? ??  ?? kk ,  make inner product ?? ij ?? ,4 , with each vector 9,,2,1 ??i j4?  of vector subspace 4  and all row vectors W i?  of  Boolean matrix , statistic the number of  TR ),,,( 921 ??? ?? ?? ij ?? ,4 =4, marked  as )( 3 jsum ? . Then get them as follows:  0)( 41 ??sum 1)( 42 ??sum  ?)( 43?sum ?)( 44?sum 0)( 45 ??sum  Obviously, in there is no vector whose support 4W 2supmin ?? . For this reason, through a few steps above, we  know that the largest frequent item set of business database D  is  the item set that nonzero-bit items consist of, which vectors 31?  and  correspond to in vector subspace , respectively,  and .  The results coincide with the traditional Apriori algorithm.

33? 3W  }{ 321 III }{ 521 III

VII. CONCLUSION As an interdiscipline of Database, Artificial intelligence,  Machine learning and Statistics, data mining has become a hotspot in the area of database technology and has been widely used in many fields. In this paper, binary search way is employed to search the expected vector in the vector space and it could obtain frequent item sets from database successfully. Studies show that the method is not only simple, just scanning the database only once, but also has advantages such as reducing the constructed vector subspace and improving search speed. For exploring and solving some questions like the explosion of data and knowledge deficient in present era, it still has some reference value.

