Pairing Continuous Authentication with Proactive Platform Hardening

Abstract?Mobile authentication has always been a usability and security challenge. In the past, researchers have discovered various methods to bypass the screen lock protection mechanism without entering authentication credentials on mobile devices.

There is a clear need for authentication to be seamless and continuous but also address the security threats that stem from the current unlock-once, always-on mechanisms. To that end, we developed a framework for continuous behavioral authentication of users. In addition, we introduce a configurable ?authentication level? for access to resources and applications. For example, if a user?s authentication level declines below a pre-specified threshold, all external communications are disabled to prevent exfiltration of sensitive data. Similarly, viewing or modifying any sensitive data on the device is also restricted by moderating access to the underlying file system based on the user?s authentication level. We will perform a live demonstration of our entire system implemented for Android 6.0.1, and show how it can successfully defend against a wide range of attacks while improving the us- ability of the mobile device by offering a seamless authentication experience.



I. INTRODUCTION  Although many device screen lock options are available, researchers estimated that 34% of Android devices did not use any screen lock [1]. In addition, Aviv et al. [2] showed that a partial or complete pattern could be revealed using ?smudge attacks? on pattern-based screen locks. Going beyond screen attacks, John Gordon [3] discovered a method to bypass the screen lock on Android 5.0 and 5.1 devices while researchers at Vulnerability Labs discovered 4 different methods to by- pass the screen lock on iOS 9.2 using Siri and other apps reachable from the screen lock [4]. To make matters worse, static biometrics can be easily compromised either directly or indirectly using photographs of the user?s fingerprints [5] or fingerprint impressions on objects they touched [6], [7].

Unfortunately, once a user?s biometric data is compromised, they cannot reliably be used again. This is the case for the 5.6 million sets of fingerprints of federal employees that were compromised [8] and the millions of Filipino voters whose biometric data were made available online [9]. There have also been vendor-specific screen lock vulnerabilities [10], [11] including how the fingerprint sensors are implemented and insecure storage of fingerprint data.

Once an attacker bypasses the screen lock, they can view and transfer sensitive data from the device. The adversary can enable Android Debug Bridge (ADB) to make a ?backup? of  the device without ?rooting? it. This includes all application data except for apps that have explicitly prohibited this action.

ADB can also be used to install applications that actively collect sensitive information. To address these threats and improve Android?s defense-in-depth posture, we developed a continuous authentication and policy enforcement platform that authenticates a user based on their interactions with the device. Our approach goes beyond simple allow/deny models offering fine-grained resource access control based on configurable authentication levels. The moderated resources can have different thresholds at which they are revoked or granted, thus authentication is not a simple binary decision.



II. DEMONSTRATION OVERVIEW  We will provide a demonstration of the authentication and enforcement platform implemented for Android devices (Android 6.0.1) against a number of practical attacks. We assume that the attacker has obtained remote programmatic or physical access to the mobile device and can bypass any screen lock protection that is present. This allows the attacker to interact with the device and freely mount attacks against the confidentiality and integrity of the device. We will demonstrate that the impostor will not be able to imitate the behavior of the authorized user, and will thus be subject to policy enforcement actions on the device. One of the most significant threats is the capability to obtain ?root? access on the device. In practice, this can be accomplished if the attacker is able to install a one-click rooting application. If there is a successful rooting strategy for the specific device, then the attacker will be able to perform unrestricted actions on the device such as obtaining sensitive application data and installing software to maintain a stealthy and persistent presence. This threat is mitigated while the attack takes place by disabling the wired and wireless communication methods, blocking ADB, and moderating access to the file system.

Another attack path is the use of physical access to transfer or backup private application data. This is a capability natively provided by the Android Operating System (OS) for backing up apps and restoring them at a later point. An attacker can enable ADB via the Settings app and interact with the device from a separate computer. The attacker can use the adb backup -all command to create a local backup of device?s private application data. The attacker can also copy files from      the emulated SD card such as the user?s photos. ADB also allows the installation and uninstallation of third-party apps via simple commands. The attacker can uninstall or disable apps on the device that provide security while installing malicious apps that have powerful permissions to obtain sensitive data and exfiltrate them at will. We will show that any attack that utilizes ADB is prevented by disabling ADB when the impostor?s authentication level drops below a certain threshold.

Moreover, independent of the approach used to obtain sensi- tive data, the wired and wireless communications methods can be disabled by the enforcement module since it can disable Wi- Fi, mobile data, Near Field Communication (NFC), Bluetooth, and ADB. The attacker can attempt to unlock the bootloader in order to flash a custom recovery image to root the device.

If the bootloader can be unlocked, the Android OS will wipe the data partition (i.e., the user?s data) when the bootloader is first unlocked. Even with the aforementioned restrictions of disabling ADB and wired and wireless communication methods, the attacker can still use the apps installed on the device which provide access to their own data. For example, the attacker can view the user?s emails, chat messages, and text messages through the appropriate app. To address this threat, we moderate access to the file system according to the user?s authentication level. When the authentication level drops below a certain threshold, applications will not be able to access any file including their own application files, which will prevent sensitive data from appearing on the screen.



III. AUTHENTICATION & ENFORCEMENT  Authentication Module: The authentication module con- siders three modalities to authenticate the user: touch, move- ment, and power consumption. These modalities capture the way that the user interacts with the device. Data collection mode gathers the user?s actions via sensor data, device files, and Android Application Programming Interface (API) method calls. More specifically, for touch gestures, characteristics such as duration of the gesture, pressure applied on screen, and other properties of the arc drawn on screen are extracted. Ac- celerometer and gyroscope sensor data and power consumption measurements are collected as a time series. Time domain statistical features such as mean and standard deviation of the measurements along each coordinate axis in a given sliding window of 2 seconds is considered. In addition, frequency domain features are extracted in the form of the first 5 coefficients of the power spectrum, for each time series in question. Initially, the user builds a profile on a per-app basis since a user does not interact with all apps in the same way.

There is a training period where data is collected from the three modalities and when sufficient data has been gathered, a model of their behavior is generated for the application. The switch from data collection mode to authentication mode is abstracted from the user and occurs on a per-app basis. The user?s current behavior is evaluated against the generated model to determine an authentication score. The authentication score ranges from 0 to 100, where a higher score represents higher confidence that current user is the authorized user that created the profile.

Additional information on the authentication module can be found in [12], [13].

Enforcement Module: Using the authentication scores that are continuously provided by the authentication module as the user is using the device, we have implemented an enforcement mechanism that resides on the device to progressively grant and revoke access to resources as the authentication scores rises and falls. If an impostor is able to get past the screen lock due to its absence or a successful attack, they will quickly lose access to resources. Some of the device resources that can be controlled by the enforcement module are the use of the camera, Wi-Fi, mobile data, Bluetooth, NFC, microphone, and ADB. ADB is disabled so that an adversary cannot ?sideload? apps, change secure settings, backup the device, transfer files, and more [14]. The control of some of these resources is accomplished by granting the WRITE_SECURE_SETTINGS permission which has a protection level of development that allows a user to explicitly grant the permission to an app via an ADB command. The prevention of installing apps from unknown sources and disabling ADB also prevents the installation of rooting apps and spyware on the device which can compromise the integrity of the device.

Dynamically Revoking and Granting Resources: The enforcement mechanism extends our work [15] to enforce access of the file system and to integrate with the authen- tication module. The external communication mechanisms can be restricted to prevent exfiltration of sensitive data from the device. Even though the exfiltration capabilities via communication and file transfer methods can be revoked, a determined attacker can still access sensitive data and take a picture of the victim device?s screen with a camera. In order to address this threat, we developed an approach to restrict access to files on the device when the user?s au- thentication score drops below a certain threshold. All of the previously-mentioned enforcement actions can be performed by a Mobile Device Management (MDM) application that has been granted the WRITE_SECURE_SETTINGS permission, but directly controlling file system access of other applications on the device requires an instrumentation technique due to Android application sandboxing.

Moderating File System Access: The enforcement module uses the presence or absence of a world-readable empty file in its private directory (i.e., /data/data/<package name>) to signal to other apps whether they can perform Input/Output (I/O) operations without restriction. Using a world-readable empty file allows all processes on the device to check for the existence of the file, although the file cannot be deleted except by the enforcement module due to its Linux file permissions.

An application will check for the presence of the file, but not actually read from it since the underlying implementation for checking for the existence of a file uses the access system call. The presence of the file indicates to other pro- cesses that I/O operations are currently prohibited, while its absence signals that I/O operations can proceed normally. The enforcement module creates and deletes the access file based on the user?s authentication score.

To prevent normal I/O operations, we provide the process requesting an I/O operation with the /dev/null special device file for reading and writing instead of the actual file it requested. This allows a process to write data to the /dev /null file which will not make any persistent changes on the file system. Reading from the /dev/null file will create an end-of-file condition so that no data will be read. This is accomplished by providing the file descriptor to the /dev/ null special device file when the process attempts to open a file. Instead of hooking the numerous high-level Android API methods for I/O access, we have identified low-level methods that are not part of the public Android API but are utilized by the high-level methods. These low-level methods are se- lected for performance reasons which allows less methods to be hooked. The libcore.io package declares many native methods that are reachable via Java Native Interface (JNI) calls that act as an abstraction for Linux system calls. Specifically, the libcore.io.Posix class covers various methods used in the Android framework for I/O operations from the java .io and java.nio packages. In addition, the enforcement module hooks additional methods to cover accessing data from SQLite databases, content providers, and command execution via system binaries.

The libcore.io.Posix.open(String, int, int) method is utilized to first open a file before reading or writing to it for many I/O operations. The first parameter provides the full path to the file to be opened. Using this parameter, we make exceptions for files that should always be able to be opened since they are important for app stability.

Performing I/O operations on structured data via a content provider, one of the four Android application components, does not directly utilize the libcore.io.Posix.open( String, int, int) method, so two non-public methods of the android.content.ContentResolver class are hooked to moderate access. The ContentResolver.

acquireUnstableProvider(Uri) method is hooked to prevent a Uniform Resource Identifier (URI) from being queried. Exceptions can be made for specific URIs if desired. If I/O operations are currently prohibited, then this method will return null so there is no resulting android.

database.Cursor object to query. For the update, insert, and delete operations, the same approach is used for the ContentResolver.acquireProvider(Uri) method.

Directly accessing an SQLite database without the use of a content provider is moderated by hooking the android.database.sqlite.SQLiteConnectionPool.

open(SQLiteDatabaseConfiguration) method. If I/O operations are currently prohibited, the hooked method throws an android.database.sqlite.SQLiteException.

This exception is not a checked exception, but it will be caught by the calling method and prevent any I/O operations on the SQLite database. Runtine.exec(String ), ProcessBuilder.start(), and similar API methods to execute commands are also hooked to prevent system binaries from accessing files (e.g., , grep, head, tail, etc.). If I/O operations are currently prohibited, then the requested file  will be replaced with the /dev/null special device file.



IV. RELATED WORK  Seifert et al. [16] implemented explicit ?spheres? which represent predefined access control prepared by device ad- ministrators. Decisions are based on external factors, such as GPS coordinates, a Wi-Fi network identifier, a Bluetooth identifier, or an RFID tag. Riva et al. [17] created a multi- modal progressive authentication system that includes biomet- rics, behavior, possession, and a secrets challenge to moderate access to applications. HMOG [18] utilizes a learning system that learns from touch, movement, and other sensory data to detect deviations and mark them as anomalies to diagnose a user as legitimate or illegitimate in a binary fashion.

