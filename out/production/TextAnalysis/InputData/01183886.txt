Mining General Temporal Association Rules for Items with Different Exhibition

Abstract  In this paper, we explore a new model of mining gen? eral temporal association rules from large databases where the exhibition periods of the items are allowed to be dif? ferent from one to another. Note thaI in this new model, the downward closure property which all prior Apriori? based algorithms relied upon to attain good efficiency is no longer valid As a result, haw to efficiently generate candidate itemsets form large databases has become the major challenge. To address this issue, we develop an ef?  ficient algorithm, referred to as algorithm SP F (standing for Segmented Progressive Filter) in this paper. The basic idea behind 5 P F is to first segment the database into sub? databases in such a w? that items in each sub-database will have either the common starting time or the common ending time. Then, for each sub-database, S P F progres? sively filters candidate 2-itemsets with cumulative filtering thresholds either forward or backward in time. This fea? ture allows SP F of adopting the scan reduction technique by generating all candidate k-itemsets (k > 2) from candi? date 2-itemsets directly. The experimental results show that algorithm SP F significantly outpeiforms other schemes which are extendedfrom prior methods in terms of the exe? cution time and scalability.

1. Introduction  In recent years, a significant amount of research ef? fort has been elaborated upon deriving data mining tech? niques to discover useful but unknown knowledge from large databases. The knowledge discovered includes those on association rules, classification rules, sequential pat? terns, path traversal patterns, user moving patterns, and etc.

Among others, mining of association rules is a welt ad? dressed important problem, i.e., "Given a database of sales   transactions, one would like to discover the important asso? ciations among items such that the presence of some items in a transaction will imply the presence of other items in the same transaction."  The problem of mining association rules was first ex? plored by [2]. Following this pioneering work, several fast algorithms based on the level-wise Apriori framework [3, 15] and partitioning [12] are proposed to remedy the per? fonnance bottleneck of Apriori. In addition, several novel mining techniques, including TreeProjection [I] and FP? growth algorithms [10], also receive a significant amount of research attention. On the other hand, many variants of mining association rules are studied to explore more mining capabilities. such as incremental updating [5,11], mining of generalized and multi-level rules [8, 16J. mining of quanti? tative rules [17], mining of multi-dimensional rules [14], constraint-based rule mining [9] and mining with multi? ple minimum supports [13, 18], mining associations among correlated or infrequent items [7), and temporal association rule discovery [4.6].

While these are important results toward enabling the integration of association mining and fast searching algo? rithms, their mining methods, however, cannot be effec? tively applied to the transaction database where the exhi? bition periods of the items are different from one to another.

As a matter of fact, it is a common phenomenon that the items in a real transaction database have different exhibi? tion periods. The problem can be best understood by the following example.

Example 1.1: Consider the transaction database V as shown in Figure I. A set of time series database indi? cates the transaction records from January 2002 to April 2002. The exhibition period of each item is given in the right of Figure 1. Assume that the minimum support and the minimum confidence required are min_supp = 30% and min_con! = 75%, respectively. By conventional min? ing algorithms, with respect to the same support counting    D  TmnatimIlflllm: It"" sbr1 at!

!lre 1ID 1_ A Jan.02 N;r.(J2  1\)1 A C F B Fd>{I2 N;r.fJ2 11)2 A D F  PI J;n.()2 1U3 C F  C lar>02 MIr-Ol  D Jan.02 Fd>{J2  TIl4 A 0 E MI'.()2 N;r-a!

1Il5 BCD F F lar>02 MIr-a!

FdJ.{l2 m; C  P2 1117 BCD  I I I A I I I  mI AB I I I  TOO C EF B I I I I I I  TID AB F P3 MI:.(J2  TIl EF  TI2 B  C I I I I I I I I  D I I I I I I I I  m A E  f>I P(r.{}2 TI4 B E  TI5 AB  I I I I E I I I I  I I I I F I I I I  TI6 AB PI P2 P3 P4  Figure 1. An illustrative database where the items have individual exhibition periods.

basis lVI, only the itemsets {A}, {B}, {C} and {F} will be termed as frequent itemsets. Thus, no rule will be dis? covered in this case. However, as will be shown later in Example 1.2, some rules do exist in the illustrative database when the individual exhibition periods of items are taken into consideration.

From Example 1.1, we can observe that the problem of conventional mining algorithms lies in their absence of eq? uitable support counting basis for each itemset. It is noted that the itemsets with longer exhibition periods (e.g., A, B. C and F) are more likely to be frequent than those with shorter exhibition periods (e.g., D and E). As a re? sult, the association rules we usually discover will be those composed of long-term items (e.g., milk and bread are fre? quently purchased together, which is, however, of less in? terest to us). In contrast, some short-term itemsets, such as those composed of seasonal food or clothes, which may be really "frequent" and interesting in their exhibition periods are less likely to be identified as frequent ones if a con? ventional mining process is employed. To address this is? sue, we explore in this paper a new model of mining gen? eral temporal association rules where the items are al10wed to have different exhibition periods, and the determination of their supports is made in accordance with their exhibi? tion periods. Explicitly, we introduce the notion of maxi? mal common exhibition period (abbreviated as MCP) and define the relative support to provide an equitable support counting basis for each item set. The MCP of the itemset X, denoted by [p, q], is defined as the period between the latest-exhibition-start time p and the earliest-exhibition-end time q of all items belonging to X. For example, for the   itemset BC in Figure I, its MCP is [2,3] since the latest? exhibition-start time of the items B and C is 2 and the earliest-exhibition-end time ofthe items B and C is 3. The relative support of the itemset X is given by supp( XP.9) = j{TEV??O!XCT}! where VM indicates the partial database IVI'.-j bounded by [p, q], and I{T E Vp,qIX ? T}I indicates the number of transactions that contain X in VP.q. The gen? eral temporal association rule (X ==} Y)p,q is termed to be frequent within its MCP (p, q] if and only if its relative support is not smaller than the minimum support required (i.e., supp?X U Y)P.q) ;:: min_supp), and its confidence is not smaller than the minimum confidence needed (i.e., conf?X ==} Y)P.9) = supp?XLJy)M) > min_conf). supp(XP.qj - Example 1.2: Based on the definitions above, the frequent general temporal association rules in Example 1.1 can be identified as follows: (1) (A => B)2.4 with supp(AB2.4) = 12 > 30% and conf?A ==} B)2.4) = .?:;;(??.;;) = ? > 75%; (2) (D ==? B)2,2 with supp(BD2,2) = ? > 30% and canf?D => B)2.2) = supp(BD"") = 1 > 75%' ,,,pp(VU) 2 ' (3) (E ==? F)3.3 with supp(EF3.3) = ? > 30% and  f(E F)3,3) - supp(EF"'") - 2 7 M . eon ==} - .tipp(E",") - 2 > 5/0, (4) (D =:- BC)2,2 with supp(BCD2,2) = ? > 30% and eanf(D ==} BC)2,2) = ."pp{BCV.,,?2) = 1 > 75%. supp(DV) 2  It is important to note that in this new model, the down? ward closure property which all prior Apriori-based algo? rithms relied upon to attain good efficiency is no longer valid. Recall that the downward closure property guar? antees that all sub-itemsets of a frequent itemset are fre? quent. Based on this property, all prior Apriori-based al? gorithms are allowed to limit their attention to those can? didates whose sub-itemsets are frequent and to prune the searching space effectively. However, once this property is not valid anymore, the searching space will explode and be? come difficult to tackle.

Example 1.3: From the illustrative database in Example 1.1, we can find that although the itemset BCD is frequent in its maximal common exhibition period, the itemsets BC, BD and CD are not all frequent in their corresponding maximal common exhibition periods. Explicitly, the item? set BC is infrequent in its maximal common exhibition pe? riod [2,3] since its relative support is only 25% ? 30%).

Similarly, the itemset CD is infrequent in its maximal com? mon exhibition period [1,2]. Hence, to determine if an itemset is frequent, without the downward closure property, we are not allowed anymore to limit our attention to those whose subitemsets are frequent.

To address this issue, we develop an efficient algorithm, referred to as algorithm SP F (standing for Segmented Progressive Filter) in this paper. In essence, algorithm SPF consists of two major procedures, i.e., Segmentation    (abbreviated as ProcSG) and Progressively Filtering (abbre? viated as ProcPF). The basic idea behind S P F is to first di? vide the database into partitions according to the time gran? ularity imposed. Then, in light of the exhibition period of each item, S P F employs ProcSG to segment the database into sub-databases in such a way that items in each sub? database will have either the common starting time or the common ending time. Note that such a segmentation will allow us of counting the itemsets in each sub-database ei? ther forward or backward (in time) efficiently. Then, for each sub-database, SP F utilizes ProcPF to progressively filter candidate 2-itemsets with cumulative filtering thresh? olds from one partition to another. Since infrequent 2- itemsets are hence filtered out in the early processed par? titions, the resulting candidate 2-itemsets will be very close to the frequent 2-itemsets. This feature allows us of adopt? ing the scan reduction technique by generating all candidate k-itemsets (k > 2) from candidate 2-itemsets directly [15].

The experimental results show that algorithm SPF signifi? cantly outperforms other schemes which are extended from prior methods in terms of the execution time and scalabil? ity. The advantage of SP F becomes even more prominent as the size of the database increases.

The rest of this paper is organized as follows. Section 2 describes the problem of mining general temporal associ? ation rules. The proposed algorithm SP F is presented in Section 3. The performance of algorithm SPF is empiri? cally evaluated in Section 4. We conclude this paper with Section 5.

2. Problem Description  As described in Section 1, the items in a transaction database may have different exhibition periods. Without loss of generality, it is assumed that a certain time gran? ularity, e.g., week, month, quarter or year, is imposed by the application database. Let n be the number of partitions divided by the time granularity imposed. In the model con? sidered, dbp,q (1 :::; p :::; q :::; n) denotes the portion of the transaction database formed by a continuous region from the partition Pp to the partition Pq, and XP?q denotes the temporal itemset whose items are commonly exhibited from the partition Pp to the partition Pq.

As such, we can define the maximal temporal itemset XP.q and the corresponding temporal sub-itemsets as fol? lows.

Definition 1: The temporal itemset XM is called a max? imal temporal itemset (FI) if Pp is the latest starting par? tition and Pq is the earliest ending partition of all items belonging to X. [p, qj is referred to as the maximal com? mon exhibition period (Mep) of the itemset X, denoted by MCP(X).

Definition 2: The temporal itemset yp,q is called a tempo-   raj sub-itemset (Sf) of the maximal temporal itemset xp,q if Yex.

Based on Definition 1, the temporal itemset ECD2.'2 in Figure I is deemed a maximal temporal itemset since the latest starting partition and the earliest ending partition of the items E, C and D are both Pz. In addition, the temporal itemsets BCz.'l, BD2,2 and CD2.z are the corresponding temporal sub-itemsets of BC D2,2 according to Definition 2. Note that BD2,2 is also a maximal temporal itemset it? self, but BC2.2 is not since the earliest ending partition of the items Band Cis P3 rather than P2?  In the conventional problem of mining association rules, the support of the itemset X is determined by supp(X) = I{TEdb1'"IXCTIi . .

Idb""1 ' whIch IS referred to as the absolute sup- port in this paper. However, as explained in Section I, we shall provide an equitable support counting basis for each temporal itemset. To this end, we define the relative sup? port for a temporal itemset below.

Definition 3: The relative support oj the temporal itemset XP.q is defined as  which is the fraction of the transactions supporting the item? set X in dbP,q.

With the equitable support counting basis defi ned in Def? inition 3, we can then determine whether a maximal tempo? ral itemset is frequent by the following definition.

Definition 4: The maximal temporal itemset XMCP(X) is termed to be frequent iff supp(XMCP(X?) ::::: min_supp where min_supp is the minimum support required.

Property 1: All temporal sub-itemsets of afrequent maxi? mal temporal itemset are frequent.

As will be explained later, Property 1 is very important for us to determine the confidence of a general temporal association rule defined below.

Definition 5: The rule (Y =g. Z)MCP(X) derived from the maximal temporal itemset X MC P(X) is called a general temporal association role if Y c X and Z = X - Y.

Definition 6: The confidence of the general temporal asso? ciation rule (Y ==> Z)MCP(YUZ) is defined as  ((Y U Z)MCP(YUZ?) conf((Y ===> Z)MCP(YUZ)) = supp . . supp(yMCP(YUZ))  Note that the calculation of the confidence of a general temporal association rule not only depends on the relative support of the corresponding maximal temporal itemset but also relys on the relative supports of the corresponding tem? poral sub-itemsets. Property 1 ensures that the relative sup? ports of the corresponding temporal sub-itemsets can be ob? tained without extra database scans since all temporal sub-    itemsets of the frequent maximal temporal item set are also frequent.

Finally, given a pair of min_con! and min_supp re? quired, we can define the frequent general temporal asso? ciation rule below.

Definition 7: The general temporal association rule (Y ==} Z)MCP(YUZ) is termed to be frequent iff supp((YUZ)MCP(YUZ)).2: min_suppandcon!((Y ? Z)MCP(YUZ)) .2: min_con/.

With these definitions, the problem of mining general temporal association rules is to discover all frequent general temporal association rules from the large database. Simi? larly, the problem of mining general temporal association can be decomposed into two steps: (1) Generate all fre? quent maximal temporal item sets (T 1 s) and the correspond? ing temporal sub-itemsets (S1 s) with their relative supports; (2) Derive all frequent general temporal association rules that satisfy min_con! from these frequent TIs.

Note that once the frequent T 1 s and S1 s with their sup? ports are obtained, deriving the frequent general temporal association rules is straightforward. Therefore, in the rest of this paper we concentrate our discussion on the algorithms for mining frequent TIs and S1 s.

3. Mining General Temporal Association Rules  We present the proposed algorithm, SPF, for mining general temporal association rules in this section. A detailed description of algorithm SPF is given in Section 3.1. In Section 3.2, we use an example to illustrate the operations ofSPF.

3.1. Algorithm SPF  The major challenge of mining general temporal associ? ation rules is that the exhibition periods of the items in the transaction database are allowed to be different from one to another. In such a circumstance, it is very difficult to efficiently generate candidate itemsets since the downward closure property is no longer valid as explained in Section 1. To address this problem, a novel algorithm, SP F, is proposed in this section to discover general temporal asso? ciation rules efficiently.

In essence, algorithm SP F consists of two major proce? dures, i.e., Segmentation (abbreviated as ProcSG) and Pro? gressively Filtering (abbreviated as ProcPF). The basic idea behind SP F is to first divide the database into partitions ac? cording to the time granularity imposed. Then, in light of the exhibition period of each item, SPF employs ProcSG to segment the database into sub-databases in such a way that items in each sub-database will have either the common starting time or the common ending time. For each sub? database, SP F utilizes ProcPF to progressively filter can? didate 2-itemsets with cumulative filtering thresholds from   one partition to another. After all sub-databases are pro? cessed, S P F unions all candidate 2-itemsets generated in each sub-database. As pointed out earlier, since infrequent 2-itemsets will be filtered out in the early processed parti? tions, the resulting candidate 2-itemsets will be very close to the frequent 2-itemsets. This feature allows us of adopting the scan reduction technique by generating all candidate k? itemsets (k > 2) from candidate 2-itemsets directly. After all candidate item sets are generated. they are transformed to TIs, and the corresponding SIs are generated based on these T 1 s. Finally, the frequent TIs and S1 s with their sup? ports can be obtained by scanning the whole database once.

3.1.1. Description of ProcSG for Segmentation  The motivation of ProcSG is to first reduce the problem of mining general temporal association rules to the one in which the exhibition periods of the items are only allowed to be either different in the starting time Or different in the ending time. After such a reduction, we are able to employ ProcPF, in each sub-database, to progressively filter can? didate 2-itemsets either forward or backward (in time) ef? ficiently. However, as mentioned above, the advantageous feature of ProcPF is that it can progressively filter out in? frequent 2-itemset in the early processed partitions. Thus, the more segments the whole database is divided into, the less significant the filtering effect will be. In view of this, ProcSG is devised to segment the whole database into the minimal number of sub-databases as required for items in each sub-database to have either the common starting parti? tion or the common ending partitioh.

indt1  A I!----'--L...---li BI W C I, ' I  t : D:. i I E , F , ! !

G: I I , ! H  0 1 2 3 naaliilL! T T F flal![iJ[R) F F T dirediGn -1 L L -I  ? , I I , ! I ? 4 5 6 T F T T -1 R  Figure 2. An example illustrating the execu? tion of ProcSG.

Figure 2 illustrates the execution of ProcSG. Operations in lines 1-3 initialize the parameters used in the procedure.

The for loop in lines 4-8, for each item, sets the left flag of the starting partition and the right flag of the ending parti? tion to be true. The resulting values inftag array are shown in the bottom of Figure 2. With these flags, the for loop in lines 9-31 scans the partitions from the first to the last. Once    the value of direction is reversed, one segmentation has to be made, and the value of direction is reset. From the ex? ample in Figure 2, the value of direction is reversed twice, meaning that two times of segmentation are needed. Con? sequently, the original database dbl,6 is divided into dbl,3, db4,4 and db5,6.

ProcedUR ProcSG(n)

I. SM = 0; dire.ctian = -1; head = 1; 2. for (index = 0 to n) 3. flag[i][LJ = false; flag[i][RJ = false; 4. for (each item i E T) { 5. (p, q) = Mep(i); 6. flagfp - l)[LJ = true; 7. flag[qllR] = true; 8. } 9. for (i = 1 to n - 1) { 10. if(directian == -1) { 11. if(flag[i)[LJ == true and flag[i][RJ == true) { 12. SM == SAl U {(head, inde.x, direction)}; 13. head = index + 1; 14. } elseifUlag[iJiLJ == true and flag[i][RJ == false) 15. direction = L; 16. elseif{flag[iJ[L] == false and flag[i][R] == true) 17. direction = R; 18. } elseif(direction == L) { 19. if(flag(indexJ[R] == true) { 20. 8M = SM U {(head, index, direction)}; 21. head = index + 1; 22. direction = -1; 23. } 24. } elseif(directian == R) { 25. if(f/ag[iJ[L] == true) { 26. 8M = SM U {(head, index, direction)}; 27, head = index + 1; 28. direction = -1; 29. } 30. } 31. } 32. SM = SMU {(head,n, direction)}; 33. Rturn SM;  3.1.2. Description of ProcPF for Progressively Filtering  After the entire database is segmented by ProcSG, ProcPF is designed to progressively filter candidates 2-itemsets from one partition to another in each sub-database. Specif? ically, ProcPF generates all 2-itemsets and counts their oc? currences in the first partition. For those 2-itemsets whose numbers of occurrences are not smaller than the filtering threshold (Le., min_supp * IPII), they are viewed as can? didate 2-itemsets and will be brought to the next partition for further processing. Then, ProcPF will generate new   2-itemsets in the second partition and count their occur? rences as well. However, for those candidate 2-itemsets brought from the previous partition, their numbers of oc? currences will be cumulated from the previous partition to the current one. Note that the filtering threshold (i.e., min_supp* (IPII + IP21) for them will also be cumulated.

Similarly, those 2?itemsets whose numbers of occurrences are not smaller than their corresponding filtering thresholds will be brought to the next partition for further processing until there is no partition to be processed any more.

Let P S denote the cumulative set of candidate 2- itemsets. It is noted that PSis composed of the follow? ing two types of candidate 2-itemsets: ( I)  the candidate 2- itemsets that were carried over from the previous partition and remain as candidate 2-itemsets after the current parti? tion is included into consideration; and (2) the candidate itemsets that were not in the cumulative candidate set in the previous partition but are newly selected after taking the current partition into account. Since a significant number of 2-itemsets will be filtered out in the early partitions, the resulting PS will be very close to the set of frequent 2- itemsets after processing all partitions. Taking advantage of this feature, we can employ the scan reduction technique to generate all candidate k-itemsets where k > 2 from (k-I)? itemsets at the same time [15].

The procedure to progressively filter out infrequent 2- item sets is shown in ProcPF. ProcPFtakes three arguments p, q and direction as the inputs, where p and q are the starting and ending partitions to be processed (p ::; q), and direction indicates the scanning direction, i.e., either for? ward (Le., from p to q) or backward (i.e., from q to p) in time, If the items in the sub-database have the same end? ing partition, the direction is forward. Otherwise, the di? rection is backward. As shown in ProcPF, operations in lines 1-5 initially set P S to be an empty set and determine the scanning sequence. The for loop, in lines 6-17, finds out all 2-itemsets with their numbers of occurrences in each partition, and employs the corresponding filtering threshold (I.e., min_supp * Lm=X.start,h IPm I) to filter out infre? quent ones. After processing all partitions, the cumulative set of candidate 2-itemsets, P S, is returned in line 18.

ProceduR ProcPF(p, q, direction) l. P8=0; 2. if (direction == left) 3. head == p; tail == q; 4. else 5. head = q; tail = p; 6. for (h = head to tail) 7. for (each. 2-itemset X2 in Ph) 8. jf(X21. PS) {  9. X2.count = N Ph (X2); 10. X,;!.start = h;

II. if(X2.count::: min_supp* iFhl)    12. PS = PSU X2; 13. } else { 14. X2.count = X2.count + N Ph (X2); 15. if(X2.count < rmin_supp * Lm=X2 .? tarl,h IP",,\l) 16. PS = PS - X2; 17. } 18. return PS;  Finally, algorithm SP F is completed by the integration of ProeSe and ProcPF. At first, algorithm SP F segments the database into sub-databases by ProeSe. Then, for each sub-database, algorithm SPF employs ProcPFto progres? sively filter out candidate 2-itemsets. Using the scan reduc? tion technique [15], SP F generates all candidate k-itemsets from (k-l )-itemsets. Thereafter, the candidate k-itemsets are transformed to TIs, and the corresponding SIs are gen? erated. Finally, the database is scanned once to determine all frequent TIs and SIs.

3.2. An Illustrative Example of Algorithm SP F  The operation of algorithm SP F can be best under? stood by an illustrative example as shown in Figure I. Sup? pose that the minimum support and confidence required are 30% and 75%, respectively, i.e., min_supp = 30% and min_con! = 75%. As explained in Section 3.1, Spp first segments the database into several sub-databases by ProeSe. In our example , the transaction database, db1,4, is segmented into two sub-databases, dbl,2 and db3,4as shown in Figure 3. The scanning direction of db1,2 is from the left to the right whereas the scanning direction of db3,4 is from the right to the left.

A I I 1 I I B i I I j c I I I D I ,  j E PI I nl I F P3 P4  direction = . =  !

j? 1 / I .

A B c Ii F  PI  I i  I i  I I I I I I P2f I P3 P4  Figure 3. Segmenting the illustrative database.

After the database is segmented into sub-databases where the items in each sub-database have either the same starting or ending partition., algorithm S P F employs ProePF to progressively filter the candidate 2-itemsets in each ofthese two sub-databases. The execution of ProcPF in sub-database db1,2 is shown in the upper-left part of Fig? ure 4, F ive 2-itemsets are first considered in the parti? tion Plo and their numbers of occurrences and the parti? tion in which they are first considered (i.e., PI) are also   p p-lf> c,-.,.... c, "'"' a:ut /'C 1 1 AD I 2  OAD 1 2 ? I 2 OM I 2 OCF I 3 00' 1 2 AD 2 I  CF I I o OC 2 2 0002 2  BF 2 I ?=-1 m 2 2  --_ .. _-"."  Mertl.: 1 ... _.,... ""w.; C2-{1\B, oc BO, OJ. CF, EFI GoIOCD} 11=(AB". oc<'. SOU. CD' '. 0"", EF'?'. iOJUl  P'l' p C, ...., aut c, -.,....

o AD 4 3 o AD 4 2 ? 3 I AE 4 I J3F 3 I lIE 4 I CE 1 1 Cl' 3 I  Off 3 2  SI=IA",8'-'. 8'-'. S".Cl. CJ,C''', CU,D'l. OU, Ee', ptJ, F".I3IJ.'. BD". CIJl-'I Mort!-. 2nd_,."... "" '-' fre<p.<rtTl={AB'-', aD'-',O"J, EFU, BOJ":  Figure 4. Progressively Filtering candidate 2- itemsets in each sub-database.

recorded. The corresponding filtering threshold for each of them is equal to 2 = r 4 * 0.3l since there are four transactions in Pl. As a result, only the 2-itemsets AD, AF and C F are viewed as the candidate 2-itemsets and brought to the next partition for further processing. In the parti tion P2, the 2-itemsets AG, Be, BD, BF and CD are newly generated, and their numbers of occurrences and the partition in which they are firs t considered (i.e., P2) are also recorded. Since AD, AF and CF are brought from the previous partition, their numbers of occurrences are cumu lated. So are the corresponding filtering thresh? olds for them (Le., 3 = rO.3 * (4 + 4)1). Thus, only the 2-itemsets CF, BC, BD and CD are viewed as candidate 2-itemsets after processing P2. The execution of ProePF in the sub-database db3,4 works similarly and is shown in the upper-right part of Figure 4. Note that the scanning direc? tion in the sub-database db3,4 is from the right to the left, i.e., from P4 to P3. After scanning the sub-databases db1.2 and db3,4, the resu lting candidate set C2 becomes {AB, BC, BD, CD, CF, EF}. Using the scan reduction tech? nique , we generate all candidate k-i temsets from candidate (k-l )-itemsets where k > 2. In our case, only one candi? date 3-itemset BCD is generated. Then, these candidates are transformed to the TIs (i.e., {AB2,4, BC2,3, BD2,3, CDI.2, CF1.3, EF3,3, BCD2,2}), and the corresponding SIs (i.e., {A2,4, B2,2, B2,3, B2,4, Cl,2, C1?3, C2,2, C2,3, D1,2 D2,2 E3.3 pl,3 p3,3 BC2,2 BD2,2 CD2?2}) are ) , l , 1 , i generated as shown in the bottom of Figure 4, By scan? ning the entire database again, we can have the relative sup? ports of all temporal itemsets in T IUS I and then deter? mine the frequent TIs. From the frequent TIs determined (i.e., {AB2,\ BD2,2, CFI,3, Ep3,3, BCD2,2}), we can thus derive all frequent general temporal association rules as shown in Example 1.2.

4. Performance Analysis  To assess the performance of algorithm SPF, we com? pare algorithm SPF with AprioriIP, which is extended from algorithm Apriori to deal with the problem of mining general temporal association rules . Apriorii P first trans? forms each item to the temporal I-itemsets with all possi? ble exhibition periods. Then, based on the anti-monotone Apriori-like heuristic, it generates candidate temporal k? itemsets from frequent temporal (k-I )-itemsets until no can? didate temporal item set can be generated any more. The simulation program is coded in e++. The experiments are run on a computer with Pentium III CPU and 512MB RAM. As will be shown later, algorithm SP F outperforms ApriorilP in terms of execution time and scalability. We describe the method used to generate synthetic databases in Section 4.1. The execution time of algorithm SPF and AprioriIP is compared in Section 42. Results of scaleup experiments are presented in Section 4.3.

4.1. Generation of Synthetic Workload  The method used in this paper to generate synthetic databases is similar to the one used in [3, 151 with some modifications. In order to mimic various exhibition peri? ods of the items in a realistic database, the modifications are made as follows. Initially, we still employ the method used in [3. 15] to generate a synthetic database. Then, we equally divide the synthetic database into P p'artitions to simulate the phenomenon of the time granularity required.

In addition, to model the exhibition periods of the items in a realistic database, we randomly select a starting partition s in the range [1, PJ and the ending partition e in range Is, PJ for each item in the synthetic database. Finally, we scan the database once to remove the items in the transactions which are not within their exhibition periods. For example, the item A would be removed from the transaction ABC in partition 1 ifthe exhibition period ofthe item A were [2,4].

Based on such a modified method, we generate several different synthetic databases to evaluate the performance of algorithm SP F. Each of the generated database consists of IDI transactions with average size of IT I items. The nwnber of different items in each database is N. The average size of the potential frequent itemsets is set to IJI, and the number of the potential frequent itemsets is set to ILl. The mean correlation level between the potential frequent itemsets is set to 0.25 in our experiments. In addition, for the simplicity of presentation, we use the notation Tx - Iy - Dz(Nm? Ln-Po) to represent a database in which ITI = x, III = Y.

D = z (K). N == m (K), ILl = n and IPI = 0 in the following subsections.

4.2. Execution Time  In the first experiment, we investigate the execution time of algorithm SPF and AprioriIP by varying minimum supports. The experimental results on various synthetic databases are shown in Figure 5. As shown in Figure 5, al? gorithm SF F consistently outperforms Apriori 1 P in terms of the execution time. Specifically, the execution time of al? gorithm S P F is in orders of magnitude smaller than that of AprioriIP. The margin even grows as the minimum sup? port decreases.

I  ? 1200 r TlO?I4-D200{N 1 O-L2-P 11)  ? 1000 ....... AprioriJP ., r " .

.5 800 I  -, ..-SPF I- , <: 600 '. ,g [ .. :; 400 '. ? I . . '"  t----- ... , t.1J 200 - - - -.?- - i 0 I . ? ? 0.1 0.3 0.5 0.7 0.9  Minimum Support (%)  Figure 5. The execution time under various minimum supports.

The advantage of SPF over ApriorilP can be ex? plained below. First, the number of candidates generated by Aprioril P increases exponentially as the number of items or the number of partitions increases. In contrast, the number of candidates generated by algorithm S P F is in proportion to the number of items or the number of par? titions in the synthetic database. Second, AprioriIP needs to scan the database multiple times to determines frequent k-itemsets. However, by the technique of scan reduction, al? gorithm SP F only needs to scan the database twice. These two factors will be further explored in the second experi? ment in Section 4.3.

4.3. Scaleup Experiments  In the fourth experiment, we investigate the scalability of algorithm SPF by varying the number of transactions in the synthetic database (IDI). Three different minimum sup? ports are considered in this experiment set, i.e., 0.2%, 0.4%, 0.8% respectively. The experimental result is shown in Fig? ure 6. Note that the execution time under various numbers of transactions are normalized with respect to the time for TIO - 14 ? DIOO. As shown in figure 6, the execution time of algorithm S P F increases linearly while the number    .,10  "!l .S 8 ? !:J !? -;; 8 6 S ?; 4 Z ?  JJ.I 2 r  . . .  , ? ? ? 0.20'/.

_ 0.4(J'/ ?  TIO-I4-Dz(N10-12?PI2) . .  '  . - ? -  o _ ? . ??? L_? ___ .?_???_-.l 100 300 500 700 900  Figure 6. Normalized execution time under various numbers of transactions  of transactions in the synthetic database increases. It shows that algorithm S P F is of good scalability.

5. Conclusion  In this paper, we explored a new model of mining general temporal association rules, i.e., (X ==> y)MCP(XUY) ,  from large databases where the exhibition periods of the items are allowed to be different from one to another. We devel? oped an efficient algorithm, referred to as algorithm SPF in this paper to discover general temporal association rules effectively. The experimental results showed that algorithm SP F significantly outperforms other schemes which are extended from prior methods in terms of the execution time and scalability. With the capability of mining general tem? poral association rules for items with different exhibition periods, algorithm SF F outperforms prior methods in its generality and superiority.

