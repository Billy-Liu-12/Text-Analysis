Improving Opportunistic Data Dissemination via Known Vector?

Abstract  An opportunistic network is a network where each node only has connectiviy with other nodes opportunistically. To disseminate data in this kind of network is a challenging task and had drawn lots of research effort. When two nodes have connectivity with each other, the data bundles stored in their memory will be either replicated or forwarded to the other node in the hope that the data eventually reaches the destination node. The protocols that has only one copy of each data bundle is catagorized as forwarding protocol while the ones with multiple copies called replicating pro- tocols. In opportunistic network, the replicating protocols are preferred over forwarding protocols. Yet, a big over- head is to be solved for replicating routing protocols, i.e.

the exchanging of metadata. To avoid sending data bundles the other party already has, replicating protocols usually exchange metadata at the beginning of the connecting pe- riod. The naive method, sending the data bundles index summary in the memory, seems reasonable. But over time, this metadata exchange will become a big overhead. This paper propose a new scheme of indexing data bundles in the memory and can also reduces the metadata exchanged by large extent.

1. Introduction  For two nodes to establish a temperarily connected link in an opportunistic network, there are usually three phas- ese, namely probing phase, metadata exchanging phase and data exchanging phase. Probing phase is for two nodes to discover each other, this is usually done by periodically bea- coning and listening. Metadata exchanging phase is for two nodes to exchange the information about the data bundles they have, the direction they are heading to, or how much  ?This paper is based on research supported by the National Science Council of Taiwan under Grant No. NSC 97-2628-E-001-007-MY3 and NSC 97-2631-S-003-003.

space they have in the memory. A node applies the meta- data it received to the utility function for some specific goal, e.g. maximum delivery rate, minimum average delay, and decides which data bundles it wants the other node to mule for. The third phase of establishing a link is the data ex- changing phase. In this phase either one node sends data to the other one or they exchange data bundles in turn. Due to the natural charactor of opportunistic network, i.e. un- stable wireless radio links, reliable transmission and how to recover from a temperarily broken link is the main issue in this phase.

In replicating protocols, on receiving metadata, a node can decide which data bundles should be replicated and sent to the other node. That is to say, the time duration and energy spent of data exchanging phase is largely decided by the metadata. With good metadata, only necessary data bundles will be repilcated to the other node and thus the en- ergy used to send/receive redundent data bundles is saved.

As important as it is, metadata is rarely discussed. In this paper, we propose a new method to index metadata, called known vector. Through known vector, we can save largely on the overhead of sending naive metadata repeatly. Pro- posed to solve the problems in the realworld, our protocol uses very little overhead and outperforms the traditional in- dexing method by a large scale.

In section 2 we will discuss other routing protocols for opportunistic networks. In section 3 we describe in details the known vector protocol. Next section 4 we will show the evaluation of the result through the simulation we did in The ONE. In section 5 we conclude the paper.

2. Background  Replication is the most popular design choice for oppor- tunistic routing schemes. For instance, the Epidemic Rout- ing scheme [14] sends identical copies of a message simul- taneously over multiple paths to mitigate the effects of a single path failure; thus, it increases the possibility of suc- cessful message delivery. However, flooding a network with   DOI 10.1109/WAINA.2009.128     duplicate data tends to be very costly in terms of traffic over- head and energy consumption.

To address the problem of excess traffic overhead caused by flooding, Harras et al. proposed a Controlled Flooding scheme to reduce the flooding cost while maintaining reli- able message delivery [8]. In this scheme, flooding is con- trolled by three parameters, namely, willingness probability, Time-to-Live, and Kill Time. Additionally, once a message has been delivered to the receiver successfully, a Passive Cure is generated to ?heal? the nodes in the network that have been ?infected? by the message. Therefore, by remov- ing the excess traffic overhead problem, while providing re- liable data delivery, controlled flooding can substantially re- duce the network overhead.

Node mobility also impacts on the effectiveness of op- portunistic routing schemes. Previous studies have shown that if the network mobility departs from the well-known random way-point mobility model (e.g., the Pursue Mobil- ity Model [4] or the Reference Point Group Mobility Model [9]), the overhead carried by epidemic- and/or flooding- based routing schemes can be further reduced by consid- ering node mobility. For instance, the Probabilistic Rout- ing scheme [13] calculates the delivery predictability from a node to a particular destination node based on the observed contact history, and forwards a message to its neighboring node if and only if that neighboring node has a higher deliv- ery predictability value. The scheme was revised by Leguay et al. [10] by taking the mobility pattern into account, i.e., a message is forwarded to a neighbor node if and only if that node has a mobility pattern more similar to the desti- nation node. [10, 11] show that the revised mobility pattern scheme is more effective than previous schemes.

Another class of opportunistic network routing schemes is based on encoding techniques, which transform a mes- sage into a different format prior to transmission. For in- stance, an integration of network coding and epidemic rout- ing techniques has been proposed to reduce the required number of transmissions in a network [16], and [15] pro- poses combining erasure coding and the simple replication- based routing method to improve data delivery for the worst delay performance cases in opportunistic networks.

Following the concept of erasure coding-based data for- warding [15], an Estimation based Erasure-Coding routing scheme (EBEC) has been proposed to adapt the delivery of erasure coded blocks using the Average Contact Fre- quency (ACF) estimate [12]. Moreover, [6] proposes a hy- brid scheme, called HEC, that combines the strength of era- sure coding and the advantages of Aggressive Forwarding.

The HEC scheme has been further enhanced by employing the techniques of sequential forwarding (i.e., HEC-SF) [7], probabilistic forwarding (i.e., HEC-PF) [5], fully interleav- ing (i.e., HEC-FI) [7], and block-based interleaving (i.e., HEC-BI) [7].

3. Meta-Message Exchange Approaches  When two nodes encounter, they usually need to ex- change some meta-messages to avoid sending duplicate messages that the other node already has. Many protocols apply a scheme which we call Summary Vector. A summary vector is the vector which comprises all identifiers of mes- sages in the buffer of a node. An identifier of a message is unique for each message in the whole network. A replicat- ing protocol usually requires summary vector exchanging to avoid sending/receiving redundant data bundles. But ex- changing the summary vector repeatedly can cause a large overhead. Therefore, we propose a scheme, Known Vec- tor, to alleviate the overhead introduced by the Summary Vector scheme. The Known Vector scheme can be consid- ered as a pre-processor that can eliminate unnecessary iden- tifiers of messages in a summary vector. Every protocol using the Summary Vector scheme can apply our Known Vector scheme to get better performance. For evaluation, we choose to apply the Known Vector scheme to the Epi- demic Routing protocol, and compare it with the original Epidemic Routing protocol with the pure Summary Vector scheme. In section 3.1, we provide an overview of the Epi- demic Routing protocol to briefly explain how the Summary Vector scheme works in this protocol. The proposed Known Vector scheme is explained in section 3.2.

3.1. Epidemic Routing  This section provides an overview of the Epidemic Rout- ing protocol. In Epidemic Routing, the buffer of each node consists of messages originated by this node as well as mes- sages relayed on behalf of other nodes. Each node also car- ries a summary vector which comprises all identifiers of the messages in its buffer. When two nodes encounter, they exchange the summary vector with each other. After re- ceiving the summary vector from the encountering node, a node compares the received summary vector to its own summary vector, and then requests the messages that are not in its buffer. In this paper, we call a request for mes- sages as a request vector. We denote the buffer of node x as BUFx. A summary vector and a request vector sent from node x to node y are denoted as SVx,y and RVx,y respectively. The following is an example of what two nodes do when they encounter. Suppose that, before en- counter, node i has messages M1, M2, and M3 (BUFi = {M1,M2,M3}), and node j has messages M3, M4, and M5 (BUFj = {M3,M4,M5}). When they encounter, node i generates a summary vector SVi,j = {M1,M2,M3} for node j, and node j generates a summary vector SVj,i = {M3,M4,M5} for node i. After exchanging summary vec- tors, node i request messages M4 and M5 by computing a request vector RVi,j = SVj,i ? BUFi, and node j re-     quest messages M1 and M2 by computing a request vector RVj,i = SVi,j ?BUFj . Suppose they have sufficient time to transmit all requested messages. Both node i and node j have 5 messages (M1 to M5) after their encounter.

3.2. The Proposed Approach: Known Vec- tor  While summary vector can be viewed as node based ap- proach, known vector can be viewed as message based ap- proach. In known vector, every message in a node keeps a vector which is a list of node IDs those already have this message this node know of. Note that this vector is not an accurate global network knowledge. The known vector can be regarded as metadata of a message, and is duplicated and sent with the message. The known vectors of replicates in different nodes of one message might not be the same due to different relaying paths. The copy of a message Mk re- sides in node x is denoted as Mk,x, and the known vector of this copy is denoted as KVMk,x . Initially a message Mk originated by node x doesn?t have any record in its known vector Mk,x. i.e. , KVMk,x = {}. When two nodes en- counter, they will take the following steps: when node i and node j encounter, the state of node i is BUFi = {M1,M2}, KVM1,i = {m, j, n}, KVM2,i = {a, b}, and the state of node j is BUFj = {M3,M1}, KVM3,j = {a}, KVM1,j = {m}.

1. Generate and exchange summary vectors: Node x generates SVx,y that contains message IDs of those whose known vector doesn?t include y. The algorithm of generating a summary vector is shown in Algorithm 1.For the example, the summary vector SVi,j contains M2 only, but SVj,i = {M3,M1}.

2. Send a request: Node x generates RVx,y = SVy,x ? BUFx. e.g., RVi,j = {M3}, and RVj,i = {M2}.

3. Transmit messages requested: For every message Mk transmitted from node x to node y, node x firstly duplicates Mk,x as M ?k,x in- cluding KVMk,x . After transmitting M  ? k,x to node y,  node x adds y into KVMk,x . After receiving M ? k,x,  node y saves it in the buffer as Mk,y with KVMk,y = KVM ?k,x ?{x}. For the example, after node i transmits M ?2,i to node j, KVM2,i becomes {a, b, j}, and node j saves M ?2,i as M2,j with KVM2,j = {a, b, i}. Also, after node j transmits M ?3,j , KVM3,j becomes {a, i}, and node i saves M ?3,j as M3,i with KVM3,i = {a, j}.

4. Update known vectors: Node x can infer that node y already has messages in the set SVx,y ? RVy,x because node y is supposed to request every message in SVx,y unless it already has  Algorithm 1 Summary vector generation of node x when it encounters node y in the Known Vector scheme Require: x ?= y Ensure: SVx,y  SVx,y ? {} for all messages Mk,x in the buffer of node x do  if y not in KVMk,x then SVx,y ? SVx,y ? {y}  end if end for  Table 2. The properties of the two network scenarios  Trace Name ZebraNet iMote Device N/A iMote  Network Type N/A Bluetooth Duration (days) 16 3  Devices participating 34 274 Number of contacts 31,693 28,217  Avg # Contacts/pair/day 3.53086 0.12574  that message. Therefore, node x adds y into the known vector of every message in the set SVx,y ?RVy,x. For example, node j can infer that node i already has M1, and then KVM1,j becomes {m, i}.

Table 1 shows all situations for a message Mk which re- sides in node i when node i encounters node j. The sec- ond column shows whether the known vector of the copy of message Mk in node i (denoted as KMk,i) contains j. The third column shows whether node j also has message Mk (denoted as Mk,j), and if node j already has Mk,j , whether the known vector of Mk,j contains i is shown in the fourth column. Explanations about situations are shown in the fifth column.

4. Evaluation  We now evaluate the performance, in terms of the deliv- ery ratio and traffic overhead, of the Summary Vector (SV) scheme and the proposed Known Vector (KV) scheme using a Java-based simulator, called The ONE [2].

We evaluated two network scenarios based on realis- tic wireless network traces, namely, the ZebraNet [1] and iMote [1] traces, which are publicly available for research purposes and correspond to the opportunistic wildlife net- work and people network scenarios. Table 2 outlines the basic properties of the network scenarios.

In each simulation run, the source and the destination pair was randomly selected from all participating peers; and the source peer transmitted messages in the first 10% of the     Table 1. Situations for a message Mk which resides in node i when node i encounters node j Situation KVMk,i contains j Node j has Mk,j KVMk,j contains i Explanation  1 No No No  1. Mk is put in SVi,j .

2. Node j requests Mk after receiving SVi,j .

3. After Mk is transmitted, j is added to KVMk,i , and i is added to  KVMk,j .

2 No Yes No  1. Mk is put in both SVi,j and SVj,i (because i does not know j has Mk , and j does not know i has Mk , either).

2. No request for Mk from node i or node j.

3. Node i can infer node j has Mk and adds j to KVMk,i ; node j can  infer node i has M and adds i to KVMk,j .

3 No Yes Yes  1. Mk is put in SVi,j but not in SVj,i (because node j knows node i has Mk from KVMk,j ).

2. No request for Mk from node j.

3. Node i can infer node j has Mk and adds j to KVMk,i .

4 Yes No No  1. KVMk,i shows node j has Mk , but node j doesn?t have Mk now.

This may happen after the buffer of node j is full and Mk is selected to delete.

2. Mk is not put in SVi,j , and node j will not request Mk from node i.

5 Yes Yes No  1. Mk is not in SVi,j , but is in SVj,i (node j does not know node i has Mk because i is not in KVMk,j ).

2. No request for Mk from node i.

3. Node j can infer node i has Mk and adds i to KVMk,j .

6 Yes Yes Yes 1. Mk is not put in SVi,j or SVj,i.

2. Do nothing regarding Mk .

simulation time with a Poisson rate of 40 seconds/message in the iMote scenario and 200 seconds/message in the Ze- braNet scenario. For simplicity, we assume that data trans- mission between peers is via ZigBee [3] with a fixed rate of 240 Kbps, and all messages are either 1K bytes or 100 bytes. We varied the buffer size in each set of evaluation, and compared the delivery performance of the two meta- message exchange schemes (i.e., the average percentage of messages received by the destination at the end of the sim- ulation run). All the results presented here are based on the average performance of 200 simulation runs for each net- work configuration.

4.1. Evaluation I: The Infinite Buffer Case  In the first set of simulations, we evaluate the two meta- message exchange schemes with infinite buffer in the two network scenarios, when the packet size is 100 bytes and 1K bytes respectively. Figure 1 illustrates the delivery per- formance in cumulative distribution function (CDF) curves, and Figure 2 illustrates the traffic overhead (i.e., the data bytes of the control messages over that of the data mes- sages) of the two schemes in the two network scenarios.

From the simulation results, we observe that, while the delivery performance of the two meta-message exchange schemes are comparable in the two network scenarios, the SV scheme consumes much more traffic overhead than the KV scheme. More precisely, as shown in Figure 2, the KV scheme is able to reduce about 16% and 31% of the traf- fic overhead, for both packet size settings, in the iMote and ZebraNet scenarios respectively. The results confirm that the proposed KV scheme is able to reduce traffic overhead   0.1  0.2  0.3  0.4  0.5  0.6  0.7  0.8  0.9   0  50000  100000  150000  200000  250000  300000  cd f o  f d el  iv er  y ra  tio  simulation time (seconds)  SV, pksize=100B KV, pksize=100B  SV, pksize=1kB KV, pksize=1kB  (a) iMote   0.1  0.2  0.3  0.4  0.5  0.6  0.7  0.8  0.9  0  200000 400000 600000 800000 1e+006 1.2e+006 1.4e+006  cd f o  f d el  iv er  y ra  tio  simulation time (seconds)  SV, pksize=100B KV, pksize=100B  SV, pksize=1kB KV, pksize=1kB  (b) ZebraNet  Figure 1. The delivery performance of the two meta-message exchange schemes with infi- nite buffer in the two network scenarios.

0.2  0.4  0.6  0.8   1.2  1.4  1.6  1.8  0  50000  100000  150000  200000  250000  300000  cd f o  f o ve  rh ea  d / t  ot al  d at  a tr  an sm  itt ed  simulation time (seconds)  SV, pksize=100B KV, pksize=100B  SV, pksize=1kB KV, pksize=1kB  (a) iMote   0.1  0.2  0.3  0.4  0.5  0.6  0.7  0  200000 400000 600000 800000 1e+006 1.2e+006 1.4e+006  cd f o  f o ve  rh ea  d / t  ot al  d at  a tr  an sm  itt ed  simulation time (seconds)  SV, pksize=100B KV, pksize=100B  SV, pksize=1kB KV, pksize=1kB  (b) ZebraNet  Figure 2. The traffic overhead of the two meta-message exchange schemes with infi- nite buffer in the two network scenarios.

for data dissemination in opportunistic networks, while pre- serving the delivery performance of the SV scheme.

4.2. Evaluation II: The Finite Buffer Case  Next, we evaluate the two meta-message exchange schemes with finite buffer in the two network scenar- ios. Figure 3 shows the delivery performance of the two schemes with various buffer settings (i.e., 20k/40k/60k bytes) when the packet size is fixed at 100 bytes. It is clear that the KV scheme outperforms the SV schemes in all test cases, and the performance gain increases as the buffer size decreases. Specifically, the performance gain is about 17%, 10%, and 0% in the iMote scenario, and about 16%, 7%, and 3% in the ZebraNet scenario when the buffer size is 20k, 40k, and 60k bytes respectively. The results indicate that the KV scheme is superior to the SV scheme, especially when the end devices are buffer-constrained (e.g., sensors and handhelds).

Figure 4 presents the traffic overhead (i.e., the data bytes of the control messages over that of the data mes- sages) of the two schemes with various buffer settings (i.e.,   0.1  0.2  0.3  0.4  0.5  0.6  0.7  0.8  0.9   0  50000  100000  150000  200000  250000  300000  cd f o  f d el  iv er  y ra  tio  simulation time (seconds)  SV, bf=20kB KV, bf=20kB SV, bf=40kB KV, bf=40kB SV, bf=60kB KV, bf=60kB  (a) iMote   0.1  0.2  0.3  0.4  0.5  0.6  0.7  0.8  0.9  0  200000 400000 600000 800000 1e+006 1.2e+006 1.4e+006 cd  f o f d  el iv  er y  ra tio  simulation time (seconds)  SV, bf=20kB KV, bf=20kB SV, bf=40kB KV, bf=40kB SV, bf=60kB KV, bf=60kB  (b) ZebraNet  Figure 3. The delivery performance of the two meta-message exchange schemes with finite buffer in the two network scenarios when the packet size is 100 bytes.

20k/40k/60k bytes), when the packet size is fixed at 100 bytes, in the two network scenarios. We observe that the KV scheme is able to reduce traffic overhead when compar- ing with the SV scheme. More precisely, the KV scheme reduces about 49%, 49%, and 41% in the iMote scenario, and about 77%, 77%, and 71% in the ZebraNet scenario when the buffer size is 20k, 40k, and 60k bytes respectively.

Again, the results show that the KV scheme is superior to the SV scheme when the buffer size is limited for each net- work participant.

5. Conclusion  In this paper, we study the meta-message exchange in opportunistic network routing protocols. We argue that the traffic overhead may increase substantially as the number of messages buffered on each node increases, and we pro- pose a novel approach, called Known Vector, to resolve the problem. Using a comprehensive set of simulations, as well as realistic network mobility traces, we evaluate the      0.5   1.5   2.5   0  50000  100000  150000  200000  250000  300000  cd f o  f o ve  rh ea  d / t  ot al  d at  a tr  an sm  itt ed  simulation time (seconds)  SV, bf=20kB KV, bf=20kB SV, bf=40kB KV, bf=40kB SV, bf=60kB KV, bf=60kB  (a) iMote   0.5   1.5   2.5  0  200000 400000 600000 800000 1e+06 1.2e+06 1.4e+06  cd f o  f o ve  rh ea  d / t  ot al  d at  a tr  an sm  itt ed  simulation time (seconds)  SV, bf=20kB KV, bf=20kB SV, bf=40kB KV, bf=40kB SV, bf=60kB KV, bf=60kB  (b) ZebraNet  Figure 4. The traffic overhead of the two meta-message exchange schemes with finite buffer in the two network scenarios when the packet size is 100 bytes.

proposed scheme with the current meta-message exchange scheme, called Summary Vector. The results show that the two schemes are comparable when the network buffer is in- finite. When the network buffer is constrained, the proposed scheme is much superior to the Summary Vector, in terms of delivery performance and traffic overhead. More, the pro- posed scheme is simple and applicable to other opportunis- tic routing protocols. Work on the analysis of the proposed scheme is ongoing, and we hope to report the results in the near future.

