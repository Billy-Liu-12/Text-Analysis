

Abstract?XML has become the standard for data representation on the web. This expansion in reputation has prompted the need for a technique to access XML documents. Many techniques have been proposed to tackle the problem of mining XML data. We study the various techniques to mine XML data and yet  We presented a java based implementation of FLEX algorithm for mining XML data.

Keywords? data mining , association rules ? XML ? Java

I. INTRODUCTION Ever since the emergence of the internet, the amount of  information on the web has been growing exponentially. The World Wide Web has become a public knowledge base, however the increasing size of the web space is beyond of the control of any personal or organization. The increasing amount of data on the Web is tremendous and the Web has happened to be a valuable place where we can find a lot of useful information. Mining the web data is a critical issue since the data is either unstructured or semi structured. Using traditional methods to mine this data directly is impossible due to the lack of structure and proper input for mining algorithms.

XML has become the standard for data representation on the internet. This expansion in reputation has prompt the need for a technique to access XML documents for particular information and to manipulate repositories of documents represented in XML to find specific documents. If we have the ability to extract information from XML data that would mean we have the talent to mine information from the Web and that is a very useful power. And that make the importance to develop new tools or methods, which can be used to extract information from XML data directly without any preprocessing or post processing of the XML documents.

Web mining is the concept of how we apply the traditional mining techniques that works on relational data onto the web data which is semi structure or unstructured. That might include transferring the data into a different format or implementing a mining algorithm into a query language that access XML.

Like data mining, web mining can be divided into four sub goals or tasks which is ; 1) browsing the resource which include the process of accessing the data from various sources .

2) Data cleaning and preparation which include removing unnecessary data or re form the data into suitable input format for the mining algorithm. 3) The mining part is done in step number three where the mining algorithm is applied on the data. 4) Validating the results and pattern representation.  [1]   2. Association rules   Association rule mining is one of the data mining techniques in which it finds interesting associations or correlation relationships among large set of data items.

Association rules extract attributes that occur frequently together in a given dataset. A typical and widely-used example of association rule mining is Market Basket Analysis.

Association rules were first introduced in [2]. It provides information of the type of "if-then" statements. These rules are generated from the data and it comes with two measurements which is the Support and Confidence of each rule that can show the level of certainty of a given rule. The contents of those rules are the items that appear in the database.

3. Mining XML data   The web data (XML data ) is different from relational data in term of structure;  relational data is  flat and have a regular structure and is govern by data types while XML structure vary and consist of tags and some user defined tags . In order to mine XML data a data preparation step should take place, data preparation depends on the nature of the XML document and the type of transformation need to be done on the XML document in order to access it and mine it.

Mining XML can be categorized into two parts           1) Indirect mining which means preprocessing of the XML documents and transform them  into a different structure (flat file for example) ,then apply the mining algorithm on the data after transformation in a relational format. And produce the result in XML format which is called post processing. [3]  2) Direct Mining which means mine the  XML file without preprocessing or post processing, the XML file will be used as an input for the mining algorithm and the results can be displayed in XML format as well. This method have two different implementations :  a)Mining XML data using an XML Query language [4]. The idea of this implementation is to embed the mining algorithm using the query language that support accessing and manipulate the XML document.

b) Mining XML using java based parsers such as SAX ( Simple API for XML ) and (DOM) document object model . [5]   A new approach[5] was proposed for a direct mining of  association rules from XML document using java based environment. It uses a program written in Java to work directly with XML documents. This offers more flexibility and performs well compared to other techniques.  Apriori algorithm[6] was implemented using DOM as well as FP- growth[7].

The input format made of an XML document contains one  root level element called the transactions with the corresponding opening and closing tags. Within that tag a list of transactions with ID that contains elements. The implementation outputs the association rules and its corresponding supports and confidence in XML format which is an optional feature since the normal form of ? X Y ?is more user friendly support and confidence. Comparing this implementation with XQuery implementations of Apriori shows that java based application performs much better when dealing with mining XML data.

Fully automatic extraction of Web page structures and  semantic contents can be difficult given the current limitations on automated natural-language parsing. However, semiautomatic methods can recognize a large portion of such structures. Experts may still need to specify what kinds of structures and semantic contents a particular page type can have. Then a page-structure-extraction system can analyze the Web page to see whether and how a segment?s content fits into one of the structures [8].

4. FLEX algorithm  Flex algorithm was first introduced in [9] and it runs on a  relational data. It  is the abbreviation for frequent lexicographic patterns and can be described using  lexicographic tree Assuming that a lexicographic ordering exists among the items in the database and lexicographic tree is used as a representation of the frequent patterns with respect to this ordering [9] .

To generate the first level of FLEX the database need to be  scanned once and the items that satisfy the minimum support will be constructing the first level of the FLEX tree according to its lexicographical .

The next level of the FLEX tree is actually generated while  checking for the possible frequent pattern extensions of a node.

Because the frequent pattern extensions will do the intersection of the possible frequent items for a given node. If the supports of possible frequent pattern extensions are exceeded the given support threshold then it will be added to the second level of the FLEX tree. So the node creation is a result of testing the frequent patterns extension against the support threshold.

5. Implementation details   We implemented a modified version of FLEX (MFLEX) algorithm using both DOM and SAX. We are using the sample XML document in Fig.1  as an input;  It consist of one root element which is the <Data> element that hold the other data content inside it. Each transaction is represented using an (opening<transaction >) and closing tag ( </transaction >) within each transaction there is two elements; transaction ID represented by the (<ID>) tag and the list of items separated by a space.

Fig.1 XML input file   Six different classes were used to implement MFLEX using  DOM and SAX, The main class will ask for the XML file?s location and the support threshold, A file object will be created after locating the filename and will be sent to the PARSER class along with the starting time of parsing .

The PARSER class initialize the XML nodereader to read  the transactions, every read will issue an even to store the information of the transaction into a (linkedhashedmap structure). a linkedhashedmap is a combination of a hash table and linked list , the reason why we use this structure is because it  has an iteration order which is the  linked list. And the retrieval speed is very high since it use a  Hashtable . The insertion order to the linkedhashmap is very important since it will determine the order of the iteration. Once parsing is done the XML file will be mapped into a LinkedHashMap.and from this LinkedHashMap we can genereate the subsequence levels using the  RootdependentComparator class  the output of this class will be sent to the result tree to display the first level and in the same time will be sent to the RootdependentComparator class to further create the subsequence levels by intersection the items .

The process of creating the output tree is done through two  classes, one responsible for creating the root node which made of the items with the associated transaction IDs and another class will be using to build the subsequence levels the input for this class is the list of items and its associated transaction IDs. For intersection purpose the items will be converted into a vector, so we can count the similarities between intersected items in a loop that ends by the last time of the list.

Fig.2 sample output   Finally in the (ResultTree) class is responsible for the  display, the result will be displayed in a tree format, specifying each node with its associated transaction ID. This class receive the data first from the rootIndependentComparator  to build the first level of all the items and their own transaction ID , then the subsequence level will be received from the rootdependentComparator class. It will also receive the parsing time from the Run class and display the result on the bottom of the display dialog . A sample output is shown in fig.2    6. Experiments and observations   Experiments are pursued on several databases, databases  can be classified into two categories, one according the number or records ?transactions ?and here we have 1000 and 10,000 transactions, and another category is according to the number of attributes per transaction and here we have 5, 10 and 20 attributes per transactions, a tabulated description of the dataset is shown as table1.

Database Description Dataset 1 Database made of 1000 record and  5 attribute per transaction MAX Dataset 2  Database made of 1000 record and  10 attribute per transaction MAX Dataset 3 Database made of 1000 record and  20 attribute per transaction MAX Dataset 4  Database made of 10,000 record  and 5 attribute per transaction MAX  Dataset 5  Database made of 10,000 record and 10 attribute per transaction MAX  Dataset 6 Database made of 10,000 record and 20 attribute per transaction MAX   Table1 database set    We studied the performance of our implementation on  dataset 1 ( fig.3) and it shows that  SAX outstrips DOM in parsing the database over different set of support counts, the reason is that SAX does not build a tree structure in order to process each transaction, since FLEX structure will be mapped into a hashed tree SAX interprets XML as a stream of events and our implementation supply event-handling callbacks, SAX parser invokes the event-handlers as it parses.

DOM vs. SAX on 1000 record and 5 attribute MAX  0 0.5 1 1.5 2  0.2  0.6  0.9  su pp  or t  time  sax dom   Fig.3 Five attributes per transaction   As illustrated in the (fig.4) SAX outstrips DOM in parsing  the database over low support counts while DOM outstrips SAX in case the support is 0.1, that is because the data set is generated randomly and the possibility of finding interesting relation on higher support is low since the similarity of the items is very low. SAX does not  build data model in memory that?s why its very fast, lightweight, and it?s a good choice when no data model is needed. While in DOM it interprets XML as a tree of nodes and builds data model in memory.

DOM vs. SAX on 1000 record and 10 attributes MAX  0 1 2 3 4 5  0.1  0.05  0.08  su pp  or t  time  SAX DOM   Fig.4 ten attributes per transaction       7. Conclusion    This paper discussed the implementation of the modified FLEX algorithm (MFLEX) using two different parse techniques DOM and SAX. The performance of the algorithm is compared with the two parsing methods and it shows that SAX outstrips DOM in term of time factor through the above analysis on the selected datasets. A parallel implementation of FLEX algorithm would be a significant future work.

