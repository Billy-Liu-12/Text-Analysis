Research on Algorithm for Mining Frequent Closed Itemsets over Data Stream

Abstract?This paper presents a new efficient algorithm for mining frequent closed itemsets in sliding windows over data streams. It divides the sliding window into several basic windows. The basic window of a sliding window was served as an updating unit in this algorithm. And all potential frequent closed itemsets of every basic window were mined by compareing the support and relationship of inclusion between itemsets. Those itemsets were stored in a new data structure.

And the frequent closed itemsets in a sliding window could be rapidly found based on the new data structure. The experimental result shows the feasibility and effectiveness of the algorithm.

Keywords - data stream, frequent itemsets, frequent closed itemsets, sliding window

I. INTRODUCTION With the development of information globalization, the  amount of information is exponential growth. Appeared large amounts of information with the carrying form of data stream[1]. For instance, phone record data stream in the field of communication, data stream of clients click on the web, data packet stream in the network monitoring, detectable data stream among various sensor network, stock data stream in the area of finance and other transaction data stream in the retail trade etc. However, these data or their general information can only be restored in order and read once or limited times. How to process these data stream quickly within restricted space to obtain useful information has significance for our research. In recent years, frequent itemsets as an important content of data stream mining research gets the worldwide study. However, in the situation of smaller minimum support threshold or dense dataset, it makes clients difficulty understand mining result well and find valuable information quickly. In 1999, Pasquier put forward a new perception frequent closed itemsets[2], which sustains the support of subset and whose number is far less than frequent itemsets. In that case, if we just mine frequent closed itemsets in data stream, it can save a lot of memory and improve efficiency, especially for some applications which have long patterns, strong patterns or lower support threshold. The algorithm of mining frequent closed itemsets has become a research focus. Many effective algorithms have been proposed.

Pasquier proposed A-close algorithm[2] is the first algorithm for mining frequent closed itemsets. The key of  this method is to create generating subset. Once all subset is found, it can make sure their closure and get all frequent closed itemsets by scanning database one time. Although the algorithm shrinks detection space and improves efficiency, problems of high CPU-spending in pattern match and I/O- spending in scanning database aren?t still resovled. Then J.Han proposed CLOSET[3] and CLOSET+[4] algorithm, which inherited FP-Tree data structure of FP-Growth[5] algorithm. With most algorithms based on FP-tree the same, CLOSET algorithm is divided into two steps: Firstly, scan database and create FP-tree. Secondly, mine FP-tree and improve the mining efficiency through the technology of item merging and subset pruning. However, this algorithm still has its limitations: It requires mining process to use recursion to build a large number of conditions of FP-Tree that would store it into memory until the end of recursion, and then restart to count the support and sort for each item.

So, this is a operation that need a lot of time and space, increase the difficulty to achieve. The key of Moment algor- ithm[6] is a data structure called CET(Closed Enumeration Tree) which is maintained in memory. This algorithm divides nodes into four styles: Infrequent node, Unpromisi- ng node, Intermediate node and Closed node. This algorithm has different treatment with these types. It uses a precise algorithm model, but needs to maintain and update frequently the information, so it will affect its efficiency.

In this paper, we proposed a new algorithm for mining frequent closed itemsets over data stream based on sliding window model: DSMCFI. This algorithm uses a new storage structure DSMCFI-Tree to store all the critical frequent closed itemsets in sliding window, and real-time updates and maintains this structure with the sliding window continuous sliding. Finally it can mine out all frequent closed itemsets in sliding window.



II. DESCRIPTION OF THE PROBLEMS AND RELATED DEFINITIONS[7-9]  Let an set of m distinct items },,,{ 21 mIIII L= , an itemset is a subset of I . The data stream DS  is composed of constantly arrived and dynamic growth transactions, denoted as },,,{ 321 LTTTDS = , where the transaction ( )L,3,2,1=iTi  is composed of the items of I , i.e. ITi ? .

Definition 1 (Sliding Window) The data stream DS divided into several segments, each segment correspondence a   DOI 10.1109/AICI.2010.157    DOI 10.1109/AICI.2010.157     certain number of subsequence of the data stream, such a data segment is called a basic window, denoted as BW . The sliding window SW is composed of a certain number of continuous basic windows, denoted as kBWBWBW ,,, 21 L , where k  is a fixed value.

With the arrival of new data, the basic window of sliding window as an updating unit was continuously update. When a new basic window 1+kBW  came into, the outdated basic window 1BW  must be deleted, the sliding window will be updated once. Therefore, the data in the sliding window is changing and updating constantly.

Let an itemset X  is a non-empty subset of I , i.e.

IX ? . An itemset with k  items is called a k-itemset. The  frequency of an itemset X , denoted as ( )Xfreq , is the number of transactions in window (sliding window or basic window) that contain X . The support of an itemset X , denoted as ( )Xsup , is the ratio of ( )Xfreq  and the total number transactions in window, i.e. ( ) ( ) WXfreqX =sup ; Definition 2  (Frequent Iitemset) Given minimum support threshold s  and allowable error ? , the itemset X  is called a Frequent Iitemset (FI) if ( ) sX >sup ; the itemset X  is called a critical frequent itemset if ( ) sX ?< sup? ; the itemset X  is called a infrequent itemset if ( ) ??Xsup .

Definition 3 (Frequent Closed Itemset) Let an itemset X and IX ? , X  is called a Frequent Closed Itemset(CFI) if X  is an FI  and there be exists no FI Y that YX ? and  ( ) ( )XY supsup = .

According to the definition of frequent closed itemsets,  there is the following property.

Property 1 Any frequent itemset X , if there be exists a superset Y and ( ) ( )XY supsup ? , then the frequent itemset X must be not frequent closed itemset; In the contrary, it  must be frequent closed itemset.

Property 2 The frequent itemsets sorted to the dictionary order, if 1+iFI is not the superset of that iFI , i.e. 1+? ii FIFI , then ( )1>+ nFI ni  is also not a superset of iFI .



III. THE DESCRIPTION OF ALGORITHM The DSMCFI algorithm used the sliding window  processing model. When the first basic window come into the sliding window, the algorithm generated a critical frequent 1-itemset sort table f-list which frequency is descending order and real-time update f-list when new basic window entered the sliding window. Then the critical frequent itemsets of window sorted to the dictionary order in accordance with the f-list, and mined critical frequent closed itemsets by comparing the itemsets inclusion relationship and the support. The algorithm used DSMCFI-Tree structure to store the critical frequent closed itemsets in sliding window. When a new basic window came into the sliding window, the algorithm reconstruct the DSMCFI- Tree according to the updated f-list. In the reconstruction  process, delete outdated information of basic window, and the critical frequent closed itemsets in each basic window rearrange by f-list, and then insert those into DSMCFI-Tree.

This make that the items with higher frequency appear in the closer position from the root. So more pattern can share the same prefix, and increase the efficiency of compression.

The algorithm is divided into 5 steps: (1) Update the f-list; (2) Fast pruning of DSMCFI-Tree; (3) Reconstruct the DSMCFI-Tree; (4) Mine the critical frequent closed itemsets in new basic window and insert into DSMCFI- Tree; (5) The output of frequent closed itemsets.

A. The Structure of DSMCFI-Tree In this paper, we used DSMCFI-Tree, a new compression  storage structure to store critical frequent closed itemsets of sliding window. It consisted of the root node(denoted as null), prefix subtree of critical frequent closed itemsets and BW-list which record the information of basic window. The node of DSMCFI-Tree structure is divided into two types: (1) The End Node The type node is the last node of a critical frequent closed itemsets in a branch. Domain of the type node is denoded as (item, f, fi,?,linki,?). The item represents item-name of the node; f represents the frequency of this node in this branch; fi represents the frequency of the critical frequent closed itemsets in the ith basic window; linki represents that point to another the end node of critical frequent closed itemsets in the same basic window BWi.

(2) The Intermediate Node The type node is not the end node of any critical frequent closed itemsets in a branch.

Such node is composed of the two domains, denoded as (item, f). The item represents the item-name of this node; f represents that the frequency of the node in this branch.

BW-list is composed of BWi-link that point to the end node of the last critical frequent closed itemsets in each basic window.

We called the tree that meet the characteristics to DSMCFI-Tree. The DSMCFI-Tree structure is shown in Fig.1. This picture shows the information of a sliding window that contains three basic windows. Included in basic window critical frequent closed itemsets were: BW1= {(cbda:2);(cb:3)};BW2={(cbd:2);(da:2)} and BW3={(bd:2); (ca:3)}. In the branch cbda, the nodes ?b?, ?d?, ?a? are the end node. The node ?b? is the end node of the critical frequent closed itemsets {cb} in basic window BW1. The node ?d? is the end node of the critical frequent closed itemsets {cbd} in basic window BW2 , The node ?a? is a end  null  b:7 c:10  a:3  d:2 b:2  a:2 d:2  d:4  a:2  BW1-link BW2-link BW3-link  item f b 2  f3item f d 2 2  link tid  BW-list  null  b:7 c:10  a:3  d:2 b:2  a:2 d:2  d:4  a:2  BW1-link BW2-link BW3-linkBW1-link BW2-link BW3-link  item f b 2  item f b 2  f3item f d 2 2  link tid  f3item f d 2  item f d 2 2  link tid  BW-list Figure1. DSMCFI-Tree structure     node of the critical frequent closed itemsets {cbda} in basic window BW1. The node ?c? is the intermediate node in the branch cbda. Therefore, the end node and intermediate node are considered in a branch rather than in DSMCFI-Tree structure. Because {cbda}, {cb} are the first and second critical frequent closed itemsets of the basic window BW1, so the b.link of the end node ?b? which comes from {cb} point to the end node ?a? of {cbda}, and the BW1-link of BW-list points to the end node ?b? of the last critical frequent closed itemsets in basic window BW1.

B. Realizing the Algorithm DSMCFI The sliding window SW contains k continuous basic  windows BWi, where 1?i? k. In this paper, we used f-list structure as in [10].

Procedure 1: Fast pruning of DSMCFI-Tree  When the sliding window has include the k basic windows, due to the arrival of a new basic window, we must delete the information of outdated basic window BW1.

Because we designed the BW-list, we just find and delete all critical frequent closed itemsets in the basic window BW1 from the BW1-link of BW-list. In the sliding window as shown in Fig.1, when a new basic window BW4 arrived, deleted the outdated basic window BW1. From the BW1-link of BW-list, find the end node ?b? of the last critical frequent closed itemsets {cb} in the basic window BW1, then let BW1-link=b.link1. Let BW1-link points to the end node ?a? of another critical frequent closed itemsets {cbda} in BW1.

The frequency f of all nodes of {cb} subtracted b.f1, and deleted the nodes which f=0. Repeat the above process until all the critical frequent closed itemsets in BW1 deleted. Fig.2 shows the DSMCFI-Tree structure which deleted all critical frequent closed itemsets of the basic window BW1 in Fig.1.

The specific Procedure is as follows: Delete (DSMCFI-Tree,1,k) Input: DSMCFI-Tree store all critical frequent closed itemsets of the k basic windows; Output: Delete the DSMCFI-Tree after BW1;  1. if(DSMCFI-Tree is not empty) 2. find the end node e of the last critical frequent  closed itemsets fp in BW1 by BW-list; 3. if(e.link1?null) 4. {BW1-link=e.link1; 5.  for each ei?fp do begin 6.  {ei.f= ei.f-e.f1; 7.   if(ei.f=0) 8.   delete ei;} 9.  e= BW1-link; } 10. else {for each ei?fp do begin 11.      {ei.f= ei.f-e.f1; 12.       if(ei.f=0) 13.       delete ei;}} 14. for(i=2;i<k;i++) 15. { BWi-link = BWi+1-link; 16.   BWk-link=null;}  17. return DSMCFI-Tree; null  b:2 c:5  a:3  d:2 b:2  a:2 d:2  d:2  BW1-link BW2-link BW3-link BW-list  null  b:2 c:5  a:3  d:2 b:2  a:2 d:2  d:2  BW1-link BW2-link BW3-linkBW1-link BW2-link BW3-link BW-list Figure2. DSMCFI-Tree structure of delete BW1  item f f1 f2 f3 a 9 2 3 4  c 7 2 3 2 d 8 4 2 2 b 8 2 2 4  item f f1 f2 f3item f f1 f2 f3 a 9 2 3 4a 9 2 3 4  c 7 2 3 2c 7 2 3 2 d 8 4 2 2d 8 4 2 2 b 8 2 2 4b 8 2 2 4   Figure3.  f-list structure  Procedure 2: Reconstruct the DSMCFI-Tree Since the new basic window slided into and the outdated  basic window slided out, the frequency of critical frequent 1-itemset will change, so the f-list must be reordered, and reconstructed on the DSMCFI-Tree in accordance with  the updated f-list. Fig.3 shows the updated f-list when the BW4={(bac:2); (abd:2)} arrived.

The DSMCFI-Tree which is shown in Fig.2 is reconstruct.

Firstly, we create a new empty DSMCFI-Tree; and then find the end node ?a? of the last critical frequent closed itemsets {da} in the basic window BW1 by the BW1-link of BW-link, and let BW1-link=a.link1, make BW1-link points to another the end node ?d? of critical frequent closed itemsets {cbd}, removed the {da}, and rearranged {da} to {ad} in accordance with the updated f-list, then inserted it into the new DSMCFI-Tree. And then found another critical frequent closed itemsets {cbd} in BW1 by BW1-link, removed {cbd}, rearranged {cbd} to {bcd} by the updated f-list , and inserted it into the new DSMCFI-Tree as the second critical frequent closed itemsets of BW1, and c.link1 of the end node ?c? of {bdc} point to the end node ?d? of {ad}. Repeat this above process until all the critical frequent closed itemsets in each basic window have been inserted.

Fig.4 shown the reconstructed DSMCFI-Tree structure.

null  d:2 a:5  c:3  b:4  d:4  c:2  BW1-link BW2-link BW3-link BW-list  null  d:2 a:5  c:3  b:4  d:4  c:2  BW1-link BW2-link BW3-linkBW1-link BW2-link BW3-link BW-list     Figure4.  Reconstructed DSMCFI-Tree structure  The specific Procedure is as follows: Reconstruct(DSMCFI-Tree, i, k) Input: The DSMCFI-Tree before reconstructed; Output: The DSMCFI-Tree after reconstructed;  1. if(DSMCFI-Tree is not empty) 2. create a new empty DSMCFI-Tree; 3. for(i=1;i<k-1;i++) 4.

4. {find the end node e of the last critical frequent  closed itemsets fp of the update basic window BWi before through the BW-list;  5.   if(e.linki?null) 6.    {BWi-link=e.linki; 7. Remove fp and inserte it into the new DSMCFI-  Tree after rearrange it according to the f-list, and the end node is e?, the f values of all nodes which inert the branch are equal to e.fi. If the branch have common prefix with the branch of new DSMCFI- Tree, the merger the common prefix, let f=f+e.fi; and other item extended to the new branch.;  8. On the new DSMCFI-Tree, if(BWi-link?null) 9.   {e?.linki= BWi-link; BWi-link =e?;} 10. else{ e?.linki= null; BWi-link =e?;} 11. On the former DSMCFI-Tree, for each ei?fp do  begin 12. { ei.f= ei.f- ei.fi; 13.    if(ei.f=0) delete ei;} 14. e= BWi-link;}} 15. return DSMCFI-Tree;  Procedure 3: Mine critical frequent closed itemsets in the new arrival basic window BWnew and insert them into DSMCFI-Tree.

According to the property 1, a frequent itemset, if it does not have same support with superset, it must be the frequent closed itemset. Therefore, we only need mine the critical frequent closed itemset from critical frequent itemset of each basic window. It can ensure that mine all frequent closed itemsets of sliding window. First of all, dictionary sort to all pattern in BWnew according to the f-list; Then divide all critical frequent itemsets in BWnew into n sets FISi(1?i?n) according to the support. In each set of FISi, if FIi? FIi+1,  then FIi is a frequent close itemsets.

The specific Procedure is as follows: Insert(CFIS?BWi?k) Input: DSMCFI-Tree and BWnew; Output: DSMCFl-Tree after inserting critical frequent closed itemsets of the BWnew .

1. The itemsets in the BWnew have a sorte of dictionary according to f-list, then delete items which does not exist in f-list, and then itemsets are divided into n sets FISi(i=1,2,?,n) according to the support;  2.   for(i=1;i<n;i++) 3.   for(j=1;j<k;j++)  4.    {if(FIj?FISi&FIj+1?FISi&FIj?FIj+1) 5.      insert FIj into new DSMCFI-Tree; 6.      else insert FIj+1 into new DSMCFI-Tree;} 7.    return DSMCFI-Tree;  Procedure 4: The output of frequent closed itemsets.

In this paper, because of the designing of BW-list, the  output of the frequent closed itemsets is also carried out the basic window as the unit. The algorithm record all frequent close itemsets in the sliding window by the output list CFI- list.

Input: DSMCFI-Tree and the smallest support s.

Output: all the frequent closed itemsets which are in the sliding window.

1. build CFI-list 2. for(i=1;i<k;i++) 3. {Find the end node e of the last critical frequent  close itemset fp in BWi  by the BW-list? 4.  if?e.linki?null? 5.  {BWi-link= e.linki ; 6.   if(fp?CFI-list) f=f+e.fi; 7.   else remove the fp and insert it into CFI-list;  f=e.fi; 8.   In DSMCFI-Tree, for each e?fp do begin, e.f=  e.f- e.fi ; if(e.fi=0) delete e; 9.  e= BWi-link;} 10.  else { if(fp?CFI-list) f=f+e.fi; 11.       else remove of fp and insert it into  CFI-list,  f=e.fi; 12.       In DSMCFI-Tree, for each e?fp do begin, e.f=  e.f- e.fi ; if(e.fi=0)  delete e;} 13.  the critical frequent closed itemsets in CFI-list by  support descending order, and the output the frequent closed itemset which frequency count is greater than s?W?;}

IV. THE EXPERIMENT ANALYZES In this paper, the experiment with VC++ 6.0 in memory  to 320 MB, CPU is IV2.4G, Windows XP operating system environment for the realization of algorithm DSMCFI performance evaluation. We tested its runtime and memory consumption respectively.

The dataset used IBM synthesis data generator to produce customer shopping data. (http://www.almaden.ibm.com/ software/quest/Resources/index.shtml). The experimental dataset is: T20I8D1000k. T represents the average length of transaction in the dataset. I represents the average length of critical frequent closed itemsets. D represents the size of the dataset. Other parameters of data generator take the default value. In all experiments, given minimum support threshold s and allowable error ?=0.2s. The number of basic window which was included in sliding window is k=4, and each basic window included the number of transaction is 50K.

The experiment has analyzed the time efficiency and the space consumption of the algorithm. In Fig.5, The runtime is the running time of each update of the sliding window.

The memory consumption in Fig.6 is the maximum storage space of the algorithm when it process each basic window.

1 2 3 4 5 6 7 8 9 10 Number of Incoming Segments  R un  tim e(  s)  s=0. 001 s=0. 0015 s=0 002   Figure 5.  Runtime of the T20I8D1000K   1 2 3 4 5 6 7 8 9 10 Number of Incoming Segments  M em  or y  Co ns  um pt  io n(  M B)  s=0. 001 s=0. 0015 s=0. 002   Figure 6.  DSMCFI algorithm memory consumption  From the Fig.5 and Fig.6, we can conclude when the support is fixed, the runtime and memory consumption gradually tend to be stable, but the upward trend was evident in the first 4 basic windows.    Since then they won?t be increased with the coming of basic window. So the algorithm can be used for data stream environment. In this experiment, the sliding window is composed of 4 basic windows. In the first 4 basic windows, when each basic window arrived, the number of critical frequent closed itemset is increased in the sliding window. So the number of critical frequent closed itemsets in DSCFI-Tree is also arised. Accordingly, the runtime and the memory consumption will increase during the reconstruct DSMCFI-Tree. When the number of basic sliding window in sliding window will not change, the runtime and the memory consumption tend to be stable.



V. CONCLUSION According to the feature of data stream, in this paper, we  proposed a new algorithm DSMCFI for mining closed  frequent itemsets in data stream which can quickly mine frequent closed itemsets in sliding window. The algorithm used DSMCFI-Tree to dynamically record the change of frequent closed itemsets in sliding window. It also can the incrementally update. We can quickly find all frequent closed itemsets in the sliding window with DSMCFI-Tree.

