A Mining Method of Frequent Tree Sequences

Abstract?With the development of frequent items and frequent sequences mining, the technology of data mining turns to solve the problem of structural pattern mining. In this paper, we introduce transformation rules and define a new representation of tree sequences by using transformation sequences. Then we propose an efficient approach to enumerate frequent transformation subsequences (FTSs) of trees from a given set of tree sequences. Its fundamental performance has been evaluated by using artificial datasets.

Keywords-data mining; tree sequence; frequent tree subsequence; frequent transformation subsequence

I. INTRODUCTION In recent years data mining of complicated structures  such as trees [1], graphs [2], molecules, XML documents and relational databases has attracted a lot of researchers.

Especially the idea of discovering characteristic patterns [1,3,4]from various structured data has recently led to a large number of specialized algorithms for mining trees, graphs and sequences [5] in databases of trees or graphs. Reference [6,7,8] designs a method to mine frequent subsequences from graph sequence data and we extend its way to find frequent subsequences of trees from a set of tree sequences.

The primary objective of this paper is to establish a framework to mine a complete set of frequent tree subsequences from a given set of observed sequences of trees. We introduce a representation of tree sequences using transformation rules of the tree sequences data. Then we propose a method to mine frequent tree subsequences through mining frequent transformation subsequences.



II. REPRESENTATION FORMALISM  A labeled tree t is represented as , where ? ?, , ,t V E L f? ? 1, 2, 3, ..., nV v v v v? ? V?is a set of nodes, ? ? ? ?? , ' | , 'E v v v v?  ?V? is a set of edges, and is a set of labels such that  L :f V E L   )  . and are sets of nodes, edges and labels of t, respectively. An observed tree sequence is represented as d = , where the superscript integer of each t represents the ordered step of the observation. We assume that each node v is mutually distinct from the others in any ( ), and has a unique ID  in d. To represent the differences between and  ( ), (V t E t  ( )it  )  1i ? ?  ( )L t  (1) (2),t t?  n  ( )nt?  t  ?  (id v ( )i ( 1)it ? , a virtual sequence s t is interpolated  between the trees and , where  ( ) ( ,1i i? ? ) ( ,, 2t )ii m ?)i ? ( ,t  ( )it ( 1)it ? ( ,1) ( )it t i? and ( , ) ( 1)ii m it t ??  ( )it ( 1it  .

A.  Principles to represent Tree Sequences We assume that the change between two successive trees and )?  is gradual, i.e., only a small part of the  structure changes and the other part remain unchanged, and that the root of the single tree in a tree sequences remains unchanged between two successive trees  and ( )it it ( 1)? .

Figure 1 shows an example of an observed tree sequence and a mined tree subsequence.

A  B    A  B C   2 3  A  B C  D   2 3   A  C    A  C  D     t2 t4t1 t3 t5  (a) A tree sequence  A  B    A  C    A  B C   2 3  A  C  D     (b) One of mined tree subsequences Figure1. Examples of a tree sequence and a mined tree subsequence  Definition1. Given an observed tree sequence (1) ,d t? ? (2) ( )nt t? ? , each observed tree ( ) is called an  interstate, given two successive interstates and  ( )it 1i ? ? ( )it  n ( 1)it ? and  their interpolation ( ) ( ,1) ( ,,i is t 2)it ( , )ii mt? ?  (1) (2)d s s  ? ?  1)s ?  , each is called an intrastate. The observed tree sequence is represented by the interpolations as  ( ,i kt )  (n? ? ? ? .

We limit the interpolations to be compact and  unambiguous by taking ones having the shortest length in terms of graph edit distance [9] to reduce both computational cost and spatial cost of tree sequence mining.

Definition2. An intrastate sequence ( ) ( ,1) ( ,2),i i is t t? ? ? ( , )ii mt ?  t  is defined as the interpolation that the edit distance between any two successive intrastate is 1 and that the edit distance between any two intrastates is minimum.

Tree sequences are transformed and the transformation is represented by the following transformation rule (TR).

Definition3. A transformation rule (TR) which transforms to( , )i k ( , 1)i kt ?  is represented by , where TR is a transformation type which is either insertion, deletion of a node or an edge; is the unique ID of a node or an edge which the transformation is applied to, and  ( , ) [ , ]ik ik  i k o lTR  ikl iko  L? is a   DOI 10.1109/ICICTA.2011.543    DOI 10.1109/ICICTA.2011.543     label to be assigned to the node or the edge by the transformation.

We introduce four TRs defined in Table1. For example, we use a transformation to insert a node having a label between the k-th and k+1-th intrastates in the i -th interstate. Since the transformations of node deletion and edge deletion do not assign any labels to the node and the edge respectively, their arguments are represented by ??? without loss of generality.

( , ) [ , ]  i k h lni  l nd  ed l  Table1.Transformation rules (TRs) to represent tree sequence data TR INSTRUCTION  Node Insertion ( , )i kni[ , ]h l Insert a node having a label and a  unique ID into to transform  to .

l h ( , )i kt  ( , 1)i kt ?  Node Deletion ( , )[ , ] i k hnd ?  Delete a node having a unique ID h  in to transform to .( , )i kt ( , 1)i kt ?  Edge Insertion 1 2[( , ), ]h h l ( , )i kei  Insert an edge having a label l  between 2 nodes having unique IDs  and  into to transform to  1h ( ,i k  2h ( , )i kt 1)t ? .

Edge Deletion 1, 2 ( , ) [( ), ]  i k h hed ?  Delete an edge between 2 nodes having unique IDs and in to  transform to .

1h ( ,i k ?  2h ( , )i kt 1)t  These TRs are governed by Axioms listed in Table2. For example, the first axiom mentions that a TR is applicable to transform t to iff a node having a unique ID is not contained in , and a node having a label l  and the unique ID is contained in .

( , ) [ , ]  i k h lni  ( , )i k ( , 1)i k ?  ( , 1)i k ?  t ( , )i kth  h t Table2. Axioms governing transformation rules  Axiom TR INSTRUCTION  Axiom1 ( , )[ , ] i k h lni  ( , )( ) . . ( )i kv V t s t id v h?? ? ? ( , 1)( ) . .( ( )i kv V t s t id v h?? ?? ? ?  and ) ( ( )f v l? ? )?  Axiom2 ( , )[ , ] i k hnd ?  ( , )( ) . . ( )i kv V t s t id v h? ?   ? and ( , 1)( ) . .( (i kv V t s t id v?? ??? ? ) h? )  Axiom3 1 2 ( , ) [( , ), ]  i k h h lei  ( , )( , ) ( )i kv v E t?? ?1 2 ( , )( ),i kv V t v  and ( , )  1 2  1 1 2 2  ( ) . .( ( ) ) ( ( ) )  i kV t s t id v h id v h? ? ?  ( , 1)( , ) ( )i kv v E t ?? ?? ?  ? ? ? ?  and 1 2 1 1. .( ( ) ) ( ( )2 2 1 2) ( ( , ) )s t id v h id v? ?? ? h f v v l? ?? ? ?  Axiom4 1, 2 ( , ) [( ), ]  i k h hed ?  ( , ) 1 2 1 1 2 2( , ) ( ) . .( ( ) ) ( ( ) )i kv v E t s t id v h id v h? ? ? ? ?  ( , 1)( , ) ( )i kv v E t ?? ??? ?and ,1 2 ( , 1) ( ,( ), (i k iv V t v V t 1)1 2 1 1 2 2  ) . . ( ( ) ) ( ( ) )  k  s t id v h id v h ? ?  ? ?  ? ? ? ? ?? ? ? ?  B.  Tree Sequences compiler Definition4. An intrastate sequence ( ) ( ,1) ( ,2),i i is t t? ? ?  ( , )ii mt ? (seq s is represented by the following sequence of TRs  called an intrastate transformation sequence. Moreover, an observed graph  sequence  ) ( ,1) ( ,2) ( , 1) [ , ] [ , ] [ , ]( )  ii i i i m o l o l o lTR TR TR  ??? ? ?  (1) (2) ( ), nd t t t? ? ? seq  ?)( ) ( , ) [ , ]  i k o l ?  ( , ) [ , ]  i k o lTR  ? is represented by an intrastate transformation sequence ? (1) (2)( ) ( ) ( )d seq s seq s? ?  ( , ) [ , ]  i k o lTR  ? ? ? TR  ( 1nseq s ? .

Let a TR pair TR  represents that precedes  ( , ) [ , ]  i k o l  ? ? ?  k in an intrastate transformation sequence,  ,. .i e k ?? .Based on the axioms in Table2 and Definition2, we define the following admissibility of a TR pair in the sequence.

Theorem1. Given an intrastate transformation sequence ( )( )seq s ( ,1) ( ,2)[ , ] [ , ] i i i  o l o lTR TR TR ( , 1) [ , ]  ii m o l  ??? ?  ik k m  ? , the admissible combinations of TRs applicable to a node having a unique ID or an edge one of whose terminal is the node of ID in the sequence is limited to either of the following 2 ordered pairs where1 1  1h 1h  ?? ? ? ? )  [ ] ? 1 2 ( , ) [( , ), ]  i k h h lei  ? 1,h lni  ( ,i k ?          1 2  ( , ) [( , ), ]  i k h h ? ? 1  ( , ) [ , ]  i k hnded  ? ?  According to Theorem1, we can enumerate a sequence of TRs to interpolate two successive trees and ( )it ( 1)it ? in a straightforward manner under the definitions in Table1 and the constraints of Theorem1. Then any tree sequence  (1)d t (2) ( ), nt t? ?  ( 1n?  ? ?  seq  ?) )  can be represented by an interstate transformation sequence  ? (1) (2)( ) ( ) ( )d seq s seq s? ?  (seq s . Based on the tree sequence representation, we propose an algorithm to compile a given set of tree sequence  ? ?( )ii?(1) nit t? ?|i iDB d d to a set of transformation sequences ? ?( )i i( )seq DB seq d d DB? ? ?  shown in Figure2.

Figure3 is an example of the compilation by this algorithm.

?  ? ? ?( , )[ ( ), ( )]  ( )  ( )  , , , , , . 1 ( ) ( )  ( , ) ( )  i i  ni nd nr ei ed er j k  ni i i id v f v  ei i  TreeSequenceCompiler DB TS for each d DB seq d  for each j Define N N N E E E k  for each v N seq d seq d ni for each v v E seq d se  ?  ??  ? ?  ?   ? ?  ?  ?   ?  ? ?  ? ? ? ?  ? ?  ( , ) [( ( ), ( )), (( , ))]  ( , ) [ ( ), ( )]  ( , ) [( ( ), ( )), (( , ))]  ( ) ( ) ( )  ( , ) ( ) ( ) ( , )  j k i id v id v f v v  j k nr i i id v f v  j k er i i id v id v f v v  ed  q d ei for each v N seq d seq d nr for each v v E seq d seq d er for each v v E  ?? ? ?  ?? ?  ?? ? ? ?  ?  ? ?   ?  ? ?   ?  ? ?  ? ? ?  ? ? ? ? ? ?  ( , ) [( ( ), ( )), ]  ( , ) [ ( ), ]  ( ) ( ) ( ) ( )  ( )  j k i i id v id v  j k nd i i id v  i  seq d seq d ed for each v N seq d seq d nd  TS TS seq d output TS  ?? ? ?  ?? ?  ? ?  ?  ?   ? ?  ?  Figure2.Algorithm to compile tree sequences to transformation sequences  A  B    A  B C   2 3  A  B C  D   2 3   A  C    A  C  D     t1 t2 t3 t4 t5  (a) An example of a tree sequence d  ? ?  (1,1) (1,2) (2,1) (2,2) (3,1) (3,2) (3,3) [3, ] [(1,3), ] [4, ] [(3,4), ] [(1,2), ] [2, ] [(3,4), ]  (3,4) (4,1) (4,2) [4, ] [5, ] [(3,5), ]  ( ) C D B D D  seq d ni ei ni ei ed nd ed nd ni ei  ? ? ?  ?  ?   ?  (b)Representation of the tree sequence by using TR d Figure3. A tree sequence and its TRs

III. FTSS MINING In this section, we will propose a method to mine  frequent transformation subsequences (FTSs) from a given set of tree sequences.

Definition5. Let ( )seq d and ( )seq d ? be transformation sequences and its representation as follows,  ? (1) (2) ( ) ( 1)( ) ( ) ( ) ( ) ( )h nseq d seq s seq s seq s seq s ?? ? ? ?  ? ?? (1) (2) ( ) ( 1)( ) ( ) ( ) ( ) ( )r nseq d seq s seq s seq s seq s ?? ? ? ? ?? ? ?  ( )seq d ? is a subsequence of ( )seq d which is denoted as ( ) ( )seq d ? seq d? iff there exist integers 11 nh h ? 1?? ???  1n? ? such that ( )( ) (r r )seq s seq h? ? for 1, , 1r n?? ? ? .

A  B C   2 3  A  B C   2 3  D  A C   D   D5  A  C    t1 t2 t3 t4  (a) A tree sequence d  A  C    t1  A C    D  A C    t3t2  D 4  (b) A subsequence ofd ? d Figure4. Inclusion relation between interstate transformation sequences  In Figure4(a), given a tree sequence its transformation sequence is represented as follows  d ( )seq d ?  ? (1,1) (1,2) (2,1) (2,2) (2,3) (2,4) (3,1) (3,2) (3,3)[4, ] [(1,4), ] [5, ] [(3,5), ] [(1,2), ] [2, ] [(3,5), ] [5, ] [(1,4), ]D D B Dni ei ni ei ed nd ed nd ed? ? ? ? ?(3,4)[4, ]Dnd  ?  , and a transformation sequence ? (1,1)[3, ]( ) Dseq d ni? ? ?(2,1) (2,2) (2,3) (2,4)[(1,3), ] [4, ] [(2,4), ] [(1,3), ] [3, ]Dei ni ei ed nd? ? ?(1,2) D  of a tree sequence d ? in  Figure4(b) is a subsequence of ( )seq d .

From above, the relative mining support value is defined  as follows, given a set of data ? ?(1) ( 2) ( )nii i i i iDB d d t t t?? ? ? , the support value ? of a transformation subsequence ( )seq d?  is defined as , ( ) ( )i i id? ? d DB seq d seq d  DB ?  ?? ? ?  ? .If ? ? ?? ,  then the transformation subsequence is called a frequent transformation sequence (FTSs)  (? ? is a minimum support threshold). The mining problem is stated as follows.

Definition6. Given a tree sequence , we define a union tree of asT d  (1) (2) ( ), nd t t t? ? ? ? ( ( )), ( ( )))u u uV T d E T d  ? ?( ) )it? ( ( ))E T d d  i?  ( ) (?  ( ) (d v v V?such that , and 1, ,  ( ( )u i n  V T d ? ? ? u ?  ? ?( )( ( ), ( )) ( , ) ( )iid v id v v v E t? ?? ? 1, ,i n? ? ? .

Definition7. Given a transformation sequence ( )seq d ? ( )seq DB  and a subtree , we define a function proj to  project t  ( )seq (proj seq  d ( ),d t  to its subsequences as follows.

) { ( ) ( ) . . ( ) }useq d seq d seq d s t T d t? ? ??( )? ? ?  We know that each union tree of a FTSs is also frequent in union trees of all ( ) ( )seq d seq DB? , based on Definition 7, we can enumerate all candidate FTSs from the projected transformation sequences.

Based on the definition of the union tree and function proj, a problem to mine frequent transformation sequences (FTSs) is defined as follows. Given a data set  ? ?(1) ( 2) ( )nii i i i iDB d d t t t?? ? ? and a minimum support threshold? ? as input, the problem is to enumerate all FTSs of the union trees. First, union trees of all tree sequence in DB are generated based on Definition 6. Then all frequent subtrees among union trees are enumerated by using the conventional tree mining algorithms. Finally, all FTSs are obtained by proj.

B C   2 3  B C   2 3 D  4 C   D   D5 C    t1 t2 t3 t4  D  A A A A      2 3 4   (a) A tree sequence                     (b) A union tree of d d  B    t1  B    D   t3t2  D  A A A     2 4  (c) A ( )seq d ? in ( ( ), )proj seq d t                                     (d) A tree t Figure5. An example to the projection  For example, given a tree sequence as shown in Figure5(a), the transformation sequence of d is represented as  d  ? (1,1) (1,2) (2,1) (2,2) (2,3) (2,4)[2, ] (3,1)[4, ] [(1,4), ] [5, ] [(3,5), ] [(1,2), ] [(1,4), ]( ) D D Bseq d ni ei ni ei ed nd de? ? ?? ? ?(3,2)[4, ]Dnd and its union tree is depicted in Figure5(b). Given a tree t that is a subtree of  as shown in Figure5(d), an example transformation sequence  ( )uT d ( )seq d ? in ( ( ), )d tproj seq  is? ?(1,1) (1,2) (2,1)[4, ] [(1,4), ] [(1,2), ] [2, ]Dni ei ed nd? ? (2,2)B as depicted in Figure5(c), where its subsequence matches with underlined rules in ( )seq d .

The algorithm to mine FTSs from DB is depicted in Figure6.

? ?  ? ? ? ?  ( ( ), , ) ( ) | ( ) ( )  ( ( ), );  ( ) ( ( ), ) | ( , ( ), , ,1,1)  u u i  u  i i  TreeFTSMiner seq DB F T d seq d seq DB  for t FrequentSubtreeMiner T d untill t NULL  proj DB proj seq d t d DB F F FTSMiner proj DB F  FTSMiner  ?? ? ? ?  ?  ? ? ? ? ?  ? ? ??  ? ?  ? ?  ( ( ), ( ), , , , ) ( )  ( ( ), ( ), , ,1,1)  ( ( ), ( ), , , , 1) ( ( ), ( ), , , 1, )  seq d seq DB F j k if seq d  AppendRule seq d seq DB F else  AppendRule seq d seq DB F j k AppendRule seq d seq DB F j k  output F Ap  ?? ?  ? ?   ? ? ? ? ? ?    ? ?  ? ?  ( , ) [ , ]  ( , ) [ , ]  ( , ) [ , ]  ( ( ), ( ), , , , ) ( ( ), ( ))  ( ( ) ) ( )  ( ( ) , ( ), , , , )  j k u l  j k i u l  j k u l  pendRule seq d seq DB F j k for every TR C seq d seq DB  if seq d TR F F seq d FTSMiner seq d TR seq DB F j k  output F  ?? ?  ? ? ? ? ?  ? ?   ? ?  ?   Figure6.Algorithm to mine frequent transformation subsequences

IV. EXPERIMENT The proposed method was implemented by C++. HP  Compaq V3800 with Windows XP was used for this experiments where Intel Core 2 T5550 1.83GHz and 1GB of main memory are installed. The performance of this mining algorithm is evaluated using artificial tree sequence data. We compared the performance of this mining algorithm with Gaston [10].The default values of parameters of the artificial datasets are as follows. is the probability of node and edge insertions in transformation sequences, |  60%p ? |avgV 5? is  the average number of unique IDs in transformation sequences, | is the average number of unique IDs in embedded FTSs and the probability of node and edge insertions in embedded FTSs is , the number of node labels and the number of edge labels are | |  |avgV ? ? 3  35%p? ? 5nL ? and  , the number of embedded FTSs is N=5, the minimum support threshold is , and the number of transformation sequences which is denoted as | are 1000.

| |eL ?1 20%?? ?  | (1)  DB Through the experiment, we firstly started from t such  that (1)( )V t ?? , and then grew each transformation sequence up to having unique IDs in the average by inserting nodes and edges with probability at every step.

| |V p  Table3. Results for the experiment  | |avgV ,p 4 8 20 80% 50% 10%  avg.length 8.1 18.9 46.8 12.5 14.8 28.5 TS comp.time 0.25 0.9 185 0.25 0.54 0.48  #of FTSs 12 61 1503 34 45 124 Comp./FTS 0.020 0.015 0.123 0.007 0.012 0.003 Ga comp.time 5.4 ? ? 99 389 ?  #of FTSs 400 ? ? 6589 21084 ? Comp./FTS 0.014 ? ? 0.015 0.018 ? | |nL , ? ? 1 4 8 10 0.2% 30% avg.length 12.5 16.8 16.8 14.8 16.8 17.5 TS comp.time 0.60 0.45 0.58 0.35 15.8 0.25 #of FTSs 156 34 35 48 140025 45 Comp./FTS 0.004 0.013 0.017 0.006 11.2E-5 5.6E-3 Ga comp.time ? ? 389.5 245 ? 145.5  #of FTSs ? ? 22031 13035 ? 6587 Comp./FTS ? ? 0.017 0.016 ? 2.2E-2  avg.length: average length of seq(d); TS: Tree sequence mining algorithm; Ga: Gaston [10]; comp.time: computation time; Comp./FTS(sec): comp.time per FTS; #of FTSs: the number of mined FTSs or frequent subtrees.

Table3 shows the computation times (sec), the numbers of derived FTSs, and the average computation times (sec) to derive a FTS under various values of | | ,and, ,|avg nV p L | ? ? , while the other patameters are set at their default values. The results indicated by ??? in the table were not obtained due to intractable computation time over one hour. The upper half of the table indicates that the computation time of both the minging algorithm and Gaston are exponential to the average length of ( )seq d provided by the settings of | and .

The main reason of the computation time increase along the  average length is considered to be the increase of the numbers of FTSs in both cases. The lower left part in Table3 shows the effects of the number of labels on the efficiency.

In contrast, the mining algorithm of the frequent transformation subsequences remains small since does not affect the length of  |  |  avgV p  | nL ( )seq d . The lower right part in  Table3 shows that the mining algorithm of the frequent transformation subsequences is tractable even under the low minimum support threshold.



V. CONCLUSION In this paper, we proposed a framework to mine a  complete set of frequent transformation subsequences from given tree sequences. We developed a tree sequence mining program and confirmed its efficient and practical performance through computational experiments using artificial datasets.

