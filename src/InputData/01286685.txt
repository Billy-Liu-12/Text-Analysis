Prefetching XML Data with Abstract Query Mining

Abstract  Web applications using the XML technologies are  increasingly popular. Besides caching, another query performance improvement approach is prefetching.

Similar to other database queries, XML queries often have their own query patterns. In this paper, we present a  pre-processing algorithm that extracts abstract queries from similar query constructs but with different  constraints values. These abstract queries help to produce useful access patterns by applying association mining on  them.  Through our preliminary experiments, we found that our prefetching approach  improved both the cache  hit ratio and precision of the XML cache system.

1.  Introduction  One of the techniques commonly used in prefetching web  pages is association rule [5]. A set of rules is extracted  from past queries history which serves as a model of a  user's surfing habit. For such rule extraction task, which is  also known as web-mining, it is important that the order of  the user's click stream is observed during the mining  process. However, the concept is not that much different  from regular association rules problems.

Various work has been done to enhance the efficiency in  caching of XML-related web queries. In [1], the  containment problem of XQuery is studied in order to  maximize the usage of the XQuery cache. In [2], the query  results are fragmented and stored as individual XPaths, so  that a more efficient replacement strategy can be used.

Comparing with XML caching, however, the idea of  prefetching is less well studied than the HTML webpages  case. In this paper, we present an approach to support  prefetching of XML queries. We focus on client side  caches, with the goal of reducing network delay time. The  queries are assumed to be XQuery or XPath statements  generated by client-side web applications.  We mined two  types of rules from a query history log: specific rules, where the queries are treated ?as is? and are similar to  webpage prefetching rules; and abstract rules, which capture the generic patterns of user actions. We identified  five possible cases of user query patterns, and presented  data-mining procedures for extracting rules from two of  the cases that make prefetching possible.

2. Predicting XML queries  Association rules algorithms have been proven to be useful  in web page prefetching [3, 4], recommender systems [6]  and user profiling [7]. In these applications, queries  histories containing web document access sequence are  analyzed in order to construct rules of the form  p1, p2, p2,...pk-1  -> pk where each pi represents a page, or more accurately, an URL, within the access sequence. Resulting rules that  exceed certain confidence and support will serve as a user model for predicting future queries.

Consider the simple two sessions of XPath history log in  Figure 1. There are basically two different queries: one  requesting the PERSONA of a play, the other retrieving  the TITLE of each ACT of a given play. Note that, both  queries contain a TITLE conditional clause whose value is  not fixed over subsequence query instances.

SESSION 1  1   //PLAY[TITLE='Venice']/PERSONA  2   //PLAY[TITLE='Venice']/ACT/TITLE  3   //PLAY[TITLE='Hamlet']/PERSONA  4   //PLAY[TITLE='Hamlet']/ACT/TITLE  SESSION 2  1   //PLAY[TITLE='Venice']/PERSONA  2   //PLAY[TITLE='Venice']/ACT/TITLE  3   //PLAY[TITLE='Macbeth']/PERSONA  4   //PLAY[TITLE='Macbeth']/ACT/TITLE  Figure 1. Sample queries.

Hence, it is desirable to obtain two types of rules from the  log. The first type treats the entries as exact units. For the  case in Figure 1, one specific rule is resulted.

//PLAY[TITLE='Venice']/PERSONA => //PLAY[TITLE='Venice']/ACT/TITLE  Depending on the query characteristics, such specific rule  could be useful at times. However, in Figure 1, it is  obviously more desirable to have an abstract rule that can  handle the different values for the same XPath constraints  in more flexible manner, i.e., It is better to have  //PLAY[TITLE=c1]/PERSONA => //PLAY[TITLE=c1]/ACT/TITLE  where the value of c1 will be substituted at runtime.

Ideally, abstract rules are to represent the patterns that  exist in users? query habit. Though, depending on the  nature the desired rule, this is not always possible.  In the  current work, each query  (XQuery or XPath) X is mapped     into a query template Qi and a set of constraint values Ci contained in the query. For example, the XQuery below  X = ?for $x in  /bank[bankcode=?015?]/account  let $a := $x/@account-num  where $x/type = ?checking?  return <ac-num> $a </ac-num>?  would be mapped into the query template  Q =  ?for $x in  /bank[bankcode= value1]/account  let $a := $x/@account-num  where $x/type = value2  return <ac-num> $a </ac-num>?  and the set of constraint values  C = {?015?, ?checking?}  With this idea, the rules from the query templates and their  associated set of constraints form the abstract rules that  represent user querying behaviour. Here, a query pattern of  the form X1 => X2, where X1,X2 are web queries, can be re-written as:  Q1[C1] => Q2[C2]  Each Qi and   Ci   is a query template and the set of  constraints in X, respectively. By separating the set of  constraints from the exact query, we see there are five  cases to be considered.

Case 1:C1= Empty Set and C2= Empty Set  Example:  //PLAY/PERSONA     =>  //PLAY/ACT/TITLE  Case 2:C1 = C2  Example:  //PLAY[TITLE=?Hamlet?]/PERSONA =>  //PLAY[TITLE=?Hamlet?]/ACT/TITLE  Case 3: C2  C1  Example:  //PLAY[TITLE=?Hamlet?]/ACT[.=?Act  II?]//SCENE =>  //PLAY[TITLE=?Hamlet?]/ACT/TITLE  Case 4: C1  C2  Example:  //PLAY[TITLE=?Hamlet?]/ACT/SCENE  =>  //PLAY[TITLE=?Hamlet?]/ACT[.=?Act  II?]/TITLE  Case 5:C1  C2 and C2  C1  Example:  //PLAY[TITLE=?Hamlet?]/ACT/SCENE[.=?  Act II?]  =>  //PLAY[TITLE=?Hamlet?]/ACT[.=?Act  IV?]/TITLE  In case 1, both the antecedent and consequence contain no  constraint value. This type of rules can be found by using  the same technique as in web page prefetching. Case 4 and  case 5 are both having a constraint that is not found in the  antecedent. Since there is no easy way for deducing that  additional constraint value based on the antecedent, these  two cases are not considered when generating the abstract  rules. However it might still be possible to have  case-specific rules. Case 2 and case 3 are both suitable  candidates for abstract rules mining.

In this paper the extraction of case 2 abstract rules from  user query log is presented, although the work can be  easily extended to the case 3 rules as well.

3 Query Log Pre-processing  In our work, it is assumed that a user activity log is already  segmented into sessions. Before mining, the segmented  query logs are pre-processed by an algorithm as shown in  Figure 2. The idea is that for each session in the log,  instead of mapping each user session into one transaction,  multiple transactions are created. This is done by first  grouping the entries that share the same constraint values  into virtual sessions, and then replacing the actual query  with query templates. Each virtual session, as well as the  original session, will form one separate transaction.

Formally, given a session S of queries, S = {x1, x2?xn},  virtual sessions set VS = {vs1, vs2?vsm} are formed,  where each vsi is a  virtual session of the form  {(qi1,ci1)?(qis,cis)} where each qij corresponds to the  template of a query in S and cij is its set of constraints, such  that for each two couples (qii,cii) and (qij,cij) in vsi, we have  cii = cij. The required transactions to be fed into data  mining engine for abstract rules mining is then defined as  {vs1?, vs2??vsm?} where each vsi? = {qi1, qi2?, qis} is the  template-only version of a virtual session.

Let X be an XML Query in user query history  Let C(X) be the set of constraints in X,  Let Q(X) be the corresponding query template  of X,  Let VSi be a set of virtual sessions, where  each entry in VSi consists of (xp,cons) tuples  where xp is a query template, cons is a set of  constraint in the original query  For each session Si VSi = initially empty set  of virtual sessions For each entries x in Si  If C(x) is not empty Modify x by replacing each constraint  values in x by symbolic variables, obtaining a query template q.

If there exists a virtual session v in VSi such that for each  (vx, vc)  tuple in v, vc = C(x):  add a new tuple (Q(x), C(x)) to v else create a new virtual session v add a new tuple (Q(x), C(x)) to v add v to VSi Create a transaction for each virtual  session v in VS  Figure 2. Pre-processing Algorithm  The process is illustrated in Figure 3. In this example, the  pre-processing algorithm creates three additional virtual  sessions for the original session number 1, and one virtual  session for the original session number 2, all according to  the constraint values contained in the queries. The  constraint values are included in each virtual session as     identification aids to the grouping process only, and will  be discarded after the grouping is done. Thus, the  pre-processed transactions to be submitted to association  mining engine will contain the six sessions as shown the  Figure 4.

Original Session 1  1  //PLAY[TITLE='Venice']/PERSONA  2  //PLAY[TITLE='Venice']/ACT/TITLE  3  //PLAY[TITLE='Hamlet']/PERSONA  4  //PLAY[TITLE='Hamlet']/ACT/TITLE  5  //PLAY[TITLE='King Lear']/ACT/TITLE  Original Session 2  1  //PLAY[TITLE='Venice']/PERSONA  2  //PLAY[TITLE='Venice']/ACT/TITLE  Virtual session 1.1  1 (//PLAY[TITLE=c1]/PERSONA,{'Venice'})  2 (//PLAY[TITLE=c1]/ACT/TITLE',{'Venice'})  Virtual session 1.2  1  (//PLAY[TITLE=c1]/PERSONA,{'Hamlet'})  2  (//PLAY[TITLE=c1]/ACT/TITLE,{'Hamlet'})  Virtual session  1.3  1(//PLAY[TITLE=c1]/ACT/TITLE,{'King Lear'})  Virtual session  2.1  1  (//PLAY[TITLE=c1]/PERSONA,{'Venice'})  2  (//PLAY[TITLE=c1]/ACT/TITLE',{'Venice'})  Figure 3. Virtual sessions.

Transaction 1 (For specific rules mining)  1  //PLAY[TITLE='Venice']/PERSONA  2  //PLAY[TITLE='Venice']/ACT/TITLE  3  //PLAY[TITLE='Hamlet']/PERSONA  4  //PLAY[TITLE='Hamlet']/ACT/TITLE  5  //PLAY[TITLE='King Lear']/ACT/TITLE  Transaction 2 (For specific rules mining)  1  //PLAY[TITLE='Venice']/PERSONA  2  //PLAY[TITLE='Venice']/ACT/TITLE  Transaction 3 (For abstract rules mining)  1  //PLAY[TITLE=c1]/PERSONA  2  //PLAY[TITLE=c1]/ACT/TITLE  Transaction 4 (For abstract rules mining)  1  //PLAY[TITLE=c1]/PERSONA  2  //PLAY[TITLE=c1]/ACT/TITLE  Transaction 5 (For abstract rules mining)  1  //PLAY[TITLE=c1]/ACT/TITLE  Transaction 6 (For abstract rules mining)  1  //PLAY[TITLE=c1]/PERSONA  2  //PLAY[TITLE=c1]/ACT/TITLE  Figure 4 Pre-processed transaction logs.

After applying association mining to transactions in Figure  4, the following association rules are:  Rule 1 //PLAY[TITLE='Venice']/PERSONA =>  //PLAY[TITLE='Venice']/ACT/TITLE Rule 2  //PLAY[TITLE=c1]/PERSONA => //PLAY[TITLE=c1]/ACT/TITLE  The mining results of the virtual sessions in Figure 4  include both specific (rule 1) and abstract (rule 2) rules. In  general, it is expected the abstract rules would occur much  more frequently and more useful than specific ones.

4 Rules extraction  The pre-processed result is sent for sequential association  rule (SAR) mining which has been proven to be useful in  web page prefetching. For XML queries issued by web  applications, however, it is not immediately obvious that it  is also the case, since the html links structures do not  necessarily exist here. For this reason we adopted both the  standard Apriori algorithm and SAR in our study and the  results are compared.

During the mining, the antecedents are assumed to be  immediately followed by the consequences. The SAR  engine we used extract all rules of antecedent of length  <=2 and consequence of length 1 that exceed some  parameter controlled support and confidence value. Here,  the support is defined as the number of transactions that  contain a pattern divided by the total number of  transactions. For mining of specific rules, only the original  transactions are counted in the denominator, whereas for  abstract rules, we count both the original and the ones that  are generated from virtual sessions during pre-processing.

5 An XML caching system with prefetching  The association mining is done as an offline process, with  the resultant rules outputted to a file that is referenced by  the XML caching system as shown in figure 5.

Figure 5  XMLCaching System with Prefetching.

In the system shown in Figure 5, the Prefetch process reads  the access log which is maintained by the client  application, and matches the entries inside against the rule  file produced offline during the data mining process. In our  experiments, the Prefetch process is activated after each  time an XML query is made by the client applications. It  has been assumed that there is sufficient inter-query time  interval for allowing prefetching operations. If not true,  this process can be performed as a low priority background  task. Among the rules that are matching, the one with the     highest confidence is selected, and the corresponding  consequence query is prefetched and pre-stored in cache.

6 Experiments  The XML caching system and a client application is built  using Java 1.3.  In the experiments we tried different  XPath queries with two XML datasets available in the web,  Plays [8], and Medline [9]. For both Plays and Medlines,  three sets of queries data, with size ranging from 535 to  667 queries, for the purpose of training, testing and  evaluation, respectively, are generated.

In the experimental setup, the query patterns are assumed  to follow a Markov model, with each node in the model  representing a query template. The user?s habit is thus  modelled by the probabilities of the flows between the  query template nodes. The data are assumed to exist in  sessions where the session lengths are assumed to be  normally distributed.

In the experiments, the Plays queries and the Medlines queries have different characteristic. The Plays queries  tend to contain more sequential patterns involving  different query templates (i.e, there are more acyclic paths  in the data generation model), whereas for the Medline logs, where related keywords tend to appear in adjacent  queries in no particular order in real life, the same query  template tends to repeat several times for related constraint  values. It is represented by self-looping in the model.

We tested four caching options in our study. The  experiment is repeated using persistent cache, where the  cache contents survive from one session to the next, and  non-persistent cache. The effect of prefetching on two  basic cache replacement strategies, Least Recently Used  (LRU) and Least Frequently Used (LFU) is also studied.

The results are shown is Figure 7 to Figure 12. From  Figure 7 to Figure 10, we see that both Apriori and  SAR-based prefetching significantly improved the cache  ratio comparing with the non-prefetching results in all  scenarios. This is especially true for the Plays dataset.

Also, we find SAR performs better than Apriori for Plays, but not necessarily for Medline, indicating that the right  choice of mining algorithm does depend on the  characteristic of the application.

In both cases, the cache hit ratios have been improved at a  cost of additional queries being made to the server. In  order to make sure prefetching worthwhile, we also looked  at the precision, which is defined by the number of cache  hits divided by the number of web accesses. The result is  shown in Figure 11 and 12. We see that, from the results,  the overall precision for SAR is higher than that of the  non-prefetching version in all but one scenario, meaning  the overall effectiveness of the system is improved despite  the extra queries.  For Apriori, this is also the case for the  Plays queries but not for Medline, indicating once again  that the ideal choice of mining algorithm should depend on  the application characteristic.

7. Conclusion  We studied the effect of prefetching of XML queries in  client side caches. With a pre-processing step that  generates virtual sessions obtained by grouping the queries  with similar constraint values, each user session can be  mapped to multiple transactions that can be processed by  association mining algorithms to obtain abstract rules for  predicting future XML queries. We found that our  prefetching approach improved both the cache hit ratio and  the precision of the cache system despite the overhead in  issuing additional prefetching queries.

8. Acknowledgement  The work reported in this paper was partially supported by  Hong Kong CERG Grant ? PolyU 5094/00E.

9. References  [1] Chen, L. and Rundensteiner, EA "ACE-XQ: A  CachE-aware XQuery Answering System", ACM  SIGMOD Associated Workshop on the Web and  Databases (WebDB), Madison, Wisconsin, June 2002,  pp 31--36.

[2] Chen, L., Wang, S. and Rundensteiner, EA "A  Fine-Grained Replacement Strategy for XML Query  Cache " ACM International Workshop on Web  Information and Data Management (WIDM), McLean,  Virginia, November 2002, pp 76?83.

[3] Qiang Yang, Henry Haining Zhang, Ian Tian Yi Li, Ye  Lu: Mining Web Logs to Improve Web Caching and  Prefetching. Web Intelligence 2001: 483-492.

[4] E. Frias-Martinez and V. Karamcheti, A Prediction  Model for User Access Sequences, Proceedings of the  WEBKDD Workshop: Web Mining for Usage Patterns  and User Profiles, ACM SIGKDD International  Conference on Knowledge Discovery and Data Mining,  July 2002.

[5] R. Agrawal, T. Imielinski, and A. Swami. Mining  association rules between sets of  items in large  databases. In Proc. ACM SIGMOD Intl. Conf.

Management of Data, pages 207-216.

[6] Andreas Geyer-Schulz and Michael Hahsler.

Evaluation of Recommender Algorithms for an Internet  Information Broker based on Simple Association-Rules  and on Repeat-Buying  Theory. Proceedingsof the  WebKDD 2002, 2002.

[7] F. Abbattista, M. Degemmis, N. Fanizzi, O. Licchelli,  P. Lopes, G. Semeraro, F. Zambetta , Learning User  Profiles for Content-Based Filtering in e-Commerce,  Proc.  Convegno AssociazioneItaliana per Intelligenze  Artificiale (AIIA 2002), Sep. 2002.

