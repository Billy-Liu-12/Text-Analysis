Mining Frequent Itemsets with Convertible Constraints *

Abstract  Recent work has highlighted the importance of the constraint-based mining paradigm in the context offrequent itemsets, associations, correlations, sequential patterns, and many other interesting patterns in large databases.

In this paper; we study constraints which cannot be han- dled with existing theory and techniques. For example, a v g ( S )  0 U ,  median(S) 0 U, sum(S) 0 v ( S  can con- tain items of arbitrary values) (0 E { >, s}), are customar- ily regarded as ?tough ?? constraints in that they cannot be pushed inside an algorithm such as Apriori. We develop a notion of convertible constraints and systematically analyze, classib, and characterize this class. We also develop tech- niques which enable them to be readily pushed deep inside the recently developed FP-growth algorithm for  frequent itemset mining. Results from our detailed experiments show the effectiveness of the techniques developed.

1. Introduction  It has been well recognized that frequent pattern min- ing plays an essential role in many important data mining tasks. However, frequent pattern mining often generates a very large number of frequent itemsets and rules, which re- duces not only the efficiency but also the effectiveness of mining since users have to sift through a large number of mined rules to find useful ones.

Recent work has highlighted the importance of the paradigm of constraint-based mining: the user is allowed to express his focus in mining, by means of a rich class of constraints that capture application semantics. Besides al- lowing user exploration and control, the paradigm allows many of these constraints to be pushed deep inside mining, thus pruning the search space of patterns to those of interest to the user, and achieving superior performance.

Itemset constraints have been incorporated into associ- ation mining [IO]. A systematic method for the incorpo- ration of two large classes of constraints-anti-monotone  ?The work was supported in part by grants from the Natural Sciences and Engineering Research Council of Canada, and the Networks of Centres of Excellence of Canada (NCWIRIS-3).

Laks V.S. Lakshmanan Concordia University & IIT - Bombay Montreal, Quebec & Mumbai, India  laks @ it.iitb.ernet.in  and succinct-in frequent itemset mining is presented in [7, 61. A method for mining association rules in large, dense databases by incorporation of user-specified con- straints that ensure every mined rule offers a predictive ad- vantage over any of its simplifications, is developed in [2].

Constraint-based mining of correlations, by exploration of anti-monotonicity and succinctness, as well as monotonic- ity, is studied in [4].

While previous studies cover a large class of useful constraints, many other useful and natural constraints re- main. For example, consider the constraints a v g ( S )  0 v, median(S) B v, and sum(S) 0 v (0 E {>,I}). The first two are neither anti-monotone, nor monotone, nor succinct.

The last one is anti-monotone when 0 is 5 and all items have non-negative values. If S can contain items of arbi- trary values, sum(S) 5 v is rather like the first two con- straints. Intuitively, this means these constraints are hard to optimize. In this paper, we investigate a whole class of constraints that subsumes these examples. The main idea is that constraints that exhibit no nice properties do so in the presence of certain item orders. We make the following contributions.

0 We introduce (Section 3) the concept of convert- ible constraints and classify them into three classes: convertible anti-monotone, convertible monotone, and strongly convertible. This covers a good number of useful constraints which were previously regarded tough, including all the examples above.

0 We characterize (Section 3) the class of convertible constraints using the notion of prejix monotone func- tions, and study the arithmetical closure properties of such functions. As a byproduct, we can show that large classes of constraints involving arithmetic are convert- ible, e.g., maz(S ) /avg (S )  < v is convertible anti- monotone and median(S) - min(S) > v is convert- ible monotone.

0 We show that convertible constraints cannot be pushed deep into the basic Apriori framework. However, they can be pushed deep into the frequent pattern growth mining. We thus develop (Section 4) algorithms for fast mining of frequent itemsets satisfying the various constraints.

0 We report our results from a detailed set of experi-  1063-6382/01$10.00 0 2001 IEEE    ments, which show the effectiveness of the algorithms developed(Section 5 ) ;  and finally, we conclude the study in Section 7.

Transaction ID  2. Problem Definition: Frequent Itemset Min- ing with Constraints  Items in transaction a, b, c ,  d ,  f  b, c ,  d ,  f 7 g ,  h a ,  c ,  d ,  e ,  f  c ,  e ,  f 99  Let I = { i l l  i2, . . . , im} be a set of all items, where an item is an object with some predefined attributes (e.g., price, weight, etc.). A transaction T = (tid, I t )  is a tuple, where tid is the identijier of the transaction and It G I. A transac- tion database 7 consists of a set of transactions. An itemset S 2 I is a subset of the set of items. A k-itemset is an itemset of size k. We write itemsets as S = ijl ij2 . . . i j k , omitting set brackets.

An itemset S is contained in a transaction T = (tid, I t ) , if and only if S G I t .  The support sup( S) of an itemset S in a transaction database 7 is the number of transactions in 7 containing S. Given a support threshold < (1 5 5 IT[), an itemset S is frequent provided sup(S) 2 <.

A constraint C is a redicate on the powerset of the set  satisfies a constraint C if and only if C ( S )  is true. The set of itemsets satisfying a constraint C is satc (I) = { S I S G I A C ( S )  = true}. We call an itemset in satc (1)  valid.

Problem definition. Given a transaction database 7, a support threshold <, and a set of constraints C, the prob- lem of mining frequent itemsets with constraints is to find the complete set of frequent itemsets satisfying C, i.e., find Fc = { s  I s E s a t c ( I )  A ~ u p ( S )  2 <}.

of items I, i.e., C : 2 P + {true,  false}. An itemset S  Many kinds of constraints can be associated with fre- quent itemset mining. Two categories of constraints, suc- cinctness and anti-monotonicity, were proposed in [7, 61; whereas the third category, monotonicity, was studied in [3, 4, 81 in the contexts of mining correlated sets and fre- quent itemsets. We briefly recall these notions below.

4 acdf, bcdf  ' ac, ad, a f ,  bc, bd, bf,'cd, c,,'cf, cg, d f ,  e f ,  f g acd, acf I adf I bed, bcf 9 bdf I cdf I cef  7 c f g  '  Definition 2.1 (Anti-monotone, Monotone, and Succinct Constraints) A constraint C, is anti-monotone if and only if whenever an itemset S violates C,, so does any superset of S. A constraint Cm is monotone if and only if when- ever an itemset S satisfies C,, so does any superset of S.

Succinctness is defined in steps, as follows.

0 An itemset I, C I is a succinct set, if it can be ex- pressed as ap (I) for some selection predicate p, where U is the selection operator.

0 SP G 2' is a succinct powerset, if there is a fixed number of succinct sets 11 , I ,  , . . . , Ik I ,  such that SP can be expressed in terms of the strict powersets of I1 , . . . , Ik using union and minus.

0 Finally, a constraint C, is succinct provided satc, (I) is a succinct powerset.

We can show the following result.

Theorem 2.1 A constraint C is both anti-monotonic and monotonic ifand only i fC(S) true for  all itemset S, or C ( S )  Theorem 2.2 Every succinct constraint involving only ag- gregate functions can be expressed using conjunction and/or disjunction of monotone and anti-monotone con- stra ints.

false for all itemset S.

Table 2. Frequent itemsets with support threshold = 2 in transaction database 7 in Table 1.

Let each item have an attribute value (such as profit), with the concrete value shown in Table 3. In all constraints such as sum(S)  B w ,  we implicitly refer to this value.

Table 3. The values (such as profit) of items in Ex- ample 1.

The constraint range(S) 5 15 requires that for an itemset S, the value range of the items in S must be no greater than 15. It is an anti-monotone constraint, in the sense that if an itemset, say ab, violates the constraint, any of its supersets will violate it; and thus ab can be re- moved safely from the candidate set during an Apriori-like frequent itemset mining process [7 ] .  However, the con- straint Cavg = awg(S) > 25 is not anti-monotone (nor monotone, nor succinct, which can be verified by read- ers). For example, avg(df) = (10 + 30)/2 < 25, vio-     lates the constraint. However, upon adding one more item a, awg(adf) = (40 + 10 + 30)/3 > 25, adf satisfies Cawg-  This example scratches the surface of a large class of useful constraints involving awg, median, etc. as well as arithmetic. Exploiting them in mining calls for new tech- niques, which is the subject of this paper.

3. Convertible Constraints and Their Classifi- cation  Before introducing the concept of convertible constraint, we motivate it with an example.

Example 2 Suppose we wish to mine frequent itemsets over transaction database 7 in Table 1, with the support threshold e = 2 and with constraint C E uwg(S) > 25.

The complete set of frequent itemsets satisfying C can be obtained by first mining the frequent itemsets without using the constraint (i.e., Table 2 )  and then filtering out those not satisfying the constraint. Since the constraint is neither anti- monotone, nor monotone, nor succinct, it cannot be directly incorporated into an Apriori-style algorithm. E.g., itemset f g  satisfies the constraint, while its subset g and its superset dfg do not.

If we arrange the items in value-descending order, ( U ,  f, g, d ,  b ,  h,  c ,  e), we can observe an interesting property, as follows. Writing itemsets w.r.t. this order leads to a no- tion of a prefix. E.g., a f d has a f and a as its prefixes.

Interestingly, the average of an itemset is no more than that of its prefix, according to this order.

3.1. Convertible Constraints  The observation made in Example 2 motivates the fol- lowing definition. We will frequently make use of an order? over the set of all items and assume itemsets are written ac- cording to this order.

Definition 3.1 (Prefix itemset) Given an order R over the set of items I ,  an itemset S? = ilia . . . il is called aprejix of itemset S = i l i 2  . . i ,  w.r.t. R, where (I 5 m) and items in both itemsets are listed according to order R. S? is called a properprejix of S if (1 < m).

We next formalize convertible constraints as follows.

Definition 3.2 (Convertible Constraints) A constraint C is convertible anti-monotone provided there is an order R on items such that whenever an itemset S satisfies C, so does any prefix of S. It is convertible monotone provided there is an order R on items such that whenever an item- set S violates C, so does any prefix of S.  A constraint is convertible whenever it is convertible anti-monotone or monotone.

~~ ~  ?Unless otherwise stated, every order used in this paper is assumed to be total over the set of items.

Note that any anti-monotone (resp., monotone) con- straint is trivially convertible anti-monotone (resp., convert- ible monotone): just pick any order on items.

Example3 We show uwg(S) 0 w where 0 E {L, >} is a convertible constraint.

Let R be the value-descending order. Given an item- set S = ala:! . . satisfying the constraint uwg(S) > w , where items in S are listed in the order R. For each prefix S ? = a l . . . a k o f S ( l I k < I ) , s i n c e a k  > a k + l  > . . . > al-1 2 a [ ,  we have avg(S?)  2 avg(S? U { a k + l } )  2 . .  . > awg(S)  2 w. This implies S? also satisfies the constraint.

So, constraint awg(S)  2 w is convertible anti-monotone.

Similarly, it can be shown that constraint awg(S)  5 w is convertible monotone.

Interestingly, if the order R-l (i.e., the reversed order of R) is used, the constraint awg(S) > w can be shown convertible monotone. For lack of space, we leave this as an exercise to the reader.

In summary, constraint uwg(S)  0 w is convertible con- straint. Furthermore, there exists an order R such that the constraint is convertible anti-monotone w.r.t. R and con- vertible monotone w.r.t. R-?.

As another example, let us examine the constraints with function sum(S).

Example4 Constraint sum(S) 5 w is anti-monotone if items are all with non-negative values. However, if items are with negative, zero or positive values, the constraint be- comes neither anti-monotone, nor monotone, nor succinct.

Curiously, this constraint exhibits a ?piecewise? con- vertible monotone or anti-montone behavior. If w >_ 0 in the constraint, the constraint is convertible anti-monotone w.r.t. item value ascending order. Given an itemset S = ala2 . . .a( such that sum(S) 5 w ,  where items are listed in value ascending order. For a prefix S? = ala:! . . . a j (1 5 j 5 I), if a j  5 0, that means a1 5 a2 5 . . .  5 aj-1 5 a j  5 0. So, sum(S?) 5 0 5 w. On theother hand, if aj  > 0, we have 0 < aj  5 aj+l 5 . . . 5 al.  Thus, sum(S?) = sum(,?) - sum(aj+l . . .  U ! )  < w. Therefore, sum(,!??) 5 w in both cases, which means S? satisfies the constraint.

If w 5 0 in the constraint, it becomes convertible mono- tone w.r.t. item value descending order. We leave it to the reader to verify this.

Similarly, we can also show that, if items are with nega- tive, zero or positive values, constraint sum(S) 2 w is con- vertible monotone w.r.t. value ascending order when w > 0, and convertible anti-monotone w.r.t. value descending order when U 5 0.

The following lemma can be proved with a straightfor- ward induction.

Lemma 3.1 Let C be a constraint over a set of items I .

1. C is convertible anti-monotone if and only if there ex- ists an order R over I such that for every itemset S     anditem a E Isuch thatVx E S , x  R a, C ( S U  { a } ) implies C(S) .

2. C is convertible monotone i f  and only if there exists an order R over I such that for every itemset S and item a E I such that V x  E S,  x R a, C ( S )  implies C(S  U { a } ) .

The notion of prefix monotone functions, introduced be- low, is helpful in determining the class of a constraint. We denote the set of real numbers as R.

Definition 3.3 (Prefix monotone functions) Given an or- der R over a set of items I ,  a function f : 2' -+ R is a prefix (monotonically) increasing function w.r.t. R if and only if for every itemset S and its prefix S' w.r.t. R, f ( S ' )  5 f ( S ) .  A function g : 2' -+ R is called a prejx (monotonically) decreasing function w.r.t. R if and only if for every itemset S and its prefix S' w.r.t. R, g(S') L g ( S ) .

We have the following lemma on the determination of prefix monotone functions. The proof is similar to that of Lemma 3.1.

Lemma 3.2 Given an order R over a set of items I .

1. A function f : 2' -+ R is a prejx decreasing function w . ~ t .  R if and only i f for every itemset S and item a such that Vz E S ,  2 R a, f ( S )  2 f( S U { a } ) .

2. A function g : 2' -+ R is a prejx increasing function w . ~ t .  72 if and only i f for every itemset S and item a suchthatV.cE S , z R a , g ( S )  i g ( S U { u } ) .

It turns out that prefix monotone functions satisfy inter- esting closure properties with arithmetic. An understanding of this would shed light on characterizing a whole class of convertible functions involving arithmetic. The following theorem establishes the arithmetical closure properties of prefix monotone functions. We say a function f : 2' -+ R is positive, provided VS C 1 : f(S) > 0.

Theorem 3.1 Let f and f' be pre$x decreasing functions, and g and g' be prefix increasing functions w . ~ t .  an order 72, respectively. Let c be a positive real number  1. Functions - f ( S ) ,  &, c . g ( S )  andg(S )  +g'(S) are pre f i  increasing functions. Functions -g(S), &, c .

f( S )  and f( S )  +f' ( S )  are pre$x decreasing functions.

2. rf f and g are positive functions, then f( S )  x f'( S )  is prefix decreasing, and g(S) x g'(S) is prejix increas- ing.

3. A constraint h ( S )  2 U (resp., h ( S )  5 U )  is convertible anti-monotone (resp., monotone) ifand only if h pre f i decreasing. Similarly, h ( S )  2 U (resp., h ( S )  5 w) is convertible monotone (resp., anti-monotone) if and only i f h  is prejx increasing.

Example 5 As an illustration, notice that uvg(S) is  a pre- fix decreasing function w.r.t. value-descending order, and aug(S) 2 20 is convertible anti-monotone w.r.t. the same order. Also, .max(S)  i s  a prefix increasing* function w.r.t.

this order. From Theorem 3.1, it follows that l / uvg(S) is prefix increasing and hence m a x ( S ) / a v g ( S )  is prefix increasing.' Consequently, we immediately deduce that max(S ) /aug(S )  5 U is convertible anti-monotone w.r.t.

this order.

We know from Theorem 2.2 that a succinct constraint can be expressed in terms of conjunction and/or disjunction of anti-monotone and monotone constraints. By definition, every monotone/anti-monotone is convertibly so. A natural question is, what is the relationship between succinct con- straints and convertible constraints? The following theorem settles this question.

Theorem 3.2 Every succinct constraint is either anti- monotone, or monotone, or convertible.

Proof Sketch. The proof of the theorem is constructed by induction on the structure of s a t c ( I )  of a succinct con- straint C', according to the definition of succinctness.

3.2. Strongly convertible constraint  Some convertible constraints have the additional desir- able property that w.r.t. an order R they are convertible anti- monotone, while w.r.t. its inverse R-l they are convertible monotone. E.g., aug(S) 5 w is convertible monotone w.r.t. value ascending order and convertible anti-monotone w.r.t. value descending order (see also Example 3). This property provides great flexibility in  data mining query op- timization.

Definition 3.4 (Strongly convertible constraint) A con- straint C,, is called a strongly convertible constraint, pro- vided there exists an order R over the set of items such that C,, is convertible anti-monotone w.r.t. R and convertible monotone w.r.t. R-I.

Notice that median(S) 0 U (0 E {<,>}) is also strongly convertible. Clearly, not every convertible con- straint i s  strongly convertible. E.g., ma;c(S) /avg(S)  5 U i s  convertible anti-monotone w.r.t. value descending order, when all items have a non-negative value. However, it is not convertible monotone w.r.t. value ascending order.

The following lemma links strongly convertible con- straints to prefix monotone functions.

Lemma 3.3 Constraint f ( S )  0 U is strongly convertible, if and only ifthere exists an order R over the set of items such that f is a prefi  decreasing function w.Kt. R and a prejx increasingfunction w.rt. R-'.

21t is also prefix decreasing w.r.t. this order.

3Assuming all items have non-negative values.

41t says the proportion of the max price of any item in the itemset over  the average price of the items in the set cannot go over certain limit.

For example, avg(S) and median(S)  are both prefix de- creasing w.r.t. value descending order and prefix increasing w.r.t. value ascending order.

There still exist some constraints that cannot be pushed by item ordering. For example, the constraint avg(S) - median(S)  = O5 does not admit any natural ordering on items w.r.t. which it is convertible. We call such constraints inconvertible.

3.3. Summary: a classification on constraints  As a general picture, constraints (only involving aggre- gate functions) can be classified into the following cate- gories according to their interactions with the frequent item- set mining process: anti-monotone, monotone, succinct and convertible, which in turn can be subdivided into convert- ible anti-monotone and convertible monotone. The inter- section of the last two categories is precisely the class of strongly convertible constraints (which can be treated either as convertible anti-monotone or monotone by ordering the items properly). Figure 1 shows the relationship among the various classes of constraints.

ccmvcmhlc wnvcnihle  convenihle  Figure 1. A classification of constraints and their re- lationships  Some commonly used convertible constraints are listed in Table 4.

4. Mining Algorithms  In this section, we explore how to mine frequent itemsets with convertible constraints efficiently. The general idea is to push the constraint into the mining process as deep as possible, thereby pruning the search space.

In Section 4.1, we first argue that the Apriori algorithm cannot be extended to mining with convertible constraints efficiently. Then, a new method is proposed by examining an example. Section 4.2 presents the algorithm 31Cd for mining frequent itemsets with convertible anti-monotone constraints. Algorithm FIC', which computes the com- plete set of frequent itemsets with convertible monotone constraint, is given in Section 4.3. Section 4.4 discusses mining frequent itemsets with strongly convertible con- straints.

'The constraint requires the median item in the itemset is with the av- erage value.

4.1. Mining frequent itemsets with convertible con- straints: An example  We first show that convertible constraints cannot be pushed deep into the Apriori-like mining.

Remark 4.1 A convertible constraint that is neither mono- tone, nor anti-monotone, nor succinct, cannot be pushed deep into the Apriori mining algorithm.

Rationale. As observed earlier for such a constraint (e.g., avg(S) 5 v), subsets (supersets) of a valid itemset could well be invalid and vice versa. Thus, within the levelwise framework, no direct pruning based on such a constraint can be made. In particular, whenever an invalid subset is eliminated without support counting, its supersets that are not suffixes cannot be pruned using frequency.

For example, itemset df in our running example violates the constraint a v g ( S )  > 25. However, an Apriori-like al- gorithm cannot prune such itemsets. Otherwise, its superset a d f ,  which satisfies the constraint, cannot be generated.

Before giving our algorithms for mining with convertible constraints, we give an overview in the following example.

Example 6 Let us mine frequent itemsets with con- straint C = a v g ( S )  > 25 over transaction database 7 in Table 1, with the support threshold < = 2. Items in every itemset are listed in value descending order R: ( ~ ( 4 0 ) ~  f ( 3 0 ) ,  dzo), 4 1 0 ) ,  b ( O ) ,  h(-10),~(-20),  e(-30)) .

It is shown that constraint C is convertible anti-monotone w.r.t. R. The mining process is shown in Figure 2.

R a-f-g-d-bc-e  Figure 2. Mining frequent itemsets satisfying con- straint a v g ( S )  > 25.

By scanning 7 once, we find the support counts for ev-  ery item. Since h appears in only one transaction, it is an infrequent items and is thus dropped without further con- sideration. The set of frequent l-itemsets are a, f, g, d, b,  c and e ,  listed in order R. Among them, only a and f satisfy     Constraint  f(S) 5 v (f is a prefix decreasing function) I * Yes * f(S) 5 v (f is a prefix increasing function) Yes * *  Convertible Convertible Strongly anti-monotone monotone convertible  Table 4. Characterization of some commonly used, SQL-based convertible constraints. (* means it  depends on the specific constraint.)  the constraint6. Since C is a convertible anti-monotonecon- straint, itemsets having g,  d, b, c or E as prefix cannot satisfy the constraint. Therefore, the set of frequent itemsets satis- fying the constraint can be partitioned into two subsets:  1 .  The ones having itemset a as a prefix w.r.t. ?2, i.e.,  2. The ones having itemset f as a prefix w.r.t. 2 ,  i.e., those containing item a ;  and  those containing item f but no n.

The two subsets form two projected databases [5] which are mined respectively.

1 .  Find frequent itemsets satisfying the constraint and having a as a prefix. First, n is a frequent itemset satisfying the constraint. Then, the frequent itemsets having a as a proper prefix can be found in the sub- set of transactions containing n ,  which is called n- projecred database. Since n appears in every transac- tion in the a-projected database, i t  is omitted. The n- projected database contains two transactions: bcdf and cde f .  Since items b and e is infrequent within this pro- jected database, neither ab nor ne can be frequent. So, they are pruned. The frequent items in the a-projected database is f ,  d ,  c, listed in the order R. Since nc  does not satisfy the constraint, there is no need to create an ac-projected database.

To check what can be mined in the a-projected database with a f  and ad, as prefix, respectively, we need to construct the two projected databases and mine them. This process is similar to the mining of a- projected databases. The a f -projected database con- tains two frequent items d and c, and only a f d  satisfy the constraint. Moreover, since a f dc does not satisfies the constraint, the process in this branch is complete.

Since a f c  violates the constraint, there is no need to construct a f c-projected database. The ad-projected database contains one frequent item c, but adc does not satisfy the constraint. Therefore, the set of fre- quent itemsets satisfying the constraint and having a as prefix contains a, a f ,  a f d ,  and ad.

?The fact that itemset g does not satisfy the constraint implies none of any I-itemsets after g in order R can satisfy the constraint avg.

2 Find frequent itemsets satisfying the constraint and having f as a prefix. Similarly, the f-projected database is the subset of transactions containing f, with both n and f removed. It has four transactions: bcd, bcd!y, C ~ E  and ceg. The frequent items in the pro- jected database are g -  d .  6 ,  c ,  e ,  listed in the order of?R..

Since only itemsets fg and fd satisfy the constraint, we only need to explore if there is any frequent item- set having f!g or f d  as a proper prefix which satisfies the constraint. The projected fg-database contains no frequent itemset with f g  as a proper prefix that sat- isfies the constraint. Since b is the item immediately after d in order K ,  and f d b  violates the constraint, any itemset having fd as a proper prefix cannot satisfy the constraint. Thus, f and fg  are the only two frequent itemsets having f as a prefix and satisfying the con- strain t.

I n  s u m m a r y ,  t h e  c o m p l e t e  se t  o f  f r equen t  i t emse t s  sat is- fying the constraint contains 6 itemsets: n ,  f, af, n d ,  n f d , fg. Our new method generates and tests only a small set of itemsets.

4.2. FXd: Mining frequent itemsets with convert- ible anti-monotone constraint  Now, let us justify the correctness and completeness of the mining process in Example 6.

First, we show that the complete set of frequent itemsets satisfying a given convertible anti-monotone constraint can be partitioned into several non-overlapping subsets. It leads to the soundness of our algorithmic framework.

Lemma 4.1 Consider a transaction database 7, a support threshold and a convertible anti-monotone constraint C w . ~ t .  an order 72 over a set of itenis I .  Let a l ,  a?,  . . . , a , be the itenis satisfying C. The coniplete set offrequent item- sets satisjj!ing C can be partitioned into in disjoint subsets: the j t h  subset (1 5 j 5 m) contains frequent itemsets sat- isfying C and having a j  as a prejix.

We mine the subsets of frequent itemsets satisfying the constraint by constructing the corresponding projected database.

Definition 4.1 (Projected database) Given a transaction database 7, an itemset a and an order R.

1. Itemset p is called the max-prefix projection of trans- action (tid, I t )  E 7 w.r.t. R, if and only if ( 1 )  a C It and p C I t ;  (2) a is a prefix of j3 w.r.t. R; and (3) there exists no proper superset y of p such that y 5 It and y also has a as a prefix w.r.t. R.

2. The a-projected database is the collection of max- prefix projections of transactions containing a,  w.r.t.

R.

Remark4.2 Given a transaction database 7, a support threshold < and a convertible anti-monotone constraint C.

Let a be a frequent itemset satisfying C. The complete set of frequent itemsets satisfying C and having a as  a prefix can be mined from the a-projected database.

The mining process can be further improved by the fol- lowing lemma.

Definition 4.2 (Ascending and descending orders) An order R over a set of items I is called an ascending order for function h : 2' + R if and only if (1) for items a and b,  h(a)  < h(b) implies a R 6 ,  and ( 2 )  for itemsets a U { a }  and a U { b }  such that both of them have a as a prefix and a R b,  f(a U { a } )  5 f ( a  U { b } ) .  R-l is called a descending order for function h.

For example, it can be verified that the value ascending order is an ascending order for function aug(S) and a de- scending order for function m a z ( S ) / a v g ( S ) .

Lemma 4.2 Given a convertible anti-monotone constraint C E f(S) 6 v ( 6  E {I,>}) w.bt. ascending/descending order R over a set of items I ,  where f is a prefix function.

Let a be a frequent itemset satisfying C and a l ,  a2 ,  , . . , a , be the set of frequent items in a-projected database, listed in the order of R.

1. Ifitemset a U { a i }  (1 5 i < m) violates C, f o r j  such that i < j 5 m, itemset Q U { a j }  also violates C.

2. If itemset a U { a j }  (1 5 j < m) satisfies C, but a U { a j  , a j + l }  violates C, no frequent itemset having a U { a j }  as a properprefi  satisfies C.

Based on the above reasoning, we have the algo- rithm FICA as follows for mining Frequent ltemsets with - Convertible Anti-monotone constraints.

Algorithm 1 (FICA) Given a transaction database 7,  a support threshold < and a convertible anti-monotone con- straint C w.r.t. an order R over a set of items I ,  the algo- rithm computes the complete set of frequent itemsets satis- fying the constraint C.

Method: Call f i e a  (0,T); function f i e Q  (a ,  ' a  is the itemset as prefix and 71, is the @-projected database.

1.

2.

3.

4.

5.

Scan 71, once, find frequent items in 71,. Let I ,  be the set of frequent items within 71, such that Vu E I,, C(a U { a } )  = true.

If I ,  = 0 return, else Vu E I,, output a U {a} as a frequent itemset satisfying the constraint.

If C is in form o f f (  S )  8 where f is a prefix function and 0 E ( 5 ,  >}, using Lemma 4.2 to optimize the mining by removing items b from I ,  such that there exists no frequent itemset satisfying C and having a U { b }  as a proper prefix.

Scan 71, once more, Vu E I [ @ ,  generate a U { a } - projected database 71,u(,).

For each item a in II,, call f i e a ( a  U { a } ,  71au{a)).

Rationale. The correctness and completeness of the algo- rithm has been reasoned step-by-step in this section. The efficiency of the algorithm is that it pushes the constraint deep into the mining process, so that we do not need to gen- erate the complete set of frequent itemsets in most of cases.

Only related frequent itemsets are identified and tested. As shown in Example 6 and in the experimental results, the search space is decreased dramatically when the constraint is sharp.

4.3. 3X': Mining frequent itemsets with mono- tone constraints  In the last two subsections, an efficient algorithm for mining frequent itemsets with convertible anti-monotone constraints is developed. Under similar spirit, an algorithm for mining frequent itemsets with convertible monotone constraints can also be developed. Due to lack of space, instead of giving details of formal reasoning, we illustrate the ideas using an example and then present the algorithm.

Example 7 Let us mine frequent itemsets in transaction database 7 in Table 1 with constraint C G a v g ( S )  5 20.

Suppose the support threshold < = 2. In this example, we use the value descending order R exactly as is used in Ex- ample 6. Constraint C is convertible monotone w.r.t. order R.

After one scan of transaction database 7, the set of fre- quent 1-itemsets is found. Among the 7 frequent 1-itemsets, g, d, 6 ,  c and e satisfy the constraint C. According to the definition of convertible monotone constraints, frequent itemset having one of these 5 itemsets as a prefix must also satisfy the constraint. That is, the g-, d-, b- ,  e- and e- projected database can be mined without testing constraint C, because adding smaller items will only decrease the value of avg.  But a- and f-projected databases should be mined with constraint C testing. However, as soon as its fre- quent k-itemsets for any k satisfy the constraint, constraint checking will not be needed for further mining of their pro- jected databases.

We present the algorithm T Z C M  for mining frequent itemsets with convertible monotone constraint as follows.

Algorithm 2 (FIC') Given a transaction database 7, a support threshold and a convertible monotone constraint C w.r.t. an order R over a set of items I ,  the algorithm com- putes the complete set of frequent itemsets satisfying the constraint C.

Method: Call f i c m  ( 0 , 7 , 1 ) ; function t i cm(&,  TI,, check-flag)s  1. Scan 71, once, find frequent items in TIa. If check-flag is 1, let f: be the set of frequent items within 71, such that Vu E I:, C (a  U { a } )  = true, and 1; be the set of frequent items within 71, such that V b  E I;, C (a  U { b } )  = f a l s e .  If check-f lag is 0, let I$ be the set of frequent items within 71, and I; be 0.

2. Vu E I$ ,  output (Y U { a }  as a frequent itemset satisfy- ing the constraint.

3. Scan 71, once more, Vu E f l iUI l ; ,  generate au{a}- projected database 71,u(,).

4. Foreach itema i n I ~ ~ , c a l l f i c , ( a U { a } , 7 ~ a u ~ a ~ ,  0); Foreach itemainfI;,call f ic,(aU{a},71,,~,) ,  1);  Rationale. The correctness and completeness of the algo- rithm can be shown based on the similar reasoning in Sec- tion 4.2. Here, we analyze the difference between 3 1 C M with an Apriori-like algorithm using constraint-checking as post-processing.

Both F1CM and Apriori-like algorithms have to gener- ate the complete set of frequent itemsets, no matter whether the frequent itemsets satisfy the convertible monotone con- straint. The frequent itemsets not satisfying the constraint cannot be pruned. That is the inherent difficulty of convert- ible monotone constraint.

The advantage of TICM a ainst Apriorix-like algo- rithms lies in  the fact that FIG' only tests some of fre- quent itemsets against the constraint. Once a frequent item- set satisfies the constraint, it guarantees all of frequent item- sets having it as a prefix also satisfy the constraint. There- fore, all that testing can be saved. An Apriori-like algorithm has to check every frequent itemset against the constraint.

In the situation such that constraint testing is costly, such as spatial constraints, the saving over constraint testing could be non-trivial. Exploration of spatial constraints is beyond the scope of this paper.

4.4. Mining frequent itemsets with strongly convert- ible constraints  The main value of strong convertibility is that the con- straint can be treated either as convertible anti-monotone or monotone by choosing an appropriate order. The main point to note in practice is when the constraint has a high selec- tivity (fewer itemsets satisfy it), converting it into an anti- monotone constraint will yield maximum benefits by search  'a is the itemset as prefix, 71, is the a-projected database, and check-flag is the flag for constraint checking.

space pruning. When the constraint selectivity is low (and checking it is reasonably expensive), then converting it into a monotone constraint will save considerable effort in con- straint checking. The constraint awg(S)  < w is a classic example.

5. Experimental Results  To evaluate the effectiveness and efficiency of the algo- rithms, we performed an extensive experimental evaluation.

In this section, we report the results on a synthetic trans- action database with IOOK transactions and 10K items. The dataset is generated by the standard procedure described in [l]. In this dataset, the average transaction size and aver- age maximal potentially frequent itemset size are set to 25 and 20, respectively. The dataset contains a lot of frequent itemsets with various length. This dataset is chosen since it is typical in data mining performance study.

The algorithms are implemented in C. All the exper- iments are performed on a 233MHz Pentium PC with 128MB main memory, running Microsoft WindowsNT.

To evaluate the effect of a constraint on mining frequent itemsets, we make use of constraint selectivity, where the selectiviy S of a constraint C on mining frequent itemsets over transaction database 7 with support threshold is de- fined as  # of frequent itemsets NOT satisfying C # of frequent itemsets  6 =  Therefore, a constraint with 0% selectivity means every fre- quent itemset satisfies the constraint, while a constraint with 100% selectivity is the one cannot be satisfied by any fre- quent itemset. The selectivity measure defined here is con- sistent with those used in [7,61.

To facilitate the mining using projected databases, we employ a data structure called FP-tree in the implementa- tions of FICA and FIC'. FP-tree is first proposed in [SI, and also be adopted by [8,9]. It is a prefix tree structure to record complete and compact information for frequent item- set mining. A transaction database/projected database can be compressed into an FP-tree, while all the consequent projected databases can be derived from it efficiently. We refer readers to [5] for details about FP-tree and methods for FP-tree-based frequent itemset mining.

Since FP-growth [5] is the FP-tree-based algorithm mining frequent itemsets and is much faster than Apriori, we include it in our experiment. Comparison among F I C A , 3 Z C M  and FP-growth makes more sense than using pure Apriori as the only reference method.

5.1. Evaluation of FZCA  To test the efficiency of FZCd w.r.t. constraint selec- tivity in mining frequent itemsets with convertible anti- monotone constraints, we run a test over the dataset with      g 140- f 120.

s 100-  Figure 3. Scalability with constraint selectivity.

,~ - - + - - - - +- - - -A- - - + -+ .FP-gmwth -h FIC(A) 20% -D- FIC(A) 80% +\  04 i 00% 02% 04% 06% 08% 10%  Support threshold  Figure 4. Scalability with support threshold.

support threshold < = 0.1%. The result is shown in Fig- ure 3. Various settings are used in the constraint for various selectivities.

As can be seen from the figure, 3 1 C A  achieves an al- most linear scalability with the constraint selectivity. As the selectivity goes up, i.e., fewer itemsets satisfy the con- straint, 3 1 C A  cuts more search space, since one frequent itemset not satisfying the constraint means all frequent itemsets having i t  as a prefix can be pruned.

We compare the runtime of both Apriori and FP-growth in the same figure. All these two methods first compute the complete set of frequent itemsets, and then use the constraint as a filter. So, their runtime is constant w.r.t. constraint selectivity. However, only when the constraint selectivity is 0%, i.e., every frequent itemset satisfies the constraint, does FICA need the same runtime as FP-growth. In all other situations, F I C A  always requires less time.

We also tested the scalability of FZC? with support threshold and the number of transactions, respectively. The corresponding results are shown in Figure 4 and Figure 5.

From these figures, we can see that 3ZCA is scalable in both cases. Furthermore, the higher the constraint selectiv- ity, the more scalable FZCA is. That can be explained by the fact that 3ZCd always cuts more search space using constraints with higher selectivity.

5.2. Evaluation of FZCM  As analyzed before, convertible monotone constraint can be used to save the cost of constraint checking, but it cannot cut the search space of frequent itemsets. In our experi- ments, since we use relatively simple constraints, such as those involving avg and sum, the cost of constraint check- ing is CPU-bound. However, the cost of the whole frequent itemset mining process is I/O-bound. This makes the effect of pushing convertible monotone constraint into the mining process hard to be observed from runtime reduction. In our experiments, 3 1 C M  achieves less than 3% runtime benefit  0 200 400 600 800 1000 Number of transactions (K)  Figure 5. Scalability with number of transactions.

in most cases.

However, if we look at the number of constraint tests  performed, the advantage of FICM can be evaluated objec- tively. F Z C ~  can save a lot of effort on constraint testing.

Therefore, in the experiments about 31C?, the number of constraint tests is used as the performance measure.

We test the scalability of 3 Z C M  with constraint selec- tivity in mining frequent itemsets with convertible mono- tone constraint. The result is shown in Figure 6.  The fig- ure shows that FZCM has a linear scalability. When the constraint selectivity is low, i.e., most frequent itemsets can pass the constraint checking, most of constraint tests can be saved. This is because once a frequent itemset satisfies a convertible monotone constraint, every subsequent frequent itemset derived from corresponding projected database has that frequent itemset as a prefix and thus satisfies the con- straint, too.

We also tested the scalability of 3 1 C M  with support threshold. The result is shown in Figure 7. The figure shows that FZCM is scalable. Furthermore, the lower the con- straint selectivity, the better the scalability FZCM is.

In summary, our experimental results show that the method proposed in this paper is scalable for mining fre- quent itemsets with convertible constraints in large transac- tion databases. The experimental results strongly support our theoretical analysis.

6. Discussions: Mining Frequent Itemsets with Multiple Convertible Constraints  We have studied the push of single convertible con- straints into frequent itemset mining. ?Can we push mul- tiple constraints deep into the frequent pattern mining pro- cess??  Multiple constraints in a mining query may belong to the same category (e.g. all are anti-monotone) or to different categories. Moreover, different constraints may be on dif- ferent properties of items (e.g. some could be on item price,     1 .  . . . . .

0% 20% 40% 60% 80% 100%  Selectivity  Figure 6. Scalability with constraint selectivity.

others on sales profits, the number of items, etc.).

As shown in our previous analysis, unlike anti-  monotone, monotone and succinct constraints, convertible constraints can be mined only by ordering items properly.

However, different constraints may require different and even conflicting item ordering. Our general philosophy is to conduct a cost analysis to determine how to combine mul- tiple order-consistent convertible constraints and how to se- lect a sharper constraint among order-conflicting ones. The details will not be presented here for lack of space.

7. Conclusions  Constraints involving holistic functions such as median, algebraic functions such as avg, or even those involving dis- tributive functions like sum over sets with positive and neg- ative item values are difficult to incorporate in an optimiza- tion process in frequent itemset mining. The reason is such constraints do not exhibit nice properties like monotonicity, etc. A main contribution of this paper is showing that by im- posing an appropriate order on items, such tough constraints can be converted into ones that possess monotone behavior.

To this end, we made.a detailed analysis and classification of the so-called convertible constraints. We characterized them using prefix monotone functions and established their arithmetical closure properties. As a byproduct, we shed light on the overall picture of various classes of constraints that can be optimized in frequent set mining. While con- vertible constraints cannot be literally incorporated into an Apriori-style algorithm, they can be readily incorporated into the FP-growth algorithm. Our experiments show the effectiveness of the algorithms developed.

We have been working on a systematic implementation of constraint-based frequent pattern mining in a data min- ing system. More experiments are needed to understand how best to handle multiple constraints. An open issue is given an arbitrary constraint, how can we quickly check if it is (strongly) convertible. We are also exploring the use of constraints in clustering.

160000 - , -t ?FP-growth t F I C ( M )  20% t F I C ( M )  80%  0.0% 0.2% 0.4% 0.6% 0.8% 1.0% Support threshold  Figure 7. Scalability with support threshold.

