

Specification for Generic Enablers as Software  John Paul Brogan Napier University  Institute for Informatics & Digital Innovation Edinburgh, United Kingdom  J.Brogan2@napier.ac.uk  Professor Christoph Thuemmler Napier University  Institute for Informatics & Digital Innovation Edinburgh, United Kingdom c.thuemmler@napier.ac.uk  Generic Enablers are a specialism of software engineering. They are components used for providing reusable building blocks that enable the construction of applications for future internet technology. The Generic Enablers satisfy requirements of application domains including big data processing, cloud infrastructure and internet-of-things. This overview paper introduces a description for defining them as software systems and is looking at the user friendliness of the current release and the appropriateness of the technology for the e-health, wellness and ambient assisted living domains. The material presented by this work is relevant to implementers for constructing their Generic Enabler software, correctly.

Keywords-Generic Enabler; Software Engineering; Reusability; Future Internet; e-Health

I. INTRODUCTION The future internet (FI) domain [1] is a topic of research and activity funded by the EU. It is guided by the aim of collecting information relating the technologies for building the next generation of the internet. Future Internet Architectures (FIA) are a foundation for establishing requirements of applications addressing the needs of systems designed for future and legacy health care solutions. Scalability of the Generic Enablers seems an important requirement to promote models for healthcare based on distributed approaches and thus the Future Internet. The intended result is for e-Health to achieve social and technological alignment across European health care sectors. The work in this field is the on-going responsibility of the FI-STAR project community.

Recent efforts by Thuemmler et al (Thuemmler, Mueller, et al.

2013; Thuemmler, Mival, et al. 2013) describe a strategy using Specific Enablers (SEs) based on the specifications of the Generic Enablers, relevant technical standards and legal and ethical requirements. Future e-Health solutions may be built based on medical modular architectures (MMAs). These MMAs use ideas from FIA domains such as Data/Context Management, Internet of Things (IoT) Services Enablement, Applications/Services Ecosystem and Delivery Framework, Security, Cloud Hosting and Interface to Networks and Devices (I2ND). The domains are comprised of sets of generic enablers that attempt to provide a state of the art components engineering paradigm, accessed from a public cloud platform  called FI-WARE. The platform is operated by developers with authorised access for using remote clients and these are able to be defined also as interactive web application instances. The remote client instances are used by generic enabler developers that have access to FI-LAB web clients, for their application development requirements. Also domains in our context are described as FI-WARE chapters. Due to the fact that health care providers globally are reluctant and due to legal constraints are limited to share patient data with public cloud providers it has become a constant argument whether or not the public health cloud is a sustainable model. The recent withdrawal of Google health from the global market may be regarded as Enlightenments if understood and imagined as a typical hype cycle in accordance with Gartner?s hype cycle theory.

However the purpose of this paper is to achieve a general understanding of FI-WARE generic enablers and to describe them without the content management system concept of using services in the FI-LAB environment but the aim instead is to assess their suitability for use in health care, wellness and ambient assisted living domains. A definition for a typical generic enabler is explored and described throughout this paper. Our work is presented in terms familiar to the software engineering and computer science disciplines.

Generic Enablers (GEs) are software engineered components and are useful for creating instances of new products or services provided over a network. They have been researched, designed and partially implemented by the FI-WARE research project which is an integral part of the 600 Million Euro European Future Internet Private Public Partnership initiative (FI-PPP). The approach of this paper is to attempt a systemic analysis of the overall GE concept by conducting a literature review, an analysis of materials published by the FI-WARE project online and a description of the outcome of practical implementations and design experiments. The results are described in terms relating to the software engineering practice for establishing a precise specification that will then further lead us to a set of properties for describing GEs in more detail.

The application of this work is for being able to handle GEs   DOI 10.1109/ITNG.2014.51     appropriately, investigate their interoperability and understand their user-friendliness further.

II. WHAT IS A GENERIC ENABLER?

A FI-WARE Generic Enabler (GE) is a building block of the FI-WARE platform [2]. GEs are described by their open specifications that supply for us the necessary information for building compliant products as instantiations, created from parts that are assembled in order to produce systems composed from the GE components. The initial idea has been that applications developed based on the GE framework would be using the so called core-platform. Ideally GE components should be standalone, interchangeable or combined together but are also dynamic in operation. GEs may be reused and configured across several application domains. They are provided upon platforms for building end user applications to achieve a given set of relevant and necessary functionalities up to certain, defined standards.

Simoes (2009) presents the idea for deploying enablers across many domains of hardware and software comprised systems.

The enablers, in general, are described as operating enablers, working upon different platforms and technology. The idea is useful because presented is that some type of generic enabler component is required for meeting dynamic internet and system requirements that are essential for creating new products and services. These can have their instantiations realised across varied technologies but are controlled and operated by the FI-WARE platform or other similar modular architecture methodology.

B?rner et al (2011) discuss an advanced software engineering paradigm referring to ?macroscopes? where apparently similar features are included and highlighted.

Although a set of specifications has been published the GE framework is short of an exact ?crisp? definition. A precisely defined model requires a consistent implementation method.

The methodology is a software development design pattern [3]. It is specific to all GE implementations and is intended to be used for a new GE system?s rapid application development (RAD). Such a design approach, applied in this context to developing GEs, is required for implementing technology products, built quickly to known and working standards. Only applications developed within the FI-WARE context are achievable as future internet applications. They are constructed by adhering to the FI-WARE platform and GE guidelines for component combination and interoperation but the question remains how are the GEs to be assembled in software? All GEs from FI-WARE are defined as being reusable combinations of objects and hardware to perform tasks and provide services.

The software can be described further as a finite set of application programming interface (API) functions or communicated protocol instances that are also required for controlling hardware and software operations of each GE  system?s set of functionalities. Furthermore connections of GE components are accomplished by calls to their API functions.

The Generic Enablers, as systems, are defined as multiple device types and their associated methods that are used for providing arbitrary network interfaces to their protocols and hardware drivers i.e. Multimodal [4].

The paradigm in this respect is object oriented and is in theory able to produce portable systems for all application solutions across all deployed device implementations. These GE object systems supply multiple interface access to their functionality, for defining actions so as to conduct automatic component interactions, service provision and background tasks. All of these are operational processes that are performed dynamically for the purpose of providing services on demand.

There exist domains within the FI-WARE context and the supplied GEs conform to open and well-formed specifications of how GEs should be defined within each domain. GE subsets, as mentioned, are described as chapters by FI-WARE and these are named as Data/Context Management, Internet of Things (IoT) Services Enablement, Applications/Services Ecosystem and Delivery Framework, Security, Cloud Hosting and Interface to Networks and Devices (I2ND). The interoperability of their GE?s across many software and hardware types is a requirement that all GE implementations are to follow but achieving this interoperability seems to be a problem because different multimodal implementations, methodologies and protocols are required to design end user applications that are composed of GE components. GE?s are also intended to be able to interact with legacy systems i.e. the GE is used as a macro or control system for interoperating with the bespoke interfaces, presented by many legacy systems already in circulation. This is also a problem that is highlighted for GE implementations to overcome.

Recent work by Paulin (2013) describes a new kind of GE approach of modular architectures in relation to legal and ethical standards of deployed application scenarios within an e-Health operational context. The idea of this work utilises instead Medical Modular Architectures that are a variant of GEs and are useful also for coping with Hippocratic or other sensitive data but attempting to cover all the areas in more detail is out with the scope of the goal of this paper, which is to show how GEs are to be specified and to describe the observable properties that a GE will always adhere to, for defining their implementations as trustworthy and reusable software components.



III. GENERIC ENABLERS AS MACROSCOPES Interestingly GEs are scalable in terms of the scope of their operation and deployment. For example GEs operating at the micro or nano level (machine instruction GEs) can have their operability and definitions reused or used in encapsulating models. The aim of encapsulating GEs in this instance is to utilise the operations of a GE at a lower level representation for providing building blocks, required to implement a new     application at a higher level representation. Therefore, in theory, GEs can be further represented by other software and hardware models for implementing a GE. The highest level interface is often the simplest method of control for a system.

The abstraction leads to simplicity. These interfaces, at all scales of design, are also referred to in the literature as macroscopes of the system underneath [5]. GEs are no exception to the principle either. The classification for a GE is also permitted to be defined as a type of the macroscopes. A GE is in essence a macroscope view on a GE?s operation and implementation. The macroscope on a GE defines, dynamically, how a GE may be used at a representational level and between such levels. For example, GE reference identifiers can be understood as abstract macroscope component notions. They may have parameters to effect the dynamic operation of the associated component. This interface and control is provided as homogenous. The GE provides the general interfacing methodology for allowing all GEs to interoperate vertically between their domains and horizontally between GEs of the same domain.

However the macroscope provides also the ability to abstract the GE detail to domain notions within and between the domains. That is achieved by the macroscope horizontally and vertically, minus their exact GE implementation definitions i.e. specific enablers. Therefore the abstraction of the GEs into simple homogenous programs composed of notions for lower level heterogeneous and multimodal component compositions is possible. Macroscopes achieve the abstraction?s operation in terms of their use and effect on the lower level representations and that is where the components are formed to interact with each other for a purpose. This ability provides a representation of the functionality for a macro system that is very simple to combine and command at a very high level paradigm. The macroscopes are a grey-box representation of a GE.



IV. A GENERIC ENABLER MODEL According to Juanjo Hierro, Chief architect of the FI-WARE platform ?An implementation of a generic enabler (GE) is made up of a set of components which together supports a concrete set of functions and provides a concrete set of APIs and interoperable interfaces that are in compliance with open specifications published for that GE?.

The idea is to be able to reuse standard and verified building blocks to ensure that a new set of well-formed applications for the Future Internet can be feasibly constructed from a reliable platform provisioning FI-WARE compliant GE components.

The result is to have less error within developed systems because they are built upon adaptable and proven GE components within a sandboxed development environment, where construction of the GE conforms exactly to FI-WARE specifications.

A. Specifying the Design of GE Systems Berre et al (2011) examined the procedure for identifying generic and specific enablers from use cases by performing  analysis of a use case in terms of which GEs will best fit the new system?s operation. Their work mentions areas of concern regarding a use case analysis process to help in preparing a correct use case, a model based on ISO RM-ODP as a reference for open distributed processing to help discussion of enabler requirements as interacting objects, decomposition from the use case system to components and objects, identification of GEs and SEs by a combination of top down and bottom up analysis of the system application, life cycle based enablers to identify enablers from service and data centric views for determining data handling enabler requirements, value chains showing system performance operations of enablers, interests regarding system stakeholders to further aid enabler identification, obtaining requirements of the system in terms of identified enablers and architectural based enablers for describing architectural component and enablers/services.

The implication from the work of Berre et al (2011) reflects the situation that in order to specify any system comprised of GEs then the practice is to first understand these system?s specifications and requirements. Then to be constructed are designs of use case, activity, sequence, deployment and component UML diagrams. These require to be skilfully performed to provide the system?s design representation and that is what enables the identification of reusable chapters (FI- WARE domains) which are necessary for constructing an application from reusable GE building blocks. It is these design task steps that provide high level domain diagram views of an application?s observed structure from a design perspective. The result is a mapping of a system?s necessary components and operations to the domain chapters and GE?s from the FI-WARE platform. Then selection of required high level GE components from chapters of FI-WARE, which best match the UML design, is conducted. Created in this respect is a new design view, defined also in UML of the system but it has been achieved according to the terminology of identifiable and application required generic enablers [6]. The result from this set of design tasks has been arrived at by observing naturally, with UML skill, where the GEs can be applied within the designs for any system of software and hardware describable in the UML.

UML designs up to this stage have been transformed several times and are ready to be enhanced, with more detail, by connecting the GE black boxes with their specific enabler component system definition counterparts. This is performed so that the system can have an interoperable instance implementation. Hence the structural designs of systems are ready and usable for transforming again to an actual application?s concrete instantiation. At this point the development can continue further to UML class diagrams and then to concrete code operating on hardware components.

However the GEs, highlighted in designs, may have all the functionality that is required already made available in their FI-WARE supplied implementations, therefore these can be reused directly. Whereas it is also the case that the GE?s can     specifically have a few of their set of operations reused by selecting only some of their API supplied functions. The results of transformations are gradual but fully formed designs for the concrete implementations of systems built from FI- WARE GE building blocks.

Despite system?s having their structure defined from their base components, however it is these system?s implementation, functionality and interoperability that are required to be made as general as is possible to define. This is required so as to accommodate the interaction from the outside to interface with the operation of the GE i.e. control of the customisable operation of the GEs via SEs. Therefore the GE itself requires further specification in terms of an exact and overall component definition and that is necessary for being able to describe a GE i.e. what makes a GE generically operable?

B. The Operation of GEs GEs are intended to operate upon many different form factor device types. Examples of these include PCs, servers, laptops, tablets, smart phones, smart watches and medical hardware.

GEs are required to work in conjunction with processing and storage media such as CPUs, databases and data structures on different levels of hardware e.g. Microcontrollers, DSPs, CPU cache, RAM, Networks and Disk. Moreover GEs must operate across different operating system platforms and programming languages. Furthermore GEs are generally deployable and reusable across technology implementations for any chosen application hosting solution.

Galache et al (2007) describe a generic API for wireless sensor networks (WSNs) which are able to operate just by using a WSN adaptation framework (WAF). Demonstrated by this work is a theory for how a generic API can be constructed and operated for controlling independent networks of sensor device motes that have been connected to a monitor display and each other. The experimental method is demonstrated where the overall apparatus and its operation show that motes are described as hardware sensor devices and have software drivers. The API facilitates the ability to have uniform homogenous access in a platform independent way through the use of the drivers that are also required for controlling the sensors. The API generically permits commands to be performed, agnostic to hardware specific implementation, for switching operational control between differing subjacent platforms of networked motes. This is accomplished from one single command initiating source.

The aim in the context of the review of the work of Galache et al (2007) for the purpose of this paper is to demonstrate that there are different routing procedures, facilitated by heterogeneous platform instances and these are composed of different hardware components. The components have interaction protocols and can be in general manipulated from just one homogenous constructed control component. Their experiment involved a monitor application, network gateways and the WAF alternating between different technology  interfaces. In relation to the GEs being described then their work is observed to be relevant in terms of verifying that a uniform API provision usable for FI-WARE GE?s can be built against the principles that were uncovered from studying their paper.

However the multimodal property of each generic enabler (Dumas 2009) implies that a universal interface will not be workable in practice. This is described as being due to an increased chance of error conditions that can happen when combining the I/O modes of the bespoke interfaces for each GE. The alternative proposal by our work is a solution that instead implements separated modular modes of operation that are then adaptively selected for defining GE operations, as constituent parts for the operability of a holistic system used to define the GE.

However an API specification is a requirement and this is to be generally designed and implemented for all GE types. It is also required to be a model of interaction facilitated by a standard and generalised proxy interface implementation. This is to be utilised for integrating access to the APIs to and from the GEs. Further complexity is obviously introduced whereby GEs are distributed applications that have been designed prior to operate over and in accordance with a network of connected devices. Out of order (asynchronous) communication to and the state of GEs, in the application test bed, at each node of the networked technologies, are necessary to be maintained and controlled too. The reason for this is so as not to have a situation arise that causes subsequent errors within a GE?s operation. The FI-WARE open specifications describe the protocols for GE types in detail. The main requirement is for GEs to be connected to a network API server that can provide a common communication method for GEs to utilise and is their interface to a networked API of resources.

A generic interface between GEs and GEs of differing domain, is possible to be implemented in software and built upon HTTP for defining message passing operations as calls to the API. This type of bidirectional communication enables client nodes to access their functions and communicate with all available network resources. It defines any given GE's callable operations and is presented also by each GE?s API. The operation of the API for a GE?s controlled set of operations is accomplished with URL strings of URIs and URNs. These call the functions by message passing over a network and utilising a network API server?s other capabilities. Data set values represent returned information and are structured formally with XML or JSON data formats.

C. Communication in a GE System The communication interface provides an almost real time and secure information exchange methodology between GE components, utilised by a system of multiple device types or things but it is constrained to operate in accordance with the governance of a network API server. In this way the GEs, their operations and participating client nodes are secured, runtime     API pluggable and are ad hoc in a network connection context i.e. assuming the network media does not break down then clients, possibly GEs, are perfectly able to join the network independently, call functions securely for services or tasks provided by any other GE present in the network and return formatted data set results over the networking medium. In this context the operations provided by GEs are able to be combined with networked function calls and give the ability for interaction between the GE types and their domains.

A networked API is the interface implementation of a GE for other entities to call commands for operations of a GE to perform. All GEs publish or promote their set of functions publicly as definitions, of web services, for their API?s and these services are networked to identifiable nodes available in the local network but this is implemented by using the abilities of the network API server i.e. proxy. Each node must interpret all of their received messages into actions that they can feasibly perform. During interpretation, interpreters filter away non-relevant messages. The interpreter must also decode data messages into received function calls or handle result sets and identify messages from their server. This happens at each node of course. A dispatcher is required for encoding function calls or return set data and being able to address new API URL calls to server side GEs via proxy operations. The interpreter and dispatcher are performing network node service roles in preparation for consistent communication over a RESTful, HTTP and asynchronous communicative implementation. The nodes marshal all data they send and receive.

D. Functional Components and Behaviour of GE Systems To implement a system from GEs, the API functions provided by selected GE?s are to be called over RESTful HTTP or HTTPS to permit the interoperability between the selected GEs. This is controlled and secured to some extent. The GE instances are instructed to perform functions for building result data sets required by other nodes (Peers) in an ad hoc network of resources that also includes a cloud infrastructure.

Each peer?s model is defined by a collection of the following high level components comprising of an HTTP/S, RESTful and asynchronous interface that is combined to interoperate with an interpreter, a set of functions, a dispatcher and a remote or network API server. The server is required also for supplying GE APIs, based on FI-WARE open specifications, as web services to provision an API rich service on demand that is made available for all authenticated and connected GE network nodes to utilise.

Further and in addition to the concrete functional components then the behavioural requirement of each peer is defined as being able to use its system operational parts to combine and work together for performing an overall procedure that the GE has been designed to implement from an open specification for it. Their designed operation is supported by a concrete set of functions required for controlling and altering GE behaviour.

These functions may be interacted with by the GE API?s and access to any GE?s functions is provisioned to other nodes in  the network by the standalone proxy server operating as a proxy API interface for them. For example, a GE can be comprised of the component parts for a heart sensor system i.e. sensor and a mobile phone. These are the base technical components for a heart sensor GE. The task behaviours are defined as the relaying and display of meaningful information to and from a patient with a sensor and a mobile operator. The API provides access to the base functions on the GE, so that it can be interacted with by another GE. The generic interfacing ability, described beforehand, is provided on top of the components, required for performing the heart sensor system processes. The GE?s network server API?s are provided, for each GE and are held as records at the server, to control the heart sensor system?s operational functionality. This is called during operation programmatically by authenticated node clients or by the operational components constituting the model for any given GE.

So in retrospect the heart sensor GE requires hardware and software component parts for performing the heart monitoring task plus also an HTTPS, RESTful and asynchronous interface that is combined as a software program solution to be defined as consisting of an interpreter, the set of heart sensor GE API control functions and a dispatcher. The network API server in this example context is providing an Input\Output (push\pull) facility for network client node control and command of the heart sensor GE sub components. The client nodes join the API server?s network as peers in a spontaneous ad hoc fashion for the purpose of performing a required computational task.

Clients or SEs are interoperable and are the participating networked components that consistently perform network transmissions to each other and GEs. It is this communication infrastructure that is the foundational technology used to facilitate API services from the GE components.



V. A GENERIC ENABLER SPECIFICATION More generally, each GE described in this section is specified as required to be composed from the following parts:  1) Operational components (parts) 2) Functions for operational part control 3) Uniform I/O for message passing 4) XML DOM or JSON Interpreters and Dispatchers 5) API for identifying functions as reusable resources 6) Structured data formats, XML or JSON  Additionally there is a requirement for a network API server to operate as a proxy API manager and that is used by each GE component so long as they are present and available on the server?s network. The operational components provide the operating mechanism for the GE?s behavioural design. The functions control each GE?s behaviour. The I/O is uniform because every generic enabler must use the same I/O protocol of HTTP/S and it is to be applicable to every GE instance type because then GEs can communicate with the network API server proxy which is required for providing the main service of reflection of the network?s state and activity to other GEs.

The GEs are constructed in software for the purpose of operating their multimodal protocols and bespoke API interfacing systems for whatever purpose they are required to be constructed for. Therefore RESTful, HTTPS, asynchronous XML interpreters and dispatchers are deployed somewhere on the technology platform?s infrastructure i.e. from the example before then the sensor and mobile phone combination require interpreters and dispatchers because they are required to be able to communicate information effectively between the participating components.

A. Network API Server The API permits network node clients to call the functions of the GE?s components as services from the server, using the uniform I/O mechanism but this network API is also adaptive to each specific GE?s context i.e. there is possible interaction with lower level hardware drivers and function calls upon initiating differing protocols [7] pertinent to each hardware component and these are used also for defining the mechanical or electrical operation of a GE?s associated hardware components. Moreover a network API server must reflect to each network node client the ability for API function calls as on demand services for the ad hoc collection of GE?s and SE?s to communicate control over other relevant GE peers in the network.

The network API server can also map a model of the GE components and their specific functionalities to provide GE APIs as services from the server. Furthermore the information exchange of data assets between GEs and client nodes before and after interaction with a network API server requires structured data formats using XML, JSON or other specific data encoding/decoding operations for each GE instance type (GEI) e.g. I?C. Essentially the interoperability between GEs is accomplished with networked APIs and push\pull data exchanges specified as being identified or defined by URLs, XML, JSON or similar message data formats. The result of the operation of the system for GE?s gives a live information (data and meta-data) driven API between GE components that relies upon a proxy network API server for handling API requests.

The API is provisioned to GEs and other client nodes. It is called for providing services of GE?s over a network. In this way the GE?s are able to be plugged into the FI-WARE platform as long as there is no problem with the underlying network or the runtime operation of a proxy API server associated to any given GE.

Generic enablers are general, interoperable and have a selective communication mechanism useful for facilitating a service to any other peer in the network. The networked API server?s implementation focuses on defining the ?HTTP/S connected menu interfaces", see fig 1, that each GE is providing access to for exchanging control function requests and data or meta-data within an ad hoc network of peers. The FI-WARE specifications define HTTP/S connected menu interfaces and supply prototypes for functions that any GE can specifically perform and return data from. This enables service on demand operations to FI-WARE GEs in an ad hoc network  that can be used for querying states, initiating task processes and requesting returned data set results in a specific data format. The technology overall, enables the GEs to have the required property of interoperability. GET, POST and the other request methods from HTTP are useable for switching between modes of interpreting and dispatching respectively.

Also there is put into use theoretical paths that define the network API server?s URLs/URIs/URNs and they are useful also for representing grouped resources within one string item, at a programming language implementation level; in preparation for network transmissions. For example the API for GE and proxy server interfacing is specified as a path construction model required for identifying and calling functions that the ad hoc collection of GEs can provide on their operations by proxy and this is made possible by the available networking medium.

Figure 1. Networked API NGSI-9 Example  POST /servers/{server_id}/action Gets the output from the console log for a server.

The path structure enables the grouping of resources and is also a file system model representation. In this context we have a function system instead of a file system and it can be queried with HTTP by any client node. The technique can be modelled safely by each node?s implementation using XML DOM encoding/decoding and communication components to interpret incoming and dispatch outgoing URL requests. This modelling is necessary for remotely controlling desired actions and dispatching further communicated information between client nodes and GEs, while at the same time utilising a server proxy pattern as a formalism. Another advantage is that a safely constructed state machine model can be built and applied to operating the traversal of the path structure by each individual client node?s implementation. This system design     can be used for implementing interpretation and dispatching operations for all GE operational tasks. It is accomplished by alternating between incoming HTTP URL path constructed request methods such as GETs and POSTs, as required, during runtime operation and the resulting continuous push and pull of data interaction that is occurring between the relevant operational entities and the networked API server. The result from the investigative research presented in this paper is a robust and trustworthy specification for a design of a GE. The next section describes the properties that all generic enabler implementations must follow in order so that any attempted implementation for a new GE may actually be considered as a correct generic enabler solution provided as software.



VI. PROPERTIES OF GENERIC ENABLERS All implementations are possible to be defined as valid instances of a generic enabler created in software if they have been constructed from established and observed properties for grouping the technology components of a GE?s concrete implementation as a software system. Therefore software GE implementations must conform to the following properties and associated software engineering technologies by clearly demonstrating these elements from inspection of a GE?s concrete design and implementation.

Please note that the listing is not fully exhaustive for all the properties due to there being the existence of other potential but yet unobserved areas that have not been covered or presented by this paper. Also neither are the exposed technologies fully conclusive for the same stated reason.

Property Technology Addressing IP address  Port Number Recognition Control Syntax  Parser Interpreter  Semantic Rules Multimodal APIs  Protocols Drivers  Structured Data XML JSON I?C  Formal Operation State Machine Operation Dispatcher  DOM Ad hoc Network Communication HTTP/S  Request Methods Asynchronous  Client/Server Modes URL Addressing of, Server, URIs, URNs  Modular Design Object Oriented Architecture Methods and Functions  Listeners Callbacks  Behavioural Multithreaded Parallel  Sequential/Imperative Result Combining  Result Verification Transformative  Bi Directional Comms Security Channel Encryption  Message Encryption Authentication  HCI GUI Hardware Interaction  Multimodal User Interfaces Human Actors (Doctors, Patients,  Engineers ..) Interoperability Networked API Server  Configuration Parameters Legacy System Integrators  RPC Table 1 Generic Enabler Software Implementation Properties.



VII. CONCLUSION This paper described an overview of what a generic enabler is and demonstrated that FI-WARE supplies only generic enabler building blocks for creating applications to standards. The problem was shown that the generic enablers were missing a precise definition of anything concrete to understand in terms of their construction. All that has been presented thus far in any documentation is the notion that a generic enabler performs some behavioural operation in relation to complex applications being created with the FI-WARE platform coupled to operate the combining of GEs through using FI- LAB. The presented work next described the relationship between generic enablers and macroscopes for being able to show that generic enablers can in theory be grouped also by macroscope notions for the strict purpose of controlling sets of generic enablers at a higher level representational design of combination and control. This is useful for understanding the different views provided by the technology used for building applications from generic enablers e.g. FI-WARE.

To remove the hurdle for understanding the generic enablers as something other than just simple component block notions then a description for a more concrete and valid software engineering specification of generic enablers was investigated by following a top down analysis activity into the system subject. This yielded insight for identifying the constituent components that all generic enabler implementations should adhere to. The generic enabler systems were identified to be definable as object oriented systems built from Operational components (parts), Functions for operational part control, Uniform I/O for message passing, XML DOM or JSON Interpreters and Dispatchers, API for identifying and using functions as reusable resources, Structured data formats including XML or JSON and a networked API Server proxy.

Finally the properties and technologies for generic enabler systems were presented in table 1 and this is also a checklist for software engineers to consider when constructing their generic enabler building blocks in software. The point in following these properties and component combinations is that newly developed GEs or other modular architectures can have their specifications and implementations included within FI-     WARE or similar platforms as new GE?s or modules to reuse as generic building block components provisioned for the purpose of constructing future internet applications simply.

