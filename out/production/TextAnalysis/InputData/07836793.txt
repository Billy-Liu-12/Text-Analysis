A Pattern Growth-based Approach for Mining Spatiotemporal Co-occurrence Patterns

Abstract?Spatiotemporal co-occurrence pattern (STCOP) mining refers to discovering the subsets of event types whose instances frequently co-locate in a spatial context and coincide in a temporal context. STCOP mining is the spatiotemporal ex- tension to Frequent Itemset Mining (FIM). Unlike the classical FIM approaches, which are applied on transactional databases, STCOP mining is applied on the spatiotemporal datasets comprised of event instances which are represented by evolving region trajectories. Previous STCOP mining algorithms are Apriori-based, where the number of candidate patterns can grow exponentially with the number of event types. In this work, we present a pattern growth-based approach for mining STCOPs, which allows us to discover STCOPs without compu- tationally expensive candidate generation processes. We exper- imented our algorithm with four real-life solar event datasets and compared its performance with the earlier Apriori-based approach.

1. Introduction  Advancements in data acquisition and sensing technolo- gies results in an unprecedented growth in spatiotemporal data in recent years [1]. Spatiotemporal trajectory data ob- tained from GPS feeds is one of the most common examples of spatiotemporal data. The spatial extent of a trajectory is represented by points or regions [2]. Region trajectories are useful for representing moving objects, where size, shape and location of the object evolve in time. As region tra- jectories are formed by complex polygon-based geometries, the storage and processing of such data are both CPU and memory intensive.

We see examples of spatiotemporally overlapping phe- nomena in scientific spatiotemporal trajectory datasets. One example is solar events. STCOPs occur frequently among various solar events. Fig. 1 is an image taken by NASA?s So- lar Dynamics Observatory (SDO) that shows spatiotempo- rally co-occurring event instances of seven solar events - Ac- tive Region (AR), Coronal Hole (CH), Emerging Flux (EF), Filament (FI), Flare (FL), Sigmoid (SG) and Sunspot (SS).

STCOPs help solar physicists in understanding the relation- ship among different solar events and learning about their influence on earth environment. Identification of STCOPs on the Sun leads to better modeling and forecasting of some  Figure 1: Image of spatiotemporally co-occurring solar event in- stances with their corresponding bounding boxes (timestamp is printed on top of the image) [3].

radiation impacting events such as coronal mass ejection and solar flares which can have detrimental effects on space and air travels, power grids and communication devices such as GPS.

Previous STCOP mining algorithms used Apriori-based approaches for candidate generation and pruning. But, simi- lar to the classical Apriori-based FIM [4], the Apriori-based approach of STCOP mining may generate an exponential number of candidate patterns as the number of event types increases. Because of the extended polygon-based geometric representations, calculation of interestingness measures for a large set of candidates is computationally very expensive.

We present an algorithm that efficiently discovers STCOPs without iterative candidate generation. Given a spatiotemporal transaction dataset where each transaction represents spatiotemporal co-occurrence of two or more region trajectories, our algorithm uses the classical frequent pattern growth algorithm, introduced in [5], for generating a set of proto-patterns. Then, we filter and refine the set of proto-patterns using significance and prevalence measures to get the actual STCOPs. The issues that are beyond the scope of this paper are the determination of significance and prevalence threshold values, spatiotemporal indexing   DOI 10.1109/ICDMW.2016.93     techniques and generation of association rules from the calculated STCOPs.

The rest of the paper is organized as follows. Section 2 discusses the related work. In Section 3, we explain some basic concepts of STCOP mining. We present our pattern growth-based STCOP mining algorithm in Section 4. We present an illustrative example of our algorithm in Section 5. In Section 6, the experimental results on the comparison of Apriori-based and pattern growth-based approach are presented. Finally, we discuss our future work and conclude the paper in Section 7.

2. Related Work  There are several notable algorithms that motivated the design of STCOP mining, such as spatial co-location pattern mining and mixed-drove co-occurrence pattern mining.

Shekhar et al. presented a co-location pattern discovery procedure that finds the subsets of events within a user defined spatial neighborhood [6]. This is an Apriori-based method for finding frequent spatial co-locations. They also proposed a novel interest measure participation index for pruning infrequent candidate patterns. Their interest measure participation index was later used in most of the spatiotem- poral pattern mining algorithms for candidate pruning. Yoo et al. extended Shekhar?s COLLOCATION-MINER by incor- porating a joinless approach that uses an instance-lookup scheme instead of spatial join operation for identifying co- location instances [7]. Instead of focussing on discovering co-location patterns with a fixed interest measure, Celik et al. proposed an algorithm for discovering zonal co-location patterns with dynamic interest measure parameter [8]. A density-based approach for mining spatial co-locations is introduced by Xiao et al. [9] that divides the spatial ob- jects into partitions and identifies co-location instances from denser partitions first. A framework using the FP-growth algorithm for finding N most prevalent spatial co-location patterns is proposed by Yoo et al. [10], where N is the user-specified threshold on the desired number of results in- stead of a specified interest measure. While aforementioned algorithms considered the spatial extent of data objects as points, Xiong et al. presented an Apriori-based algorithm [11] that finds the spatial co-locations in datasets with extended spatial representation. They introduced a buffer- based model for defining the neighborhood of the objects with extended spatial representation.

The transition from the mining of spatial co-location patterns to the mining of spatiotemporal co-occurrence pat- terns was made by Celik et al. They introduced mixed-drove spatiotemporal co-occurrence patterns (MDCOP) [12], that are subsets of two or more event types whose instances are located in spatial and temporal proximity. This algorithm is an extension of spatial co-location mining algorithm with time information included. They also presented an algorithm for mining top-K% MDCOPs that does not require user- specified spatial and temporal prevalence threshold [13].

There are several variants of spatiotemporal co-occurrence patterns present in the literature such as SECOPs [14],  PECOPs [15], PACOPs [16] and SPCOZs [17]. Sustained emerging spatiotemporal co-occurrence patterns (SECOP) represent subsets of event types that are increasingly located together in space and time [14]. The subsets of event types that spatiotemporally co-occur in a periodic manner are rep- resented by periodic spatiotemporal co-occurrence patterns (PECOP) [15]. When the objects of the event types exist partially in their lifetime in the database, the subsets of those event types are represented by partial spatiotemporal co-occurrence patterns (PACOP) [16]. Spread patterns of spatiotemporal co-occurrences over zones (SPCOZs) repre- sent the spread structures over the zones for the subsets of event types. Similar to the COLLOCATION-MINER of [6], the algorithms for mining MDCOPs, SECOPs, PECOPs, PACOPs and SPCOZs work through Apriori-based candi- date generation process. All of them consider the spatial extent of each object as points and infer spatial co-location based on spatial close-by relationship.

Instead of spatial and temporal close-by relationships, Pillai et al. presented an algorithm STCOP-MINER that finds spatiotemporal co-occurrences based on the spatial and temporal intersection [18]. Another novelty of their work is, STCOP-MINER handles event instances with evolving polygon-based representations instead of points. This work is further improved by incorporating spatiotemporal trajec- tory indexing techniques [19]. Aydin et al. applied two well known spatiotemporal indexing techniques: Scalable and Ef- ficient Trajectory Indexing [20] and Chebyshev polynomial indexing [21]. Due to the computationally expensive nature of spatiotemporal operations in centralized database set- ting, a cloud-based distributed STCOP mining process was presented in [22]. A method for finding top-K% STCOPs without using prevalence threshold is introduced in [23].

Among other notable works on spatiotemporal pattern min- ing, there are algorithms such as spatiotemporal sequential pattern mining [24], spatiotemporal mobility pattern mining [25], and cascading spatiotemporal pattern mining [26].

The common characteristic of all aforementioned al- gorithms is, they work through Apriori-based candidate generation process. The reasons for choosing Apriori-based approaches are the simplicity of algorithm design and the challenges in transactionalizing spatiotemporal event types.

In this work, we have defined spatiotemporal transactions based on the spatiotemporal overlaps of the event instances.

Taking the set of spatiotemporal transactions as input, our algorithm finds the STCOPs without Apriori-based candi- date pattern generation.

3. Basic Concepts  In this section, we discuss some key terms of mining STCOPs, introduced in [18], and explain some new terms for our pattern growth-based approach.

The input of STCOP mining algorithm is a set of event instances, I = {Ins1, Ins2, ..., Insn}. Each instance has a unique instance id, an event type label and a spatiotemporal region trajectory (i.e., a set of timestamp-geometry pairs).

An event type is denoted as ei, and the set of all event types     is denoted by E = {e1, e2, ..., em}. An instance Insi, which belongs to event type ej , is denoted by ?Insi : ej?, where 1 ? i ? n and 1 ? j ? m. The set of all instances of an event type ei is denoted as Iei .

An STCOP is a subset of E, whose instances frequently co-occur in spatial and temporal context. A pattern is de- noted as P , where P ? E. The number of event types in a pattern is called cardinality. By definition [18], the cardinality of a STCOP is greater than 1. Given a k- cardinality STCOP P = {e1, e2, ..., ek}, a pattern instance, denoted by pat ins = {Ins1, Ins2, ..., Insk}, is a set of unique instances of all k event types of P , such that all k instances spatiotemporally co-occur.

Two types of measures are used in STCOP mining.

They are significance measure and prevalence measure. Co- occurrence coefficient (cce) is the significance measure, which is defined for the pattern instances and used to assess the spatiotemporal overlapping significance of k instances of a size-k pattern instance. Prevalence measure is defined for patterns and used for evaluating the prevalence of a pattern using the participation of instances of different event types.

Jaccard (J) measure is used for determining the signif- icance of spatiotemporal overlap in a pattern instance. J is calculated as a ratio of spatiotemporal intersection volume to the spatiotemporal union volume. Given a k-cardinality pattern instance pat ins = {Ins1, Ins2, ..., Insk}, J is calculated as follows.

J(pat ins) = V (Ins1 ? Ins2 ? ... ? Insk) V (Ins1 ? Ins2 ? ... ? Insk) (1)  Here, V is the three-dimensional (i.e., spatiotemporal) volume function, where ? represents the intersection and ? represents the union of the spatiotemporal instances.

Participation index (pi) measure, introduced in [6] is used for determining the prevalence of a STCOP. It is the minimum of the participation ratios of all the participating event types of that pattern. Given a k-cardinality pattern, P = {e1, e2, ..., ek}, pi is calculated as follows.

pi(P ) = min 1?i?k  pr(ei, P ) (2)  Let |Pei | denotes the number of unique instances of event type ei participating in the pattern instances of P and |Iei | denotes the total number of instances of event type ei, the participation ratio of event type ei in pattern P is,  pr(ei, P ) = |Pei | |Iei |  (3)  There are threshold values for both significance and prevalence measures. They are denoted as cceth and pith.

A pattern can be considered as prevalent, when the co- occurrence coefficients of all of its pattern instances are greater than or equal to cceth and the participation index of the pattern is greater than or equal to pith.

Figure 2: A spatiotemporal evolving region trajectory dataset  TABLE 1: Spatiotemporal transaction dataset  TID Co-occurring instance set 1 Ins4 : e2, Ins6 : e3 2 Ins4 : e2, Ins6 : e3 3 Ins2 : e1, Ins7 : e3, Ins8 : e4 4 Ins3 : e1, Ins5 : e2 5 Ins5 : e2, Ins8 : e4  3.1. Spatiotemporal Transactions  Each spatiotemporal co-occurrence is recorded as a transaction of a set of instances of different event types. In the spatiotemporal transaction dataset D, each transaction T is a non-empty set of event instances where each instance belongs to unique event type and they intersect both in spatial and temporal context. If in a valid timestamp, two or more instances of different event types have a spatial intersection in their polygon-based geometries, that makes a spatiotemporal transaction which contains the co-occurring instance ids with their corresponding event types. In a transaction, the ?instance id : event type? pairs are sorted in the order of event types.

In Fig. 2, we show an example of a spatiotemporal dataset I with evolving region trajectories. This dataset has four event types, i.e., E = {e1, e2, e3, e4}. The event type e1 has three instances (Ins1, Ins2 and Ins3), the event type e2 has two instances (Ins4 and Ins5), the event type e3 has two instances (Ins6 and Ins7) and the event type e4 has one instance (Ins8). From the figure, it is visible that in some time instants such as t2 and t6 there are spatial overlapping of geometries of two or more instances. Spatial overlapping of the instance geometries in different time instants results in a number of spatiotemporal transactions, where each transaction has a transaction identifier TID and a set representing co-occurring instances, where each element is a ?instance id : event type? pair. In Table 1, we show the five resultant transactions that represent spatiotemporal co-occurrences of the instances of the dataset of Fig. 2.

3.2. Proto-Patterns  Proto-patterns are subsets of event types, where the par- ticipating event types have at least one pattern instance. To reduce the search space of all possible patterns, we calculate the proto-patterns by removing the patterns in which event types never co-occur. The computation of the proto-patterns is less expensive, because they are calculated without the computation of disk-based and geometric operation-rich significance and prevalence measures. Reducing the search space by using proto-patterns makes a qualitative difference with Apriori-based STCOP mining approaches, because in those approaches all possible candidate patterns may be required to be processed.

4. Pattern Growth-based Approach for Mining STCOPs  In this section, we discuss our PG-STCOP-MINER algo- rithm. The inputs of the algorithm are: a set of event types E and a set of event instances I where each instance is labeled by an event type and has a spatiotemporal region trajec- tory, a set of spatiotemporal transactions D, user defined co-occurrence coefficient threshold cceth and participation index threshold pith. The output of the algorithm is a set of STCOPs that satisfy cceth and pith.

Algorithm 1 depicts the outline of pattern growth-based STCOP mining process. The three procedures called by Al- gorithm 1 are GENPROTOPATTERNS, FILTER and REFINE.

These procedures are used for generating the proto-patterns, filtering the set of proto-patterns, and refining the set of filtered proto-patterns to produce the STCOPs.

Algorithm 1 PG-STCOP-MINER Algorithm Input: A spatiotemporal dataset with instances of dif- ferent event types, a set of spatiotemporal transactions, co-occurrence coefficient threshold and participation index threshold.

Output: A set of STCOPs.

1: procedure PGSTCOPMINER(E, I,D, cceth, pith) 2: PP ? GENPROTOPATTERNS(D) 3: FPP ? FILTER(PP,D, pith) 4: STCOP ? REFINE(FPP, I,D, cceth, pith) 5: return STCOP 6: end procedure  The procedure for the generation of the proto-patterns is shown in Algorithm 2. For each spatiotemporal transaction in D, the function GETEVENTTYPES returns the set of participating event types of that transaction (line 4). The collection of eventset-based transactions (ET ) is passed as an input to the FP-growth algorithm [5] with minimum support as 1 (line 6). FP-growth algorithm creates a FP tree from the eventset-based transactions and extracts frequent patterns from the FP-tree. Finally, after executing the func- tion REMOVESIZE1EVENTSETS size-k proto-patterns are returned, where k > 1.

Algorithm 2 Proto-patterns Generation Procedure 1: procedure GENPROTOPATTERNS(D) 2: ET ? ? 3: for all transaction T ? D do 4: ET ? ET ? GETEVENTTYPES(T ).

5: end for 6: PP ? FPGROWTH(ET, 1) 7: PP ? REMOVESIZE1EVENTSETS(PP ) 8: return PP 9: end procedure  Algorithm 3 shows the proto-patterns filtering proce- dure. This procedure filters the set of proto-patterns by calculating the approximate participation index (piapp) of each proto-pattern and removing the proto-patterns whose piapp is less than pith. This procedure also makes a global map that stores key (proto-pattern) and value (pattern in- stance set) pairs. For each proto-pattern, the set of all pattern instances is found by scanning the spatiotempo- ral transaction dataset (lines 4 - 9). If a transaction con- tains the eventset of the proto-pattern, then the function GETINSTANCEIDS returns the corresponding event instance ids to form a pattern instance. In the example spatiotem- poral transaction dataset of Table 1, for the proto-pattern {e1, e4}, there is a transaction TID : 3 (whose content is {Ins2 : e1, Ins7 : e3, Ins8 : e4}) that contains both e1 and e4. The function GETINSTANCEIDS returns Ins2 and Ins8 to form a pattern instance {Ins2, Ins8} for the proto- pattern {e1, e4}. When the set of all pattern instances is ready, piapp is calculated on that pattern instance set by CALCULATEPI function (line 10). If the calculated piapp value is less than the given pith, then that proto-pattern is deleted (line 12). Otherwise, the pattern instance set of that proto-pattern is stored in the map by PUTINTOMAP function, so that the proto-pattern maps the pattern instance set (line 14). One important thing to notice is that we do not remove any pattern instance from the pattern instance set by cce thresholding. In other words, this procedure considers the cceth to be 0 for each pattern instance. As there exist pattern instances that may not eventually pass cce threshold, calculated piapp is approximate. Through piapp, FILTER procedure removes unprevalent proto-patterns with- out computationally expensive cce calculation and reduces the search space of REFINE procedure.

The procedure of Algorithm 4 returns the refined STCOPs by cce and pi calculation on the filtered set of proto-patterns. At the beginning of this procedure, the func- tion SORTBYCARDINALITY sorts the set of proto-patterns (PP ) by their cardinality. The purpose of this sorting is to leverage the Downward Closure Property [27], which states that all the subpatterns of a frequent pattern are also frequent. Therefore, the size-2 STCOPs are calculated at first, so that size-(k) STCOPs can be used in the calculation of size-(k+1) STCOPs. Before calculating computationally expensive significance and prevalence measures of a size-k proto-pattern, where k > 2, it is tested whether all of its size-(k ? 1) subpatterns are frequent. This is done by two     Algorithm 3 Proto-patterns Filtering Procedure 1: procedure FILTER(PP,D, pith) 2: for all pattern pat ? PP do 3: pat ins set? ? 4: for all transaction T ? D do 5: if pat ? GETEVENTTYPES(T ) then 6: pat ins? GETINSTANCEIDS(T, pat) 7: pat ins set? pat ins set ? pat ins 8: end if 9: end for  10: piapp ? CALCULATEPI(pat ins set) 11: if piapp < pith then 12: PP ? {PP ? pat} 13: else 14: PUTINTOMAP(pat, pat ins set) 15: end if 16: end for 17: return PP 18: end procedure  functions - GETSUBPATTERNS and ALLFREQUENT. GET- SUBPATTERNS function (line 6) returns all possible size- (k ? 1) subpatterns of a given size-k pattern. For example, if the input to this functions is a size-3 pattern {e1, e2, e3}, then it returns all three size-2 subpatterns {e1, e2}, {e2, e3} and {e1, e3}. The function ALLFREQUENT tests whether all of the subpatterns returned by GETSUBPATTERNS function are in the set of proto-patterns (line 7). If any of these subpatterns is not found in the set of proto-patterns, then the current pattern is removed from the set of proto-patterns and the loop continues with the next proto-pattern.

For each proto-pattern in PP , the procedure retrieves its pattern instance set from the map by GETFROMMAP function (line 12). Then for each pattern instance, CALCU- LATEJACCARD function performs the J calculation using Equation 1. For each event instance of the pattern instance, geometry at each time instant is collected and spatial inter- section and union operations are performed. If the J value of the pattern instance is less than cceth, that pattern instance is removed. After the set of pattern instances is updated by J thresholding, the pi of the proto-pattern is calculated and the proto-pattern is kept, or deleted depending on whether its pi value passes pith.

5. An Illustrative Example  Consider the spatiotemporal evolving region trajectory dataset I of Fig. 2 and spatiotemporal transaction dataset D of Table 1. Given I and D, the steps of our pattern growth- based STCOP mining algorithm is explained in Fig. 3.

In order to find the STCOPs in pattern growth-based approach the first step is to determine the proto-patterns.

Procedure GENPROTOPATTERNS of Algorithm 2 gets D as input. It scans through all the transactions in D and at each transaction (which contains both the event type and instance id information) only the event types are collected.

Thus, the eventset-based transaction dataset (ET ) is formed  Algorithm 4 Proto-patterns Refining Procedure 1: procedure REFINE(PP, I,D, cceth, pith) 2: SORTBYCARDINALITY(PP ) 3: for all pattern pat ? PP do 4: k ? CARDINALITY(pat) 5: if k > 2 then 6: S ? GETSUBPATTERNS(pat, k ? 1) 7: if ?ALLFREQUENT(S, PP ) then 8: PP ? {PP ? pat} 9: continue  10: end if 11: end if 12: pat ins set? GETFROMMAP(pat) 13: for all pat ins ? pat ins set do 14: J ? CALCULATEJACCARD(pat ins) 15: if J < cceth then 16: pat ins set? {pat ins set?pat ins} 17: end if 18: end for 19: pi? CALCULATEPI(pat ins set) 20: if pi < pith then 21: PP ? {PP ? pat} 22: end if 23: end for 24: return PP 25: end procedure  (Fig. 3(a)). Then classical FP-growth algorithm is executed on ET with min sup = 1. Each transaction of ET is mapped into a path of the FP-tree. Each node of the FP- tree denotes an event type with corresponding support count, e.g., event type e2 has support count 4. Frequent patterns can be generated using suffix-based approach [28] by traversing the FP-tree in bottom-up fashion. Frequent patterns ending with e4 are found by retrieving all paths that lead to the nodes denoting e4. After removing size-1 eventsets, we get 7 proto-patterns.

FILTER procedure removes the proto-patterns whose piapp value fails to pass pith (Fig. 3(b)). This procedure finds the pattern instance set of each proto-pattern. For the proto-pattern {e1, e3, e4}, it finds a pattern instance {Ins2, Ins7, Ins8}. When the set of all pattern instances is found, the participation index of that proto-pattern is calcu- lated using Equation 2 and 3. Proto-pattern {e1, e3, e4} has piapp = 1/3. As only one instance Ins2 of e1 participates in the pattern instance set and e1 has total three instances in the dataset, participation ratio (pr) of e1 in proto-pattern {e1, e3, e4} is 1/3. Therefore,  piapp({e1, e3, e4}) = min(pr(e1, {e1, e3, e4}), pr(e3, {e1, e3, e4}), pr(e4, {e1, e3, e4}))  In our example, we used the pith = 0.45. All the proto- patterns having piapp value less than 0.45 is removed. After the FILTER step, there are three proto-patterns {e2, e3}, {e2, e4} and {e3, e4}.

Figure 3: Execution of three procedures of PG-STCOP-MINER on an example spatiotemporal dataset  For each pattern instance of the filtered proto-patterns, REFINE procedure calculates J (Fig. 3(c)). The g() function returns the geometry of an instance, given the instance id and valid timestamp. As Ins4 of e2 and Ins6 of e3 has spatiotemporal co-occurrence in time instants t2 and t5, spatial intersection and union of their geometries at both time instants is calculated and their J value is found from the Equation 1. For showing the effect of J thresholding, we assume that the J values of the pattern instances of the proto-patterns {e2, e3} and {e2, e4} are greater than cceth, while the J value of the pattern instance of {e3, e4} could not exceed cceth. Therefore, the pattern instance set of {e3, e4} becomes empty. Finally, when the participation in- dex is calculated, proto-pattern {e3, e4} is removed. The PG- STCOP-MINER algorithm outputs two STCOPs - {e2, e3} and {e2, e4}.

6. Experimental Evaluation  In this section, we demonstrate our experiments on our PG-STCOP-MINER algorithm. To show the performance gain, we compared our algorithm?s execution time against Apriori-based STCOP-MINER algorithm presented in [18].

We used four real-life solar datasets for the perfor- mance evaluation of PG-STCOP-MINER and Apriori-based STCOP-MINER. We obtained these datasets from the solar data repository Heliophysics Event Knowledgebase (HEK) [29]. These datasets contain six solar event types - Active Region, Coronal Hole, Emerging Flux, Filament, Sigmoid, and Sunspot. The first dataset contains the event instances of those six event types reported for 1-month period from October 2nd, 2013 to November 2nd, 2013 (denoted as S1); the second one covers the instances reported for 3-months period from July 2nd, 2013 to October 2nd, 2013 (denoted as S3); the third one covers the instances reported for 6-months period from January 2nd, 2013 to July 2nd, 2013 (denoted  TABLE 2: Characteristics of the Datasets  Dataset Description Tag  Number of Instances  Number of Geometries  1-month solar data S1 1,152 193,673 3-months solar data S3 3,100 479,881 6-months solar data S6 6,844 921,567  12-months solar data S12 13,212 1,994,010  as S6) and the fourth one covers the instances reported for 12-months period from January 2nd, 2012 to January 2nd, 2013 (denoted as S12). The total number of event instances (i.e., spatiotemporal region trajectories) and the total number of polygon-based geometries in each dataset are shown in Table 2.

For the implementation of both algorithms, we used Java programming language with JTS Topology Suite library for 2D spatial functions. We stored the datasets in PostgreSQL database with spatial extension PostGIS. We conducted all of our experiments in a Linux server (Ubuntu 16.04) with 128 processors (Intel Xeon E7-8860 v3 2.20GHz) and 1 TB memory.

As the interest measure in STCOP mining is participa- tion index, we ran the experiments on all the datasets by varying pith values. We have used four pith values : 0.05, 0.1, 0.15 and 0.2. In all of our experiments, we kept cceth as a constant value of 0.01. We explain the effect of varying pith on Apriori-based and pattern growth-based approach by three performance criteria: execution time, the number of J calculation and the total number of candidate patterns (or proto-patterns). We also explain the execution time behavior of both algorithms as the size of the dataset increases.

6.1. Effect of varying participation index threshold  As there are six event types in our data, the Apriori- based approach has  (  ) = 15 size-2 candidate patterns     Figure 4: Execution times of Apriori-based and Pattern growth- based STCOP mining algorithms on four real datasets  Figure 5: Number of J operations by Apriori-based and Pattern growth-based STCOP mining algorithms on four real datasets  in the first iteration. If the pith is high (e.g., 0.2), the algorithm most likely terminates after the first iteration, i.e., the algorithm handles exactly 15 candidates. On the other hand, when the pith is small (e.g., 0.05), because of the downward closure property, size-3 candidates can be generated, which increases the total number of candidates.

Therefore, the total number of candidates in all Apriori- based experiments is not less than 15 (Fig. 6). The number of candidates in Apriori-based approach effects the number of J calculation (Fig. 5) and execution time (Fig. 4). Due to the nature of the real datasets, all experiments of Apriori-based approach terminate after one or two iterations resulting in 15-19 candidates out of 26 ? 7 = 57 possible patterns. But in the worst case, this approach can possibly be testing all 57 candidate patterns.

While the Apriori-based approach has a lower bound on the number of candidates in all pith values, pattern growth-based approach works with less number of candidate patterns (input proto-patterns in REFINE procedure), when the pith is larger. When the pith is very small, then FILTER procedure can not prune less prevalent patterns. Therefore, the number of proto-patterns in the REFINE step is almost the same as the number of candidates in Apriori-based approach. When the value of pith is large, FILTER procedure removes all proto-patterns that are unable to pass that large pith value. For this reason, the number of proto-patterns in  Figure 6: Number of proto-patterns for which cce calculation is performed by Apriori-based and Pattern growth-based STCOP mining algorithms on four real datasets  Figure 7: Average percentage gain by PG-STCOP-MINER in each dataset in comparison with Apriori-based approach  REFINE procedure reduces (Fig. 6). It also results in reduced number of J calculation (Fig. 5) and reduced execution time (Fig. 4).

6.2. Effect of size of the dataset  PG-STCOP-MINER has better performance in larger datasets such as S3, S6, and S12. When the dataset is small (e.g., S1), Apriori-based approach outperforms pattern growth-based approach. As large datasets contain many spatiotemporal records of event instances by covering a long period of time, the spatiotemporal transaction table also becomes large. Larger transaction table means a large number of pattern instances for each candidate pattern.

As all experiments of Apriori-based approach works with minimum 15 candidate patterns, it takes a long time for each of them to scan through large transaction table by calculating J of each pattern instance. In small datasets, each event type contains a small number of instances. There- fore, approximate participation index of FILTER procedure tends to be larger. It prevents the FILTER procedure to prune less prevalent patterns. For this reason, pattern growth-based approach performs poorly in the small datasets such as S1 (Fig. 4, 5, 6). Fig. 7 shows the average percentage gain (decrease in execution time) in each dataset by PG-STCOP- MINER against the Apriori-based approach. In average, the     execution time of PG-STCOP-MINER is approximately 36% less than its Apriori-based counterpart in datasets S3, S6, and S12. But in S1, the Apriori-based approach has less execution time. Considering the execution times of all exper- iments on all datasets, PG-STCOP-MINER achieves 27.12% average speedup.

7. Conclusion  In this work, we presented a pattern growth-based al- gorithm for mining STCOPs from spatiotemporal evolving region trajectory dataset. Instead of Apriori-based candidate pattern generation, we used FP-growth algorithm on a spa- tiotemporal transaction dataset to generate a set of proto- patterns. Then, we filter and refine the set of proto-patterns to find the STCOPs.

We have evaluated our algorithm and compared its per- formance with Apriori-based STCOP mining approach using four real-life solar event datasets. Our experiments show that the pattern growth-based approach has better performance in larger datasets.

For the future work, we plan to investigate the effect of spatiotemporal region trajectory indexing [19] in our algorithm. In addition to that, we plan to use less expensive significance measures such as J? [22] instead of J to ac- celerate co-occurrence co-efficient calculation in our pattern growth-based STCOP mining approach.

