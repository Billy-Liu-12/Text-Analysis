2332-7790 (c) 2016 IEEE. Personal use is permitted, but republication/redistribution requires IEEE permission. See http://www.ieee.org/publications_standards/publications/rights/index.html for more information.

Abstract?Today, cloud storage becomes one of the critical services, because users can easily modify and share data with others in cloud. However, the integrity of shared cloud data is vul- nerable to inevitable hardware faults, software failures or human errors. To ensure the integrity of the shared data, some schemes have been designed to allow public verifiers (i.e., third party auditors) to efficiently audit data integrity without retrieving the entire users? data from cloud. Unfortunately, public auditing on the integrity of shared data may reveal data owners? sensitive information to the third party auditor. In this paper, we propose a new privacy-aware public auditing mechanism for shared cloud data by constructing a homomorphic verifiable group signature.

Unlike the existing solutions, our scheme requires at least t group managers to recover a trace key cooperatively, which eliminates the abuse of single-authority power and provides non- frameability. Moreover, our scheme ensures that group users can trace data changes through designated binary tree; and can recover the latest correct data block when the current data block is damaged. In addition, the formal security analysis and experimental results indicate that our scheme is provably secure and efficient.

Index Terms?Data Integrity; Homomorphic Verifiable; Non- frameability; Provable Security.



I. INTRODUCTION  DUE to the increasing number of applications of shareddata, such as iCloud, Google Docs, and so on, users can upload their data to a cloud and share it with other peers as a group. Unfortunately, since cloud servers are vulnerable to inevitable hardware faults, software failures or human errors, data stored in the cloud may be spoiled or lost [1]. In the worst cases, a cloud owner may even conceal data error accidents in order to preserve its reputation or avoid profit losses [2],[3]. In addition, users who lose direct control over their data are not sure whether their cloud-stored data is intact or not. Therefore, integrity verification for the shared data in the cloud is an important, yet timely issue for a large number of cloud users.

To ensure the integrity of data stored in cloud servers, a number of mechanisms based on various techniques have been  This work is supported by National Science Foundation of Chi- na (61572255), Natural Science Foundation of Jiangsu Province, China (BK20141404 and BK20150787), and Six Talent Peaks Project of Jiangsu Province, China (XYDXXJS-032).

Anmin Fu and Chanying Huang are with the School of Computer Science and Engineering, Nanjing University of Science and Technology, Nanjing, PR China.

Shui Yu is with the School of Information Technology, Deakin University, Melbourne, Australia.

Yuqing Zhang is with the National Computer Network Intrusion Protection Center, UCAS, Beijing, PR China.

Huaqun Wang is with the Jiangsu Key Laboratory of Big Data Security & Intelligent Processing, School of Computer Science, Nangjing University of Posts and Telecommunications, Nanjing, PR China.

proposed. In particular, in order to reduce the burden on users, a trusted third-party auditor (TPA) is engaged to conduct the verification, which is called public auditing [4]. However, the TPA may have unnecessary access to private information dur- ing the auditing process [5]. Therefore, researchers proposed some new schemes to protect privacy, including data privacy [6], and identity privacy [7]-[9]. To be specific, the TPA cannot learn each block that is signed by a particular user in the group by constructing homomorphic authenticable ring signatures [7] or computing tags based on common group private key [8]. However, since both methods concern about unconditional privacy, the real identity of the signer can no longer be traced.

A later development is the homomorphic authenticable group signature scheme based on group signatures [9], which is designed to protect privacy. On one hand, the identity of each signer is anonymous; and on the other hand, the group manager can trace a signer?s real identity after a dispute. Unfortunately, in all existing public auditing schemes, the tracing process is accomplished by a single entity. As a result, that entity has the privilege of tracing, which may lead to abuse of single- authority power. Therefore, an innocent user may be framed or a malicious user may be harbored.

Meanwhile, to support data dynamics, the data structure based on index hash table [7]-[11] or Merkle Hash Tree (MHT) has been utilized [12], [15]. However, this kind of data structure merely records the newest data block with the corresponding signature, which prevents users from tracing the changes of the data blocks. When the current data has been corrupted, users cannot recover the old data from the records.

Therefore, the problem of data traceability and recoverability also should be considered.

Moreover, a necessary authentication process is missing between the auditor and the cloud in most existing public auditing schemes, hence anyone can challenge the cloud for the auditing proofs. This problem will trigger network conges- tion and unnecessary waste of cloud resources. Although Liu et al. [12] designed an authorized public auditing scheme to solve the problem, it is only suitable for a single client, and cannot be applied to group-shared data. Since the malicious or pretended auditors/users might constantly request cloud access for the auditing proof by utilizing TPA, unauthorized auditing is another important issue that should be addressed in integrity verification for shared cloud data.

At present, all the existing public auditing schemes only consider a single group manager when applied to shared data with group users. However, in real-world applications, there might be multiple managers in a group.For instance, the shared data of a project team is created by multiple managers together,    2332-7790 (c) 2016 IEEE. Personal use is permitted, but republication/redistribution requires IEEE permission. See http://www.ieee.org/publications_standards/publications/rights/index.html for more information.

This article has been accepted for publication in a future issue of this journal, but has not been fully edited. Content may change prior to final publication. Citation information: DOI 10.1109/TBDATA.2017.2701347, IEEE Transactions on Big Data   whats more, any of them can maintain the shared data. Another important practical problem is that the group users should be able to dynamically enroll and revoke the group, which will be managed by the group managers. And significantly, when tracing the real identity of the signer, a specified number of managers can work together, which ensures the fairness of the tracing process.

In this paper, we propose a new privacy-aware public auditing mechanism, called NPP, for the shared cloud data with multiple group managers. Our contributions can be sum- marized as follows.

1) We establish a model for data (in a group) shared with multiple group managers, and propose a new privacy- preservation public auditing scheme for multiple group man- agers in shared cloud storage. Our proposed scheme can not only provide multi-levels privacy-preservation abilities (including identity privacy, traceability and non-frameability), but also can well support group user revocation.

2) We design a data structure based on a binary tree for clouds to record all the changes of data blocks. Group users can trace the data changes through the binary tree and recover the latest correct data block when the current data block is damaged.

3) We utilize an authorized authenticate process to verify TPA?s challenge messages. Therefore, only the TPA who has been authorized by the group users can pass the authentication and then challenge the cloud, which protects clouds from malicious challenges.

4) Our formal security analysis and experimental results show that NPP is provably secure and efficient.

The rest of this paper is organized as follows. Section II presents a review of related work on public auditing schemes in cloud storage. Then we introduce our system model, threat model and design objectives in Section III. Section IV briefly introduces the cryptographic knowledge applied in our scheme. In Section V, we describe the proposed public auditing scheme NPP in detail. Section VI analyzes its security and Section VII evaluates its performance. Finally, this paper is concluded in Section VIII.



II. RELATED WORK  Ateniese et al. [16] firstly proposed the Provable Data Possession (PDP) model, utilizing homomorphic verifiable tags, and the process of data integrity checking was a kind of ?challenge-response? protocol. In order to support data retrievability, Juels et al. [17] proposed the Proofs of Retriev- ability (POR) model. Many extended schemes based on PDP or POR have been proposed to solve different problems in public auditing [7]-[14], [18]-[23].

Considering the application of cloud data shared by group users, Wang et al. [7] proposed a privacy-preserving public auditing scheme, called Oruta, for shared data in the cloud.

Their scheme was based on a homomorphic authenticable ring signature, which allows a public auditor to audit the shared data without retrieving all data from the cloud. However, the auditing overhead linearly increases with the number of group users, hence it is not suitable for large groups in the cloud. To  support large groups, Wang et al. [8] proposed a new auditing scheme, called Knox. The auditing overhead is independent of the number of group users, hence Knox can support shared data with large groups. Moreover, any group manager can reveal the identity of the signer. Unfortunately, the scheme cannot support user revocation.

Many schemes have been proposed in order to deal with this problem. In [9]-[11], homomorphic authentications based on proxy re-signature were constructed. With the cooperation of cloud and revoked users, these schemes converted the signatures of the revoked users into those of the existing users.

As the cloud has powerful computation ability, this method has no effect on the existing users. The problem is that it cannot resist collusion attacks. If a revoked user colludes with the cloud, the private keys of the existing users can be obtained by the cloud. Therefore, the cloud can tamper with the shared data stored in it arbitrarily. Besides, Yu et al. [15] pointed out that the scheme in [11] is vulnerable to replace attacks.

Recently, to solve the problem of collusion attacks, Yuan et al. designed polynomial-based authentication tags, allowing aggregation of tags for different data blocks [19]. Their scheme allows secure delegation of user revocation operations to the cloud, permitting the cloud itself to conduct revocation without the participation of revoked users. Unfortunately, their scheme is also vulnerable to resist collusion attacks. If a revoked user colludes with the cloud, the cloud server can update the data as many times as the revoked user requests until it finally returns a legal data [22], [24]. Another attempt to solve the issue is the combination of vector commitments and group signatures with verifier-local revocation [22]. However, the computation cost of user revocation grows with the number of revoked users.

In addition, to eliminate threats of unauthorized audit chal- lenges from malicious or pretended third-party auditors, Liu et al. [12] proposed an authorized auditing scheme by adding an additional authentication process between the cloud and the TPA. Additionally, to support fine-grained update requests, the authorized scheme employed BLS signatures and MHT.

However, the scheme can only be applied to a single client.



III. PROBLEM STATEMENT  In this section, we describe the system model and the threat model of this paper, and give the design objectives of our public auditing scheme.

A. System Model  As shown in Fig. 1, the system model contains four entities: cloud, TPA, trusted private key generator (PKG), and group users. The cloud has powerful storage space and computing capacity, and provides services (e.g., data storage, data sharing, etc.) for group users. The TPA can verify the integrity of the shared data on behalf of the group users. The PKG generates the system public parameters and group key pair for group users. The group users include two types of users: GMs (Group Managers) and ordinary members.

Unlike existing system models, the GMs contain multiple members who create the shared data together and share them with the ordinary members through the cloud. Therefore, the    2332-7790 (c) 2016 IEEE. Personal use is permitted, but republication/redistribution requires IEEE permission. See http://www.ieee.org/publications_standards/publications/rights/index.html for more information.

This article has been accepted for publication in a future issue of this journal, but has not been fully edited. Content may change prior to final publication. Citation information: DOI 10.1109/TBDATA.2017.2701347, IEEE Transactions on Big Data   GMs act as the common owners of the original data, and their identities are equal. Meanwhile, any of the GMs can add new members or revoke members from the group. In addition, either a GM or an ordinary member can access, download, and modify the shared data in the cloud. Note that multiple managers in a group is very common in practice. For instance, the shared data of a project team is created by multiple managers together. Later, any of the GMs can maintain the shared data and manage the group users. When tracing the real identity of the signer, a given number of managers can cooperate to trace the real identity, which ensures the fairness of the tracing process.

When a group user wants to check the integrity of the shared data, she/he first submits an auditing request message to the TPA. After receiving the request, the TPA challenges the cloud for an auditing proof. Once the cloud receives the auditing challenge, it firstly authenticates the TPA. If valid, the cloud will return the auditing proof to the TPA. Otherwise the cloud will refuse the request. Finally, the TPA verifies the validity of the proof and sends an auditing response to the group user.

B. Threat Model  1) Integrity Threat. There are two kinds of threats related to shared data integrity. One is that external attackers might corrupt the shared data in the cloud, so that group users can no longer access the correct data. The other is that the cloud may corrupt or delete the shared data due to the hardware/software faults or human errors. What?s worse, the cloud may conceal the fact of data damage from users in order to maintain self- interest and service reputation.

2) Privacy Threat. As a trusted and inquisitive verifier, a TPA might obtain some privacy information from the verifi- cation metadata during the auditing process. For instance, the TPA might analyze which data block has been modified most or which user has modified the data most, and finally conclude which particular data block or which group user is of a higher value than the others. Then the TPA might directly obtain the data or the identity of the group user from the signatures of the data blocks.

3) Challenge Threat. Because the auditing challenge mes- sage is very simple and has not been authorized, any other entity can utilize the TPA to challenge the cloud for auditing  Fig. 1. The system model of NPP.

TABLE I NOTIONS  Notions Description mpk shared group public key mskl the secret key of GMl  {spk,ssk} public/private key pair uski user signing key upki user membership key rvki user revocation key  (Vj,1, Vj,2, ?j) the signature of the block mj AUTH authorization  t timestamp  proofs. In this case, a malicious entity might launch denial of service attacks on the cloud by sending massive challenge messages continuously, which will lead to network congestion and unnecessary waste of the clouds resources.

C. Design Objectives  To achieve integrity checking of the shared data in the cloud, NPP is expected to the following design objectives: 1) Public auditing: Besides the group users, the TPA can also correctly check the integrity of the shared data in the cloud without retrieving entire users? data from cloud. 2) Authorized auditing: Only the TPA that has been authorized by the group users can challenge the cloud. 3) Identity privacy: During the process of auditing, the TPA cannot learn the identity of the group user from the signatures of the data blocks. 4) Traceability: Under certain conditions, the group managers can reveal the signer?s identity from the signatures and decide which group user has modified the data block. 5) Non- frameability: Group managers can guarantee the fairness of the tracing process, i.e., innocent group user won?t be framed and the misbehaved user won?t be harbored by the group managers. 6) Support data traceability and recoverability: Group users can easily trace the data changes and recover the latest correct data once current data is damaged. 7) Support group dynamics: Group dynamics include two aspects. One is that GMs can easily join or leave the group, the other is that new users can be easily added into the group and misbehaved users can be efficiently excluded from the group.



IV. PRELIMINARIES  In this section, we briefly introduce the cryptographic knowledge applied in NPP. The main notations used in this paper are described in Table I.

A. Homomorphic Verifiable Tags  Homomorphic Verifiable Tags [16] (HVTs) acting as the verification metadata of file blocks have been widely used in integrity checking for data stored in the cloud.

Definition 1 (Homomorphic verifiable signature). If an HVT based on signatures can satisfy the following two properties simultaneously, then the signature scheme is a homomorphic verifiable signature scheme [7], [11].

Supposing (pk,sk) are the public/private key pair of the signer, ?1 and ?2 denote the tags of data block m1,m2 ? Zq , respectively.

2332-7790 (c) 2016 IEEE. Personal use is permitted, but republication/redistribution requires IEEE permission. See http://www.ieee.org/publications_standards/publications/rights/index.html for more information.

This article has been accepted for publication in a future issue of this journal, but has not been fully edited. Content may change prior to final publication. Citation information: DOI 10.1109/TBDATA.2017.2701347, IEEE Transactions on Big Data   1) Blockless verification: A verifier can judge the cor- rectness of all data through the linear combination of the data without retrieving it from the cloud. Specifically, given ?1, ?2, two random numbers y1, y2 ? Zp and data block m = y1m1 + y2m2, a verifier can check the correctness of m without knowing m1, m2.

2) Non-malleability: Any entity without the secret key cannot generate a new and valid tag through combining the known tags. Specifically, given ?1, ?2, two random numbers y1, y2 ? Zp and data block m = y1m1+ y2m2, an entity who has no sk cannot generate the valid tag ? for m by combining ?1 and ?2.

B. Discrete Logarithm (DL) Problem  Definition 2 (DL Problem). Let a ? Z?p , given g, ga ? G1 as input, output a. The advantage of probabilistic polynomial time algorithm A? in solving the DL problem in G1 is defined as AdvDL  A? = Pr[A?(g, ga) = a : a  R?? Z?p ], where the probability is over the choice of a, and the coin tosses of A?.

In this case, for any probabilistic polynomial time algorithm A?, the advantage of solving the DL problem in G1 is negligible.



V. THE NPP SCHEME  A. Overview  We assume that there is S group managers GMl(1 < l ? S), and d users Ui(1 ? i ? d) in NPP. The shared data M is divided into w data blocks, i.e. M = {m1,m2, ? ? ? ,mw}.

In order to support dynamic operations on the shared data, we index each data block by leveraging index hash table [9].

Specifically, NPP consists of eight algorithms: {Setup, Enroll, Revoke, Sign, Authorize, ProofGen, ProofVerify, Open}.

In Setup phase, the PKG sets parameters for the entire system, distributes the group key pair {mpkl,mskl} and a shared public/private key pair {spk,ssk} used to authorize each GMl, and initializes the membership information ? . Then, any GM generates a user signing key uski, a (public) user membership key upki, and a user revocation key rvki for Ui.

GM also shares the authorization key pair {spk, ssk} with Ui in the Enroll procedure. Once a group user is revoked, GM invokes the Revoke algorithm to update ?. The group user can compute the signatures of the shared data block from the issued keys in the Sign process. With the Authorize algorithm, the group authorizes TPA to generate authorized auditing challenges, and then the valid TPA can check the integrity of the shared data on behalf of the group user. Once the cloud receives a challenge from TPA, the cloud verifies whether the challenge has been authorized and decides whether to generate the audit proof via ProofGen. TPA checks the correctness of the proof via ProofVerify. Finally, in the Open process, at least t GMs work together to trace the real identity of the signer.

B. Support Data Traceability and Recoverability  Since the identity of each data block can be described by the index hash table, i.e., idj = {vj , rj}, where vj is denoted as the virtual index of block mj , and rj is a random number generated by a collision-resistant hash function, every group      m  s    i  i  m  s    w  w  m  s  Fig. 2. The original records.

w  w  m  s      m  s    i  i  m  s    w  w  m  s      m  s    i  i  m  s    i  i  m  s    w  w  m  s    i  i  m  s      m  s    i  i  m  s    i  i  m  s    w  w  m  s    i  i  m  s      m  s    i  i  m  s    i  i  m  s    i  i  m  s  Fig. 3. The records when the ith block has been updated three times.

user can easily perform dynamic operations on the shared data, the details of which can be found in [7]. However, if the data block has been changed maliciously, the group user cannot trace the changes and recover the right data.

To support data tracing and recovery, we have designed an additional data structure based on binary tree for the cloud server to record every change of data block. Through the records, group users can easily trace data changes. When the damaged has been found, group users can recover the right data by the records. As the group users can verify the older blocks one by one until discover the latest correct block. As shown in Fig. 2, original data blocks {m1,m2, ? ? ? ,mw} with the corresponding signatures {?1, ?2, ? ? ? , ?w} are stored as the roots of w binary trees respectively. {mji , ?  j i }(1 ? i ?  w) denotes the ith block has been modified j times, hence {m0i , ?0i } means the data block is the original one. We will use some examples to show different records when group users perform dynamic operations on the shared data later. Fig. 3 and 4 describe update operation and insert operation respectively.

In addition, when group users want to delete a block, the cloud server still keeps the records related to this block, without any other additional operations. Whats more, the cloud server does not need to know which block has been deleted.

As shown in Fig. 3, the ith block has been updated for three times, and the latest one is always the root of the binary tree; the old ones are the nodes of the binary tree. If we define the depth of the binary tree as N , then the number of nodes    2332-7790 (c) 2016 IEEE. Personal use is permitted, but republication/redistribution requires IEEE permission. See http://www.ieee.org/publications_standards/publications/rights/index.html for more information.

This article has been accepted for publication in a future issue of this journal, but has not been fully edited. Content may change prior to final publication. Citation information: DOI 10.1109/TBDATA.2017.2701347, IEEE Transactions on Big Data       m  s      i  i  m  s  -  -    w  w  m  s    i  i  m  s  ?  ?    i  i  m  s  Fig. 4. The record when a block has been inserted.

belongs to range [2N?1, 2N ? 1], and the number of times for the cloud to record the updates belongs to range [2N?1 ? 1, 2N ? 2].

Once the current signature ?3i has been damaged, group users can trace the changes {(m2i , ?2i ), (m1i , ?1i ), (m0i , ?0i )} by implementing the postorder traversal to the final binary tree.

As the damaged signature cannot pass the verification, the group users are able to verify the signature ?2i , if it can pass the verification, then the latest right block has been found.

Otherwise, the group users continue verifying the signatures one by one according to the order of traversal tree with the help of TPA until the latest right block is discovered. The verification algorithm can be found in the next section.

As shown in Fig. 4, when group users want to insert a block, for example a new block m?i is inserted between the block mi?1 and the block mi, and id?i = {v?i, r?i} = {?(vi?1 + vi)/2?, r?i}, the cloud server will create a new root (i.e., {m0i? , ?0i?}) for this new block.

C. Construction of NPP In this section, we describe the details of the eight al-  gorithms included. To protect data privacy, the data can be encrypted by the means of symmetrical encryption technology and attribute-based encryption technology before shared data is outsourced to the cloud [25]; however, this is outside the scope of our paper.

1) Setup: With the input security parameters ? > 1, k, lp ? N , PKG randomly chooses parameters ?1, ?2, ?1 and ?2 such that ?1 > ?(?2 + k) + 2, ?2 > 4lp, ?1 > ?(?2 + k) + 2 and ?2 > ?1 + 2, two multiplicative cyclic groups G1, G2 with the same order q, and g0 is the generator of G1. Then PKG chooses a bilinear map e : G1 ? G1 ?? G2 and two one- way hash functions: H1{0, 1}? ?? Zq,H2{0, 1}? ?? G1, and defines two intervals: A = [2?1 ? 2?2 , 2?1 + 2?2 ], B = [2?1 ? 2?2 , 2?1 + 2?2 ]. The parameters above are all public.

Then, PKG computes the shared group public key mpk = (n, a, a0, Y, g0, g, h, g1, g2, ?1, ?2) and each GMl?s secret key mskl = (p  ?, q?, Xl) as follows: ? Select lp-bit primes p?, q? such that P = 2p? + 1 , and  Q = 2q? + 1 . Set the modulus n = PQ (Note that all the following arithmetic operations are modulo n unless specified otherwise).

? Choose random elements a, a0, g, h, g1, g2, ?1, ?2 ?R QR(n) (of order q ), where QR(n) denotes the set of quadratic residues of group Z?n .

? Choose a random secret X ?R Z?q , and set Y = gX .

? Choose a t-1 degree polynomial f(x) = b0 + b1x + ? ? ?+bt?1xt?1 with b0 = X, b1, ? ? ? , bt?1 ? Zq , compute Xl = f(l)(l = 1, 2, ? ? ? , S and 2t ? 1 ? S), i.e. X is divided into S pieces Xl [26].

? Initialize the membership information ? = (c, u), where c is initialized to g1, and u is initialized to 1.

Next, PKG chooses a public/private key pair {spk, ssk} used for authorization only.

Finally, PKG sends {mpk,mskl} along with {spk, ssk} to GMl securely.

2) Enroll: The uski, rvki, and upki of a new member Ui are generated as follows:  ? Ui generates a secret exponent x?i ?R [0, 2?2 ], a random integer r?i ?R [0, n], computes C1 = gx?ihr?i and broad- casts C1 to any GM.

? GM who has received C1 checks whether C1 ? QR(n).

If this is the case, the GM chooses ?i, ?i ?R [0, 2?2 ] and sends {?i, ?i} to Ui.

? Ui computes xi = 2?1 +(?ix?i+?i mod 2?2), C2 = axi and broadcasts C2 to the GM.

? GM checks whether C2 ? QR(n). If this is the case, GM chooses ei, ? ?R B, computes Ai = (C2a0)1/ei = (axia0)  1/ei , ? = g0?(? is public) and sends {Ai, ei, ?} along with {spk, ssk} to Ui.

? Ui checks axia0 ?

= Aeii . If the equation holds, Ui sets  uski = (xi, ?), rvki = ei, upki = Ai and shares the key pair {spk, ssk} with all the GMs.

? GM maintains a users-list, which contains all related keys and the valid time of the group users. Different users may be assigned with different valid times. Finally, GM adds Ui, Ui?s related keys and valid time to the list.

3) Revoke: Supposing user Uk(1 ? k ? d) is to be revoked, the revocation key is rvkk and the current member- ship information is ? = (c, u), then any GM should update c = crvkk , u = u ? rvkk.

Suppose there are revoked users {Ue, ? ? ? , Uk}(1 ? e < k ? d), the latest c = c  ?k i=e rvki , u =  ?k i=e rvki.

Then PKG distributes a new key pair {spk?, ssk?} to all GMs, and the GM shares it with the existing group users.

Meanwhile, the GM updates the revoked users? valid time as a negative value in the users-list.

4) Sign: Group user Ui computes the signature ?j = (Vj,1, Vj,2, ?j) [27] for block mj ? Zq(1 ? j ? w, idj is the identifier ) as follows:  i. Compute Vj,1.

? Randomly choose rj?R{0, 1}2lp and compute Tj,1 = Y rjAj , Tj,2 = g  rj , Tj,3 = g rvki?hrj .

? Randomly choose rj,1?R ? {0, 1}?(?2+k), rj,2?R ? {0, 1}?(?2+k), rj,3?R ? {0, 1}?(?1+2lp+k+1), rj,4?R ? {0, 1}?(2lp+k) and then compute dj,1 = T  rj,1 j,1 /(a  rj,2 ? Y rj,3), dj,2 = T  rj,1 j,2 /g  rj,3 , dj,3 = grj,4 , dj,4 = grj,1 ?hrj,4 .

? Compute vj,1 = ?  mj 1 H1(g?h?Y ?a0?a?Tj,1?Tj,2?Tj,3  ?dj,1?dj,2?dj,3?dj,4).

? Compute sj,1 = rj,1 ? vj,1(rvki ? 2?1), sj,2 = rj,2 ?  vj,1(xi ? 2?1), sj,3 = rj,3 ? vj,1 ? rvki ? rj , sj,4 = rj,4 ? vj,1 ? rj .

? Output Vj,1 = (vj,1, sj,1, sj,2, sj,3, sj,4, Tj,1, Tj,2, Tj,3).

ii. Compute Vj,2.

? Find f, b ? Z such that f ? u+ b ? rvki = 1, and then set d = g?b1 (because Ui has not been revoked, rvki is not included in u =  ?k i=1 rvki and gcd(rvki, u) = 1).

? Compute Tj,4 = d ? g rj 2 .

2332-7790 (c) 2016 IEEE. Personal use is permitted, but republication/redistribution requires IEEE permission. See http://www.ieee.org/publications_standards/publications/rights/index.html for more information.

This article has been accepted for publication in a future issue of this journal, but has not been fully edited. Content may change prior to final publication. Citation information: DOI 10.1109/TBDATA.2017.2701347, IEEE Transactions on Big Data   ? Randomly choose rj,5?R ? {0, 1}?(?2+k), rj,6?R ? {0, 1}?(?2+k), rj,7?R ? {0, 1}?(?1+2lp+k+1), rj,8?R ? {0, 1}?(2lp+k) and compute dj,5 = T  rj,5 j,4 /(c  rj,6 ? grj,72 ), dj,6 = g  rj,5 ? hrj,8 .

? Compute vj,2 = ?  mj 2 H1(g?h?g1?g2?c?Tj,3?Tj,4?dj,5  ?dj,6).

? Compute sj,5 = rj,5 ? vj,2(rvki ? 2?1), sj,6 = rj,6 ?  vj,2(f ? 2?1), sj,7 = rj,7 ? vj,2 ? rvki ? rj , sj,8 = rj,8 ? vj,2 ? rj .

? Output Vj,2 = (vj,2, sj,5, sj,6, sj,7, sj,8, Tj,3, Tj,4).

iii. Compute tag ?j = [H2(idj)g  mj 0 ]  ?.

iv. Output the signature ?j = (Vj,1, Vj,2, ?j).

5) Authorize: Any group member can authorize the TPA on  behalf of the group to challenge the cloud through the shared key pair {spk, ssk} as follows:  ? The group member asks the ID of the TPA (for security, the ID is used for authorization only). Then the TPA returns its ID encrypted with the public key spk.

? The group member decrypts it with ssk to get ID, computes sigAUTH = Sigssk(AUTH?t?ID) (AUTH means authorization and t is the timestamp), and sends sigAUTH as the auditing authorization message to the TPA. Then the TPA can challenge the cloud on behalf of the group users.

Note that after message {AUTH, t, sigAUTH} is stored in the cloud along with the signatures of the data blocks, it will be deleted from local storage.

6) ProofGen: In this phase, the TPA first sends a challenge message to the cloud, and then the cloud generates a auditing proof message if the TPA is authorized.

i. The TPA challenges the cloud as follows: ? Randomly choose a subset ? from the set [1, w], where  ? contains D elements, i.e. |?| = D.

? Generate random numbers yj ? Zq, j ? ?.

? Send an auditing challenge message {sigAUTH , {ID}PKcloud , {(j, yj)}j??} to the cloud.

Because the PKcloud is the public key of the cloud, the cloud can decrypt {ID}PKcloud with the corresponding private key SKcloud to get ID.

ii. The cloud checks whether the TPA has been authorized as follows:  ? Compute ID by decrypting {ID}PKcloud with its private key SKcloud.

? Decrypt sigAUTH with the group?s public key spk to get ID,AUTH and t. If ID = ID?, the computed AUTH is equal to the AUTH stored in the cloud and t is valid, the cloud will generate the auditing proof. Otherwise, the cloud will refuse to generate the proof.

iii. The cloud generates the auditing proof message to the TPA as follows:  ? Compute ? = ?  i?? yjmj ? Zq and aggregate the selected tags as ? =  ? j?? ?  yj j ? G1.

? Output ?j = {Vj,1, Vj,2}j?? based on the selected block- s, where Vj,1 = (vj,1, sj,1, sj,2, sj,3, sj,4, Tj,1, Tj,2, Tj,3), Vj,2 = (vj,2, sj,5, sj,6, sj,7, sj,8, Tj,3, Tj,4).

? Send the auditing proof {{idj}j??, {?j}j??, ?,?} to the TPA.

7) ProofVerify: The TPA checks the correctness of the proof as follows.

? Compute d?j,1 ? d?j,6 as follows:  d?j,1 = (a vj,1 0 ? T  sj,1?vj,1?2?1 j,1 )/(a  sj,2?vj,1?2?1 ? Y sj,3) (1)  d?j,2 = T sj,1?vj,1?2?1 j,2 /g  sj,3 (2)  d?j,3 = T vj,1 j,2 ? g  sj,4 (3)  d?j,4 = T vj,1 j,3 ? g  sj,1?vj,1?2?1 ? hsj,4 (4)  d?j,5 = ((g ?1 1 )  vj,2 ? T sj,5?vj,2?2 ?2  j,4 )/(c sj,6?vj,2?2?1 ? gsj,72 )  (5)  d?j,6 = T vj,2 j,3 ? g  sj,5?vj,2?2?1 ? hsj,8 (6)  ? Verify the correctness of the following equations:? j??  v yj j,1  ?

= ??1  ? j??  H1(g? ? ? ? ?d?j,4)yj (7)  ? j??  v yj j,2  ?

= ??2  ? j??  H1(g? ? ? ? ?d?j,6)yj (8)  e(?, g0) ?

= e(  ? j??  H2(idj) yj ?g?0 , ?) (9)  Note that for simplicity, we use H1(g?h? ? ? ? ?d?j,4) and H1(g? ? ? ? ?d?j,6) instead of H1(g?h?Y ?a0?a?Tj,1?Tj,2?Tj,3?d?j,1?d?j,2?d?j,3?d?j,4) and H1(g?h?g1?g2?c?Tj,3?Tj,4?d?j,5?d?j,6), repetitively, in the following parts.

? If the equations (7) (8) (9) all hold, then the auditing proof is valid. Otherwise, it is not.

? If the proof is valid, TPA will send a positive report to the user. Otherwise, a negative report will be sent instead.

8) Open: When users have performed malicious actions on the shared data, at least t GMs work together to trace the real identity of the group user as follows:  ? Negotiate with each other to construct a polynomi- al y(x) =  ?t l=1 f(l) ? Fl(x) =  ?t l=1 X(l) ? Fl(x),  where the Lagrange polynomial interpolation Fl(x) =? 0?h??t,h? ?=l  x? h?  l ? h? .

? Compute the trace key X = y(0) = ?t  l=1 X(l) ? Fl(0).

? Compute upki = Tj,1/TXj,2 = Ai, and then reveal the real  identity of the signer through upki.

This procedure guarantees the current user can be found.

When GMs need to find previous users who have affected the shared data, they can trace the data changes by implementing the postorder traversal to the additional binary tree, and then reveal the real user identities of each data change through the above procedure.

2332-7790 (c) 2016 IEEE. Personal use is permitted, but republication/redistribution requires IEEE permission. See http://www.ieee.org/publications_standards/publications/rights/index.html for more information.

This article has been accepted for publication in a future issue of this journal, but has not been fully edited. Content may change prior to final publication. Citation information: DOI 10.1109/TBDATA.2017.2701347, IEEE Transactions on Big Data   D. Discussions 1) Group Managers Dynamics: ? GM joining If a new GM wants to join the group, the PKG computes  S? = S+1, and tests whether 2t?1 ? S?. If it holds, the PKG will compute a new piece (S?, Xs? ) with polynomial f(x) and distribute it to the new GM?S ; otherwise, the PKG chooses a new (t? ? 1)-degree polynomial f ?(x) = b?0 + b?1x + ? ? ? + b?t??1x  t??1, where 2t? ? 1 ? S?, b?0 = X, b?1, ? ? ? , b?t??1 ? Zq , and computes X ?l = f  ?(l)(l = 1, 2, ? ? ? , S?), i.e. X is divided into S? pieces X ?l and then distributed to GMl.

In addition, the PKG generates a new key pair {spk?, ssk?}, and broadcasts it to all the GMs, who can then share it with the existing group users. Note that the process of updating {spk, ssk} has no effect on auditing, because the signing keys, the membership keys and the revocation keys of the existing users do not need to be updated. Nor do the signatures of the data blocks.

? GM leaving If an existing GMl wants to leave the group, the PKG first  sets S? = S ? 1, chooses a new (t? ? 1)-degree polynomial f ?(x) = b?0+ b  ? 1x+ ? ? ?+ b?t??1xt  ??1, where 2t??1 ? S?, b?0 = X, b?1, ? ? ? , b?t??1 ? Zq , and then computes and distributes new X ?l = f  ?(l)(l = 1, 2, ? ? ? , S?) to each GMl.

In addition, the PKG generates a new key pair {spk?, ssk?},  and broadcasts it to all the GMs, who can then share it with the existing group users.

2) User Revocation: GMs maintain a users-list, which is composed of each user?s related key and expiration time. Once a user?s service subscription expires, their signing key should become invalid from then on. In this case, any GM can invoke the Revoke algorithm by updating the membership information ? and the key pair {spk, ssk} and setting the value of the revoked user?s expiration time to be negative.

There might be misbehaving users in the group. In this case, any GM can invoke the Revoke algorithm as mentioned above.

Note that when a user is revoked from a group, GMs do not need to re-compute and re-distribute new keys to the valid users, since the revoked user Ui cannot find f, b ? Zq such that f ?u+b?rvki = 1, Ui cannot compute the partial signature V2 any more.

If the revoked user Ui maliciously reveals their signing key uski = (xi, ?), then the partial signature of other users can be discerned because of the common key ?. However, it is not enough to forge a valid signature as the secret key xj of the other users is still unknown. Therefore, the partial signature V1 cannot be computed.

As we have demonstrated, valid users do not need to update their keys and the existing signatures. Signatures belonging to the revoked users can be re-computed by the GMs. Specifical- ly, the existing user interacts with GMs to generate a proxy signature key, then GMs use the proxy key to compute the signatures of the revoked users. That transforms them into the signatures which sign by the private key of the existing user.



VI. SECURITY ANALYSIS The correctness analysis and security analysis of our pro-  posed NPP protocol are established by the following theorems:  Lemma 1. NPP is a homomorphic authenticable group signature scheme.

Proof: According to the Definition 1, if NPP is a homo- morphic verifiable, it must satisfy both blockless verification and non-malleability.

? Blockless verification When TPA selects the subset ? = {1, 2} and computes  ? = y1m1 + y2m2, Equations (7), (8) and (9) are all correct (the specific proof process can be referred to Equations (10), (11) and (12) below). Therefore, NPP satisfies the property of blockless verification.

? Non-malleability An attacker without the private key cannot generate the valid  tag ?? of m? by combining ?1 and ?2, because ? y1 1 ? ?  y2 1 =  [H2(id1) y1 ?H2(id2)y2 ? gm  ?  0 ] ? , ?? = [H2(id?) ? gm  ?  0 ] ?. If ?? =  ?y11 ? ? y2 1 , then H2(id  ?) = H2(id1) y1 ? H2(id2)y2 = C. Once  a value id? can be found such that H2(id?) = C, it disproves that H2 is a one-way hash function. Therefore, NPP has the property of non-malleability.

Therefore, from Lemma 1, we can demonstrate that NPP has the properties of public auditing and correctness.

Theorem 1 (Public Auditing). Given a message M and its group signature ?, the TPA is able to publicly and correctly check the integrity of message M under NPP.

Proof: Besides the group users, the TPA can execute auditing by randomly choosing a subset ? of [1, w] without the need of retrieving all data blocks from the cloud, which satisfies the object of public auditing.

The correctness of the verifying process relies on the correctness of Equations (7), (8) and (9). Specific proofs are as follows:?  j?? v yj j,1 =  ? j??  (? yjmj 1 ?H1(g? ? ? ? ?d?j,4)yj )  = ? ?  j?? yjmj 1 ?  ? j??  H1(g? ? ? ? ?d?j,4)yj (10)  = ??1 ? ? j??  H1(g? ? ? ? ?d?j,4)yj  ? j??  v yj j,2 =  ? j??  (? yjmj 2 ?H1(g? ? ? ? ?d?j,6)yj )  = ? ?  j?? yjmj 2 ?  ? j??  H1(g? ? ? ? ?d?j,6)yj (11)  = ??2 ? j??  H1(g? ? ? ? ?d?j,6)yj  e(?, g0) = e( ? j??  ? yj j , g0)  = e( ? j??  (H2(idj)g mj 0 )  yj?, g0) (12)  = e( ? j??  H2(idj) yj ?g?0 , ?)  From Equations (10), (11) and (12), we conclude that TPA can correctly check the integrity of the shared data without retrieving all the data blocks on behalf of the group users.

2332-7790 (c) 2016 IEEE. Personal use is permitted, but republication/redistribution requires IEEE permission. See http://www.ieee.org/publications_standards/publications/rights/index.html for more information.

This article has been accepted for publication in a future issue of this journal, but has not been fully edited. Content may change prior to final publication. Citation information: DOI 10.1109/TBDATA.2017.2701347, IEEE Transactions on Big Data   Theorem 2 (Unforgeability). Given shared data M and its group signatures ?, it is computationally unfeasible that an untrusted cloud or adversary can generate an invalid auditing proof that can pass the verification under NPP.

Proof: According to the security game defined in [7], we firstly define Game 1 as follows:  Game 1: TPA sends auditing challenge message {(j, yj)}j?? of shared data M to the cloud, and the correct auditing proof should be {idj ,?j , ?,?}j??, which can pass the verification. Now, instead of generating the correct auditing proof, the untrusted cloud generates an invalid auditing proof of {idj ,?j , ??,?}j?? based on the corrupted shared data M?, where ?? =  ? j?? yjm  ? j . Define  ?mj = m ? j ? mj for j ? ?, and at least one element of  {?mj}j?? is nonzero (because M ? ?= M ). If the invalid proof still can pass the verification performed by the TPA, then the cloud wins this game. Otherwise, it fails.

Now we show that, if the untrusted cloud wins the above game, we can find a solution to the DL problem. We first assume the untrusted cloud could win Game 1. Then, accord- ing to Equation (6), we have e(?, g0) = e(  ? j?? H2(id)  yj ? g?  ?  0 , ?), where ? ? =  ? y?? yjm  ? j . Since {idj ,?j , ?,?}j??  is the correct auditing proof, we also have e(?, g0) = e( ?  j?? H2(id) yj ? g?0 , ?)  Then we learn that g? ?  0 = g ? 0 , g  ? j?? yjmj  0 = g ?  j?? yjm ? j  0 , g ?  j?? yj?mj 0 =  ? j??(g  yj 0 )  ?mj = 1.

As G1 is a cyclic group, given two random elements  g, h ? G1, there exists x ? Zp such that g = hx. Without loss of generality, given g, h ? G1, each g  yj 0 can be ran-  domly and correctly generated by computing gyj0 = g ?jh?j ,  where ?j and ?j are random values of Zp. Then, we have 1 =  ? j??(g  yj 0 )  ?mj = ?  j??(g ?jh?j )?mj = g  ? j?? ?j?mj ?  h ?  j?? ?j?mj .

Clearly, we can find a solution to the DL problem. More  specifically, given h, g = hx ? G1, we can output g =  hx = h ?  ? j?? ?j?mj? j?? ?j?mj , x = ?  ? j?? ?j?mj? j?? ?j?mj  , unless the  denominator is zero. However, as we defined in Game 1, at least one element of {?mj}j?? is nonzero, and ?j is a random element of Zp; therefore, the probability of the denominator being zero is 1/p, which is negligible because p is a large prime. It means that once the untrusted cloud wins Game 1, we can find a solution to the DL problem with a probability of 1 ? 1/p, which contradicts the assumption that the DL problem is computationally unfeasible in G1. Therefore, it is computationally unfeasible for the untrusted cloud to generate an invalid auditing proof that can pass the verification.

Theorem 3 (Authorized Auditing). NPP supports autho- rization verification.

Proof: Since the ID of the TPA is encrypted with the public key spk, any other entity excluded by the group cannot obtain the valid ID without the private key ssk. Therefore, they cannot forge a valid message sigAUTH to pass the authentica- tion. In addition, the timestamp t included in sigAUTH ensures that a previous authorization message cannot be utilized as a valid message. Therefore, only the TPA who has been  authorized by the group can challenge the cloud.

Theorem 4 (Identity Privacy). Given a message M and  its group signature ?, it is computationally unfeasible for a verifier to reveal the identity of the signer.

Proof: Because TPA cannot infer the secret value X from the known Y = gX and g, it is computationally unfeasible for the TPA to infer the real identity of the signer from signatures Vj,1 and Vj,2. In addition, although ?, used to verify the partial signature ?, is public, users in the group share the same secret value ?, hence the partial signatures ? of all users in the group are the same. Therefore, TPA cannot infer the real identity of the signer from the signature ?.

Theorem 5 (Traceability and Non-frameability). At least t GMs can work together to recover the identity of the signer from the signatures.

Proof: The secret value X is divided into S pieces by the PKG based on (t, s) secret sharing scheme, and the S pieces are distributed to S GMs respectively. GMl owns piece Xl of X . By Lagrange polynomial interpolation, at least t GMs work together to recover X = y(0) =  ?t l=1 Xl ? Fl(0) and  then compute upki = Tj,1/TXj,2 = Ai. Therefore, the identity of the signer can be traced by at least t GMs after recovering upki. That means at least t GMs work together, the group managers can expose the signers identity from the signatures.

Note that since the tracing process is performed by multiple GMs instead of a single entity, it eliminates the potential risks brought by power centralization and ensures non-frameability during the tracing process.

Moreover, by implementing the postorder traversal to the additional binary tree and revealing the real identities from the signatures, GMs can trace each user who has performed actions on the shared data. Finally, if the current data block has been damaged, through postorder traversal, GMs can verify all the previous records of this data block one by one with the help of TPA until they find the latest right data block.

Theorem 6 (Data Traceability and Recoverability). NPP supports data traceability and recoverability.

Proof: According to the data structure based on the binary tree, the cloud server can record every change of the shared data blocks. Through the records, the group users can trace the data changes. Even if the current data block has been damaged, the users can recover the latest right data by verifying the older blocks one by one in the records.(We have made a detailed description in the subsection V.B)

VII. EVALUATION A. Functionality Comparison  Table II lists the features of NPP compared with other auditing schemes Knox [8] and PDM [19] for shared data in the cloud. As Table II shows, the two very important properties non-frameability and data traceability and recoverability are all not found in other two schemes. Whats more, comparing to their schemes, NPP adds a lot of features. Hence, NPP has wider application than Knox and PDM.

B. Performance Analysis In our experiments, we utilize Pairing Based Cryptography  (PBC) library [28] to simulate the cryptographic operations in    2332-7790 (c) 2016 IEEE. Personal use is permitted, but republication/redistribution requires IEEE permission. See http://www.ieee.org/publications_standards/publications/rights/index.html for more information.

This article has been accepted for publication in a future issue of this journal, but has not been fully edited. Content may change prior to final publication. Citation information: DOI 10.1109/TBDATA.2017.2701347, IEEE Transactions on Big Data   TABLE II FUNCTIONALITY COMPARISON  Knox [8] PDM [19] NPP Public Auditing Yes Yes Yes  Authorized Auditing Yes No Yes Identity Privacy Yes No Yes  Traceability Yes No Yes Non-frameability No No Yes  Data Traceability and Recoverability No No Yes  User Revocation No Yes Yes  TABLE III COMMUNICATION COST COMPARISON  Scheme Communication Cost(KB) Knox [8] D|w|+ (10D + k + 1)|q|+D(|id|+ |T |) = 106.4  PDM [19] (d+ 5)|q|+D|id| = 4.6 + 0.02d NPP D|w|+ (16D + 2)|q|+D|id| = 149.4  TABLE IV COMPUTATION COST COMPARISON  Scheme Computation Cost(s)  Knox [8] D(2ExpZq + 4MulZq ) + kMulZq +D(17ExpG1 +11MulG1 ) +D(ExpGT +MulGT ) + 4Pair = 1.351  PDM [19] (k + 6)ExpG1 + (k +D + 3)MulG1 + (D + 3)Pair = 1.446  NPP D(22ExpZq + 14MulZq ) +D(2ExpG1 + 2MulG1 ) +2Pair = 0.236  EXPZq and MULZq are one exponentiation operation and one multiplication operation on Zq respectively; EXPG1 and MULG1 are one exponentiation operation and one multiplication operation on Group G1 respectively; EXPGT and MULGT are one exponentiation operation and one multiplication operation on Group GT respectively; Pair is a bilinear pairing operation.

the schemes. All tests are applied to a Ubuntu system with i7 3.40GHz-Intel Core and 4GB-memory over 1,000 times. We set the size of elements in G1, G2, GT , Zq as 160 bits (i.e., |q| = 160bit, |T | = 160bit), the identity of each data block as 50 bits (i.e., |id| = 50bit), and the number of the shared data blocks as 1,000,000 (i.e., w = 1, 000, 000 and |w| = 20bit).

Each data block contains 100 elements (i.e., k = 100), the size of each data block is 2KB and the shared data is 2GB in all the experiments. Based on random sampling method [7], if the TPA select D = 460 data blocks, the detection probability is greater than 99%, and if D = 300, the detection probability is greater than 95%. To keep a higher detection probability, we chose D = 460. The performance analysis and the experiment results are as follows.

1) Communication cost: As Table III shows, the commu- nication costs of NPP and Knox are both constant, but that of PDM linearly increases with the number of the group users. To support user revocation, NPP adds V2 as a partial signature, which brings additional overhead |V2| = 7D|q| = 62.89KB compared with Knox. However, compared with the shared data size of 2GB, the additional communication cost of 62.89KB is small and acceptable.

2) Computation cost: As Table IV shows, the computation costs of all the three schemes are constant, which are inde- pendent of the number of the group users. Obviously, NPP outperforms Knox and PDM. Because the operations on GT  and the pairing operations are time-consuming, NPP has no operations on GT and has the fewest pairing operations. In contrast, Knox has several operations on GT and more pairing operations. Although the PDM has no operations on GT , the number of pairing operations in PDM linearly increase with D.

3) Performance results: From the above analysis, NPP has the lowest computation cost compared with Knox and PDM.

Specifically, the computation cost of Knox is almost 5.7 times that of NPP, and PDM is almost 6.1 times that of NPP.

Therefore, in terms of computation cost, NPP significantly outperforms Knox and PDM. As for communication cost, although the cost of NPP is a bit more than that of Knox, the additional overhead 63KB is small and acceptable compared to the size of shared data with 2GB.



VIII. CONCLUSION  In this paper, we propose a novel multi-level privacy pre- serving public auditing scheme for cloud data sharing with multiple managers. During the process of auditing, the TPA cannot obtain the identities of the signers, which ensures the identity privacy of the group users. Moreover, unlike the existing schemes, the proposed NPP requires at least t group managers to work together to trace the identity of the misbehaving user. Therefore, it eliminates the abuse of single- authority power and ensures non-frameability. Exceptionally, group users can trace the data changes through the designed binary tree and recover the latest correct data block when the current data block is damaged. In addition, the analysis and the experimental results show that NPP is provably secure and efficient.

