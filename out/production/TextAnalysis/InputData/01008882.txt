

Clusterwise Data Mining Within a Fuzzy Querying Interface  Janusz Kacprzyk', Jan W. Owsinski' and Slawomir Zadroiny''2 ' Systems Research Institute, Polish Academy of Sciences, ul. Newelska 6 ,01447 Warsaw, Poland * University of Information Technology and Management, ul. Newelska 6 , 0 1 4 7  Warsaw, Poland  E-mail: Janusz.Kacprzyk@ibspan.waw.pl  AbstrmL  This paper is a further development of a combined fuzzy querying and data mining paradigm. The point of departure is the FQUERY for Access (Kacpnyk and Zadroiny [8-121). Its earlier version (e.g., [ I t ,  121) offered the generation of fuzzy association rules within the fuzzy querying interface. W e  report on extensions to a wider range of available data mining tools, mainly from cluster analysis, and more specifically, a clustering algorithm by Owsinski and Zadroiny [20,21,22]. The data to be clustered is first fuzzified using a dictionary of linguistic terms.

Additionally, the resulting clusters are helpful in running other data mining tools, notably the generation of association rules.

INTRODUCTION  Data mining provides tools for discovering regularities in data. No single tool may take into account all possible types of such regularities. Thus, the construction of an interface combining several tools seems to be worthwhile. In our previous works [8,9,10] we developed the FQUERY for Access, a fuzzy querying interface based on Microsoft Access. This tool itself provides interesting data mining capabilities making it possible to formulate and execute intelligent queries using linguistic terms and non- conventional aggregation (connectives) of atomic conditions.

Obviously, it is primarily a querying interface, thus its data analysis capability is user-driven. The user has still to conceive a query. The fuzzy interface makes it is much easier to construct such a query.

Our next step was to implement a support for so-called database summaries [23,26,25,27,] within that fuzzy querying interface. We proposed algorithms for deriving various types of summaries [ 11,12,13,14]. More sophisticated ones require complex computations. The most general correspond to fuzzy IF-THEN rules. Their generation faces combinatorial explosion. To circumvent computational complexity we experimented with two approaches. The first, not directly related to the fuzzy querying interface, consists in application of genetic algorithms. Starting with a general idea of George and Srikant [4], very promising results with a genetic algorithm based system for generation of database summaries were obtained by Kacprzyk and Strykowski [6,7]. The second approach boils down to a simplification of an IF-THEN rule to an association rule that can be mined by some efficient algorithms [ 1,24,18].

Thus, FQUERY for Access offered both: a limited data mining functionality via intelligent fuzzy querying and a full- fledged data mining feature provided by linguistic database  summaries generation, including association rules mining. A motivation for a further extension of this interface was to implement a support for more sophisticated fuzzy association rules and another data mining technology, i.e. cluster analysis, within the same integrated fuzzy querying interface. We employ a clustering tool by Owsihski [20,21], implemented by Owsinski and Zadroiny [22]. Another reason was that the previous implementation of the association rules mining was not efficient enough. We redesigned (in the sense of software engineering) a part of our interface, too.

Section 2 contains a brief description of the FQUERY for Access fuzzy querying interface. Section 3 shows the implementation of database summaries within that package.

Section 4 presents the clustering analysis algorithm employed. Finally, in Section 5 we present the position and role of clustering within the FQUERY for Access.

FUZZY QUERYING IN FQUERY FOR ACCESS  The fuzzy querying implemented in the FQUERY for Access provides for a direct use of linguistic terms in queries.

Our point of departure is the standard syntax of the SQL query (the SELECT instruction). Then, we offer a more flexible syntax of the condition in the WHERE clause. For example, instead of "age<20", it may be "age is young". The meaning of linguistic terms is vague, and we have to use special means to deal with them. Moreover, we assume that instead of listing a crisp set of matching database rows, a fuzzy query against precise data yields a fuzzy set of such rows, each accompanied by its matching degree.

The linguistic terms used may be:  numerical fuzzy values, exemplified by low in "profitability is low", scalar fuzzy values, exemplified by Central Europe in "country is in Central Europe", fuzzy relations, exemplified by much greater than in "income is much greater than spending", and linguistic quantifiers, exemplified by most in "most conditions have to be met",  and they h e  building blocks of fuzzy queries. Similarly to linguistic quantifiers, they are all are represented as fuzzy sets (fuzzy trapezoidal numbers). Often, a separate repertoire of linguistic terms may be required for each attribute. However, it also possible to define universal numerical fuzzy values applicable for any numerical attribute. They are defined as fuzzy sets on a universal interval [ -IO,  +lo] and are converted to the ranges of particular attributes as needed.

0-7803-7293-X/01/$17.00 0 2001 IEEE 1239 2001 lEEE lnternational Fuzzy Systems Conference    Usually, a query consists of a number of simple conditions combined by the classical AND and OR. Linguistic quantifiers provide a more flexible aggregation as, e.g., instead of requiring all simple conditions to be are met, we may require most of them to be met.

FQUERY for Access maintains a dictionary of linguistic terms defined by users as well as predefmed ones. This feature supports both fuzzy querying and data mining.

FQUERY for Access was implemented as an add-in to Microsoft Access providing the user of this popular desktop DBMS with fuzzy querying, cf. [8-141.

DATA MINING VIA THE GENERATION OF ASSOCIATION RULES IN  FQUERY FOR ACCESS  Yager [25] proposed to use linguistically quantified propositions in the sense of Zadeh [28,29] to summarize the content of a database. We followed and extended this idea in the context of the FQUERY for Access.

The calculus of linguistically quantified propositions provides the semantics for such propositions being essentially different than in the classical logic. Consider, e.g., the proposition "Most transactions were profitable". First, the property of objects (transactions) is described imprecisely.

Second, the objects are quantified using a linguistic quantifiers (most) instead of the classical 'Ifor each" or "there exists". The calculus of linguistically quantified propositions makes possible to calculate the truth values of this type of propositions. Additionally, a counterpart of the scope of a quantifier, considered in the classical logic, is here taken into account making it possible to deal also with the propositions exemplified by "Most recent transactions are profitable".

The linguistically quantified propositions are well suited to summarize the content of a database. For example, having a database on transactions in a company, one may be interested to know if most of them are profitable. There are two issues related to the processing of such summaries:  How to evaluate the corresponding linguistically  How to come up (guess, conceive?) with such  The former may easily be solved via the FQUERY for Access. The fuzzy querying interface alone does not directly handle, for now, linguistic quantifiers so that we may treat a summary as a fuzzy query (the syntax of queries accepted by the FQUERY for Access will soon be extended to accommodate this). However, the FQUERY for Access supports not only fuzzy querying, but also data mining so that it is possible to request practically any summary. The latter problem is much more complex. The examples of summaries (linguistically quantified propositions) discussed so far were fairly simple but other summaries of a richer structure should be taken into account too. Similarly to the queries, summaries may also employ various connectives as, e.g., "Most young employees are well-educated and poorly paid". Thus, the evaluation of all possible summaries quickly becomes a computationally hard problem.

quantified propositions ?, and even more basic  summaries?

We proposed a typology of the summaries. For simpler ones, we proposed direct derivation schemes. For more complex ones, we proposed simplifications and then studied how to generate them. This typology may be briefly described as follows:  Most (e) young employees (F) are well-educated and where Q is a linguistic quantifier, F is its scope (may be interpreted as a fuzzy filter in the context of a database) and S is the main body of a summary (may be interpreted as a WHERE clause of the FQUERY for Access' fuzzy query).

Thus, the generation of a linguistic summary consists in finding propositions of type (1) that have a high truth-value.

Two extreme strategies, indicated previously, are possible:  either the user proposes a candidate summary and the system just evaluates its truth degree, or the very summary is not only evaluated but also automatically generated by the system.

In-between these two extremes there are different types of summaries, with various assumptions on what is automatically generated (sought) and what is provided by the user. In case of Q, the situation is simple: it may be given or sought. In case of F and S, more possibilities exist. Basically, both F and S consist of simple conditions, each stating what value an attribute should take on, connected using logical connectives. Then, we distinguished five types of summaries, cf. [12]. For the most complex ones, of Type 5, the whole structure and all components is to be automatically generated.

From now on we deal only with the summaries of Type 5 that are a counterpart of a fuzzy rule describing dependencies between specific values of attributes. Their meaning is that if a row meets the filter's condition, then it also meets the query's conditions. For a general form of such a summary it is difficult to devise an effective and efficient generation algorithm. Thus, we investigated the similarity of Type 5 summaries to association rules [ 13. Originally, the association rules were defined for binary valued attributes as:  A I A A ~ A  ...AA,, + A , + *  (2)  poorly paid (S) (1)  Thus, an association rule states that if in a database row all attributes from the set { A l ,  A2,.., A,,} take on value 1, then also attribute A,,+I is expected to take on value 1. Algorithms proposed for mining the association rules are based on the following. A row in a database (table) supports a set of attributes {Ai}i,, if attributes from this set take on in this row value 1. The support of rule (2) is the fraction of the number of rows supporting the set { A i } ,  i? { l,..,n+l} in a database (table). The confidence of a rule in a database (table) is the fraction of the number of rows supporting the set {Az}, ie { 1 ,.., n+l} among all rows supporting the set { A , } ,  iE { 1, .., n } .  The algorithms 11,181 search for rules having values of support above some minimal threshold and a high value of confidence. These algorithms may easily be adopted for non- binary valued data and more sophisticated rules than (2) . In particular, we can considerfuzzy association rules:  (3) A I  IS SI A A 2  IS Sl A...A A ,  IS S. 3 A,+I IS Sn+l     where Si is a fuzzy set defmed in the domain of attribute Ai, i.e., a fuzzy value; this is just an example of a fuzzy IF-THEN rule. Thus, a fuzzy association rule may be treated as a special case of a Type 5 summary where the structure of filter F and query S is rather limited but this simplicity secures the existence of efficient generation algorithms.

A benefit of data mining via a fuzzy querying interface is also implied by that a part of software modules may be used for both tasks. In fact, the simplest summaries may be produced as a by-product of running a query.

A CLUSTER ANALYSIS ALGORITHM  A cluster analysis method based on a global objective function was first presented by Owsinski [20], and then extended in [21]. Then, it was applied by the present authors to a number of real-life data from a variety of domains.

Assume that a set of indices I of objects analyzed, i, ic I = ( 1 ,  ..., n } ,  is to be partitioned into subsets (clusters) A,,  forming the partition P = {A,}:=, that reflects in the best  possible (most faithful) way geometrical properties of the entire set of objects, with special emphasis on densities. This means that in the partitions objects assigned to the same clusters A ,  should be possibly close, while objects assigned to different clusters - possibly far away from each other.

Following this verbal formulation, the method employs an explicit objective function reflecting the quality of partitions, denoted Qf ( P )  , which is composed of two parts:  QSD(O = Q ~ ( P ) + Q ~ ( P )  (4) D  where Q (P)  is a function of distance between objects assigned to various clusters, defined over the whole space of partitions, while Qs(P) is its intra-cluster similarity analogue.

Function Qf(P) is to be maximized, and this allows - at least in principle - to determine both the composition of an optimal A ,  and an optimum p ,  the number of clusters. This unique feature is the consequence of a global nature of (4).

The generality of (4) is reflected through the possibility of accommodating a broad variety of formulations. First, instead of maximizing (4) we can minimize its ?dual? in which QD(P) is a function of distances between objects within the same clusters, while @(P) is the function of similarities between objects in different clusters. Then, the function formulation is subject to choice, driven by the problem and numerical capabilities. In particular, fuzzy elements may also be accommodated, especially at lower levels (values of variables, distances/proximities, ...).

Yet, according to the method proposed which includes also the respective algorithm of the search for a solution, the formulations of (4), or its ?dual?, are subject to a condition of algorithmic nature. Namely, for virtually all reasonable forms of (4) there are no effective exact optimization algorithms (various metaheuristics are commonly employed). Thus, a compromise is to be found: while losing as little as possible  out on optimality, gain as much as possible in computational effectiveness. Hence, (4) is transformed into  in which rc  [0,1]. Then, the function is suboptimized through a simple, classical progressive merger procedure. The procedure starts with r=l, when the parametric function is equivalent to @(P), whose maximization yields the optimum partition P*(1) = I (i.e. each object forms a separate cluster).

As r decreases, consecutive partitions P*(r) are formed through mergers of clusters created at earlier stages.

To lead to a (sub)optimum solution, the condition of opposite monotonicity with respect to aggregation/ disaggregation of clusters is applied to the components of Q f  ( P )  . It means that when we obtain from a given partition P another partition through a merger of arbitrary clusters, then the resulting changes in the values of @(P) and QdP) should go in the opposite directions, and with each possible aggregation these directions will, for a given component, always be the same. It turns out that there exists a broad class of such @ (P)?s and QS(P)?s, cf. [Zl].

By employing functions that satisfy the ?opposite monotonicity? the applied progressive merger scheme, comparable to those described with the Lance-Williams- Jambu formula, may yield suboptimum solutions. This scheme is in general as effective as the latter ones and suboptimizes both the contents of clusters and their number.

The actual effectiveness of the algorithm will depend upon the form of @(P) and QdP). Additionally, the algorithm is equipped with a natural index r o f  hierarchy whose values, obtained during the functioning of the algorithm, may serve to assess the robustness of individual partitions forming the hierarchical structure. The ultimate suboptimal solution is obtained for the lowest value of r not smaller than 0.5.

CLUSTER ANALYSIS WITHIN FQUERY FOR ACCESS  The above cluster analysis algorithm was implemented within our combined fuzzy queryindmining interface for two reasons. First, to simply extend the range of tools. Second, we follow the idea of Miller and Yang [ 191 by looking for a more sophisticated forms of summaries (fuzzy association rules).

Now we will discuss both modes of application of cluster analysis in FQUERY for Access.

Our cluster analysis module, implemented using BorlandInprise Delphi, is integrated with the fuzzy querying interface but may be used in several modes. It offers its own interface for setting all parameters needed (distance functions selection for all relevant attributes, type of parametrization etc.) and running cluster analysis on data taken from the host Access database. It may also be controlled fiom the main interface of the FQUERY for Access and executed in the background. This mode genuinely exploits the integration of the tools as the data to be clustered may be automatically prepared using a dictionary of linguistic terms from the fuzzy querying interface. For example, if we have three fuzzy values: ?low?, ?medium? and ?high? represented by trapezoidal fuzzy numbers, then if the attribute is     selected, for the use in the clustering phase, the user may request an automatic fuzzification of values of this attribute using the above fuzzy values. Thus, in the data set read by the clustering module instead of the actual values of "salary" there will be put fuzzy values. The appropriate fuzzy values will be determined as those maximizing the membership degree of the actual value of "salary" in the fuzzy sets defining particular fuzzy values. The user may also decide if the fuzzified attribute is to be treated by the clustering module as nominal, ordinal or regular numerical one because the clustering module supports various distance functions, also for qualitative data.

The second role of the clustering module within the queryingmining interface is to enhance the execution of other mining tool available. This mainly deals with the discretizatiodpartition of domains of the attributes to be used by the association rules discovery module. The use of numerical fiuzy values itself alleviates to some extent the problem of a proper partition of attribute domains. A domain may be covered by a number of overlapping fuzzy values making the partitioning more flexible. However, sometimes such a coverage may be improper, e.g. due to data skewness.

An experienced user may even then defme appropriate fuzzy values. However, sometimes it may be useful to rely on an automatic partition of the feature space offered by the clustering module. We implemented both one-dimensional clustering along the domain of each attribute separately as well as multi-dimensional clustering and the partition of the domains in the spirit of Fu et al. [5 ] .  Finally we also adopted an approach in the spirit of Miller and Yang [19]. They advocate the use bf cluster analysis to determine a proper partition of the attributes domain. In fact they go even further by proposing an extension of the association rule concept.

Namely, they suggest that it may be advantageous to group attributes provided the distance in corresponding multi- dimensional spaces may be meaningfully defmed. Then, in a simple condition of a rule - instead of requiring that a numerical attribute lies in a given interval - we may require that values of a group of attributes lie in a cluster. We additionally propose to use the very clustering process for the association rules generation. We start with the observation that a the rows gathered in the clusters of the size exceeding some threshold (corresponding to the support threshold) may be treated as revealing some fiequent patterns of data (corresponding to the frequent/large itemsets).

