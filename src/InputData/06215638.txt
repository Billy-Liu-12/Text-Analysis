An Efficient Weighted Rule Mining for Web Logs

Abstract- Web mining techniques are used to analyze the web information resources. Web content mining and structure mining  methods are used to analyze the web page contents. The user  access information is maintained under the web logs. The usage  mining technique is used to analyze the web logs. The web logs  are maintained under the web server environment. User access  patterns are extracted from the web logs. The web content  management and link connectivity are improved using the access  patterns. The association rule mining techniques are used to  extract item set relationships. Item set frequencies are used in the  rule mining process. Page weights are used to denote the  importance of the web pages. The weighted rule mining techniques are used to fetch the frequently accessed web pages  with its weight values.

Frequent pattern mmmg algorithms are designed to find  commonly occurring sets in databases. Memory and run time  requirements are very high in frequent pattern mining  algorithms. Systolic tree structure is a reconfigurable  architecture used for frequent pattern mining operations. High  throughput and faster execution are the highlights of the systolic  tree based reconfigurable architecture. The systolic tree  mechanism is used in the frequent pattern extraction process for  the web access logs. Systolic tree based rule mining scheme is  enhanced for weighted rule mining process. Automatic weight  estimation scheme is used in the system. The dynamic web page  weight assignment scheme uses the page request count and span  time values. The proposed system is improves the weight  estimation process with span time, request count and access  sequence details. The user interest based page weight is used to  extract the frequent item sets.

Keywords-web log, structure mining, web content mining, systolic tree.



I. INTRODUCTION  The goal of frequent pattern mining is to determine which items in a transactional database commonly appear together.

Given the size of typical modern databases, an exhaustive search is usually not feasible, making this a challenging computational problem. The FP-growth algorithm [1] stores all transactions in the database as a tree using two scans. The FP? growth algorithm was originally designed from a software developer's perspective and uses recursion to traverse the tree and mine patterns. It is cumbersome to implement recursive processing directly in hardware, as dynamic memory allocation typically requires some software management. For this reason, the dynamic data structures which are widely used in software  implementations are very rarely used in a direct hardware implementation. Consequently, it would be very difficult to directly translate this FP-growth algorithm into a hardware implementation.

In [2], we have previously introduced reconfigurable systolic tree architecture for frequent pattern mining, and describe a prototype using a Field Programmable Gate Array (FPGA) platform. The systolic tree is configured to store the support counts of the candidate patterns in a pipelined fashion as the database is scanned in, and is controlled by a simple software module that reads the support counts and makes pruning decisions. In this paper, we focus on improving the original scheme introduced in [2] by eliminating the counting nodes, and provide a new COUNT mode algorithm [11]. A new database projection approach which is suitable for mining a systolic tree is proposed and implemented. Based on the reconfigurable platform presented, the area requirement of FPGAs and softwarelhardware mining time are studied. We perfonned experiments over several benchmarks. The experimental results show that our FPGA-based approach can be several times faster than a software implementation of the FP growth algorithm.



II. RELATED WORK  One advantage that FPGAs have over traditional computing platfonns is the ability to parallelize algorithms at the operand? level granularity, as opposed to the module-level or higher.

Consequently, there have been several recent efforts into hardware-based accelerators for data mining algorithms. In [3], the authors described hardware architecture for a Decision Tree Classification (DTC) algorithm, and showed that optimizing the Gini score computation significantly increases the overall perfonnance. A parallel implementation of the Apriori algorithm on FPGAs was first done in [4]. Due to the processing time involved in reading the transactional database multiple times, the hardware implementation was only 4_ faster than the fastest software implementation. The HAPPI architecture proposed in [5] applies the pipeline methodology to resolve the bottleneck of Apriori-based hardware schemes.

HAPPI outperforms the architecture in [4] when the number of different items and the minimum support values are increased [5]. Conclusions from several independent evaluations indicate that FP-growth is one of the best-performing association rules mining algorithms [6, 1], While software solutions exist, we are unaware of any existing hardware implementations of FP? growth algorithms.

lD I  Items lD Items B,C,D 5 A,B,C B,C 6 A,B,C A,C,D 7 A,B,D A,C,D  Figure I. A simple transactional database.



III. DESIGN OF SYSTOLIC TREE  A. Frequent pattern Mining  Given a transactional database D, where each row represents a transaction as shown in Fig. 1, let I = {i], i2, ? ? ?  in} be the set of all items in the database D and D = {tl, t2, ? . .  td} be the set of all transactions. For any transaction t" t, <;::::: I. Let  r (P) be the support count of a pattern (item set) P, where P is a set of items. r P= l{tilP <;::::: ti, ti E D}I is equal to the number of transactions containing P.A pattern (item set) P is frequent if r P is no less than a predefined minimum support threshold D. The objective of frequent pattern mining is to find  the set of patterns in D which satisfy IT (D) = IP r (P) ? ? .

In Fig. 1, I = {A, B, C, D} and let ? 4. r {A,C, D} = 2 < 4, hence {A, B,C, D} is not frequent; r (B,C) = 4 2:: 4, hence (B,C) is frequent.

B. Systolic Tree  In VLSI terminology, a systolic tree is an arrangement of pipelined processing elements (PEs) in a multidimensional tree pattern. The goal of our architecture is to mimic the internal memory layout of the FP-growth algorithm while achieving a much higher throughput. The role of the systolic tree as mapped in FPGA hardware is then similar to the FP-tree as used in software. Given a transactional database, the relative positions of the elements in the systolic tree should be the same as in the FP-tree. To achieve this objective, the systolic tree in this work can be designed based on the following observations:  1. A control PE which corresponds to the root node in the FP-tree acts as the input and output interfaces to the systolic tree.

2. The systolic tree construction algorithm starts from the root node upon receiving a new transaction. For two nodes which store any two items in a transaction, one node must be an ancestor of the other. If two transactions share a common prefix, the shared parts are merged using one prefix path. The degree of a node is equal to the number of transactions which share the common prefix. In the worst case, the degree of a node is equal to the number of frequent items N. Barring the use of dynamic partial reconfiguration, the PEs in hardware cannot be created and deleted dynamically as in software. If each PE is connected to N child PEs, the hardware structure and operation in each PE will be very complex. To avoid this hindrance, each PE in the systolic tree connects to its leftmost child.

3. In the FP-growth algorithm, the first item in each transaction is stored in a child of the root while the other items are stored in its descendants. However, all PEs in the systolic tree operate in parallel and there is no "pointer" concept in the  hardware implementation. Due to the intrinsic characteristics of the tree, the operation of a transaction usually starts from the root. Thus, the control PE acts as the inputloutput interface of the systolic tree. Each clock cycle, an item is transferred to the control PE which may forward the item to its children.

Each PE has a level associated with it. The control PE is at level O. The level of a general PE is equal to its distance to the control PE. The children of a PE has the same level.

Property 1. Each general PE has only one parent which connects to its leftmost child directly. The other children connect to their parents indirectly through their left siblings.

Property 2. A systolic tree which has W levels with K  children for each PE has 2::0 Ki .

A PE has three modes of operation: write mode, scan mode,  and count mode which will be discussed in the following sections. The systolic tree is built in write mode (Algorithm 1).

Input items are streamed from the root node in the direction set by the defined write mode algorithm. The support count of a candidate item set is extracted in both scan mode and count mode. We refer to this process as candidate item set matching.

Input: Input item if Match +-- 0; InPath +-? If PE is empty then IIStep (1)  Store the item if ;count +-- l;match +-- 1; stop forwarding  else if( if is in PE) and (InPath = 1 )then IIStep(2) match +--1; count++; stop forwarding  else if match = 0 then II Step(3) Inpath +-- O;forward if to the sibling Else IIStep( 4) Forward if to the children End if  Algorithm I: WRITE Mode Algorithm in Each PE  C. Systolic Tree Creation  The design principle of the WRITE mode algorithm is that the built-up systolic tree should have a similar layout with the FP-tree given the same transactional database. The ith item in a transaction is mapped to the ith level in the systolic tree. For any two PEs in the path of the same transaction, the PE in the ith level is the ancestor of the PE in the i + 1 th or higher level.

A PE is never in the same path of a transaction with its siblings. Suppose the transactional database has N frequent items. The number of PEs in the first level is at most N. The depth of the systolic tree is at most N. Suppose all items in Fig.

1 are frequent. The first items in all transactions only include items A and B. Therefore, we only need two PEs in the first level of the systolic tree. However, counting the number of items in each level may impair the overall pattern mining performance. Thus, the values ofK and W are usually set to be equal to N. The last item of a transaction may not be put into the leaf of the systolic tree if the number of items in the transaction is less than N. If two transactions share the same      prefix, they will share a path in the systolic tree. In summary, the design intuition behind the WRITE mode algorithm is that the path an item travels through the FP-tree is the same as the path it travels in the systolic tree.

The WRITE mode algorithm is presented in Algorithm l.

The same algorithm runs in each PE of the systolic tree in every clock cycle. That is, the inner hardware structure of each PE is the same. Initially all PEs are empty. An item is loaded into the control PE each clock cycle which in turn transfers each item into the general PEs. After all items in a transaction are sent to the systolic tree, a control signal that states the termination of an old transaction and the start of a new one is sent to the control PE. The signal will be broadcast to all PEs which reinitialize themselves for the next transaction. The initialization includes resetting match and Inpath flags in the first line of Algorithm l. The input of the algorithm is an item it. The match flag is set when the item in the PE matches it.

The Inpath flag is not set when the PE does not contain any item from the current transaction.



IV. PATTERN MINING USING SYSTOLIC TREES  To mine frequent patterns in the systolic tree, a collaborating hardware/software platform is required. The software sends a candidate pattern to the systolic tree. After some clock cycles, the systolic tree sends the support count of the candidate pattern back to the software. The software compares the support count with the support threshold and decides whether the candidate pattern is frequent or not. After all candidate patterns are checked with the support threshold in software, the pattern mining is done. The approach to get the support count of a candidate pattern is called candidate item set matching.

A. Candidate Item Set Matching  The main principle of matching is that any path containing the queried candidate item set will be reported to the control PE. Note that such a path may contain more items than the queried item set. Before introducing item set matching, we examine some useful properties of the systolic tree which will facilitate frequent pattern mining. As mentioned in previous sections, each frequent item is assigned a sequence number.

The items in each transaction enter the systolic tree in an increasing order in both the WRITE mode algorithm and the SCAN mode algorithm.

The first step to get the support count of a candidate item set is to locate those PEs which contain the last item. Those PEs, called reporting PEs, are responsible for reporting the stored count. In the second step, the support counts stored in reporting PEs are reported to the software. Since each PE has independent hardware components and stored data, a flag IsLeaf is set in the reporting PE. In the second step, each PE checks its own IsLeaf flag. If it is set, the PE will report its count. The matching algorithm should run after the systolic tree is built. A signal which indicates the SCAN mode is first broadcast from the control PE to all PEs. The design principle of the SCAN mode algorithm is similar to that of the WRITE mode algorithm. The items arriving later in the candidate item set follow the path of the previous items. However, the goal of  the WRITE mode algorithm is to find the path which shares the same prefix with the new transaction. In contrast, the goal of the SCAN mode algorithm is to locate all the paths which contain the dictated item set. In the SCAN mode algorithm, the PEs where the last item resides are the reporting PEs. Since there may be multiple reporting PEs, some items in the candidate item set must be duplicated when forwarded in PEs.

As discussed in previous sections, each PE has two output interfaces. The design of the SCAN algorithm is based on the following propositions:  The SCAN mode algorithm is shown in Algorithm 2. In step three even though itemt is smaller than the stored item iteme, itemt should be sent to the siblings of PEe. This is because the items in the siblings may be smaller than iteme or equal to itemt? If the input item itemt is larger than the stored item itemc, the stored items in the siblings or children of PEe may be equal to itemt? Thus, itemt should be forwarded to all open doors as shown in step four. a matching happens if item, is equal to iteme and the bottom door is open as shown in step two. The itemt still needs to be sent to the siblings of PEe in case some descendant of the siblings has a stored item matching itemt? In sum, itemt should be sent to the sibling of PEe regardless of its relationship with iteme  Input: Input item it Open the bottom door:IsLeaf ? ? If PE is empty then //Step(1)  Stop forwarding  else if ( it is in PE) and (bottom door is open)then //Step(2)  I sleaf ? l;forward it to the sibling  else if it < the item in PE then //step(3)  I sLeaf ? 0, close the bottom door; forward it to the sibling;  else if it > the item in PE then //step(4)  IsLeaf ? 0, forward it to the sibling;  forward it to the child if the bottom door is open end if  Algorithm 2. SCAN Mode Algorithm in Each PE         Figure 2. Equivalent systolic tree-based hardware architecture for acceleration  B. Candidate Item Set Count Computation  According to Property 1 of the systolic tree, there is only one path tracing back from any PE to the control PE since each PE has a unique parent. Once all items in a candidate item set are sent to the systolic tree, a control signal signifying the COUNT mode is broadcast to the whole systolic tree. The first child's input interface is always connected to its parent while others accept input from the sibling in WRITE and SCAN mode. After a candidate frequent item set is delivered into the systolic tree, the PEs report the support count of the candidate item set to its unique parent. The PE which is not directly connected to its parent sends its count to the left sibling. The parent PE collects the support counts reported by the children PEs and sends them to its own parent direction. The COUNT mode algorithm in each PE is given in Algorithm 3, where the support counts are transferred to each PE's parent in a pipelined fashion. The inputs of the algorithm are two count values sent by a PE's sibling and child, respectively. The NMyself variable is the number of the locally stored item. The  control PE adds up all count values and sends it as an output signal.

Input: NRIgh(, NBortom  Sent +--- 0; NClllld +--- N Right +N Bottom  If(Sent = 0) and (lsLeaf -l)then  Sent +--- 1  forward (Nmyselr+Nchild) to its parent direction  else  forward NChild to its parent direction  end if  Algorithm 3. COUNT Mode Algorithm in Each PE

V. TREE SCALING By DATABASE PROJECTION  It is unreasonable to assume that a tree-based representation can fit in the available hardware resources (either memory or logic) for any arbitrary database. In the case that memory or logic is not large enough to hold the whole tree, the database must be divided into multiple smaller databases with fewer frequent items. Without the technique of database projection, the brute-force candidate item set matching will take an intolerable amount of time when the number of frequent items is large.

A. Database Projection Model  To use the systolic tree to mine frequent item sets, the original database is projected into sub databases. Each of the projected databases has no more than N = min (K, W) frequent items and is guaranteed to fit into the FPGAs. Let's illustrate the database projection with an example. Suppose the FPGA logic can at most hold a systolic tree with two frequent items.

The database in Fig. 1 has four frequent items and should be projected into subdatabases each of which has at most two frequent items. The frequent items are usually sorted in frequency-decreasing order, which introduces a dense tree structure. For illustrative purpose, we arrange the frequent items in an alphabetic order, i.e., A; B, C,DStarting at frequent item A, the set of transactions that contain A are collected as an A-projected database. Since there are three frequent items B;C;D in the A-projected database, it should be further projected into two subdatabases. A-projected database and the A-projected database.

B. Frequent item Set Generation with Database Projection  For each frequent item set f3 , the frequent item sets  generated from the projected database of f3 (f3 -proj, or  Proj f3) are combined with f3 . This process is denoted as f3  X frequent?attern _set Proj f3 . The optimization of the single prefix-path FP-tree is the same as the approach proposed in [1].

However, the database projection needs not be performed for the single prefix path P since it has been generated into frequent?attern_set (Proj a ). The frequent item set generated from the projected database of the tree containing a single      prefix path should be combined with each pattern in that single prefix path separately denoted as fre'LPattern _set(R). This is because the top branching node of Q is replaced by a null root.

Each frequent pattern f3 generated in tree Q is combined with  the frequent patterns in Proj f3 .



VI. SYSTOLIC TREE BASED WEIGHTED RULE MINING  The proposed system is designed to perform weighted rule mining for web logs. Automatic weight estimation scheme is used in the system. Each web page is assigned a weight value with reference to the request count and sequence. A systolic tree is an arrangement of pipelined processing elements (PEs) in a multidimensional tree pattern. The transaction items are updated into the systolic tree with candidate item matching and count update operations. The systolic tree based algorithm is enhanced with weighted rule mining concepts. In the weighted rule mining model candidate and item sets are updated with weight values. the system is designed to find frequent patterns on web usage logs. The systolic tree based model is used in the system. Rule mining and weighted rule mining operations are performed in the system. The system is divided into five major modules. They are Web log analysis, Weight estimation process, Systolic tree construction.

A. Web Log Analysis  The web page request details are maintained in the web logs. Page URL, IP address, requested time and session ID are updated for each page request. Each page request is updated as a separate entry with unique session ID for the user. Noisy data values are removed in cleaning process. The data populate process transfers log data into the database. The page request entries are grouped with reference to the session ID. The session conversion arranges all page request into a single transaction.

B. Weight Estimation Process  The weight estimation module is designed to assign weights for the web pages. The access log is used in the weight estimation process. Access sequence based weight estimation model is used in the system. The weight values are used in the weighted rule mining process.

C. Systolic Tree Construction  The systolic tree maintains the candidate sets and its frequency values. The memory is mapped for similar sub tree values. The web page request sequence is updated in the systolic tree. The frequency values are updated for each page request.

D. Rule Mining Process  The rule mining process is carried out to find frequent patterns. The page request sequence patterns are extracted from the systolic tree. The support value is used in the mining process. The rule mining process uses the frequency values.

E. Weighted Rule Mining  The page weights are used in the weighted rule mining process. The page request frequencies and weight values are updated in the systolic tree. The frequent patterns are extracted with the weight values. The weighted support is estimated and used for the pages.



VII. CONCLUSION  The association rule mining techniques are used to extract frequent patterns. Systolic tree is used to arrange candidate sets with frequency values. Due to the limited size of the systolic tree, a transactional database must be projected into smaller ones each of which can be mined in hardware efficiently. A high performance projection algorithm which fully utilizes the advantage of FP-growth is proposed and implemented. It reduces the mining time by partitioning the tree into dense and sparse parts and sending the dense tree to the hardware.

Systolic tree based rule mining scheme is enhanced for weighted rule mining process. Automatic weight estimation scheme is used in the system.

