

EXTENDING OBJECT-ORIENTED DATABASES WITH RULES  P. Soupos, S. Goutas, D. Christodoulakis  Computer Engineering Dept.

and  Computer Technology Institute University of Patras, 26500 Patras, Greece  In the recent years we have seen a substantial influx of ideas in the DBMS technology coming from object-oriented programming languages, logic programming and rule based systems. This stimulated a lot of research effort in the area and a number of ob- ject-oriented models and systems have been put forward [Kim89]. A proposal that seems to attract attention recently is the integration of object-oriented and deductive databases [Bal188].

In this abstract we investigate the use of rules in an object-ori- ented DBMS. We focus on issues of structure, integrity and re- trieval. Even though our purpose is not to tackle issues of an ob- ject-oriented knowledge based management system but rather to deal with the incorporation of rules in an object-oriented DBMS, the proposed system can be used as a knowledge base because it provides objects for describing complex structured data, rules for expressing object-dependent constraints and object associations, and finally, logic for inference and retrieval. Furthermore our ap- proach can be used in connecting knowledge bases by trans- forming the data models of the knowledge bases to be connected, to the one proposed here. Interconnection is achieved by associ- ating objects belonging to diffmnt knowledge bases via rules.

A major issue in the 0-0 DBMS's nowadays is the degree to which knowledge is explicit or embedded. Knowledge con- ceming object types is expressed mainly in the form of methods and in that sense it is embedded. When, for instance, attributes and methods are used to express relationships between objects, this representation lacks qualities such as naturalness, simplicity, uniformity. and understandability. Rules however, which are the most popular form of knowledge representation in expert sys- tems, can serve as a vehicle for expressing functionalities of ob- jects declaratively with all the previously mentioned attractive features.

Another major issue that emerges from knowledge repre- sentation is that of integrity constraints. Most existing 0-0 sys- tems [Kim891 typically rely on the inherent constraints of the type system to assure consistency in the sense that a type constraints the permissible methods that can be applied to an object of that type. To overcome the limited constraint specification facility provided by inherent constraints alone 0-0 systems must be pro- vided with a mechanism for specifying explicit constraints. Such constraints express explicitly value ranges, dependence, referen- tial integrity and any other type of restriction that cannot be ex- pressed by the type system, for any kind of method and not only for update. Here again rules can give an answer since in typical "if X then Y" rules, X must be true for a situation in order to in- fer action Y.

Yet another well recognized problem is that the role of declar- atively specified knowledge in the form of constraints must be reexamined in the sense that in an object-oriented environment where any operation may be user defined, the system cannot au- tomatically determine which operations can see the effects of which others, or what the side-effects of a given operation might be. This comes as a result of the absence of explicit connection between constraints and the pertaining operations. In order to minimize checking as many constraints, related to an operation,  as possible should be in the same description as the operation it- self. The formalism of rules again provides the solution.

Based on the issues raised in the preceding discussion we have adopted rules as a means of expressing knowledge which is uniform throughout the type lattice but needs to be customized for each object type with integrity constraints. More specifically such knowledge involves associations between instances, be- tween objects and between objects in different databases, grouping of instances, creation and deletion of object instances and any other activity that requires a uniform approach in order to assure consistency, and transparency.

Finally based on the representation of associations between objects, which as already mentioned can be made by rules, we have used a logical query language. Our goal was not a full- fledged object-oriented pgramming language but rather a logical query language with base predicates associations between ob- jects. A logical query language has the obvious advantage of ex- pressiveness and simplicity, but poses certain difficulties in eval- uation. Evaluation is an issue in the case of recursive queries due to time-consuming join operations. We overcome this problem successfully by transforming recursion into iterative navigation through associations between object instances.

Now we will discuss briefly the basic concepts of our data model, more can be found in [Gout89, Chri891. This model is composed of what we consider essential structural components of representation in application areas such as CADICAM, office information, AI etc. We have focused on simplicity and have used as few basic constructs and concepts as possible. After all the abundance of concepts with some of them overlapping is one of the major criticisms against object-oriented systems.

The need for 0-0 systems to support sets is well recognized [OOPS87]. In 0-0 database systems based on languages that provide persistence, sets are considered as extensions of types and it is up to the programmer to decide what is to be kept and what is not. In the case of databases though, sets must be man- aged automatically not as extensions but as ad hoc types.

In our model we distinguish between object types, the in- stances of which must be maintained as separate sets, which we call collection objects and object types that have no instances and we refer to as type objects. Furthermore for efficiency and logical organization of collection objects, groups of predicate derived groups of instances are supported. These groups are called ag- gregations. Aggregations are rules, as will be shown in section 3.

We have adopted multiple inheritance which has been proved advantageous compared to simple inheritance because it simpli- fies data modeling. Two types of inheritance are supported.

First, inheritance that indicates specialization, the so called ISA [Mylo80], and second, partial inheritance [Stro86], where some properties are inherited and others are suppressed.

As already mentioned the degree to which knowledge rep- resentation in an 0-0 DBMS is declarative or procedural is an important one. 0-0 database systems tend to be procedural be- cause of concepts such as methods. Methods describe the be- haviour of objects and due to their procedural nature, object  CH2728-4/90/0000/0556$01 .OO 0 1990 IEEE 556    tuncnonality has no clear descnption. Furthermore, followng the procedural approach, the need to express explicit constraints.

leads to a mess.

Having taken all that into account we have adopted rules to express functionality and constraints. We have chosen a basic set of methods that a database object should have, and each such method we have attached to a rule with the corresponding condi- tions that must be satisfied so that the method preserves the in- tegrity of the data it manipulates. Apart from rules involving ba- sic operations, new rules can be defined by the programmer in- corporating existing or userdefined methods.

As already mentioned, associations or relationships between objects are expressed by rules which are included into the be- haviour part of objects. More specifically relationships are viewed as binary, bilateral associations between objects follow- ing the example of the binary data model. We call these relation- ships disciplined relationships. A disciplined relationship is structural knowledge common to a pair of objects, represented by a rule in each participating object.

So for two objects to be involved in a relationship, two rules with the same name must be defined, one for each object de- scription. This may appear as rather unnatural but if the complete definition of a relationship were to be placed in both objects it would mean that constraints for both objects should be defined in one rule. That would compromise information hiding because the involved objects should know each other. As far as the user is concerned relationships are primarily meant to express a bond between two objects, so it is not important to have the full con- straint at one place since constraints are automatically monitored by the system. Furthermore it is enough for an object, as a viewing mechanism, to contain information regarding its rela- tionships with constraints that involve anything defined at that object.

The well known IS-PART-OF relationship expresses, in a declarative manner. that every instance of an aggregated object has associated with it instances of its components. In other words it expresses two things between an object and its compo- nents, firstly taxonomy through hierarchy and secondly refer- ence between instances. Reference between an instance of an object and the instances of its components is much more a rela- tionship than a mere constraint through inheritance rules since it must be clearly specified at any moment which instances are components of which instance. This type of special behaviour of the IS-PART-OF can be better expressed in a declarative form as a disciplined relationship which is referred to as the PART-OF disciplined relationship.

The complete representation of the IS-PART-OF relationship comprises the disciplined relationship PART-OF, which ex- presses association between the whole and its components, along with a TYPE-OF hierarchy, which expresses taxonomy. An im- portant advantage of this representation of IS-PART-OF is that it supports both physical part hierarchy, in which an object cannot be part of more than one object, and logical part hierarchy, where one object can be part of more than one objects.

PART-OF can be used alone to define complex objects in two cases that cannot be covered by the standard approach for com- plex objects. The first case is when we want to build complex objects bottom-up, that is, to assemble existing objects in order to create a complex object. The second case is when we want to keep the component objects after the deletion of the parent object.

A database schema is a self-sufficient module that can Serve as a component for modular design. That is, an application can be partitioned into interacting, logically independent parts and then each part can be independently represented by a schema. These separate schemas can then be interconnected via disciplined  relanonships to form the environment of the applicanon. In such an environment the tight hierarchical organization of objects is not followed between schemas but instead the more loose disci- plined relationships approach is adopted for flexibility without loss of consistency. This modular design approach. ie. with loosely coupled modules, enables the formation of distributed environments in a variety of configurations.

Disciplined relationships can be also used to interconnect dis- tinct databases in a similar way as they serve to interconnect dif- ferent schemas of the same database. Furthermore heterogeneous databases can be connected in the same way by transforming the corresponding data models to the one we propose.

From the discussion so far we can deduce that the basic idea of our Data Model is objects having "knowledge" of their rela- tionships with the rest of the objects. This knowledge is private for each object. The idea of retrieval and data manipulation is based on these relationships and the object structure. A well ac- cepted type of language for solving problems involving relation- ships between objects, is a logical one. More specifically, logic has provided a basis for relational databases and database theory, especially for expressing queries and defining views.

In view of the above we have chosen a formalism based on Hom Clauses. So from the data manipulation point of view. we have a logic database where the extensional database consists of objects that have attributes and rules. Furthermore the terms of queries always refer to specific objects and not to the whole data base.

The well defined semantics and the simple, well understood notation of Horn Clauses combined with the concept of disci- plined relationships led us to a method for the evolution of database schemas in terms of new object interrelations. This method is based on transaction monitoring. Commonly used, simple query patterns appearing in queries are identified and mapped onto the database schema and onto the data. The advan- tage of this approach as opposed to saving specific queries is that query patterns provide an abstraction over a number of queries and are thus more useful in query optimization and more appro- priate to be included into the database schema.

