

Abstract?The paper proposes a novel methodology of finding frequent itemsets in data stream. Fuzzification of support of closed frequent itemsets in conjunction with jumping window has been used for finding frequent itemsets. Fuzzification of support of closed frequent itemsets helps in preserving information regarding the frequent itemsets at different point in time in the data stream. Use of jumping window over the high speed data stream improves the speed of the proposed algorithm.

Effectiveness of the proposed algorithm is shown by comparing its performance with the widely known MOMENT algorithm on both IBM synthetic datasets and benchmark datasets taken from UCI Machine Learning Repository.

Keywords: Closed frequent itemsets, Jumping window, L- function, R-function, Fuzzy membership value,

I. I. INTRODUCTION Association rule mining forms a major part of data mining.

Various association rule mining algorithms have been developed in the past. Among them the widely used algorithms are Apriori [1], AprioriTid [2], AprioriHybrid [2], Pincer- search [13], FP-tree [9]. For establishing the strength of association rule two constraints are defined, minimum support and confidence.

In association rule mining an undesirably large number of frequent itemsets can be generated requiring more memory.

Hence, an alternative to this problem is to store closed frequent or maximal frequent itemsets that require comparatively less memory. Closed frequent itemsets have an edge over maximal frequent itemsets. Closed frequent itemsets maintain sufficient information about the frequent itemsets along-with their support while maximal frequent itemsets do not maintain support of each frequent itemset that can be generated from it.

There are many applications where data is coming online in the form of data stream. As a result data stream has received a lot of attention in the recent past. For mining useful knowledge from data stream various stream mining algorithms have been proposed. Data stream algorithms are broadly divided into three categories on the basis of the type of window used viz. landmark [10] [11]; damped [5] [7] [8]; sliding [4] [12].

Algorithms using landmark window model identifies all the frequent itemsets from a specific point called landmark to the present. Damped window model based algorithms, on the other hand, associates some weight with each transaction which diminishes with time. Third category of algorithms that  uses sliding window model [6] processes only those transactions that come under the sliding window for finding frequent itemsets. Each model has its own advantages and disadvantages.

In the proposed approach, the concept of fuzzification of support of closed frequent itemsets using jumping window has been attempted in order to preserve the advantages of both the landmark and sliding window. Fuzzification of support of closed frequent itemsets helps in preserving the information regarding the frequent itemsets in the previous windows without maintaining all the transactions. Maintaining fuzzy membership value of support of closed frequent itemsets from the beginning of data stream till the end by updating fuzzy membership values after every processed window gives the same advantage as landmark window.

Effectiveness of the proposed algorithm has been measured by comparing it with widely known MOMENT algorithm.

Experimental results show that as the size of dataset increases the proposed algorithm outperforms MOMENT algorithm by reducing the computational time to many folds.

Rest of the paper is organized as follows. Section 2 presents overview of the earlier work done; section 3 explains the proposed approach; performance results are shown in section 4 and finally in the last section concluding remarks are given.



II. OVERVIEW OF THE EARLIER WORK Mining frequent itemsets from the Market Basket Data was  introduced by Aggarwal, Imielinski and Swami [1].  Maximal frequent itemset mining was proposed by Bayardo [3]. Later on, Pasquier, Bastide, Taouil and Lakhal [14] introduced generation of closed frequent itemsets from the given dataset for finding frequent itemsets. Han, Pei and Yin [9] introduced tree based pattern growth algorithm named FP-Growth for finding frequent itemsets.

Giannelle et al [7] [8] proposed an approximation algorithm that uses FP_Stream to maintain itemset frequency count for finding frequent itemsets over arbitrary time intervals. Chang and Lee [5] proposed an algorithm for data stream that associated weight with each transaction on the basis of the age of the transaction. Chi, Wang, Yu and Muntz [4] introduced an algorithm for mining closed frequent itemsets from the data stream using CET (Closed Enumeration Tree) and sliding window. CET stores information regarding        INPUT: minimum support ms; data stream DS, jumping window size jw_S; ?; OUTPUT: list of closed frequent itemsets; { ms_c = ms + ? * ms ms_pc = ms - ? * ms for first window {  n=call Implement (transactions in the current window); _  , , ms _ , ms _ ; add n to fuzzy set   ~; maintain the fuzzy membership value of each added itemset n; _  , , ms _ , ms_ ; add n to fuzzy set   ~ ; maintain the fuzzy membership value of each added itemset n;  } for(w=2; ;w++) { n=call  Implement (transactions in the current window); _  , , ms _ , ms _ ; _  _ , _ ; if itemset n is not available in the fuzzy set ~ { add itemset n to the fuzzy set ~ ; maintain the fuzzy membership value of each added itemset n; } else _   = _ ; _  , , ms _ , ms_ ; _  _ , _ ; if itemset n is not available in the fuzzy set ~ ; {  add itemset n to the fuzzy set ~  ; maintain the fuzzy membership value of each added itemset n;  } else _   = _ ; } C? =call Defuzzification(fuzzy set  ~  ,   ); for each itemset n in C? if(membership(n)=1) output n; frequent itemsets = all possible subsets of n; }  function Implement (transactions in the current window) { generate FP-tree; frequent_ itemsets= call Find (n, ms); return Closed_itemsets= call Check_Closed  (frequent_itemsets); }  the closed frequent itemsets and boundary nodes present in the transactions in the current sliding window over the data stream. Li, Lee and Shah [11] proposed DSM-FI algorithm for data stream that uses FP tree approach to find frequent itemsets over the entire history using landmark window.

MFI-TransSW algorithm proposed by Li, Ho, Shan and Lee [12] uses a transaction sensitive sliding window for finding frequent itemsets in the data stream by using bit sequence representation of items. Liu, Guan and Hu [10] proposed FP-CDS algorithm uses FP-CDS tree for storing closed frequent itemsets over landmark window.

The algorithms proposed earlier identifies frequent, closed frequent or maximal frequent itemsets from the data stream using landmark, damped or sliding window models. In the proposed algorithm novel concept of fuzzification of the support of closed frequent itemsets using jumping window model is introduced for finding frequent itemsets over the data stream. The detailed explanation of the proposed algorithm is given the section 3.



III. PROPOSED APPROACH In the proposed approach, for every batch of transactions in  the jumping window; FP-tree is generated. FP-tree is used since it reduces the space required for storing transactions.

Frequent itemsets are generated and are stored in the enumeration tree. Hash based approach is used for implementing enumeration tree. Each node of the enumeration tree stores the itemset and its support. From enumeration tree, closed frequent itemsets are identified and their support is fuzzified using membership functions which are special cases of trapedoidal function viz. L-function and R-function. FP-tree generation for the each batch of transactions in the jumping window is done in the foreground while in the background generation of enumeration tree from FP-tree; identification of closed frequent itemsets from the enumeration tree and fuzzification of their support is done. Size of jumping window, minimum support and number of itemsets in the enumeration tree decides the complexity of the algorithm. The proposed algorithm is given in Fig. 1.

Fig. 2 presents a function for identifying the closed frequent  itemsets. Function for finding frequent itemsets and to store them in hash table is given by Fig. 3. Fig. 4 gives function to identify closed frequent itemsets from the hash table.

A. Fuzzification of  support of closed frequent itemsets Special cases of trapezoidal function viz. L-function and R-  function are used as membership functions for maintaining the fuzzy membership value of support of closed frequent itemsets in the fuzzy set for closed frequent itemsets ~ and fuzzy set for prospective closed itemsets  ~  .

Figure 1.  Proposed Algorithm    Figure 2.  Function to identify closed frequent itensets          function Find(n, ms) { { if support (n)  <  ms  then mark n as infrequent itemset; else for each frequent itemset n, { insert n into the hash table; create n? new child of n ; for each child of n compute support using FP-Tree; call Find( n?,ms); } } return n; }  function FuzzificationL(n, support, ms_c, ms_pc) { { if (support < ms_pc) set ?   = 0; elseif (support  ? ms_c) && (support ? ms_pc) set  ? _ _ _ elseif (support > ms_c) set ?   = 1; } return ?  ; }  function FuzzificationR(n, support, ms_c, ms_pc) { { if (support > ms_c) set ?   = 0; elseif (support  ? ms_c) && (support ? ms_pc) set  ? _ _ _ elseif (support < ms_pc) set ?   = 1; } return ?  ; }  function Check_Closed( n) { for each itemset n in the hash table {  if there does not exists immediate superset of n in the hash table having same support as n then mark that itemset n as closed frequent itemset;  } return n; }    Figure 3.  Function to identify frequent itemsets and store in hash table  Figure 4.  Function to identify closed frequent itemsets from the hash table enteries  L-function curve gives the fuzzy membership value for the elements belonging to fuzzy set ~  and is defined as: ?C~ itemset   0                              ,        support  ms_pcsupport ms_pcms_c ms_pc  , ms_pc support ms_c1                           ,         support  ms_c   R-function curve gives the fuzzy membership value for the elements belonging to fuzzy set ~   and is defined as: ?PC~ itemset 0                        ,         support  ms_c__ _  , ms_pc support ms_c1                                 ,           support  ms_pc   Graphical representation of the L-function and R-function is  given in the Fig. 5.

Fuzzification of support of the closed itemsets identified from  enumeration tree is done. Fuzzy membership value of support of closed itemsets obtained from the current window is clubbed with the previous membership values of the closed itemsets using the following formula: f_? p_?  window 1 n_? curr_win_sizeWIN_SIZEwindow 1 curr_win_sizeWIN_SIZE where f_?             : fuzzy membership value of the closed itemset n after  considering current jumping window  p_?                 : fuzzy membership value of the closed itemset n without considering current jumping window n_?                       : fuzzy membership value of the closed itemset n in current jumping window window                  : total number of windows WIN_SIZE               : size taken for the jumping window curr_win_size        : size of current jumping window      Figure 5.   Curve for L-function and R-function showing fuzzy sets ~  and ~  respectively  Fig. 6 and Fig. 7 gives function for finding fuzzy membership value for support of closed frequent itemsets using L-function and R-function respectively. Function for finding final membership value for support of closed frequent itemsets encountered so far in the data stream is given by Fig. 8.

Figure 6.  Function returning fuzzy membership value computed using L-function  Figure 7.  Function returning fuzzy membership value computed using R-function        function Final ( _  , _ )   {          _ _  _ _ ___ __  return _  ; }  function Defuzzification (fuzzy set    ~ , ) { {    set ?; for each n in fuzzy set set    ~ if (? < ?) ?   = 0; else ?   = 1; add n in set } return    ; }  Figure 8.  Function forfinding final fuzzy membership value for support of closed frequent itemsets encountered so far in the datastream  B. Defuzzification Closed frequent itemsets are identified at any intermediate  point or at the end of data stream by defuzzification of itemsets stored in the fuzzy set  ~ . For this, ? ? cutset C? is defined where 0 ? ? ? 1. C? is a crisp set and is given by  C? =  | ~ The itemset in the crisp set C? can have either 0 or 1 as the  membership value which depending on the fuzzy membership value of support of closed frequent itemset present in the fuzzy set   ~. Figure 9 gives function for defuzzification.

Figure 9.  Function for defuzzification

IV. RESULTS This section deals with comparison of the proposed algorithm  with the widely known MOMENT algorithm. Comparative evaluation of the execution time is done on both synthetic and benchmark datasets. Synthetic datasets are generated using IBM synthetic data generator [15] and benchmark datasets were taken from UCI Machine Learning Repository [16]. All executions are performed on Intel Pentium ? 4 CPU 2.93GHz having 512 MB RAM. Results are compiled using g++ 3.0 complier on Red Hat Linux 9 (2.4.20-8).

For synthetic datasets, comparison of the execution of  proposed algorithm with MOMENT is done at minimum support of 0.3%, window size taken is 10K, ? is taken as 0.4 and ? ? cutest value is 0.002.

Experiments were also conducted in order to check whether  the proposed algorithm gives the same set of frequent itemsets for the following cases: Case (I):   When the complete dataset is considered under one  window without fuzzification of closed itemsets.

Case (II): When the concept of fuzzification of support of  closed frequent itemsets and jumping window is used.

Accuracy of the results obtained from Case (I) and Case (II)  is checked by taking set difference of the frequent itemsets  generated from the complete dataset under one window and that generated using concept of fuzzification and jumping window. Accuracy is given by  Accuracy = 1 -  |FI C DS FI C DS | |FI C DS FI C DS |FI C DS |FI C DS |  FI Cl DSc  -    frequent itemsets generated from Case (I) FI Cl DSj  -    frequent itemsets generated from Case (II) |FI Cl DSj FI Cl DSc |  - denotes the set difference between frequent itemsets generated from closed itemsets obtained from Case (II) and Case (I) |FI Cl DSc FI Cl DSj |  - denotes the set difference between frequent itemsets generated from closed itemsets obtained from Case (I) and Case (II)  Computation results showing execution time and accuracy for  synthetic datasets are tabulated in Table 1.

TABLE I.  EXECUTION TIME AND ACCURACY RESULTS OF THE PROPOSED ALGORITHM AND MOMENT ALGORITHM ON DATASETS HAVING  DIFFERENT NUMBER OF TRANSACTIONS  Dataset A B C D E F G  D50KT20I10K 116.4 998.5 2718 2732 3106 3148 98.6  D100KT20I10K 243.5 3067.3 2711 2725 3087 3136 98.4  D150KT20I10K 354.9 5169.2 2715 2727 3035 3088 98.2  D200KT20I10K 488.8 7088.8 2719 2731 3011 3067 98.1  D250KT20I10K 646.0 9231.4 2728 2740 2991 3039 98.4  D300KT20I10K 743.8 11129.8 2728 2740 2974 3007 98.9  D350KT20I10K 956.3 13456.1 2697 2714 2947 2981 98.8  D400KT20I10K 1027.3 15881.8 2682 2689 2952 2978 99.1  D450KT20I10K 1213.6 17923.6 2689 2701 2915 2965 98.3  D500KT20I10K 1342.0 19826.9 2688 2699 2858 2886 99.0  D550KT20I10K 1495.0 22003.1 2689 2701 2851 2883 98.8  D600KT20I10K 1605.1 24399.8 2682 2689 2845 2889 98.4  D650KT20I10K 1750.2 26565.3 2682 2689 2849 2887 98.6  D700KT20I10K 1874.5 28788.8 2687 2695 2860 2891 98.9  D750KT20I10K 2020.0 31010.5 2714 2722 2852 2889 98.7  D800KT20I10K 2178.5 33162.6 2684 2692 2858 2883 99.1  D850KT20I10K 2418.6 35339.9 2683 2691 2843 2891 98.3  D900KT20I10K 2531.6 37598.9 2712 2726 2858 2891 98.8  A = Execution Time in seconds (proposed algorithm, Case (II)), B = Execution Time in seconds (MOMENT Algorithm, Case (I)), C = Number of closed frequent itemsets obtained from Case (I), D = Number of closed frequent itemsets obtained from Case (II), E = Number of Frequent itemsets generated from closed   frequent   itemsets obtained from Case (I), F = Number of Frequent itemsets generated from closed frequent itemsets obtained from Case (II), G = Accuracy of finding Frequent itemsets (%) using the proposed algorithm (Case (II)).

For benchmark datasets, comparison of the execution of proposed algorithm with MOMENT is done at minimum support of 40% and 70%, window size taken is 1000, ? is taken as 0.4 and ? ? cutest value for 40% support is taken as 0.35 and for 70% support is taken as 0.6.

Computation results showing execution time comparisons are tabulated for minimum support of 40% and 70% in Table 2.

Accuracy results are given in Table 3 (at minimum support of 40%) and Table 4 (at minimum support of 70%).

TABLE II.  EXECUTION TIME TAKEN BY THE PROPOSED ALGORITHM AND THE MOMENT ALGORITHM ON BENCHMARK DATASETS AT MINIMUM  SUPPORT OF 40% AND 70%  Minimum Support = 40% Minimum Support = 70% Dataset H I Dataset H I  Chess 29459.36 109756.08 Connect 23325.25 72603.04  Mushroom 10.23 15.48 Chess 728.91 1225.88  Pumsb* 1797.99 3114.00 Pumsb 72890.85 510579.27 H = Execution Time in seconds (proposed algorithm, Case (II)), I = Execution Time in seconds (MOMENT Algorithm, Case (I)) From the above tables, it can be inferred that execution time for the proposed algorithm is much less as compared to the MOMENT algorithm.

TABLE III.  ACCURACY RESULTS FOR THE PROPOSED ALGORITHM (CASE (II)) ON BENCHMARK DATASETS AT MINIMUM SUPPORT OF 40%  Dataset M N O P Q  Chess 1361157 1551821 6439702 6498508 99.09  Mushroom 140 156 565 583 96.86  Pumsb* 2610 2644 27354 28082 97.37  TABLE IV.  ACCURACY RESULTS FOR THE PROPOSED ALGORITHM (CASE (II)) ON BENCHMARK DATASETS AT MINIMUM SUPPORT OF 70%  Dataset M N O P Q  Connect 35871 48123 4128175 4167543 99.05  Chess 23892 31235 48731 49824 97.78  Pumsb 241196 32786 2698264 2725632 98.99 M = Number of closed frequent itemsets obtained from Case (I), N = Number of closed frequent itemsets obtained from Case (II), O = Number of Frequent Itemsets generated from closed    frequent  itemsets obtained from Case (I), P = Number of Frequent itemsets generated from closed frequent itemsets obtained from Case (II), Q = Accuracy of finding Frequent itemsets (%) using the proposed algorithm (Case (II)).

From the above tables, it can be seen that on synthetic datasets the proposed algorithm gives accuracy of nearly 98.5% in finding frequent itemsets while on benchmark datasets accuracy increases as the number of frequent itemsets increases.

Comparison of the proposed algorithm is done with MOMENT algorithm at different minimum support values by keeping same dataset (D300KT20I10K). The comparison results of execution time are tabulated in Table 5.

TABLE V.  EXECUTION TIME TAKEN BY THE PROPOSED ALGORITHM AND THE MOMENT ALGORITHM FOR SAME DATASET AT DIFFERENT  MINIMUM SUPPORT VALUE  J K L J K L  0.3 743.80 11167.76 0.7 143.25 1977.32  0.4 371.20 7386.24 0.8 128.10 1260.43  0.5 235.30 5085.80 0.9 117.20 862.26  0.6 172.95 3307.09 1.0 109.80 603.66 J = Minimum Support, K = Execution Time in seconds (proposed algorithm, Case (II)), L = Execution Time in seconds (MOMENT Algorithm, Case (I))  From the above table, it is quite clear that at different minimum support values on the same dataset the proposed algorithm is faster as compared to MOMENT algorithm.

Although, the fuzzification of support of closed frequent itemsets results in slight increase in memory requirements of the proposed algorithm but the execution time is very less as compared to the MOMENT algorithm.



V. CONCLUSIONS Closed frequent itemsets helps in finding frequent itemsets in reduced memory space. A novel approach of finding frequent itemsets in data stream using fuzzification of closed frequent itemsets has been attempted in this paper. The concept of jumping window has been used since it reduces the computation time. Using only the concept of jumping window the frequent itemsets in the previous window may be lost.

Fuzzification of support of closed frequent itemsets using jumping window helps in preserving the frequent itemsets over every window.

