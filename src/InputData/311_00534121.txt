Automatic analysis of functional program style

Abstract Functional programming style is discussed and seven  simple semantic style rules, based on program transforma- lion, are enunciated. An automatic style analyser devel- oped from these rules is then presented.

1 Introduction Good programming style is deemed important to com-  municate programs effectively to other people, to optimise implementations and to minimise error proneness. How- ever, programmming style is notoriously difficult to char- acterise and there are substantial differences of opinion about just what constitutes good programming style.

We adopt the viewpoint that style is not concerned with what is said but rather with how well it is said. In the context of programming, we assume that a program is cor- rect in the sense of producing the appropriate outputs from inputs, whether demonstrated formally or by convincing testing. Thus, program style is concerned with how effec- tively an input/output process is expressed, regardless of what that process actually is.

There is a temptation to overload style and make it re- sponsible for all aspects of programming. Our viewpoint sees style as subsequent to design decisions, concerned with presentation rather than content. For example, in a system to count ASCII characters in text files, the represen- tation of characterkount associations in linked lists rather than direct indexed arrays is a poor design decision rather than an instance of poor style. In contrast, writing an itera- tive quicksort is stylistically dubious. To make an analogy with natural language, style is concerned with the organi- sation of chapters, paragraphs and sentences, not the plot.

This analogy should not be taken too far: computers are far less forgiving than humans of imprecision and differ- ences in usage. For example, while purists may fulminate against split infinitives or sentences starting with conjunc- tions, these are no hindrance to spoken communication and an annoyance, rather than a source of ambiguity or error, when written. Indeed, a distinctive style, where ?rules of good style? are bent to create an aesthetic effect, is consid-  ered a hallmark of a creative writer. In contrast, in com- puters the compiler and run-time system are the ultimate arbiters of program acceptability. Anything that does not correspond precisely to the language definition, be it ex- plicit or implicit in the implementation, will be rejected.

Furthermore, programming languages are much simpler than natural languages, giving far less scope for stylistic variation. Nonetheless, style inconsistencies seem subjec- tively to have much more impact on the intelligibility of programs than of novels.

We see succinctness, economy of expression, as central to style. This should not be confused with brevity, the soul of obfuscation as well as of wit: it is often poor style to say too little as well as too much. Succinctness is related to the expressive power of languages: those with well devel- oped orthogonal abstraction mechanisms tend to support succinct programmming. Despite continuing advances in optimising compilers, there is still an inverse relationship between expressive power in programming languages and efficiency of implementation. For example, consider recur- sion, structured programming and pattern matching. Each enables succinct programs yet each has more efficient but less succinct equivalents, namely iteration, gotos and struc- ture selection. Thus, we necessarily view implementation aspects of programming style as at best secondary to the effective communication of programs between people.

2 A linguistic characterisation of style Programming languages are defined in terms of a lexi-  con, syntax, semantics and pragmatics. It is a useful start- ing point to consider how style relates to each of these.

There are two approaches to style: relative and abso- lute. Relative style is concerned with assessing something against an appropriate exemplar whereas absolute style is based on generic, domain independent rules. Here we will consider absolute style.

The lexicon specifies the symbols - the smallest mean- ingful units in a language. In programming, a program- mer only has control over the construction of identifie] symbols for variables. The use of meaningful identifiers  http://cee.hw.ac.uk   in programming is a fundamental rule of thumb but not amenable to automatic checking. There have been at- tempts to prescribe minimum lengths for identifiers but these are self defeating: in general, there is no connection between an identifier?s length and its meaningfulness. Fur- thermore, ?meaningless? small identifiers like i, j and k are used universally for loop variables, following mathe- matical practice.

The syntax specifies valid grammatical structure - well formed symbol sequences. In programming, a programmer must stick exactly to the syntax and only has control over how a program is laid out. There have been many attempts to specify layout rules for free format languages, for exam- ple to regularise indentation for blocks, but for any given language no one layout style has found general favour. For some languages, for example KRC and occam, layout is prescribed. Many layout checking and pretty printing sys- tems for different languages have been developed. In prac- tice, there is probably no need for a common layout style provided each programmer uses one style consistently.

The semantics specifies the meaning of well formed symbol sequences. Here, style is concerned with the use of appropriate constructs. For imperative languages, which typically offer a wide range of semantically equivalent con- structs, this is a source of endless theological disputes. For example:  Are gotos to be discouraged?

Are FORS better than WHILES for sequenced struc- ture access?

Is recursion preferable to iteration?

How many parameters should a sub-program have?

Dijkstra[3] answers the first question eloquently in the af- firmative: the basis of structured programming. It is much harder to address the other questions rationally without some overarching guiding principles. Typically, such ques- tions also conflate issues of implementation efficiency with ease of human understanding. In principle, equivalent se- mantic constructs should be compilable to the same low level code. In practice, compilers and optimisers are not yet sufficiently adept. Arguably, if the least complex algo- rithm has been constructed then the mode of its expression is arbitrary.

Pragmatics is concerned with the context of use. In pro- gramming, there may be differences in the support environ- ment, for example in the provision of libraries, but again a programmer has little control over these. In style terms, however, we may view the use of comments, assertions and type annotations as pragmatic issues. Comments provide a natural language description of program components to ease human understanding. Like meaningful identifier use, the use of comments is generally thought to be good style.

However they are not amenable to automatic analysis other than with crude checks for their presence and size. As- sertions specify logical requirements that should be met at different points in programs. They are most valuable where they are used to prove programs correct - not a fea- ture of? any extant language implementation - or where they are implemented as additional run-time checks. Otherwise they are effectively comments. Somle polymorphic typed languages, for example HOPE, require explicit type anno- tations. In others, for example Hasklell, they are optional.

Requiiring type annotations is useful for teaching, to ensure that students understand typing, but frustrating for general use. A type checlung system can often deduce the types of variables from the context of their use: where it cannot the variables must be typed explicitly. Thus optional type annotations also serve as comments.

Our approach is semantics oriented and discussed fur- ther below.

3 Background Programming language textbooks have curiously little  to say about program style beyond the use of meaningful identifiers and layout. Even the classic books by Kernighan and Plauger[l2] and Ledgard, Hueras and Nagin[l4] are essentially collections of maxims. EIoth range across the whole gamut of linguistic style cbaracteristics outlined above; neither enunciates a consistent approach to ensur- ing good style.

There have been numerous attempits to characterise pro- gramming style for program assessmlent purposes both in education and industry. Style checkiing based on various criteria has been incorporated into program analysis sys- tems. Here we survey salient work.

Some authors seem to question the possibility of for- malising style at all. For example, Miller and Peterson[l7] describe an approach to program evalluation for use by in- structors. They allocate 10% of marks to comments, 10% to meaningful data names, 10% to indentation and 5% to design modularity. Other marks are given for output clarity(35%), program length(5%), and the nebulous ?out- put errtbellishments?(5%) and ?exemplary program style and cl,dty?(lO%). The final 10% is for the flowchart.

Olson[ 181, in contrast to Miller and Peterson?s ?analytic? method, proposes a holistic approach to grading. Here, the instructor is to assess the program as, a whole using a set of very loose guidelines. Olson found little correlation be- tween holistic and analytic marks, with holistic marks be- ing consistently higher. He comments that the approach relies on the assumption that ??computer science teachers recognise good programs when they see them? and that it provides little diagnostic information. Howatt[ 101 criti- cised Olson for failing to justify his holistic guidelines. He attempts to merge analytic categories with holistic criteria     for each, Style is one such category, receiving 15% of over- all marks, with ?Well formed, understandable code; appro- priate use of language capabilities? as desirable holistic cri- teria. We think that the holistic approach is far too vague to be useful: our work is based on the premise that program- ming style is explicitly quantifiable.

Marca[ 151 presents style guidelines for Pascal. Most recommendations, beyond the use of meaningful iden- tifiers, are syntactic, for example the use of paren- thesise to clarify expression evaluation order and gen- eral layout rules. Alas, one example suggests that if EndOfFile=false should be changed to the prefer- able i f  EndOfFile=true with the then and else actions swapped on the grounds that a negation is harder to understand than a positive condition. However the compar- ison with a boolean value is a classic semantic style error.

Gillett[6] developed the Interactive Program Advising System to comment on FORTRAN programs. Most checks are for low level semantic ?conceptual errors? for exam- ple failing to simplify arithmetic expressions or eliminate common subexpressions or using null IF statements. This system is interesting in suggesting how the program might be changed to avoid the error. S.S.Robinson and Soffa?s system[22] for FORTRAN is based on a combination of Halstead?s metrics to count various program features, for example number of unique variables, operators, data struc- tures and sub-programs, and semantic checks for example to favour FORS over WHILES and the use of one 2D rather than several ID arrays. Their hope is that students will ?learn how to write efficient programs that make correct use of control structures?. S.K.Robinson and Torsun[21] also use Halstead?s metrics in their FORTRAN checker.

Rees? influential STYLE system[20] evaluated Pascal programs on a mix of lexical(1ength of identifiers, vari- eties of identifier names), syntactic(1ine length, layout) and pragmatic(c0mments) criteria. It also checked for goto use. Rosenthal[23] developed an awk script to carry out Rees? checks which Meekings[ 161 further refined. Berry and Meekings[2] then changed the system to check C pro- grams and ran it on 80,000 lines of code from well known UNIX utilities. Overall, the code received low style marks.

The authors were amused to note that the lowest score went to a ?C beautifier? program. In general, they found very low use of comments and high use of gotos. However, Harrison and Cook[9] then applied Beny and Meeking?s system to 20 malfunctioning C modules containing 35,000 lines of code. Their analysis showed that the style measure had no relationship to the error frequency. They criticise Rees? criteria on the grounds of adequacy and complete- ness, and suggest that attention should be turned to how style rules affect human program comprehension. Finally, Hannemyr[7] criticises Rees for seeking a ?symbolic solu-  tion to a semantical problem? and notes ?our profession?s blind faith in instrumentalism?.

Redish and Smyth[l9] propose six criteria for style analysis i.e. economy, modularity, simplicity, struc- ture, documentation and layout. Like Rees? STYLE and the Halstead based systems described above, their AU- TOMARK for FORTRAN 77 is based almost entirely on low level counts of program constructs. Lake and Cook?s[l3] STYLE system for Pascal is also based on Re- dish and Smyth?s criteria.

Van Verth and Ralston[25] criticise systems based on feature counting and propose the use of Oviedo?s complex- ity measures, based on control graph analysis. They have used their approach to implement a Pascal grader and claim that a low complexity measure is indicative of good style.

Nonetheless, this is still feature counting, albeit at a higher level.

In summary, almost all work has focussed on non- semantic aspects of style and automatic style analysis is based primarily on construct counting. We agree with Han- nemyr that semantic style considerations are central but think that if they can be made explicit then they can be subject both to symbolic analysis and measurement.

4 Dromey?s software product quality model Recently, Dromey[5] has elaborated a hierarchical prop-  erty model for assessing software product quality, in re- sponse to the international standard ISO-9 126 Software Product Evaluation Characteristics[ 111. He identifies cor- rectness and style properties as the fundamental contribu- tors to quality and relates these to the structural forms of programs. This enables him to locate the source of poor quality at the appropriate lowest structural level in a pro- gram. He enunciates categories of properties termed cor- rectness, concerned primarily with proof and termination, structural, concerned with low level constructs, modularity, concerned with high level constructs, and descriptive, con- cerned with specification and documentation. Thorough descriptions of each are provided with examples.

Dromey?s framework is strongly influenced by the Floyd/Hoare/Dijkstra imperative program proof and syn- thesis tradition[4], leading to a pleasing focus on se- mantic issues in the correctness, structural and modu- larity categories. The descriptive properties are prag- matic(specifications, comments) and lexical(meaningfu1 identifiers). However, where semantic properties are mo- tivated by program proof and termination concerns, pri- marily the correctness properties, they are not amenable to automatic analysis but require substantial computer as- sistance for hand assurance of programs. Most other prop- erties are suitable for automatic assessment, in particular many of the structural properties motivated by structured programming and the modular properties concerned with     issues of cohesion and coupling. However, some non- formal properties make reference to the problem a program is intended to solve and are not automatable, for example those structural and modular properties to do with the ne- cessity or abstractness of constructs.

Despite our reservations, Dromey ?s model represents a significant advance in characterising imperative program style.

5 Semantic style and functional program- ming  Functional languages have been proposed widely as a basis for rigorous software development. Pure functional languages lack time ordering through assignment, leading to relative ease of program proof and transformation. They are also seen as valuable pedagogically in their own right, and are taught on an increasing number of courses[8].

Functional languages are more succinct than many of their imperative brethren. In particular, case structuring with pattern matching enables close associations between the structures of recursive data structures and the functions that manipulate them. However, functional languages still provide alternative ways of expressing the same intention.

For example, Haskell has case structured pattern matching and guarded patterns as well as an explicit conditional ex- pression. For example, many functional languages allow structure access with explicit selectors as well as through pattern matching.

Our interest in functional programming style is strongly motivated by concern for common mistakes and misap- prehensions in elementary functional programs written by novices. We think that semantic style errors in program- ming arise from conceptual misunderstandings. If style is amenable to formal characterisation then the learning of programming can be supported by a program analysis sys- tem which identifies style errors and suggests how they can be overcome.

We do not claim to provide an exhaustive taxonomy of functional programming style akin to Dromey?s: we do not consider correctness or descriptive properties, and our fo- cus on programming in the small reduces the relevance of modular properties. Furthermore, the absence of assign- ment renders many structural and modular properties ir- relevant. We are left with what are effectively structural properties which are amenable to automatic analysis.

The principle of compositionality[24] was enunciated for language semantics: a construct should be defined in terms of the meanings of its sub-constructs. Composi- tionality is related to Jackson?s correspondence principle which Dromey cites as the basis of his ?resolved? struc- tural property. This is a fruitful starting point for eluci- dating semantic style rules for functional languages which provide case structure with pattern matching. The over-  all structure is identified in the bound variable pattern on the left of a case. The sub-structures are then manipulated in the: case body. For a recursive structure, this enables the clear differentiation of base and recursion cases corre- sponding to base and recursive components of the struc- ture. This approach is certainly not universally applica- ble: many problems do not have strictly compositional so- lutionis. Nonetheless, compositionality enables a first focus on the semantic component of functional program style.

In the following sections, we present style checking rules for two aspects of compositionality. We then discuss rules for introducing ?partial application?, for removing unused variables in patterns and for simplifying boolean comparisons and results. These latteir rules are also seman- tic in focus and motivated by a desire for economy of ex- pression.

Rules are presented here as schematic rewrite transfor- mations enabling the correction as well as the identification of style errors. It would be relatively simple to prove for- mally that each rule preserves meaning: this is not done here.

5.1 Compositionality and lists  list and a concatenation of a head and a tail: Consider the list type which usually provides an empty  list -> [ I list -> head : : tail  In strongly typed languages, if the head i s  of some element type then the tail must be a list of thad type or empty.

An arbitrary list may be processed with a base case for an empty list and a recursion case for a non-empty list:  fun process list = if list= [ ] then base case else recursion case using  (hd list) and ( t 1 list)  where hd selects the list head and t I. selects the list tail.

An alternative to a conditional expression with an ex-  plicit comparison with the empty list is to separate out the base and recursion cases through pattern matching:  fun process [ ] = base case I process list =  recursion case using (hd list) and (tl lisl)  Sinlilarly, explicit list selection in the recursion case can be replaced with pattern matching:  fun process [ ] = base case I process (head : : tail) =  recursion case using head and tail     We think that this compositional approach is preferable: the cases and patterns make explicit the overall structure of the data to be processed and the function bodies show the processing of sub-structures.

5.2 Case structure from constant comparison  Our first rules generalise the list example, to introduce case structure from a conditional expression by replacing any explicit comparison between a variable and a constant in the condition with pattern matching:  fun name pattern with var = i f  var=const then  expression I with var else expression 2 with var ==>  fun name pattern with const = expression 1 with const I  name pattern with var = expression 2  For example:  fun sum 1 = i f  1=[] then  0 else sum 1 = hd l+sum ( t l  1) ==>  fun sum [ I  = O I sum 1 = hd l+sum (t l  1)  We identify a special case for a condition which is a boolean variable, as the variable need not be retained:  fun name pattern with var = i f  var then  expression 1 with var else expression 2 with var ==>  fun namepattern with t r u e  = expression 1 with t r u e  I  namepattern with f a l s e  = expression 2 with f a l s e  For example: fun no t  x =  i f  x then  f a l s e else t r u e  ==>  fun not  t r u e  = f a l s e  I no t  f a l s e  = t r u e  5.3  tern matching:  Patterns from explicit structure selection Our second rule replaces explicit list selection with pat-  fun name pattern with var = expression with (hd var)  and  ( t l  var)  andvar==> fun name pattern with (h-var : : t -var  ) =  and h-var : : t v a r expression with h-var and t-var  For example:  fun sum [ I  = 0 I sum 1 = hd l+sum (t l  1) ==>  fun sum [I = 0 I sum (h-1: : t-1) = h-l+sum t-1  5.4 Partial application Functional languages enable the definition of nested  functions of single bound variables, known as curried func- tions. Such functions may be ?partially applied? by spe- cialising outer arguments. For example:  fun add x y = x+y  is a function of x which returns a function of y which adds x and y. Thus:  v a l  i nc  = add 1  is a function of y with x bound to 1.

Inexperienced functional programmers often provide an  unnecessary explicit inner bound variable in such defini- tions:  fun i n c  y = add 1 y  This may be remedied by:  fun name patternspattern = expression pattern = =>  fun name patterns = expression  fun name pattern = expression pattern = = >  Val name = expression  provided no identifiers in p a t t e m  appear in expression.

5.5 Unused variables in patterns Many functional languages provide a wildcard pattern  which matches anything. This may replace a variable in a pattern which is not used subsequently, to simplify patterns and emphasise significant elements in structures:  fun name pattern with var = expression without var ==>  fun name pattern with - = expression  For example:  fun f i r s t  ( x , y , z )  = x ==>  fun f i rs t  (x,-,-) = x     5.6 Boolean comparison and results A common novice excess in many languages is to test  explicitly for a boolean value using comparison. This can be replaced with the compared expression:  expression=true ==> expression  e*presswn=false ==> not expression  For example:  fun ispos x = (x>O)=true ==>  fun ispos x = x>O  A related foible is to return a boolean value from a condi- tional expression where the condition itself will suffice:  if condition then true else false ==> condition if condition then false else true ==>  not condition  For example:  fun isneg x = if x<O then true else false ==>  fun isneg x = x<O  These errors seem to suggest a misunderstanding about the relationship between conditions and boolean values. Con- ditions are mainly used in the context of decisions rather than to return values, and non-boolean values must be con- structed and tested explicitly.

6 Implementation A style checker for a pure functional subset of Standard  ML was written in C using the above rules. It parses SML functions to construct a tree and then checks each rule.

Where a rule applies, the tree is transformed and pretty printed along with a terse message.

For example, to replace conditioned constant compari- son with case structured pattern matching:  fun pred x = if x=O then 0 else x-1  CONVERT if <var>=<const:> TO PATTERN  if x=O then 0 else x-1 ==>  fun pred x =  fun pred 0 = 0 I pred x = x-1  To replace a boolean variable as a condition with case structured pattern matching:  fun and x y = if x then y else false  CHECK 5:  CONVERT if <van TO PATTERN f?un and x y = if x then y else false ==>  fun and true y = y I and false y = false  To replace structure selection with patterns:  fun ordered [ I  = true I ordered [ V I  = true 1 ordered 1 = (hd l)<(hd (tl 1)) andalso ordered (tl 1)  CHECK 7 :  CONVERT hd/tl ?CJSE TO PATTERN 1 ==> h-l::(h-t-l::t-t-l)  CHECK 7 :  CONVERT hd/tl LJSE TO PATTERN hd 1 ==> h-1  CHECK 7 : CONVERT hd/ tl ?CJSE TO PATTERN hd (tl 1) ==> h-t-1  CHECK 7 :  CONVERT hd/tl USE TO PATTERN tl 1 ==> h-t-1::t-t-1  fun ordered [ I  = true I ordered [VI  = true I ordered (h-1: : (h-t-l : : t-t-1) ) = h-lch-t-1 andalso  To introduce partial application:  ordered (h-t-l : : t-.t-l)  fun sizes 1 = map size 1.

CHECK 3 : INTRODUCE PARTIAL APPLICATION fun sizes 1 = map size 1. ==>  CHECK 6 :  Val sizes = map size     To remove unused pattern variables:  fun seconds [ I  = 11 I seconds [VI = [ I  I seconds (hl:: (h2: :t) = h2:: (seconds t)  CHECK 4 : REMOVE UNUSED VARIABLE I N  PATTERN v ==> -  CHECK 4 : REMOVE UNUSED VARIABLE I N  PATTERN hl ==> -  fun seconds [ I  = [ I  I seconds [-I = [ I  I seconds (-: : (h2: : t) 1 = h2 : : (seconds t  To remove comparison with a boolean constant:  fun alpha ch = ( ch>= 'I a " andal s o ch< = 'I z I' ) =true  CHECK 2 :  REMOVE COMPARISON WITH BOOLEAN ( ch> = " a " andal s o c h< = '' z I' ) = true == >  fun alpha ch = ch>="a" andalso ch<=lCzbz  TO remove a condition returning boolean results:  fun notdigit ch = if ch>="O" andalso ch<="9" then false else true  CHECK 1:  if ch>= 'I 0 andalso ch<=" 9 then false else true ==>  REMOVE if <cond> then true else false  fun notdigit ch = not (ch>="O" andalso ch<="9")  Rules are applied repeatedly until none succeed. Fi- nally, consider:  fun count0 1 = if 1=[] then 0 else if (hd 1)=0 then l+(countO (tl 1) ) else count0 (tl 1)  which counts how often 0 appears in a list of integers.

First of all, the checker identifies that the explicit com-  parison of the list argument against the empty list may be replaced with two cases:  CHECK 6 :  fun count0 1 = CONVERT if <var>=<const> TO PATTERN  if 1=[] then 0 else if (hd 1)=0 then l+(countO (tl 1)) else count0 (tl 1) ==>  fun count0 [ I  = 0 I count0 1 =  if (hd 1)=0 then l+(countO (tl 1)) else count0 (tl 1)  Next, explicit use of hd and tl may be replaced by patterns:  CHECK 7 :  CONVERT hd/tl USE TO PATTERN 1 ==> h-1: : t-1  CHECK 7 :  CONVERT hd/tl USE TO PATTERN hd 1 ==> h-1  CHECK 7 :  CONVERT hd/tl USE TO PATTERN tl 1 ==> t-1  CHECK 7 :  CONVERT hd/tl USE TO PATTERN tl 1 ==> t-1  fun count0 [ ]  = 0 I count0 (h-1::t-1) =  if h-l=O then 1+ (count 0 t-1) else count0 t-1  Thence the comparison with the head of the list against 0 is replaced with two new patterned cases:  CHECK 6 :  fun count0 [ I  = 0 I CONVERT if <var>=<const> TO PATTERN  count0 (h-1::t-1) = if h-l=O then 1+ (count0 t-1) else count0 t-1 ==>  fun count0 [ ]  = 0 I count0 (0::t-1) = l+(countO t-1) 1 count0 (h-1::t-1) = count0 t-1  Last the unused list head in the final case's pattern is replaced with the wildcard pattern:     CHECK 4:  h-1 ==> - REMOVE UNUSED VARIABLE I N  PATTERN  fun count0 [ I  = 0 I count0 (O::t-1) = l+(countO t-1) I count0 (-: :t-l) = count0 t-1  Note that the unused variable was introduced by the checker itself.

7 Evaluation The style checker was developed for use with the  Ceilidh automatic assessment system for SML. In Ceilidh, students submit answers to exercises which are assessed empirically by comparing their outputs with those of model answers on standard test data. The original Ceilidh[ 11 for C also included simple style checking, primarily for lexical and syntactic style.

For SML, students supply type specifications for their functions for comparison with the specimen answers? types. The style checker is used to check for style mistakes.

Students may also use the style checker independently to get style comments in the form discussed above.

Ceilidh for SML was first prototyped without the style checker with a first year class who had already studied Pas- cal for one term. Subsequently, the style checker was used independently to analyse the students? submissions. Note that at this stage checks for wildcard, and hd and tl use had not been incorporated into the checker:  check occurrences  partial application 395 54.8% boolean comparison 125 17.3% var/const comp in if 80 11.1% boolean if result 68 9.4% boolean if condition 52 7 . 2 %  total occurrences 720  99.8%  _____________-______--------- - - -  ................................

Only the first positive check on each function was counted to avoid counting checks detected as a result of program transformation of earlier checks.

Partial application is a new concept for imperative pro- grammers: the high frequency of positive checks for mis- use (54.8%) is not surprising. However, explicit boolean comparison and results from conditional constructs are discouraged in imperative programming. Their presence in functional programs (26.7% of positive checks) corre- sponds to the above suggestion of more general novice confusion as to the status of boolean values. Positive com- positional checks for poor pattern usage (1 8.3%) are least frequent suggesting student understanding and acceptance of this style of programming.

8 Conclusions The style checker has been integrated into Ceilidh for  SML, which is now used regularly at Heriot-Watt Univer- sity to support SML teaching. Anecdotally, students seem to find style checks confusing initially but soon learn to sat- isfy thlem. Students may submit exercises as often as they like within a given period. A few seem to treat Ceilidh as if it were a game, seeking to maximise their marks by fre- quent submissions with minor, poorly thought out changes.

Most, however, develop a functional programming style which satisfies the above requirements. A more substantial analysis of style checks of student programs is planned.

We intend to develop additional semantic style rules for functional programming, in particular for the use of higher order functions, for compositional processing of user de- fined (concrete data types and to simplify non-exclusive function cases. The style checker will then be extended to include these new rules.

Finally, the style rules are ?hard wired? in the current style checker. It would be interesting to adopt an existing program transformation system to work with style rules.

9 Acknowledgements This work was supported by the: UK Higher Educa-  tion Funding Councils? Teaching and Learning Technol- ogy Programme as part of the Ceilidh automatic program assessment project. I would like to {hank Sandra Foubis- ter for integrating the style checker into Ceilidh for SML. I would also like to thank her and Diana Bental for monitor- ing its use by students.

I would like to thank Lachlan MacKinnon, Peter King and the anonymous referees for their constructive com- ments.

